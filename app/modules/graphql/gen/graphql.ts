/* eslint-disable */
import { DocumentTypeDecoration } from '@graphql-typed-document-node/core';

export type Maybe<T> = T | null;
export type InputMaybe<T> = T | null | undefined;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = {
  [_ in K]?: never;
};
export type Incremental<T> =
  | T
  | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  /** The `BigInt` scalar type represents non-fractional signed whole numeric values. */
  BigInt: { input: any; output: any };
  /** The `Byte` scalar type represents byte value as a Buffer */
  Byte: { input: any; output: any };
  /** A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar. */
  DateTime: { input: string; output: string };
  /** A field whose value is a IPv4 address: https://en.wikipedia.org/wiki/IPv4. */
  IPv4: { input: any; output: any };
  /** A field whose value is a IPv6 address: https://en.wikipedia.org/wiki/IPv6. */
  IPv6: { input: any; output: any };
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: { input: Record<string, any>; output: Record<string, any> };
  /** A string that cannot be passed as an empty value */
  NonEmptyString: { input: any; output: any };
  /** Integers that will have a value of 0 or more. */
  NonNegativeInt: { input: any; output: any };
  ObjMap: { input: any; output: any };
  /** Integers that will have a value greater than 0. */
  PositiveInt: { input: any; output: any };
  /** A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt. */
  URL: { input: any; output: any };
  _DirectiveExtensions: { input: any; output: any };
  query_listAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_items_items_spec_documentRevisionRef_version: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaInstanceForAllNamespaces_items_items_spec_runtime_sandbox_containers_items_env_items_valueFrom_resourceFieldRef_divisor: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listComputeDatumapisComV1alphaInstanceForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaInstanceForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaInstanceForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_spec_scaleSettings_metrics_items_resource_target_averageValue: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_spec_scaleSettings_metrics_items_resource_target_value: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_spec_template_spec_runtime_sandbox_containers_items_env_items_valueFrom_resourceFieldRef_divisor: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_spec_placements_items_scaleSettings_metrics_items_resource_target_averageValue: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_spec_placements_items_scaleSettings_metrics_items_resource_target_value: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_spec_template_spec_runtime_sandbox_containers_items_env_items_valueFrom_resourceFieldRef_divisor: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_addresses_items_type: {
    input: any;
    output: any;
  };
  /**
   * Value of the address. The validity of the values will depend
   * on the type and support by the controller.
   *
   * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
   */
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_addresses_items_value: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_name: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_supportedKinds_items_group: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_supportedKinds_items_kind: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_placements_items_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_placements_items_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_placements_items_conditions_items_type: {
    input: any;
    output: any;
  };
  /** Content is the text content of the note. */
  query_listCrmMiloapisComV1alpha1Note_items_items_spec_content: { input: any; output: any };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listCrmMiloapisComV1alpha1Note_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listCrmMiloapisComV1alpha1Note_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listCrmMiloapisComV1alpha1Note_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_alias_content: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_caa_tag: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_cname_content: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_name: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_ns_content: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_recordSets_items_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_recordSets_items_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_recordSets_items_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneClass_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneClass_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneClass_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_alias_content: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_caa_tag: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_cname_content: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_name: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_ns_content: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneForAllNamespaces_items_items_spec_domainName: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listDnsNetworkingMiloapisComV1alpha1DNSZoneForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_items_items_status_latestRevisionRef_version: {
    input: any;
    output: any;
  };
  query_listDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_items_items_spec_version: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_endpoints_items_fqdn_hostname: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_endpoints_items_hostname: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_endpoints_items_ip_address: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_tls_caCertificateRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_tls_caCertificateRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_tls_caCertificateRefs_items_name: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_connection_bufferLimit_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_connection_bufferLimit_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_connection_socketBufferLimit_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_connection_socketBufferLimit_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_dns_dnsRefreshRate: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_faultInjection_delay_fixedDelay: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_http_hostname: {
    input: any;
    output: any;
  };
  /** Path defines the HTTP path that will be requested during health checking. */
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_http_path: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_initialJitter: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_timeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_passive_baseEjectionTime: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_passive_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_http2_initialConnectionWindowSize_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_http2_initialConnectionWindowSize_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_http2_initialStreamWindowSize_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_http2_initialStreamWindowSize_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_loadBalancer_consistentHash_cookie_ttl: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_loadBalancer_slowStart_window: {
    input: any;
    output: any;
  };
  /**
   * Name of the HTTP header.
   * The header name is case-insensitive unless PreserveHeaderCase is set to true.
   * For example, "Foo" and "foo" are considered the same header.
   */
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_global_rules_items_clientSelectors_items_headers_items_name: {
    input: any;
    output: any;
  };
  /**
   * Value within the HTTP header.
   * Do not set this field when Type="Distinct", implying matching on any/all unique
   * values within the header.
   */
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_global_rules_items_clientSelectors_items_headers_items_value: {
    input: any;
    output: any;
  };
  /**
   * Value is the IP CIDR that represents the range of Source IP Addresses of the client.
   * These could also be the intermediate addresses through which the request has flown through and is part of the  `X-Forwarded-For` header.
   * For example, `192.168.0.1/32`, `192.168.0.0/24`, `001:db8::/64`.
   */
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_global_rules_items_clientSelectors_items_sourceCIDR_value: {
    input: any;
    output: any;
  };
  /**
   * Name of the HTTP header.
   * The header name is case-insensitive unless PreserveHeaderCase is set to true.
   * For example, "Foo" and "foo" are considered the same header.
   */
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_local_rules_items_clientSelectors_items_headers_items_name: {
    input: any;
    output: any;
  };
  /**
   * Value within the HTTP header.
   * Do not set this field when Type="Distinct", implying matching on any/all unique
   * values within the header.
   */
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_local_rules_items_clientSelectors_items_headers_items_value: {
    input: any;
    output: any;
  };
  /**
   * Value is the IP CIDR that represents the range of Source IP Addresses of the client.
   * These could also be the intermediate addresses through which the request has flown through and is part of the  `X-Forwarded-For` header.
   * For example, `192.168.0.1/32`, `192.168.0.0/24`, `001:db8::/64`.
   */
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_local_rules_items_clientSelectors_items_sourceCIDR_value: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_requestBuffer_limit_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_requestBuffer_limit_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_redirect_hostname: {
    input: any;
    output: any;
  };
  /**
   * ReplaceFullPath specifies the value with which to replace the full path
   * of a request during a rewrite or redirect.
   */
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_redirect_path_replaceFullPath: {
    input: any;
    output: any;
  };
  /**
   * ReplacePrefixMatch specifies the value with which to replace the prefix
   * match of a request during a rewrite or redirect. For example, a request
   * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
   * of "/xyz" would be modified to "/xyz/bar".
   *
   * Note that this matches the behavior of the PathPrefix match type. This
   * matches full path elements. A path element refers to the list of labels
   * in the path split by the `/` separator. When specified, a trailing `/` is
   * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
   * match the prefix `/abc`, but the path `/abcd` would not.
   *
   * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
   * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
   * the implementation setting the Accepted Condition for the Route to `status: False`.
   *
   * Request Path | Prefix Match | Replace Prefix | Modified Path
   */
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_redirect_path_replacePrefixMatch: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_response_body_valueRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_response_body_valueRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_response_body_valueRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_retry_perRetry_backOff_baseInterval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_retry_perRetry_backOff_maxInterval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_retry_perRetry_timeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the target resource. */
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRef_sectionName: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the target resource. */
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRefs_items_sectionName: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetSelectors_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetSelectors_items_kind: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_tcpKeepalive_idleTime: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_tcpKeepalive_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_timeout_http_connectionIdleTimeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_timeout_http_maxConnectionDuration: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_timeout_http_requestTimeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_timeout_tcp_connectTimeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_kind: {
    input: any;
    output: any;
  };
  /**
   * Name is the name of the referent.
   *
   * Support: Core
   */
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_sectionName: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_controllerName: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_credentialInjection_credential_valueRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_credentialInjection_credential_valueRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_credentialInjection_credential_valueRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_credentialInjection_credential_valueRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_directResponse_body_valueRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_directResponse_body_valueRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_directResponse_body_valueRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_apiKeyAuth_credentialRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_apiKeyAuth_credentialRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_apiKeyAuth_credentialRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_apiKeyAuth_credentialRefs_items_namespace: {
    input: any;
    output: any;
  };
  /**
   * Name is a user-friendly name for the rule.
   * If not specified, Envoy Gateway will generate a unique name for the rule.
   */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_clientCIDRs_items: {
    input: any;
    output: any;
  };
  /**
   * Name of the HTTP header.
   * The header name is case-insensitive unless PreserveHeaderCase is set to true.
   * For example, "Foo" and "foo" are considered the same header.
   */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_headers_items_name: {
    input: any;
    output: any;
  };
  /**
   * Name is the name of the claim.
   * If it is a nested claim, use a dot (.) separated string as the name to
   * represent the full path to the claim.
   * For example, if the claim is in the "department" field in the "organization" field,
   * the name should be "organization.department".
   */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_jwt_claims_items_name: {
    input: any;
    output: any;
  };
  /**
   * Provider is the name of the JWT provider that used to verify the JWT token.
   * In order to use JWT claims for authorization, you must configure the JWT
   * authentication with the same provider in the same `SecurityPolicy`.
   */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_jwt_provider: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_jwt_scopes_items: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_basicAuth_users_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_basicAuth_users_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_basicAuth_users_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_basicAuth_users_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_cors_allowOrigins_items: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_cors_maxAge: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRefs_items_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_connection_bufferLimit_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_connection_bufferLimit_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_connection_socketBufferLimit_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_connection_socketBufferLimit_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_dns_dnsRefreshRate: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_http_hostname: {
    input: any;
    output: any;
  };
  /** Path defines the HTTP path that will be requested during health checking. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_http_path: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_initialJitter: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_timeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_passive_baseEjectionTime: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_passive_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_http2_initialConnectionWindowSize_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_http2_initialConnectionWindowSize_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_http2_initialStreamWindowSize_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_http2_initialStreamWindowSize_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_loadBalancer_consistentHash_cookie_ttl: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_loadBalancer_slowStart_window: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_retry_perRetry_backOff_baseInterval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_retry_perRetry_backOff_maxInterval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_retry_perRetry_timeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_tcpKeepalive_idleTime: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_tcpKeepalive_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_timeout_http_connectionIdleTimeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_timeout_http_maxConnectionDuration: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_timeout_http_requestTimeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_timeout_tcp_connectTimeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRefs_items_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_connection_bufferLimit_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_connection_bufferLimit_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_connection_socketBufferLimit_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_connection_socketBufferLimit_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_dns_dnsRefreshRate: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_http_hostname: {
    input: any;
    output: any;
  };
  /** Path defines the HTTP path that will be requested during health checking. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_http_path: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_initialJitter: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_timeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_passive_baseEjectionTime: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_passive_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_http2_initialConnectionWindowSize_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_http2_initialConnectionWindowSize_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_http2_initialStreamWindowSize_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_http2_initialStreamWindowSize_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_loadBalancer_consistentHash_cookie_ttl: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_loadBalancer_slowStart_window: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_retry_perRetry_backOff_baseInterval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_retry_perRetry_backOff_maxInterval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_retry_perRetry_timeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_tcpKeepalive_idleTime: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_tcpKeepalive_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_timeout_http_connectionIdleTimeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_timeout_http_maxConnectionDuration: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_timeout_http_requestTimeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_timeout_tcp_connectTimeout: {
    input: any;
    output: any;
  };
  /**
   * Issuer is the principal that issued the JWT and takes the form of a URL or email address.
   * For additional details, see https://tools.ietf.org/html/rfc7519#section-4.1.1 for
   * URL format and https://rfc-editor.org/rfc/rfc5322.html for email format. If not provided,
   * the JWT issuer is not checked.
   */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_issuer: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_localJWKS_valueRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_localJWKS_valueRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_localJWKS_valueRef_name: {
    input: any;
    output: any;
  };
  /**
   * Name defines a unique name for the JWT provider. A name can have a variety of forms,
   * including RFC1123 subdomains, RFC 1123 labels, or RFC 1035 labels.
   */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRefs_items_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_connection_bufferLimit_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_connection_bufferLimit_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_connection_socketBufferLimit_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_connection_socketBufferLimit_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_dns_dnsRefreshRate: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_http_hostname: {
    input: any;
    output: any;
  };
  /** Path defines the HTTP path that will be requested during health checking. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_http_path: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_initialJitter: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_timeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_passive_baseEjectionTime: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_passive_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_http2_initialConnectionWindowSize_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_http2_initialConnectionWindowSize_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_http2_initialStreamWindowSize_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_http2_initialStreamWindowSize_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_loadBalancer_consistentHash_cookie_ttl: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_loadBalancer_slowStart_window: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_retry_perRetry_backOff_baseInterval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_retry_perRetry_backOff_maxInterval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_retry_perRetry_timeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_tcpKeepalive_idleTime: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_tcpKeepalive_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_timeout_http_connectionIdleTimeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_timeout_http_maxConnectionDuration: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_timeout_http_requestTimeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_timeout_tcp_connectTimeout: {
    input: any;
    output: any;
  };
  /**
   * URI is the HTTPS URI to fetch the JWKS. Envoy's system trust bundle is used to validate the server certificate.
   * If a custom trust bundle is needed, it can be specified in a BackendTLSConfig resource and target the BackendRefs.
   */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_uri: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientIDRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientIDRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientIDRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientIDRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientSecret_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientSecret_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientSecret_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientSecret_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_cookieDomain: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_defaultRefreshTokenTTL: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_defaultTokenTTL: {
    input: any;
    output: any;
  };
  /** Value specifies the string value that the match must have. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_denyRedirect_headers_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRefs_items_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_connection_bufferLimit_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_connection_bufferLimit_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_connection_socketBufferLimit_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_connection_socketBufferLimit_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_dns_dnsRefreshRate: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_http_hostname: {
    input: any;
    output: any;
  };
  /** Path defines the HTTP path that will be requested during health checking. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_http_path: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_initialJitter: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_timeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_passive_baseEjectionTime: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_passive_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_http2_initialConnectionWindowSize_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_http2_initialConnectionWindowSize_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_http2_initialStreamWindowSize_allOf_0: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_http2_initialStreamWindowSize_allOf_1: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_loadBalancer_consistentHash_cookie_ttl: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_loadBalancer_slowStart_window: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_retry_perRetry_backOff_baseInterval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_retry_perRetry_backOff_maxInterval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_retry_perRetry_timeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_tcpKeepalive_idleTime: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_tcpKeepalive_interval: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_timeout_http_connectionIdleTimeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_timeout_http_maxConnectionDuration: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_timeout_http_requestTimeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_timeout_tcp_connectTimeout: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the target resource. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRef_sectionName: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the target resource. */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRefs_items_sectionName: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetSelectors_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetSelectors_items_kind: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_kind: {
    input: any;
    output: any;
  };
  /**
   * Name is the name of the referent.
   *
   * Support: Core
   */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_sectionName: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_controllerName: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the target resource. */
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_sectionName: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_hostname: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_subjectAltNames_items_hostname: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_subjectAltNames_items_uri: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_kind: {
    input: any;
    output: any;
  };
  /**
   * Name is the name of the referent.
   *
   * Support: Core
   */
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_sectionName: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_controllerName: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayClass_items_items_spec_controllerName: {
    input: any;
    output: any;
  };
  /** Description helps describe a GatewayClass with more details. */
  query_listGatewayNetworkingV1GatewayClass_items_items_spec_description: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayClass_items_items_spec_parametersRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayClass_items_items_spec_parametersRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1GatewayClass_items_items_spec_parametersRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayClass_items_items_spec_parametersRef_namespace: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listGatewayNetworkingV1GatewayClass_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayClass_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayClass_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_addresses_items_type: {
    input: any;
    output: any;
  };
  /**
   * When a value is unspecified, an implementation SHOULD automatically
   * assign an address matching the requested type if possible.
   *
   * If an implementation does not support an empty value, they MUST set the
   * "Programmed" condition in status to False with a reason of "AddressNotAssigned".
   *
   * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
   */
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_addresses_items_value: {
    input: any;
    output: any;
  };
  /**
   * GatewayClassName used for this Gateway. This is the name of a
   * GatewayClass resource.
   */
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_gatewayClassName: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_allowedRoutes_kinds_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_allowedRoutes_kinds_items_kind: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_hostname: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_protocol: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_addresses_items_type: {
    input: any;
    output: any;
  };
  /**
   * Value of the address. The validity of the values will depend
   * on the type and support by the controller.
   *
   * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
   */
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_addresses_items_value: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_supportedKinds_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_supportedKinds_items_kind: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_hostnames_items: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_kind: {
    input: any;
    output: any;
  };
  /**
   * Name is the name of the referent.
   *
   * Support: Core
   */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_sectionName: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_add_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_add_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_set_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_set_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_hostname: {
    input: any;
    output: any;
  };
  /**
   * ReplaceFullPath specifies the value with which to replace the full path
   * of a request during a rewrite or redirect.
   */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_path_replaceFullPath: {
    input: any;
    output: any;
  };
  /**
   * ReplacePrefixMatch specifies the value with which to replace the prefix
   * match of a request during a rewrite or redirect. For example, a request
   * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
   * of "/xyz" would be modified to "/xyz/bar".
   *
   * Note that this matches the behavior of the PathPrefix match type. This
   * matches full path elements. A path element refers to the list of labels
   * in the path split by the `/` separator. When specified, a trailing `/` is
   * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
   * match the prefix `/abc`, but the path `/abcd` would not.
   *
   * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
   * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
   * the implementation setting the Accepted Condition for the Route to `status: False`.
   *
   * Request Path | Prefix Match | Replace Prefix | Modified Path
   */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_path_replacePrefixMatch: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_add_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_add_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_set_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_set_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_hostname: {
    input: any;
    output: any;
  };
  /**
   * ReplaceFullPath specifies the value with which to replace the full path
   * of a request during a rewrite or redirect.
   */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_path_replaceFullPath: {
    input: any;
    output: any;
  };
  /**
   * ReplacePrefixMatch specifies the value with which to replace the prefix
   * match of a request during a rewrite or redirect. For example, a request
   * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
   * of "/xyz" would be modified to "/xyz/bar".
   *
   * Note that this matches the behavior of the PathPrefix match type. This
   * matches full path elements. A path element refers to the list of labels
   * in the path split by the `/` separator. When specified, a trailing `/` is
   * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
   * match the prefix `/abc`, but the path `/abcd` would not.
   *
   * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
   * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
   * the implementation setting the Accepted Condition for the Route to `status: False`.
   *
   * Request Path | Prefix Match | Replace Prefix | Modified Path
   */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_path_replacePrefixMatch: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_hostname: {
    input: any;
    output: any;
  };
  /**
   * ReplaceFullPath specifies the value with which to replace the full path
   * of a request during a rewrite or redirect.
   */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replaceFullPath: {
    input: any;
    output: any;
  };
  /**
   * ReplacePrefixMatch specifies the value with which to replace the prefix
   * match of a request during a rewrite or redirect. For example, a request
   * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
   * of "/xyz" would be modified to "/xyz/bar".
   *
   * Note that this matches the behavior of the PathPrefix match type. This
   * matches full path elements. A path element refers to the list of labels
   * in the path split by the `/` separator. When specified, a trailing `/` is
   * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
   * match the prefix `/abc`, but the path `/abcd` would not.
   *
   * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
   * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
   * the implementation setting the Accepted Condition for the Route to `status: False`.
   *
   * Request Path | Prefix Match | Replace Prefix | Modified Path
   */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replacePrefixMatch: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_hostname: {
    input: any;
    output: any;
  };
  /**
   * ReplaceFullPath specifies the value with which to replace the full path
   * of a request during a rewrite or redirect.
   */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replaceFullPath: {
    input: any;
    output: any;
  };
  /**
   * ReplacePrefixMatch specifies the value with which to replace the prefix
   * match of a request during a rewrite or redirect. For example, a request
   * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
   * of "/xyz" would be modified to "/xyz/bar".
   *
   * Note that this matches the behavior of the PathPrefix match type. This
   * matches full path elements. A path element refers to the list of labels
   * in the path split by the `/` separator. When specified, a trailing `/` is
   * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
   * match the prefix `/abc`, but the path `/abcd` would not.
   *
   * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
   * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
   * the implementation setting the Accepted Condition for the Route to `status: False`.
   *
   * Request Path | Prefix Match | Replace Prefix | Modified Path
   */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replacePrefixMatch: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_value: {
    input: any;
    output: any;
  };
  /** Value of the HTTP path to match against. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_path_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP query param to be matched. */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_timeouts_backendRequest: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_timeouts_request: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_controllerName: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_kind: {
    input: any;
    output: any;
  };
  /**
   * Name is the name of the referent.
   *
   * Support: Core
   */
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_sectionName: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the target resource. */
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_sectionName: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_hostname: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_subjectAltNames_items_hostname: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_subjectAltNames_items_uri: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_kind: {
    input: any;
    output: any;
  };
  /**
   * Name is the name of the referent.
   *
   * Support: Core
   */
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_sectionName: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_controllerName: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_controllerName: {
    input: any;
    output: any;
  };
  /** Description helps describe a GatewayClass with more details. */
  query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_description: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_parametersRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_parametersRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_parametersRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_parametersRef_namespace: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listGatewayNetworkingV1beta1GatewayClass_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayClass_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayClass_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_addresses_items_type: {
    input: any;
    output: any;
  };
  /**
   * When a value is unspecified, an implementation SHOULD automatically
   * assign an address matching the requested type if possible.
   *
   * If an implementation does not support an empty value, they MUST set the
   * "Programmed" condition in status to False with a reason of "AddressNotAssigned".
   *
   * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
   */
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_addresses_items_value: {
    input: any;
    output: any;
  };
  /**
   * GatewayClassName used for this Gateway. This is the name of a
   * GatewayClass resource.
   */
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_gatewayClassName: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_allowedRoutes_kinds_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_allowedRoutes_kinds_items_kind: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_hostname: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_protocol: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_addresses_items_type: {
    input: any;
    output: any;
  };
  /**
   * Value of the address. The validity of the values will depend
   * on the type and support by the controller.
   *
   * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
   */
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_addresses_items_value: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_supportedKinds_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_supportedKinds_items_kind: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_hostnames_items: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_kind: {
    input: any;
    output: any;
  };
  /**
   * Name is the name of the referent.
   *
   * Support: Core
   */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_sectionName: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_add_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_add_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_set_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_set_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_hostname: {
    input: any;
    output: any;
  };
  /**
   * ReplaceFullPath specifies the value with which to replace the full path
   * of a request during a rewrite or redirect.
   */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_path_replaceFullPath: {
    input: any;
    output: any;
  };
  /**
   * ReplacePrefixMatch specifies the value with which to replace the prefix
   * match of a request during a rewrite or redirect. For example, a request
   * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
   * of "/xyz" would be modified to "/xyz/bar".
   *
   * Note that this matches the behavior of the PathPrefix match type. This
   * matches full path elements. A path element refers to the list of labels
   * in the path split by the `/` separator. When specified, a trailing `/` is
   * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
   * match the prefix `/abc`, but the path `/abcd` would not.
   *
   * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
   * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
   * the implementation setting the Accepted Condition for the Route to `status: False`.
   *
   * Request Path | Prefix Match | Replace Prefix | Modified Path
   */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_path_replacePrefixMatch: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_add_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_add_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_set_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_set_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_hostname: {
    input: any;
    output: any;
  };
  /**
   * ReplaceFullPath specifies the value with which to replace the full path
   * of a request during a rewrite or redirect.
   */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_path_replaceFullPath: {
    input: any;
    output: any;
  };
  /**
   * ReplacePrefixMatch specifies the value with which to replace the prefix
   * match of a request during a rewrite or redirect. For example, a request
   * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
   * of "/xyz" would be modified to "/xyz/bar".
   *
   * Note that this matches the behavior of the PathPrefix match type. This
   * matches full path elements. A path element refers to the list of labels
   * in the path split by the `/` separator. When specified, a trailing `/` is
   * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
   * match the prefix `/abc`, but the path `/abcd` would not.
   *
   * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
   * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
   * the implementation setting the Accepted Condition for the Route to `status: False`.
   *
   * Request Path | Prefix Match | Replace Prefix | Modified Path
   */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_path_replacePrefixMatch: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_hostname: {
    input: any;
    output: any;
  };
  /**
   * ReplaceFullPath specifies the value with which to replace the full path
   * of a request during a rewrite or redirect.
   */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replaceFullPath: {
    input: any;
    output: any;
  };
  /**
   * ReplacePrefixMatch specifies the value with which to replace the prefix
   * match of a request during a rewrite or redirect. For example, a request
   * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
   * of "/xyz" would be modified to "/xyz/bar".
   *
   * Note that this matches the behavior of the PathPrefix match type. This
   * matches full path elements. A path element refers to the list of labels
   * in the path split by the `/` separator. When specified, a trailing `/` is
   * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
   * match the prefix `/abc`, but the path `/abcd` would not.
   *
   * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
   * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
   * the implementation setting the Accepted Condition for the Route to `status: False`.
   *
   * Request Path | Prefix Match | Replace Prefix | Modified Path
   */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replacePrefixMatch: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_hostname: {
    input: any;
    output: any;
  };
  /**
   * ReplaceFullPath specifies the value with which to replace the full path
   * of a request during a rewrite or redirect.
   */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replaceFullPath: {
    input: any;
    output: any;
  };
  /**
   * ReplacePrefixMatch specifies the value with which to replace the prefix
   * match of a request during a rewrite or redirect. For example, a request
   * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
   * of "/xyz" would be modified to "/xyz/bar".
   *
   * Note that this matches the behavior of the PathPrefix match type. This
   * matches full path elements. A path element refers to the list of labels
   * in the path split by the `/` separator. When specified, a trailing `/` is
   * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
   * match the prefix `/abc`, but the path `/abcd` would not.
   *
   * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
   * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
   * the implementation setting the Accepted Condition for the Route to `status: False`.
   *
   * Request Path | Prefix Match | Replace Prefix | Modified Path
   */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replacePrefixMatch: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_value: {
    input: any;
    output: any;
  };
  /** Value of the HTTP path to match against. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_path_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP query param to be matched. */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_value: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_timeouts_backendRequest: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_timeouts_request: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_controllerName: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_group: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_kind: {
    input: any;
    output: any;
  };
  /**
   * Name is the name of the referent.
   *
   * Support: Core
   */
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_name: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_namespace: {
    input: any;
    output: any;
  };
  query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_sectionName: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listIamMiloapisComV1alpha1GroupForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1GroupForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1GroupForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listIamMiloapisComV1alpha1MachineAccountForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1MachineAccountForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1MachineAccountForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listIamMiloapisComV1alpha1NamespacedPolicyBinding_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1NamespacedPolicyBinding_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1NamespacedPolicyBinding_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listIamMiloapisComV1alpha1NamespacedRole_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1NamespacedRole_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1NamespacedRole_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listIamMiloapisComV1alpha1NamespacedUserInvitation_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1NamespacedUserInvitation_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1NamespacedUserInvitation_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listIamMiloapisComV1alpha1PlatformAccessDenial_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1PlatformAccessDenial_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1PlatformAccessDenial_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listIamMiloapisComV1alpha1PlatformInvitation_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1PlatformInvitation_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1PlatformInvitation_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listIamMiloapisComV1alpha1ProtectedResource_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1ProtectedResource_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1ProtectedResource_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listIamMiloapisComV1alpha1UserDeactivation_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1UserDeactivation_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1UserDeactivation_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listIamMiloapisComV1alpha1UserPreference_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1UserPreference_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1UserPreference_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listIamMiloapisComV1alpha1User_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1User_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listIamMiloapisComV1alpha1User_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /** Name of the referenced Connector. */
  query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_spec_connectorRef_name: {
    input: any;
    output: any;
  };
  /**
   * Address of the service.
   *
   * Can be an IPv4, IPv6, or a DNS address. A DNS address may contain
   * wildcards. A DNS address acts as an allow list for what addresses the
   * connector will allow to be requested through it.
   *
   * DNS resolution is the responsibility of the connector.
   */
  query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_spec_layer4_items_services_items_address: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /** ControllerName is the name of the controller responsible for this ConnectorClass. */
  query_listNetworkingDatumapisComV1alpha1ConnectorClassForAllNamespaces_items_items_spec_controllerName: {
    input: any;
    output: any;
  };
  /** Type of capability */
  query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_spec_capabilities_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_capabilities_items_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_capabilities_items_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_capabilities_items_conditions_items_type: {
    input: any;
    output: any;
  };
  /** Type of capability */
  query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_capabilities_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /** IPv4 or IPv6 address */
  query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_connectionDetails_publicKey_addresses_items: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaDomainForAllNamespaces_items_items_spec_domainName: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNetworkingDatumapisComV1alphaDomainForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaDomainForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaDomainForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_hostnames_items: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_cors_allowHeaders_items: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_cors_allowOrigins_items: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_cors_exposeHeaders_items: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_extensionRef_group: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_extensionRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_extensionRef_name: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestHeaderModifier_add_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestHeaderModifier_add_items_value: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestHeaderModifier_set_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestHeaderModifier_set_items_value: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestMirror_backendRef_group: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestMirror_backendRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestMirror_backendRef_name: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestMirror_backendRef_namespace: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestRedirect_hostname: {
    input: any;
    output: any;
  };
  /**
   * ReplaceFullPath specifies the value with which to replace the full path
   * of a request during a rewrite or redirect.
   */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestRedirect_path_replaceFullPath: {
    input: any;
    output: any;
  };
  /**
   * ReplacePrefixMatch specifies the value with which to replace the prefix
   * match of a request during a rewrite or redirect. For example, a request
   * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
   * of "/xyz" would be modified to "/xyz/bar".
   *
   * Note that this matches the behavior of the PathPrefix match type. This
   * matches full path elements. A path element refers to the list of labels
   * in the path split by the `/` separator. When specified, a trailing `/` is
   * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
   * match the prefix `/abc`, but the path `/abcd` would not.
   *
   * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
   * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
   * the implementation setting the Accepted Condition for the Route to `status: False`.
   *
   * Request Path | Prefix Match | Replace Prefix | Modified Path
   */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestRedirect_path_replacePrefixMatch: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_responseHeaderModifier_add_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_responseHeaderModifier_add_items_value: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_responseHeaderModifier_set_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_responseHeaderModifier_set_items_value: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_urlRewrite_hostname: {
    input: any;
    output: any;
  };
  /**
   * ReplaceFullPath specifies the value with which to replace the full path
   * of a request during a rewrite or redirect.
   */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_urlRewrite_path_replaceFullPath: {
    input: any;
    output: any;
  };
  /**
   * ReplacePrefixMatch specifies the value with which to replace the prefix
   * match of a request during a rewrite or redirect. For example, a request
   * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
   * of "/xyz" would be modified to "/xyz/bar".
   *
   * Note that this matches the behavior of the PathPrefix match type. This
   * matches full path elements. A path element refers to the list of labels
   * in the path split by the `/` separator. When specified, a trailing `/` is
   * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
   * match the prefix `/abc`, but the path `/abcd` would not.
   *
   * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
   * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
   * the implementation setting the Accepted Condition for the Route to `status: False`.
   *
   * Request Path | Prefix Match | Replace Prefix | Modified Path
   */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_urlRewrite_path_replacePrefixMatch: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_cors_allowHeaders_items: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_cors_allowOrigins_items: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_cors_exposeHeaders_items: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_group: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_name: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_value: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_value: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_group: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the referent. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_name: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_namespace: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_hostname: {
    input: any;
    output: any;
  };
  /**
   * ReplaceFullPath specifies the value with which to replace the full path
   * of a request during a rewrite or redirect.
   */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replaceFullPath: {
    input: any;
    output: any;
  };
  /**
   * ReplacePrefixMatch specifies the value with which to replace the prefix
   * match of a request during a rewrite or redirect. For example, a request
   * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
   * of "/xyz" would be modified to "/xyz/bar".
   *
   * Note that this matches the behavior of the PathPrefix match type. This
   * matches full path elements. A path element refers to the list of labels
   * in the path split by the `/` separator. When specified, a trailing `/` is
   * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
   * match the prefix `/abc`, but the path `/abcd` would not.
   *
   * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
   * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
   * the implementation setting the Accepted Condition for the Route to `status: False`.
   *
   * Request Path | Prefix Match | Replace Prefix | Modified Path
   */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replacePrefixMatch: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_value: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_value: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_hostname: {
    input: any;
    output: any;
  };
  /**
   * ReplaceFullPath specifies the value with which to replace the full path
   * of a request during a rewrite or redirect.
   */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replaceFullPath: {
    input: any;
    output: any;
  };
  /**
   * ReplacePrefixMatch specifies the value with which to replace the prefix
   * match of a request during a rewrite or redirect. For example, a request
   * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
   * of "/xyz" would be modified to "/xyz/bar".
   *
   * Note that this matches the behavior of the PathPrefix match type. This
   * matches full path elements. A path element refers to the list of labels
   * in the path split by the `/` separator. When specified, a trailing `/` is
   * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
   * match the prefix `/abc`, but the path `/abcd` would not.
   *
   * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
   * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
   * the implementation setting the Accepted Condition for the Route to `status: False`.
   *
   * Request Path | Prefix Match | Replace Prefix | Modified Path
   */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replacePrefixMatch: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP Header to be matched. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_value: {
    input: any;
    output: any;
  };
  /** Value of the HTTP path to match against. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_path_value: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_name: {
    input: any;
    output: any;
  };
  /** Value is the value of HTTP query param to be matched. */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_value: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_name: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_addresses_items_type: {
    input: any;
    output: any;
  };
  /**
   * Value of the address. The validity of the values will depend
   * on the type and support by the controller.
   *
   * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
   */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_addresses_items_value: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_hostnames_items: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNetworkingDatumapisComV1alphaLocationForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaLocationForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaLocationForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNetworkingDatumapisComV1alphaNamespacedNetworkBinding_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedNetworkBinding_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedNetworkBinding_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNetworkingDatumapisComV1alphaNamespacedNetworkContext_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedNetworkContext_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedNetworkContext_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNetworkingDatumapisComV1alphaNamespacedNetwork_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedNetwork_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedNetwork_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNetworkingDatumapisComV1alphaNamespacedSubnetClaim_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedSubnetClaim_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedSubnetClaim_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNetworkingDatumapisComV1alphaNamespacedSubnet_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedSubnet_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedSubnet_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_ruleSets_items_owaspCoreRuleSet_ruleExclusions_idRanges_items: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_ruleSets_items_owaspCoreRuleSet_ruleExclusions_tags_items: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_targetRefs_items_group: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_targetRefs_items_kind: {
    input: any;
    output: any;
  };
  /** Name is the name of the target resource. */
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_targetRefs_items_name: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_targetRefs_items_sectionName: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_group: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_kind: {
    input: any;
    output: any;
  };
  /**
   * Name is the name of the referent.
   *
   * Support: Core
   */
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_name: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_namespace: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_sectionName: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_controllerName: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNotificationMiloapisComV1alpha1ContactForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1ContactForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1ContactForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNotificationMiloapisComV1alpha1EmailForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1EmailForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1EmailForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNotificationMiloapisComV1alpha1EmailTemplate_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1EmailTemplate_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1EmailTemplate_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /** Content is the text content of the note. */
  query_listNotificationMiloapisComV1alpha1NamespacedNote_items_items_spec_content: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listNotificationMiloapisComV1alpha1NamespacedNote_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1NamespacedNote_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listNotificationMiloapisComV1alpha1NamespacedNote_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * ResourceType specifies which resource type this bucket aggregates quota for.
   * Must exactly match a ResourceRegistration.spec.resourceType that is currently active.
   * The quota system validates this reference and only creates buckets for registered types.
   *
   * The identifier format is flexible, as defined by platform administrators
   * in their ResourceRegistrations.
   *
   * Examples:
   * - "resourcemanager.miloapis.com/projects"
   * - "compute_cpu"
   * - "storage.volumes"
   * - "custom-service-quota"
   */
  query_listQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_items_items_spec_resourceType: {
    input: any;
    output: any;
  };
  /**
   * Expression specifies the CEL expression to evaluate against the trigger resource.
   * This is a pure CEL expression WITHOUT {{ }} delimiters (unlike template fields).
   * Must return a boolean value (true to match, false to skip).
   * Maximum 1024 characters.
   *
   * Available variables in GrantCreationPolicy context:
   * - trigger: The complete resource being watched (map[string]any)
   *   - trigger.metadata.name, trigger.spec.*, trigger.status.*, etc.
   *
   * Common expression patterns:
   * - trigger.spec.tier == "premium" (check resource field)
   * - trigger.metadata.labels["environment"] == "prod" (check labels)
   * - trigger.status.phase == "Active" (check status)
   * - trigger.metadata.namespace == "production" (check namespace)
   * - has(trigger.spec.quotaProfile) (check field existence)
   */
  query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_spec_trigger_constraints_items_expression: {
    input: any;
    output: any;
  };
  /**
   * Message provides a human-readable description explaining when this condition applies.
   * Used for documentation and debugging. Maximum 256 characters.
   *
   * Examples:
   * - "Applies only to premium tier organizations"
   * - "Matches organizations in production environment"
   * - "Triggers when quota profile is specified"
   */
  query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_spec_trigger_constraints_items_message: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_spec_trigger_resource_apiVersion: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_target_parentContext_apiGroup: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_target_parentContext_kind: {
    input: any;
    output: any;
  };
  /**
   * NameExpression is a CEL expression that resolves the name of the parent context resource.
   * Must return a string value that identifies the specific parent context instance.
   * Maximum 512 characters.
   *
   * Available variables:
   * - object: The trigger resource being evaluated (complete object)
   *
   * Common expression patterns:
   * - object.spec.organization (direct field reference)
   * - object.metadata.labels["parent-org"] (label-based resolution)
   * - object.metadata.namespace.split("-")[0] (derived from namespace naming)
   *
   * Examples:
   * - "acme-corp" (literal parent name)
   * - object.spec.parentOrganization (field from trigger resource)
   * - object.metadata.labels["quota.miloapis.com/organization"] (label value)
   */
  query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_target_parentContext_nameExpression: {
    input: any;
    output: any;
  };
  /**
   * Expression specifies the CEL expression to evaluate against the trigger resource.
   * This is a pure CEL expression WITHOUT {{ }} delimiters (unlike template fields).
   * Must return a boolean value (true to match, false to skip).
   * Maximum 1024 characters.
   *
   * Available variables in GrantCreationPolicy context:
   * - trigger: The complete resource being watched (map[string]any)
   *   - trigger.metadata.name, trigger.spec.*, trigger.status.*, etc.
   *
   * Common expression patterns:
   * - trigger.spec.tier == "premium" (check resource field)
   * - trigger.metadata.labels["environment"] == "prod" (check labels)
   * - trigger.status.phase == "Active" (check status)
   * - trigger.metadata.namespace == "production" (check namespace)
   * - has(trigger.spec.quotaProfile) (check field existence)
   */
  query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_trigger_constraints_items_expression: {
    input: any;
    output: any;
  };
  /**
   * Message provides a human-readable description explaining when this condition applies.
   * Used for documentation and debugging. Maximum 256 characters.
   *
   * Examples:
   * - "Applies only to premium tier organizations"
   * - "Matches organizations in production environment"
   * - "Triggers when quota profile is specified"
   */
  query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_trigger_constraints_items_message: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_trigger_resource_apiVersion: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_trigger_resource_kind: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listQuotaMiloapisComV1alpha1NamespacedResourceClaim_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1NamespacedResourceClaim_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1NamespacedResourceClaim_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listQuotaMiloapisComV1alpha1NamespacedResourceGrant_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1NamespacedResourceGrant_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1NamespacedResourceGrant_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * BaseUnit defines the internal measurement unit for all quota calculations.
   * The system stores and processes all quota amounts using this unit.
   * Use singular form with lowercase letters. Maximum 50 characters.
   *
   * Examples:
   * - "project" (for Entity type tracking Projects)
   * - "millicore" (for CPU allocation)
   * - "byte" (for storage or memory)
   * - "user" (for Entity type tracking Users)
   */
  query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_baseUnit: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_claimingResources_items_apiGroup: {
    input: any;
    output: any;
  };
  /**
   * Kind specifies the resource type that can create **ResourceClaims** for this registration.
   * Must match an existing resource type. Maximum 63 characters.
   *
   * Examples:
   * - `Project` (**Project** resource creating claims for **Project** quota)
   * - `User` (**User** resource creating claims for **User** quota)
   * - `Organization` (**Organization** resource creating claims for **Organization** quota)
   */
  query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_claimingResources_items_kind: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_consumerType_apiGroup: {
    input: any;
    output: any;
  };
  /**
   * Description provides human-readable context about what this registration tracks.
   * Use clear, specific language that explains the resource type and measurement approach.
   * Maximum 500 characters.
   *
   * Examples:
   * - "Projects created within Organizations"
   * - "CPU millicores allocated to workloads"
   * - "Storage bytes claimed by volume requests"
   */
  query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_description: {
    input: any;
    output: any;
  };
  /**
   * DisplayUnit defines the unit shown in user interfaces and API responses.
   * Should be more human-readable than BaseUnit. Use singular form. Maximum 50 characters.
   *
   * Examples:
   * - "project" (same as BaseUnit when no conversion needed)
   * - "core" (for displaying CPU instead of millicores)
   * - "GiB" (for displaying memory/storage instead of bytes)
   * - "TB" (for large storage volumes)
   */
  query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_displayUnit: {
    input: any;
    output: any;
  };
  /**
   * ResourceType identifies the resource to track with quota.
   * Platform administrators define resource type identifiers that make sense for their
   * quota system usage. This field is immutable after creation.
   *
   * The identifier format is flexible to accommodate various naming conventions
   * and organizational needs. Service providers can use any meaningful identifier.
   *
   * Examples:
   * - "resourcemanager.miloapis.com/projects"
   * - "iam.miloapis.com/users"
   * - "compute_cpu"
   * - "storage.volumes"
   * - "custom-service-quota"
   */
  query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_resourceType: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listResourcemanagerMiloapisComV1alpha1Organization_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listResourcemanagerMiloapisComV1alpha1Organization_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listResourcemanagerMiloapisComV1alpha1Organization_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listResourcemanagerMiloapisComV1alpha1Project_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listResourcemanagerMiloapisComV1alpha1Project_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listResourcemanagerMiloapisComV1alpha1Project_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_spec_sinks_items_name: {
    input: any;
    output: any;
  };
  query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_spec_sources_items_name: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_conditions_items_type: {
    input: any;
    output: any;
  };
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_sinks_items_conditions_items_message: {
    input: any;
    output: any;
  };
  query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_sinks_items_conditions_items_reason: {
    input: any;
    output: any;
  };
  query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_sinks_items_conditions_items_type: {
    input: any;
    output: any;
  };
};

/** APIGroupList is a list of APIGroup, to allow clients to discover the API at /apis. */
export type ApiGroupList_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** groups is a list of APIGroup. */
  groups: Array<Maybe<ApiGroup_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
};

/** APIGroup contains the name, the supported versions, and the preferred version of a group. */
export type ApiGroup_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  /** name is the name of the group. */
  name: Scalars['String']['output'];
  preferredVersion?: Maybe<GroupVersionForDiscovery_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>;
  /** a map of client CIDR to server address that is serving this group. This is to help clients reach servers in the most network-efficient way possible. Clients can use the appropriate server address as per the CIDR that they match. In case of multiple matches, clients should use the longest matching CIDR. The server returns only those CIDRs that it thinks that the client can match. For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP. Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP. */
  serverAddressByClientCIDRs?: Maybe<
    Array<Maybe<ServerAddressByClientCidr_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>>
  >;
  /** versions are the versions supported in this group. */
  versions: Array<Maybe<GroupVersionForDiscovery_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>>;
};

/** APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced. */
export type ApiResourceList_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** groupVersion is the group and version this APIResourceList is for. */
  groupVersion: Scalars['String']['output'];
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  /** resources contains the name of the resources and if they are namespaced. */
  resources: Array<Maybe<ApiResource_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>>;
};

/** APIResource specifies the name of a resource and whether it is namespaced. */
export type ApiResource_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io = {
  /** categories is a list of the grouped resources this resource belongs to (e.g. 'all') */
  categories?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** group is the preferred group of the resource.  Empty implies the group of the containing resource list. For subresources, this may have a different value, for example: Scale". */
  group?: Maybe<Scalars['String']['output']>;
  /** kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo') */
  kind: Scalars['String']['output'];
  /** name is the plural name of the resource. */
  name: Scalars['String']['output'];
  /** namespaced indicates if a resource is namespaced or not. */
  namespaced: Scalars['Boolean']['output'];
  /** shortNames is a list of suggested short names of the resource. */
  shortNames?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely. The singularName is more correct for reporting status on a single item and both singular and plural are allowed from the kubectl CLI interface. */
  singularName: Scalars['String']['output'];
  /** The hash value of the storage version, the version this resource is converted to when written to the data store. Value must be treated as opaque by clients. Only equality comparison on the value is valid. This is an alpha feature and may change or be removed in the future. The field is populated by the apiserver only if the StorageVersionHash feature gate is enabled. This field will remain optional even if it graduates. */
  storageVersionHash?: Maybe<Scalars['String']['output']>;
  /** verbs is a list of supported kube verbs (this includes get, list, watch, create, update, patch, delete, deletecollection, and proxy) */
  verbs: Array<Maybe<Scalars['String']['output']>>;
  /** version is the preferred version of the resource.  Empty implies the version of the containing resource list For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)". */
  version?: Maybe<Scalars['String']['output']>;
};

export type Dns_Const = 'DNS';

/** GroupVersion contains the "group/version" and "version" string of a version. It is made a struct to keep extensibility. */
export type GroupVersionForDiscovery_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io = {
  /** groupVersion specifies the API group and version in the form "group/version" */
  groupVersion: Scalars['String']['output'];
  /** version specifies the version in the form of "version". This is to save the clients the trouble of splitting the GroupVersion. */
  version: Scalars['String']['output'];
};

export type HttpMethod =
  | 'CONNECT'
  | 'DELETE'
  | 'GET'
  | 'HEAD'
  | 'OPTIONS'
  | 'PATCH'
  | 'POST'
  | 'PUT'
  | 'TRACE';

/** Info contains versioning information. how we'll want to distribute that information. */
export type Info_Version_Pkg_Apimachinery_K8s_Io = {
  buildDate: Scalars['String']['output'];
  compiler: Scalars['String']['output'];
  /** EmulationMajor is the major version of the emulation version */
  emulationMajor?: Maybe<Scalars['String']['output']>;
  /** EmulationMinor is the minor version of the emulation version */
  emulationMinor?: Maybe<Scalars['String']['output']>;
  gitCommit: Scalars['String']['output'];
  gitTreeState: Scalars['String']['output'];
  gitVersion: Scalars['String']['output'];
  goVersion: Scalars['String']['output'];
  /** Major is the major version of the binary version */
  major: Scalars['String']['output'];
  /** MinCompatibilityMajor is the major version of the minimum compatibility version */
  minCompatibilityMajor?: Maybe<Scalars['String']['output']>;
  /** MinCompatibilityMinor is the minor version of the minimum compatibility version */
  minCompatibilityMinor?: Maybe<Scalars['String']['output']>;
  /** Minor is the minor version of the binary version */
  minor: Scalars['String']['output'];
  platform: Scalars['String']['output'];
};

/** ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}. */
export type ListMeta_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io = {
  /** continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message. */
  continue?: Maybe<Scalars['String']['output']>;
  /** remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact. */
  remainingItemCount?: Maybe<Scalars['BigInt']['output']>;
  /** String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency */
  resourceVersion?: Maybe<Scalars['String']['output']>;
  /** Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. */
  selfLink?: Maybe<Scalars['String']['output']>;
};

/** ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}. */
export type ListMeta_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io_Input = {
  /** continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message. */
  continue?: InputMaybe<Scalars['String']['input']>;
  /** remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact. */
  remainingItemCount?: InputMaybe<Scalars['BigInt']['input']>;
  /** String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency */
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  /** Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. */
  selfLink?: InputMaybe<Scalars['String']['input']>;
};

export type Loops_Const = 'Loops';

/** ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to. */
export type ManagedFieldsEntry_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io = {
  /** APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted. */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1" */
  fieldsType?: Maybe<Scalars['String']['output']>;
  fieldsV1?: Maybe<Scalars['JSON']['output']>;
  /** Manager is an identifier of the workflow managing these fields. */
  manager?: Maybe<Scalars['String']['output']>;
  /** Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'. */
  operation?: Maybe<Scalars['String']['output']>;
  /** Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource. */
  subresource?: Maybe<Scalars['String']['output']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  time?: Maybe<Scalars['DateTime']['output']>;
};

/** ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to. */
export type ManagedFieldsEntry_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io_Input = {
  /** APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted. */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1" */
  fieldsType?: InputMaybe<Scalars['String']['input']>;
  fieldsV1?: InputMaybe<Scalars['JSON']['input']>;
  /** Manager is an identifier of the workflow managing these fields. */
  manager?: InputMaybe<Scalars['String']['input']>;
  /** Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'. */
  operation?: InputMaybe<Scalars['String']['input']>;
  /** Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource. */
  subresource?: InputMaybe<Scalars['String']['input']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  time?: InputMaybe<Scalars['DateTime']['input']>;
};

export type Mutation = {
  /** create an AuditLogQuery */
  createActivityMiloapisComV1alpha1AuditLogQuery?: Maybe<Com_Miloapis_Go_Activity_Pkg_Apis_Activity_V1alpha1_AuditLogQuery>;
  /** create a MutatingWebhookConfiguration */
  createAdmissionregistrationV1MutatingWebhookConfiguration?: Maybe<Io_K8s_Api_Admissionregistration_V1_MutatingWebhookConfiguration>;
  /** create a ValidatingAdmissionPolicy */
  createAdmissionregistrationV1ValidatingAdmissionPolicy?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicy>;
  /** create a ValidatingAdmissionPolicyBinding */
  createAdmissionregistrationV1ValidatingAdmissionPolicyBinding?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBinding>;
  /** create a ValidatingWebhookConfiguration */
  createAdmissionregistrationV1ValidatingWebhookConfiguration?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingWebhookConfiguration>;
  /** create a DocumentAcceptance */
  createAgreementMiloapisComV1alpha1NamespacedDocumentAcceptance?: Maybe<Com_Miloapis_Agreement_V1alpha1_DocumentAcceptance>;
  /** create a CustomResourceDefinition */
  createApiextensionsV1CustomResourceDefinition?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinition>;
  /** create an APIService */
  createApiregistrationV1APIService?: Maybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiService>;
  /** create a SelfSubjectReview */
  createAuthenticationV1SelfSubjectReview?: Maybe<Io_K8s_Api_Authentication_V1_SelfSubjectReview>;
  /** create a TokenReview */
  createAuthenticationV1TokenReview?: Maybe<Io_K8s_Api_Authentication_V1_TokenReview>;
  /** create a LocalSubjectAccessReview */
  createAuthorizationV1NamespacedLocalSubjectAccessReview?: Maybe<Io_K8s_Api_Authorization_V1_LocalSubjectAccessReview>;
  /** create a SelfSubjectAccessReview */
  createAuthorizationV1SelfSubjectAccessReview?: Maybe<Io_K8s_Api_Authorization_V1_SelfSubjectAccessReview>;
  /** create a SelfSubjectRulesReview */
  createAuthorizationV1SelfSubjectRulesReview?: Maybe<Io_K8s_Api_Authorization_V1_SelfSubjectRulesReview>;
  /** create a SubjectAccessReview */
  createAuthorizationV1SubjectAccessReview?: Maybe<Io_K8s_Api_Authorization_V1_SubjectAccessReview>;
  /** create an Instance */
  createComputeDatumapisComV1alphaNamespacedInstance?: Maybe<Com_Datumapis_Compute_V1alpha_Instance>;
  /** create a Workload */
  createComputeDatumapisComV1alphaNamespacedWorkload?: Maybe<Com_Datumapis_Compute_V1alpha_Workload>;
  /** create a WorkloadDeployment */
  createComputeDatumapisComV1alphaNamespacedWorkloadDeployment?: Maybe<Com_Datumapis_Compute_V1alpha_WorkloadDeployment>;
  /** create a Lease */
  createCoordinationV1NamespacedLease?: Maybe<Io_K8s_Api_Coordination_V1_Lease>;
  /** create a Namespace */
  createCoreV1Namespace?: Maybe<Io_K8s_Api_Core_V1_Namespace>;
  /** create a ConfigMap */
  createCoreV1NamespacedConfigMap?: Maybe<Io_K8s_Api_Core_V1_ConfigMap>;
  /** create an Event */
  createCoreV1NamespacedEvent?: Maybe<Io_K8s_Api_Core_V1_Event>;
  /** create a Secret */
  createCoreV1NamespacedSecret?: Maybe<Io_K8s_Api_Core_V1_Secret>;
  /** create a Note */
  createCrmMiloapisComV1alpha1Note?: Maybe<Com_Miloapis_Crm_V1alpha1_Note>;
  /** create an EndpointSlice */
  createDiscoveryV1NamespacedEndpointSlice?: Maybe<Io_K8s_Api_Discovery_V1_EndpointSlice>;
  /** create a DNSZoneClass */
  createDnsNetworkingMiloapisComV1alpha1DNSZoneClass?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClass>;
  /** create a DNSRecordSet */
  createDnsNetworkingMiloapisComV1alpha1NamespacedDNSRecordSet?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSet>;
  /** create a DNSZone */
  createDnsNetworkingMiloapisComV1alpha1NamespacedDNSZone?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZone>;
  /** create a DNSZoneDiscovery */
  createDnsNetworkingMiloapisComV1alpha1NamespacedDNSZoneDiscovery?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscovery>;
  /** create a Document */
  createDocumentationMiloapisComV1alpha1NamespacedDocument?: Maybe<Com_Miloapis_Documentation_V1alpha1_Document>;
  /** create a DocumentRevision */
  createDocumentationMiloapisComV1alpha1NamespacedDocumentRevision?: Maybe<Com_Miloapis_Documentation_V1alpha1_DocumentRevision>;
  /** create an Event */
  createEventsV1NamespacedEvent?: Maybe<Io_K8s_Api_Events_V1_Event>;
  /** create a FlowSchema */
  createFlowcontrolApiserverV1FlowSchema?: Maybe<Io_K8s_Api_Flowcontrol_V1_FlowSchema>;
  /** create a PriorityLevelConfiguration */
  createFlowcontrolApiserverV1PriorityLevelConfiguration?: Maybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfiguration>;
  /** create a Backend */
  createGatewayEnvoyproxyIoV1alpha1NamespacedBackend?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_Backend>;
  /** create a BackendTrafficPolicy */
  createGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicy?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicy>;
  /** create a HTTPRouteFilter */
  createGatewayEnvoyproxyIoV1alpha1NamespacedHTTPRouteFilter?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_HttpRouteFilter>;
  /** create a SecurityPolicy */
  createGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicy>;
  /** create a GatewayClass */
  createGatewayNetworkingV1GatewayClass?: Maybe<Io_K8s_Networking_Gateway_V1_GatewayClass>;
  /** create a BackendTLSPolicy */
  createGatewayNetworkingV1NamespacedBackendTLSPolicy?: Maybe<Io_K8s_Networking_Gateway_V1_BackendTlsPolicy>;
  /** create a Gateway */
  createGatewayNetworkingV1NamespacedGateway?: Maybe<Io_K8s_Networking_Gateway_V1_Gateway>;
  /** create a HTTPRoute */
  createGatewayNetworkingV1NamespacedHTTPRoute?: Maybe<Io_K8s_Networking_Gateway_V1_HttpRoute>;
  /** create a BackendTLSPolicy */
  createGatewayNetworkingV1alpha3NamespacedBackendTLSPolicy?: Maybe<Io_K8s_Networking_Gateway_V1alpha3_BackendTlsPolicy>;
  /** create a GatewayClass */
  createGatewayNetworkingV1beta1GatewayClass?: Maybe<Io_K8s_Networking_Gateway_V1beta1_GatewayClass>;
  /** create a Gateway */
  createGatewayNetworkingV1beta1NamespacedGateway?: Maybe<Io_K8s_Networking_Gateway_V1beta1_Gateway>;
  /** create a HTTPRoute */
  createGatewayNetworkingV1beta1NamespacedHTTPRoute?: Maybe<Io_K8s_Networking_Gateway_V1beta1_HttpRoute>;
  /** create a Group */
  createIamMiloapisComV1alpha1NamespacedGroup?: Maybe<Com_Miloapis_Iam_V1alpha1_Group>;
  /** create a GroupMembership */
  createIamMiloapisComV1alpha1NamespacedGroupMembership?: Maybe<Com_Miloapis_Iam_V1alpha1_GroupMembership>;
  /** create a MachineAccount */
  createIamMiloapisComV1alpha1NamespacedMachineAccount?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccount>;
  /** create a MachineAccountKey */
  createIamMiloapisComV1alpha1NamespacedMachineAccountKey?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccountKey>;
  /** create a PolicyBinding */
  createIamMiloapisComV1alpha1NamespacedPolicyBinding?: Maybe<Com_Miloapis_Iam_V1alpha1_PolicyBinding>;
  /** create a Role */
  createIamMiloapisComV1alpha1NamespacedRole?: Maybe<Com_Miloapis_Iam_V1alpha1_Role>;
  /** create an UserInvitation */
  createIamMiloapisComV1alpha1NamespacedUserInvitation?: Maybe<Com_Miloapis_Iam_V1alpha1_UserInvitation>;
  /** create a PlatformAccessApproval */
  createIamMiloapisComV1alpha1PlatformAccessApproval?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessApproval>;
  /** create a PlatformAccessDenial */
  createIamMiloapisComV1alpha1PlatformAccessDenial?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessDenial>;
  /** create a PlatformAccessRejection */
  createIamMiloapisComV1alpha1PlatformAccessRejection?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessRejection>;
  /** create a PlatformInvitation */
  createIamMiloapisComV1alpha1PlatformInvitation?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformInvitation>;
  /** create a ProtectedResource */
  createIamMiloapisComV1alpha1ProtectedResource?: Maybe<Com_Miloapis_Iam_V1alpha1_ProtectedResource>;
  /** create an User */
  createIamMiloapisComV1alpha1User?: Maybe<Com_Miloapis_Iam_V1alpha1_User>;
  /** create an UserDeactivation */
  createIamMiloapisComV1alpha1UserDeactivation?: Maybe<Com_Miloapis_Iam_V1alpha1_UserDeactivation>;
  /** create an UserPreference */
  createIamMiloapisComV1alpha1UserPreference?: Maybe<Com_Miloapis_Iam_V1alpha1_UserPreference>;
  /** create a Connector */
  createNetworkingDatumapisComV1alpha1NamespacedConnector?: Maybe<Com_Datumapis_Networking_V1alpha1_Connector>;
  /** create a ConnectorAdvertisement */
  createNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisement?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisement>;
  /** create a ConnectorClass */
  createNetworkingDatumapisComV1alpha1NamespacedConnectorClass?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorClass>;
  /** create a Domain */
  createNetworkingDatumapisComV1alphaNamespacedDomain?: Maybe<Com_Datumapis_Networking_V1alpha_Domain>;
  /** create a HTTPProxy */
  createNetworkingDatumapisComV1alphaNamespacedHTTPProxy?: Maybe<Com_Datumapis_Networking_V1alpha_HttpProxy>;
  /** create a Location */
  createNetworkingDatumapisComV1alphaNamespacedLocation?: Maybe<Com_Datumapis_Networking_V1alpha_Location>;
  /** create a Network */
  createNetworkingDatumapisComV1alphaNamespacedNetwork?: Maybe<Com_Datumapis_Networking_V1alpha_Network>;
  /** create a NetworkBinding */
  createNetworkingDatumapisComV1alphaNamespacedNetworkBinding?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkBinding>;
  /** create a NetworkContext */
  createNetworkingDatumapisComV1alphaNamespacedNetworkContext?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkContext>;
  /** create a NetworkPolicy */
  createNetworkingDatumapisComV1alphaNamespacedNetworkPolicy?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkPolicy>;
  /** create a Subnet */
  createNetworkingDatumapisComV1alphaNamespacedSubnet?: Maybe<Com_Datumapis_Networking_V1alpha_Subnet>;
  /** create a SubnetClaim */
  createNetworkingDatumapisComV1alphaNamespacedSubnetClaim?: Maybe<Com_Datumapis_Networking_V1alpha_SubnetClaim>;
  /** create a TrafficProtectionPolicy */
  createNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy?: Maybe<Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicy>;
  /** create an EmailTemplate */
  createNotificationMiloapisComV1alpha1EmailTemplate?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailTemplate>;
  /** create a Contact */
  createNotificationMiloapisComV1alpha1NamespacedContact?: Maybe<Com_Miloapis_Notification_V1alpha1_Contact>;
  /** create a ContactGroup */
  createNotificationMiloapisComV1alpha1NamespacedContactGroup?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroup>;
  /** create a ContactGroupMembership */
  createNotificationMiloapisComV1alpha1NamespacedContactGroupMembership?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembership>;
  /** create a ContactGroupMembershipRemoval */
  createNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemoval?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemoval>;
  /** create an Email */
  createNotificationMiloapisComV1alpha1NamespacedEmail?: Maybe<Com_Miloapis_Notification_V1alpha1_Email>;
  /** create an EmailBroadcast */
  createNotificationMiloapisComV1alpha1NamespacedEmailBroadcast?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailBroadcast>;
  /** create a Note */
  createNotificationMiloapisComV1alpha1NamespacedNote?: Maybe<Com_Miloapis_Notification_V1alpha1_Note>;
  /** create a ClaimCreationPolicy */
  createQuotaMiloapisComV1alpha1ClaimCreationPolicy?: Maybe<Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicy>;
  /** create a GrantCreationPolicy */
  createQuotaMiloapisComV1alpha1GrantCreationPolicy?: Maybe<Com_Miloapis_Quota_V1alpha1_GrantCreationPolicy>;
  /** create an AllowanceBucket */
  createQuotaMiloapisComV1alpha1NamespacedAllowanceBucket?: Maybe<Com_Miloapis_Quota_V1alpha1_AllowanceBucket>;
  /** create a ResourceClaim */
  createQuotaMiloapisComV1alpha1NamespacedResourceClaim?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceClaim>;
  /** create a ResourceGrant */
  createQuotaMiloapisComV1alpha1NamespacedResourceGrant?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceGrant>;
  /** create a ResourceRegistration */
  createQuotaMiloapisComV1alpha1ResourceRegistration?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceRegistration>;
  /** create a ClusterRole */
  createRbacAuthorizationV1ClusterRole?: Maybe<Io_K8s_Api_Rbac_V1_ClusterRole>;
  /** create a ClusterRoleBinding */
  createRbacAuthorizationV1ClusterRoleBinding?: Maybe<Io_K8s_Api_Rbac_V1_ClusterRoleBinding>;
  /** create a Role */
  createRbacAuthorizationV1NamespacedRole?: Maybe<Io_K8s_Api_Rbac_V1_Role>;
  /** create a RoleBinding */
  createRbacAuthorizationV1NamespacedRoleBinding?: Maybe<Io_K8s_Api_Rbac_V1_RoleBinding>;
  /** create an OrganizationMembership */
  createResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembership>;
  /** create an Organization */
  createResourcemanagerMiloapisComV1alpha1Organization?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Organization>;
  /** create a Project */
  createResourcemanagerMiloapisComV1alpha1Project?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Project>;
  /** create an ExportPolicy */
  createTelemetryMiloapisComV1alpha1NamespacedExportPolicy?: Maybe<Com_Miloapis_Telemetry_V1alpha1_ExportPolicy>;
  /** delete collection of MutatingWebhookConfiguration */
  deleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ValidatingAdmissionPolicy */
  deleteAdmissionregistrationV1CollectionValidatingAdmissionPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ValidatingAdmissionPolicyBinding */
  deleteAdmissionregistrationV1CollectionValidatingAdmissionPolicyBinding?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ValidatingWebhookConfiguration */
  deleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a MutatingWebhookConfiguration */
  deleteAdmissionregistrationV1MutatingWebhookConfiguration?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ValidatingAdmissionPolicy */
  deleteAdmissionregistrationV1ValidatingAdmissionPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ValidatingAdmissionPolicyBinding */
  deleteAdmissionregistrationV1ValidatingAdmissionPolicyBinding?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ValidatingWebhookConfiguration */
  deleteAdmissionregistrationV1ValidatingWebhookConfiguration?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of DocumentAcceptance */
  deleteAgreementMiloapisComV1alpha1CollectionNamespacedDocumentAcceptance?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a DocumentAcceptance */
  deleteAgreementMiloapisComV1alpha1NamespacedDocumentAcceptance?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of CustomResourceDefinition */
  deleteApiextensionsV1CollectionCustomResourceDefinition?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a CustomResourceDefinition */
  deleteApiextensionsV1CustomResourceDefinition?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an APIService */
  deleteApiregistrationV1APIService?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of APIService */
  deleteApiregistrationV1CollectionAPIService?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Instance */
  deleteComputeDatumapisComV1alphaCollectionNamespacedInstance?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Workload */
  deleteComputeDatumapisComV1alphaCollectionNamespacedWorkload?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of WorkloadDeployment */
  deleteComputeDatumapisComV1alphaCollectionNamespacedWorkloadDeployment?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an Instance */
  deleteComputeDatumapisComV1alphaNamespacedInstance?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Workload */
  deleteComputeDatumapisComV1alphaNamespacedWorkload?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a WorkloadDeployment */
  deleteComputeDatumapisComV1alphaNamespacedWorkloadDeployment?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Lease */
  deleteCoordinationV1CollectionNamespacedLease?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Lease */
  deleteCoordinationV1NamespacedLease?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ConfigMap */
  deleteCoreV1CollectionNamespacedConfigMap?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Event */
  deleteCoreV1CollectionNamespacedEvent?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Secret */
  deleteCoreV1CollectionNamespacedSecret?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Namespace */
  deleteCoreV1Namespace?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ConfigMap */
  deleteCoreV1NamespacedConfigMap?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an Event */
  deleteCoreV1NamespacedEvent?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Secret */
  deleteCoreV1NamespacedSecret?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Note */
  deleteCrmMiloapisComV1alpha1CollectionNote?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Note */
  deleteCrmMiloapisComV1alpha1Note?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of EndpointSlice */
  deleteDiscoveryV1CollectionNamespacedEndpointSlice?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an EndpointSlice */
  deleteDiscoveryV1NamespacedEndpointSlice?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of DNSZoneClass */
  deleteDnsNetworkingMiloapisComV1alpha1CollectionDNSZoneClass?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of DNSRecordSet */
  deleteDnsNetworkingMiloapisComV1alpha1CollectionNamespacedDNSRecordSet?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of DNSZone */
  deleteDnsNetworkingMiloapisComV1alpha1CollectionNamespacedDNSZone?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of DNSZoneDiscovery */
  deleteDnsNetworkingMiloapisComV1alpha1CollectionNamespacedDNSZoneDiscovery?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a DNSZoneClass */
  deleteDnsNetworkingMiloapisComV1alpha1DNSZoneClass?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a DNSRecordSet */
  deleteDnsNetworkingMiloapisComV1alpha1NamespacedDNSRecordSet?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a DNSZone */
  deleteDnsNetworkingMiloapisComV1alpha1NamespacedDNSZone?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a DNSZoneDiscovery */
  deleteDnsNetworkingMiloapisComV1alpha1NamespacedDNSZoneDiscovery?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Document */
  deleteDocumentationMiloapisComV1alpha1CollectionNamespacedDocument?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of DocumentRevision */
  deleteDocumentationMiloapisComV1alpha1CollectionNamespacedDocumentRevision?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Document */
  deleteDocumentationMiloapisComV1alpha1NamespacedDocument?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a DocumentRevision */
  deleteDocumentationMiloapisComV1alpha1NamespacedDocumentRevision?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Event */
  deleteEventsV1CollectionNamespacedEvent?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an Event */
  deleteEventsV1NamespacedEvent?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of FlowSchema */
  deleteFlowcontrolApiserverV1CollectionFlowSchema?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of PriorityLevelConfiguration */
  deleteFlowcontrolApiserverV1CollectionPriorityLevelConfiguration?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a FlowSchema */
  deleteFlowcontrolApiserverV1FlowSchema?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a PriorityLevelConfiguration */
  deleteFlowcontrolApiserverV1PriorityLevelConfiguration?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Backend */
  deleteGatewayEnvoyproxyIoV1alpha1CollectionNamespacedBackend?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of BackendTrafficPolicy */
  deleteGatewayEnvoyproxyIoV1alpha1CollectionNamespacedBackendTrafficPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of HTTPRouteFilter */
  deleteGatewayEnvoyproxyIoV1alpha1CollectionNamespacedHTTPRouteFilter?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of SecurityPolicy */
  deleteGatewayEnvoyproxyIoV1alpha1CollectionNamespacedSecurityPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Backend */
  deleteGatewayEnvoyproxyIoV1alpha1NamespacedBackend?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a BackendTrafficPolicy */
  deleteGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a HTTPRouteFilter */
  deleteGatewayEnvoyproxyIoV1alpha1NamespacedHTTPRouteFilter?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a SecurityPolicy */
  deleteGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of GatewayClass */
  deleteGatewayNetworkingV1CollectionGatewayClass?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of BackendTLSPolicy */
  deleteGatewayNetworkingV1CollectionNamespacedBackendTLSPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Gateway */
  deleteGatewayNetworkingV1CollectionNamespacedGateway?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of HTTPRoute */
  deleteGatewayNetworkingV1CollectionNamespacedHTTPRoute?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a GatewayClass */
  deleteGatewayNetworkingV1GatewayClass?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a BackendTLSPolicy */
  deleteGatewayNetworkingV1NamespacedBackendTLSPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Gateway */
  deleteGatewayNetworkingV1NamespacedGateway?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a HTTPRoute */
  deleteGatewayNetworkingV1NamespacedHTTPRoute?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of BackendTLSPolicy */
  deleteGatewayNetworkingV1alpha3CollectionNamespacedBackendTLSPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a BackendTLSPolicy */
  deleteGatewayNetworkingV1alpha3NamespacedBackendTLSPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of GatewayClass */
  deleteGatewayNetworkingV1beta1CollectionGatewayClass?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Gateway */
  deleteGatewayNetworkingV1beta1CollectionNamespacedGateway?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of HTTPRoute */
  deleteGatewayNetworkingV1beta1CollectionNamespacedHTTPRoute?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a GatewayClass */
  deleteGatewayNetworkingV1beta1GatewayClass?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Gateway */
  deleteGatewayNetworkingV1beta1NamespacedGateway?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a HTTPRoute */
  deleteGatewayNetworkingV1beta1NamespacedHTTPRoute?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Group */
  deleteIamMiloapisComV1alpha1CollectionNamespacedGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of GroupMembership */
  deleteIamMiloapisComV1alpha1CollectionNamespacedGroupMembership?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of MachineAccount */
  deleteIamMiloapisComV1alpha1CollectionNamespacedMachineAccount?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of MachineAccountKey */
  deleteIamMiloapisComV1alpha1CollectionNamespacedMachineAccountKey?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of PolicyBinding */
  deleteIamMiloapisComV1alpha1CollectionNamespacedPolicyBinding?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Role */
  deleteIamMiloapisComV1alpha1CollectionNamespacedRole?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of UserInvitation */
  deleteIamMiloapisComV1alpha1CollectionNamespacedUserInvitation?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of PlatformAccessApproval */
  deleteIamMiloapisComV1alpha1CollectionPlatformAccessApproval?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of PlatformAccessDenial */
  deleteIamMiloapisComV1alpha1CollectionPlatformAccessDenial?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of PlatformAccessRejection */
  deleteIamMiloapisComV1alpha1CollectionPlatformAccessRejection?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of PlatformInvitation */
  deleteIamMiloapisComV1alpha1CollectionPlatformInvitation?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ProtectedResource */
  deleteIamMiloapisComV1alpha1CollectionProtectedResource?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of User */
  deleteIamMiloapisComV1alpha1CollectionUser?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of UserDeactivation */
  deleteIamMiloapisComV1alpha1CollectionUserDeactivation?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of UserPreference */
  deleteIamMiloapisComV1alpha1CollectionUserPreference?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Group */
  deleteIamMiloapisComV1alpha1NamespacedGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a GroupMembership */
  deleteIamMiloapisComV1alpha1NamespacedGroupMembership?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a MachineAccount */
  deleteIamMiloapisComV1alpha1NamespacedMachineAccount?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a MachineAccountKey */
  deleteIamMiloapisComV1alpha1NamespacedMachineAccountKey?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a PolicyBinding */
  deleteIamMiloapisComV1alpha1NamespacedPolicyBinding?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Role */
  deleteIamMiloapisComV1alpha1NamespacedRole?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an UserInvitation */
  deleteIamMiloapisComV1alpha1NamespacedUserInvitation?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a PlatformAccessApproval */
  deleteIamMiloapisComV1alpha1PlatformAccessApproval?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a PlatformAccessDenial */
  deleteIamMiloapisComV1alpha1PlatformAccessDenial?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a PlatformAccessRejection */
  deleteIamMiloapisComV1alpha1PlatformAccessRejection?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a PlatformInvitation */
  deleteIamMiloapisComV1alpha1PlatformInvitation?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ProtectedResource */
  deleteIamMiloapisComV1alpha1ProtectedResource?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an User */
  deleteIamMiloapisComV1alpha1User?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an UserDeactivation */
  deleteIamMiloapisComV1alpha1UserDeactivation?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an UserPreference */
  deleteIamMiloapisComV1alpha1UserPreference?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Session */
  deleteIdentityMiloapisComV1alpha1Session?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Connector */
  deleteNetworkingDatumapisComV1alpha1CollectionNamespacedConnector?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ConnectorAdvertisement */
  deleteNetworkingDatumapisComV1alpha1CollectionNamespacedConnectorAdvertisement?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ConnectorClass */
  deleteNetworkingDatumapisComV1alpha1CollectionNamespacedConnectorClass?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Connector */
  deleteNetworkingDatumapisComV1alpha1NamespacedConnector?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ConnectorAdvertisement */
  deleteNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisement?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ConnectorClass */
  deleteNetworkingDatumapisComV1alpha1NamespacedConnectorClass?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Domain */
  deleteNetworkingDatumapisComV1alphaCollectionNamespacedDomain?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of HTTPProxy */
  deleteNetworkingDatumapisComV1alphaCollectionNamespacedHTTPProxy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Location */
  deleteNetworkingDatumapisComV1alphaCollectionNamespacedLocation?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Network */
  deleteNetworkingDatumapisComV1alphaCollectionNamespacedNetwork?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of NetworkBinding */
  deleteNetworkingDatumapisComV1alphaCollectionNamespacedNetworkBinding?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of NetworkContext */
  deleteNetworkingDatumapisComV1alphaCollectionNamespacedNetworkContext?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of NetworkPolicy */
  deleteNetworkingDatumapisComV1alphaCollectionNamespacedNetworkPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Subnet */
  deleteNetworkingDatumapisComV1alphaCollectionNamespacedSubnet?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of SubnetClaim */
  deleteNetworkingDatumapisComV1alphaCollectionNamespacedSubnetClaim?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of TrafficProtectionPolicy */
  deleteNetworkingDatumapisComV1alphaCollectionNamespacedTrafficProtectionPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Domain */
  deleteNetworkingDatumapisComV1alphaNamespacedDomain?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a HTTPProxy */
  deleteNetworkingDatumapisComV1alphaNamespacedHTTPProxy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Location */
  deleteNetworkingDatumapisComV1alphaNamespacedLocation?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Network */
  deleteNetworkingDatumapisComV1alphaNamespacedNetwork?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a NetworkBinding */
  deleteNetworkingDatumapisComV1alphaNamespacedNetworkBinding?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a NetworkContext */
  deleteNetworkingDatumapisComV1alphaNamespacedNetworkContext?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a NetworkPolicy */
  deleteNetworkingDatumapisComV1alphaNamespacedNetworkPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Subnet */
  deleteNetworkingDatumapisComV1alphaNamespacedSubnet?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a SubnetClaim */
  deleteNetworkingDatumapisComV1alphaNamespacedSubnetClaim?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a TrafficProtectionPolicy */
  deleteNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of EmailTemplate */
  deleteNotificationMiloapisComV1alpha1CollectionEmailTemplate?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Contact */
  deleteNotificationMiloapisComV1alpha1CollectionNamespacedContact?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ContactGroup */
  deleteNotificationMiloapisComV1alpha1CollectionNamespacedContactGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ContactGroupMembership */
  deleteNotificationMiloapisComV1alpha1CollectionNamespacedContactGroupMembership?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ContactGroupMembershipRemoval */
  deleteNotificationMiloapisComV1alpha1CollectionNamespacedContactGroupMembershipRemoval?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Email */
  deleteNotificationMiloapisComV1alpha1CollectionNamespacedEmail?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of EmailBroadcast */
  deleteNotificationMiloapisComV1alpha1CollectionNamespacedEmailBroadcast?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Note */
  deleteNotificationMiloapisComV1alpha1CollectionNamespacedNote?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an EmailTemplate */
  deleteNotificationMiloapisComV1alpha1EmailTemplate?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Contact */
  deleteNotificationMiloapisComV1alpha1NamespacedContact?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ContactGroup */
  deleteNotificationMiloapisComV1alpha1NamespacedContactGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ContactGroupMembership */
  deleteNotificationMiloapisComV1alpha1NamespacedContactGroupMembership?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ContactGroupMembershipRemoval */
  deleteNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemoval?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an Email */
  deleteNotificationMiloapisComV1alpha1NamespacedEmail?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an EmailBroadcast */
  deleteNotificationMiloapisComV1alpha1NamespacedEmailBroadcast?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Note */
  deleteNotificationMiloapisComV1alpha1NamespacedNote?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ClaimCreationPolicy */
  deleteQuotaMiloapisComV1alpha1ClaimCreationPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ClaimCreationPolicy */
  deleteQuotaMiloapisComV1alpha1CollectionClaimCreationPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of GrantCreationPolicy */
  deleteQuotaMiloapisComV1alpha1CollectionGrantCreationPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of AllowanceBucket */
  deleteQuotaMiloapisComV1alpha1CollectionNamespacedAllowanceBucket?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ResourceClaim */
  deleteQuotaMiloapisComV1alpha1CollectionNamespacedResourceClaim?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ResourceGrant */
  deleteQuotaMiloapisComV1alpha1CollectionNamespacedResourceGrant?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ResourceRegistration */
  deleteQuotaMiloapisComV1alpha1CollectionResourceRegistration?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a GrantCreationPolicy */
  deleteQuotaMiloapisComV1alpha1GrantCreationPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an AllowanceBucket */
  deleteQuotaMiloapisComV1alpha1NamespacedAllowanceBucket?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ResourceClaim */
  deleteQuotaMiloapisComV1alpha1NamespacedResourceClaim?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ResourceGrant */
  deleteQuotaMiloapisComV1alpha1NamespacedResourceGrant?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ResourceRegistration */
  deleteQuotaMiloapisComV1alpha1ResourceRegistration?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ClusterRole */
  deleteRbacAuthorizationV1ClusterRole?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a ClusterRoleBinding */
  deleteRbacAuthorizationV1ClusterRoleBinding?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ClusterRole */
  deleteRbacAuthorizationV1CollectionClusterRole?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ClusterRoleBinding */
  deleteRbacAuthorizationV1CollectionClusterRoleBinding?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Role */
  deleteRbacAuthorizationV1CollectionNamespacedRole?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of RoleBinding */
  deleteRbacAuthorizationV1CollectionNamespacedRoleBinding?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Role */
  deleteRbacAuthorizationV1NamespacedRole?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a RoleBinding */
  deleteRbacAuthorizationV1NamespacedRoleBinding?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of OrganizationMembership */
  deleteResourcemanagerMiloapisComV1alpha1CollectionNamespacedOrganizationMembership?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Organization */
  deleteResourcemanagerMiloapisComV1alpha1CollectionOrganization?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of Project */
  deleteResourcemanagerMiloapisComV1alpha1CollectionProject?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an OrganizationMembership */
  deleteResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an Organization */
  deleteResourcemanagerMiloapisComV1alpha1Organization?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete a Project */
  deleteResourcemanagerMiloapisComV1alpha1Project?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete collection of ExportPolicy */
  deleteTelemetryMiloapisComV1alpha1CollectionNamespacedExportPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** delete an ExportPolicy */
  deleteTelemetryMiloapisComV1alpha1NamespacedExportPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status>;
  /** partially update the specified MutatingWebhookConfiguration */
  patchAdmissionregistrationV1MutatingWebhookConfiguration?: Maybe<Io_K8s_Api_Admissionregistration_V1_MutatingWebhookConfiguration>;
  /** partially update the specified ValidatingAdmissionPolicy */
  patchAdmissionregistrationV1ValidatingAdmissionPolicy?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicy>;
  /** partially update the specified ValidatingAdmissionPolicyBinding */
  patchAdmissionregistrationV1ValidatingAdmissionPolicyBinding?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBinding>;
  /** partially update status of the specified ValidatingAdmissionPolicy */
  patchAdmissionregistrationV1ValidatingAdmissionPolicyStatus?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicy>;
  /** partially update the specified ValidatingWebhookConfiguration */
  patchAdmissionregistrationV1ValidatingWebhookConfiguration?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingWebhookConfiguration>;
  /** partially update the specified DocumentAcceptance */
  patchAgreementMiloapisComV1alpha1NamespacedDocumentAcceptance?: Maybe<Com_Miloapis_Agreement_V1alpha1_DocumentAcceptance>;
  /** partially update status of the specified DocumentAcceptance */
  patchAgreementMiloapisComV1alpha1NamespacedDocumentAcceptanceStatus?: Maybe<Com_Miloapis_Agreement_V1alpha1_DocumentAcceptance>;
  /** partially update the specified CustomResourceDefinition */
  patchApiextensionsV1CustomResourceDefinition?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinition>;
  /** partially update status of the specified CustomResourceDefinition */
  patchApiextensionsV1CustomResourceDefinitionStatus?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinition>;
  /** partially update the specified APIService */
  patchApiregistrationV1APIService?: Maybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiService>;
  /** partially update status of the specified APIService */
  patchApiregistrationV1APIServiceStatus?: Maybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiService>;
  /** partially update the specified Instance */
  patchComputeDatumapisComV1alphaNamespacedInstance?: Maybe<Com_Datumapis_Compute_V1alpha_Instance>;
  /** partially update status of the specified Instance */
  patchComputeDatumapisComV1alphaNamespacedInstanceStatus?: Maybe<Com_Datumapis_Compute_V1alpha_Instance>;
  /** partially update the specified Workload */
  patchComputeDatumapisComV1alphaNamespacedWorkload?: Maybe<Com_Datumapis_Compute_V1alpha_Workload>;
  /** partially update the specified WorkloadDeployment */
  patchComputeDatumapisComV1alphaNamespacedWorkloadDeployment?: Maybe<Com_Datumapis_Compute_V1alpha_WorkloadDeployment>;
  /** partially update status of the specified WorkloadDeployment */
  patchComputeDatumapisComV1alphaNamespacedWorkloadDeploymentStatus?: Maybe<Com_Datumapis_Compute_V1alpha_WorkloadDeployment>;
  /** partially update status of the specified Workload */
  patchComputeDatumapisComV1alphaNamespacedWorkloadStatus?: Maybe<Com_Datumapis_Compute_V1alpha_Workload>;
  /** partially update the specified Lease */
  patchCoordinationV1NamespacedLease?: Maybe<Io_K8s_Api_Coordination_V1_Lease>;
  /** partially update the specified Namespace */
  patchCoreV1Namespace?: Maybe<Io_K8s_Api_Core_V1_Namespace>;
  /** partially update status of the specified Namespace */
  patchCoreV1NamespaceStatus?: Maybe<Io_K8s_Api_Core_V1_Namespace>;
  /** partially update the specified ConfigMap */
  patchCoreV1NamespacedConfigMap?: Maybe<Io_K8s_Api_Core_V1_ConfigMap>;
  /** partially update the specified Event */
  patchCoreV1NamespacedEvent?: Maybe<Io_K8s_Api_Core_V1_Event>;
  /** partially update the specified Secret */
  patchCoreV1NamespacedSecret?: Maybe<Io_K8s_Api_Core_V1_Secret>;
  /** partially update the specified Note */
  patchCrmMiloapisComV1alpha1Note?: Maybe<Com_Miloapis_Crm_V1alpha1_Note>;
  /** partially update status of the specified Note */
  patchCrmMiloapisComV1alpha1NoteStatus?: Maybe<Com_Miloapis_Crm_V1alpha1_Note>;
  /** partially update the specified EndpointSlice */
  patchDiscoveryV1NamespacedEndpointSlice?: Maybe<Io_K8s_Api_Discovery_V1_EndpointSlice>;
  /** partially update the specified DNSZoneClass */
  patchDnsNetworkingMiloapisComV1alpha1DNSZoneClass?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClass>;
  /** partially update status of the specified DNSZoneClass */
  patchDnsNetworkingMiloapisComV1alpha1DNSZoneClassStatus?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClass>;
  /** partially update the specified DNSRecordSet */
  patchDnsNetworkingMiloapisComV1alpha1NamespacedDNSRecordSet?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSet>;
  /** partially update status of the specified DNSRecordSet */
  patchDnsNetworkingMiloapisComV1alpha1NamespacedDNSRecordSetStatus?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSet>;
  /** partially update the specified DNSZone */
  patchDnsNetworkingMiloapisComV1alpha1NamespacedDNSZone?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZone>;
  /** partially update the specified DNSZoneDiscovery */
  patchDnsNetworkingMiloapisComV1alpha1NamespacedDNSZoneDiscovery?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscovery>;
  /** partially update status of the specified DNSZoneDiscovery */
  patchDnsNetworkingMiloapisComV1alpha1NamespacedDNSZoneDiscoveryStatus?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscovery>;
  /** partially update status of the specified DNSZone */
  patchDnsNetworkingMiloapisComV1alpha1NamespacedDNSZoneStatus?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZone>;
  /** partially update the specified Document */
  patchDocumentationMiloapisComV1alpha1NamespacedDocument?: Maybe<Com_Miloapis_Documentation_V1alpha1_Document>;
  /** partially update the specified DocumentRevision */
  patchDocumentationMiloapisComV1alpha1NamespacedDocumentRevision?: Maybe<Com_Miloapis_Documentation_V1alpha1_DocumentRevision>;
  /** partially update status of the specified DocumentRevision */
  patchDocumentationMiloapisComV1alpha1NamespacedDocumentRevisionStatus?: Maybe<Com_Miloapis_Documentation_V1alpha1_DocumentRevision>;
  /** partially update status of the specified Document */
  patchDocumentationMiloapisComV1alpha1NamespacedDocumentStatus?: Maybe<Com_Miloapis_Documentation_V1alpha1_Document>;
  /** partially update the specified Event */
  patchEventsV1NamespacedEvent?: Maybe<Io_K8s_Api_Events_V1_Event>;
  /** partially update the specified FlowSchema */
  patchFlowcontrolApiserverV1FlowSchema?: Maybe<Io_K8s_Api_Flowcontrol_V1_FlowSchema>;
  /** partially update status of the specified FlowSchema */
  patchFlowcontrolApiserverV1FlowSchemaStatus?: Maybe<Io_K8s_Api_Flowcontrol_V1_FlowSchema>;
  /** partially update the specified PriorityLevelConfiguration */
  patchFlowcontrolApiserverV1PriorityLevelConfiguration?: Maybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfiguration>;
  /** partially update status of the specified PriorityLevelConfiguration */
  patchFlowcontrolApiserverV1PriorityLevelConfigurationStatus?: Maybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfiguration>;
  /** partially update the specified Backend */
  patchGatewayEnvoyproxyIoV1alpha1NamespacedBackend?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_Backend>;
  /** partially update status of the specified Backend */
  patchGatewayEnvoyproxyIoV1alpha1NamespacedBackendStatus?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_Backend>;
  /** partially update the specified BackendTrafficPolicy */
  patchGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicy?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicy>;
  /** partially update status of the specified BackendTrafficPolicy */
  patchGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicyStatus?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicy>;
  /** partially update the specified HTTPRouteFilter */
  patchGatewayEnvoyproxyIoV1alpha1NamespacedHTTPRouteFilter?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_HttpRouteFilter>;
  /** partially update the specified SecurityPolicy */
  patchGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicy>;
  /** partially update status of the specified SecurityPolicy */
  patchGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicyStatus?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicy>;
  /** partially update the specified GatewayClass */
  patchGatewayNetworkingV1GatewayClass?: Maybe<Io_K8s_Networking_Gateway_V1_GatewayClass>;
  /** partially update status of the specified GatewayClass */
  patchGatewayNetworkingV1GatewayClassStatus?: Maybe<Io_K8s_Networking_Gateway_V1_GatewayClass>;
  /** partially update the specified BackendTLSPolicy */
  patchGatewayNetworkingV1NamespacedBackendTLSPolicy?: Maybe<Io_K8s_Networking_Gateway_V1_BackendTlsPolicy>;
  /** partially update status of the specified BackendTLSPolicy */
  patchGatewayNetworkingV1NamespacedBackendTLSPolicyStatus?: Maybe<Io_K8s_Networking_Gateway_V1_BackendTlsPolicy>;
  /** partially update the specified Gateway */
  patchGatewayNetworkingV1NamespacedGateway?: Maybe<Io_K8s_Networking_Gateway_V1_Gateway>;
  /** partially update status of the specified Gateway */
  patchGatewayNetworkingV1NamespacedGatewayStatus?: Maybe<Io_K8s_Networking_Gateway_V1_Gateway>;
  /** partially update the specified HTTPRoute */
  patchGatewayNetworkingV1NamespacedHTTPRoute?: Maybe<Io_K8s_Networking_Gateway_V1_HttpRoute>;
  /** partially update status of the specified HTTPRoute */
  patchGatewayNetworkingV1NamespacedHTTPRouteStatus?: Maybe<Io_K8s_Networking_Gateway_V1_HttpRoute>;
  /** partially update the specified BackendTLSPolicy */
  patchGatewayNetworkingV1alpha3NamespacedBackendTLSPolicy?: Maybe<Io_K8s_Networking_Gateway_V1alpha3_BackendTlsPolicy>;
  /** partially update the specified GatewayClass */
  patchGatewayNetworkingV1beta1GatewayClass?: Maybe<Io_K8s_Networking_Gateway_V1beta1_GatewayClass>;
  /** partially update status of the specified GatewayClass */
  patchGatewayNetworkingV1beta1GatewayClassStatus?: Maybe<Io_K8s_Networking_Gateway_V1beta1_GatewayClass>;
  /** partially update the specified Gateway */
  patchGatewayNetworkingV1beta1NamespacedGateway?: Maybe<Io_K8s_Networking_Gateway_V1beta1_Gateway>;
  /** partially update status of the specified Gateway */
  patchGatewayNetworkingV1beta1NamespacedGatewayStatus?: Maybe<Io_K8s_Networking_Gateway_V1beta1_Gateway>;
  /** partially update the specified HTTPRoute */
  patchGatewayNetworkingV1beta1NamespacedHTTPRoute?: Maybe<Io_K8s_Networking_Gateway_V1beta1_HttpRoute>;
  /** partially update status of the specified HTTPRoute */
  patchGatewayNetworkingV1beta1NamespacedHTTPRouteStatus?: Maybe<Io_K8s_Networking_Gateway_V1beta1_HttpRoute>;
  /** partially update the specified Group */
  patchIamMiloapisComV1alpha1NamespacedGroup?: Maybe<Com_Miloapis_Iam_V1alpha1_Group>;
  /** partially update the specified GroupMembership */
  patchIamMiloapisComV1alpha1NamespacedGroupMembership?: Maybe<Com_Miloapis_Iam_V1alpha1_GroupMembership>;
  /** partially update status of the specified GroupMembership */
  patchIamMiloapisComV1alpha1NamespacedGroupMembershipStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_GroupMembership>;
  /** partially update status of the specified Group */
  patchIamMiloapisComV1alpha1NamespacedGroupStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_Group>;
  /** partially update the specified MachineAccount */
  patchIamMiloapisComV1alpha1NamespacedMachineAccount?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccount>;
  /** partially update the specified MachineAccountKey */
  patchIamMiloapisComV1alpha1NamespacedMachineAccountKey?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccountKey>;
  /** partially update status of the specified MachineAccountKey */
  patchIamMiloapisComV1alpha1NamespacedMachineAccountKeyStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccountKey>;
  /** partially update status of the specified MachineAccount */
  patchIamMiloapisComV1alpha1NamespacedMachineAccountStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccount>;
  /** partially update the specified PolicyBinding */
  patchIamMiloapisComV1alpha1NamespacedPolicyBinding?: Maybe<Com_Miloapis_Iam_V1alpha1_PolicyBinding>;
  /** partially update status of the specified PolicyBinding */
  patchIamMiloapisComV1alpha1NamespacedPolicyBindingStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PolicyBinding>;
  /** partially update the specified Role */
  patchIamMiloapisComV1alpha1NamespacedRole?: Maybe<Com_Miloapis_Iam_V1alpha1_Role>;
  /** partially update status of the specified Role */
  patchIamMiloapisComV1alpha1NamespacedRoleStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_Role>;
  /** partially update the specified UserInvitation */
  patchIamMiloapisComV1alpha1NamespacedUserInvitation?: Maybe<Com_Miloapis_Iam_V1alpha1_UserInvitation>;
  /** partially update status of the specified UserInvitation */
  patchIamMiloapisComV1alpha1NamespacedUserInvitationStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_UserInvitation>;
  /** partially update the specified PlatformAccessApproval */
  patchIamMiloapisComV1alpha1PlatformAccessApproval?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessApproval>;
  /** partially update status of the specified PlatformAccessApproval */
  patchIamMiloapisComV1alpha1PlatformAccessApprovalStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessApproval>;
  /** partially update the specified PlatformAccessDenial */
  patchIamMiloapisComV1alpha1PlatformAccessDenial?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessDenial>;
  /** partially update status of the specified PlatformAccessDenial */
  patchIamMiloapisComV1alpha1PlatformAccessDenialStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessDenial>;
  /** partially update the specified PlatformAccessRejection */
  patchIamMiloapisComV1alpha1PlatformAccessRejection?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessRejection>;
  /** partially update status of the specified PlatformAccessRejection */
  patchIamMiloapisComV1alpha1PlatformAccessRejectionStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessRejection>;
  /** partially update the specified PlatformInvitation */
  patchIamMiloapisComV1alpha1PlatformInvitation?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformInvitation>;
  /** partially update status of the specified PlatformInvitation */
  patchIamMiloapisComV1alpha1PlatformInvitationStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformInvitation>;
  /** partially update the specified ProtectedResource */
  patchIamMiloapisComV1alpha1ProtectedResource?: Maybe<Com_Miloapis_Iam_V1alpha1_ProtectedResource>;
  /** partially update status of the specified ProtectedResource */
  patchIamMiloapisComV1alpha1ProtectedResourceStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_ProtectedResource>;
  /** partially update the specified User */
  patchIamMiloapisComV1alpha1User?: Maybe<Com_Miloapis_Iam_V1alpha1_User>;
  /** partially update the specified UserDeactivation */
  patchIamMiloapisComV1alpha1UserDeactivation?: Maybe<Com_Miloapis_Iam_V1alpha1_UserDeactivation>;
  /** partially update status of the specified UserDeactivation */
  patchIamMiloapisComV1alpha1UserDeactivationStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_UserDeactivation>;
  /** partially update the specified UserPreference */
  patchIamMiloapisComV1alpha1UserPreference?: Maybe<Com_Miloapis_Iam_V1alpha1_UserPreference>;
  /** partially update status of the specified UserPreference */
  patchIamMiloapisComV1alpha1UserPreferenceStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_UserPreference>;
  /** partially update status of the specified User */
  patchIamMiloapisComV1alpha1UserStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_User>;
  /** partially update the specified Connector */
  patchNetworkingDatumapisComV1alpha1NamespacedConnector?: Maybe<Com_Datumapis_Networking_V1alpha1_Connector>;
  /** partially update the specified ConnectorAdvertisement */
  patchNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisement?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisement>;
  /** partially update status of the specified ConnectorAdvertisement */
  patchNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisementStatus?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisement>;
  /** partially update the specified ConnectorClass */
  patchNetworkingDatumapisComV1alpha1NamespacedConnectorClass?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorClass>;
  /** partially update status of the specified ConnectorClass */
  patchNetworkingDatumapisComV1alpha1NamespacedConnectorClassStatus?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorClass>;
  /** partially update status of the specified Connector */
  patchNetworkingDatumapisComV1alpha1NamespacedConnectorStatus?: Maybe<Com_Datumapis_Networking_V1alpha1_Connector>;
  /** partially update the specified Domain */
  patchNetworkingDatumapisComV1alphaNamespacedDomain?: Maybe<Com_Datumapis_Networking_V1alpha_Domain>;
  /** partially update status of the specified Domain */
  patchNetworkingDatumapisComV1alphaNamespacedDomainStatus?: Maybe<Com_Datumapis_Networking_V1alpha_Domain>;
  /** partially update the specified HTTPProxy */
  patchNetworkingDatumapisComV1alphaNamespacedHTTPProxy?: Maybe<Com_Datumapis_Networking_V1alpha_HttpProxy>;
  /** partially update status of the specified HTTPProxy */
  patchNetworkingDatumapisComV1alphaNamespacedHTTPProxyStatus?: Maybe<Com_Datumapis_Networking_V1alpha_HttpProxy>;
  /** partially update the specified Location */
  patchNetworkingDatumapisComV1alphaNamespacedLocation?: Maybe<Com_Datumapis_Networking_V1alpha_Location>;
  /** partially update status of the specified Location */
  patchNetworkingDatumapisComV1alphaNamespacedLocationStatus?: Maybe<Com_Datumapis_Networking_V1alpha_Location>;
  /** partially update the specified Network */
  patchNetworkingDatumapisComV1alphaNamespacedNetwork?: Maybe<Com_Datumapis_Networking_V1alpha_Network>;
  /** partially update the specified NetworkBinding */
  patchNetworkingDatumapisComV1alphaNamespacedNetworkBinding?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkBinding>;
  /** partially update status of the specified NetworkBinding */
  patchNetworkingDatumapisComV1alphaNamespacedNetworkBindingStatus?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkBinding>;
  /** partially update the specified NetworkContext */
  patchNetworkingDatumapisComV1alphaNamespacedNetworkContext?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkContext>;
  /** partially update status of the specified NetworkContext */
  patchNetworkingDatumapisComV1alphaNamespacedNetworkContextStatus?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkContext>;
  /** partially update the specified NetworkPolicy */
  patchNetworkingDatumapisComV1alphaNamespacedNetworkPolicy?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkPolicy>;
  /** partially update status of the specified NetworkPolicy */
  patchNetworkingDatumapisComV1alphaNamespacedNetworkPolicyStatus?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkPolicy>;
  /** partially update status of the specified Network */
  patchNetworkingDatumapisComV1alphaNamespacedNetworkStatus?: Maybe<Com_Datumapis_Networking_V1alpha_Network>;
  /** partially update the specified Subnet */
  patchNetworkingDatumapisComV1alphaNamespacedSubnet?: Maybe<Com_Datumapis_Networking_V1alpha_Subnet>;
  /** partially update the specified SubnetClaim */
  patchNetworkingDatumapisComV1alphaNamespacedSubnetClaim?: Maybe<Com_Datumapis_Networking_V1alpha_SubnetClaim>;
  /** partially update status of the specified SubnetClaim */
  patchNetworkingDatumapisComV1alphaNamespacedSubnetClaimStatus?: Maybe<Com_Datumapis_Networking_V1alpha_SubnetClaim>;
  /** partially update status of the specified Subnet */
  patchNetworkingDatumapisComV1alphaNamespacedSubnetStatus?: Maybe<Com_Datumapis_Networking_V1alpha_Subnet>;
  /** partially update the specified TrafficProtectionPolicy */
  patchNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy?: Maybe<Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicy>;
  /** partially update status of the specified TrafficProtectionPolicy */
  patchNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicyStatus?: Maybe<Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicy>;
  /** partially update the specified EmailTemplate */
  patchNotificationMiloapisComV1alpha1EmailTemplate?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailTemplate>;
  /** partially update status of the specified EmailTemplate */
  patchNotificationMiloapisComV1alpha1EmailTemplateStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailTemplate>;
  /** partially update the specified Contact */
  patchNotificationMiloapisComV1alpha1NamespacedContact?: Maybe<Com_Miloapis_Notification_V1alpha1_Contact>;
  /** partially update the specified ContactGroup */
  patchNotificationMiloapisComV1alpha1NamespacedContactGroup?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroup>;
  /** partially update the specified ContactGroupMembership */
  patchNotificationMiloapisComV1alpha1NamespacedContactGroupMembership?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembership>;
  /** partially update the specified ContactGroupMembershipRemoval */
  patchNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemoval?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemoval>;
  /** partially update status of the specified ContactGroupMembershipRemoval */
  patchNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemovalStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemoval>;
  /** partially update status of the specified ContactGroupMembership */
  patchNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembership>;
  /** partially update status of the specified ContactGroup */
  patchNotificationMiloapisComV1alpha1NamespacedContactGroupStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroup>;
  /** partially update status of the specified Contact */
  patchNotificationMiloapisComV1alpha1NamespacedContactStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_Contact>;
  /** partially update the specified Email */
  patchNotificationMiloapisComV1alpha1NamespacedEmail?: Maybe<Com_Miloapis_Notification_V1alpha1_Email>;
  /** partially update the specified EmailBroadcast */
  patchNotificationMiloapisComV1alpha1NamespacedEmailBroadcast?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailBroadcast>;
  /** partially update status of the specified EmailBroadcast */
  patchNotificationMiloapisComV1alpha1NamespacedEmailBroadcastStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailBroadcast>;
  /** partially update status of the specified Email */
  patchNotificationMiloapisComV1alpha1NamespacedEmailStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_Email>;
  /** partially update the specified Note */
  patchNotificationMiloapisComV1alpha1NamespacedNote?: Maybe<Com_Miloapis_Notification_V1alpha1_Note>;
  /** partially update status of the specified Note */
  patchNotificationMiloapisComV1alpha1NamespacedNoteStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_Note>;
  /** partially update the specified ClaimCreationPolicy */
  patchQuotaMiloapisComV1alpha1ClaimCreationPolicy?: Maybe<Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicy>;
  /** partially update status of the specified ClaimCreationPolicy */
  patchQuotaMiloapisComV1alpha1ClaimCreationPolicyStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicy>;
  /** partially update the specified GrantCreationPolicy */
  patchQuotaMiloapisComV1alpha1GrantCreationPolicy?: Maybe<Com_Miloapis_Quota_V1alpha1_GrantCreationPolicy>;
  /** partially update status of the specified GrantCreationPolicy */
  patchQuotaMiloapisComV1alpha1GrantCreationPolicyStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_GrantCreationPolicy>;
  /** partially update the specified AllowanceBucket */
  patchQuotaMiloapisComV1alpha1NamespacedAllowanceBucket?: Maybe<Com_Miloapis_Quota_V1alpha1_AllowanceBucket>;
  /** partially update status of the specified AllowanceBucket */
  patchQuotaMiloapisComV1alpha1NamespacedAllowanceBucketStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_AllowanceBucket>;
  /** partially update the specified ResourceClaim */
  patchQuotaMiloapisComV1alpha1NamespacedResourceClaim?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceClaim>;
  /** partially update status of the specified ResourceClaim */
  patchQuotaMiloapisComV1alpha1NamespacedResourceClaimStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceClaim>;
  /** partially update the specified ResourceGrant */
  patchQuotaMiloapisComV1alpha1NamespacedResourceGrant?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceGrant>;
  /** partially update status of the specified ResourceGrant */
  patchQuotaMiloapisComV1alpha1NamespacedResourceGrantStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceGrant>;
  /** partially update the specified ResourceRegistration */
  patchQuotaMiloapisComV1alpha1ResourceRegistration?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceRegistration>;
  /** partially update status of the specified ResourceRegistration */
  patchQuotaMiloapisComV1alpha1ResourceRegistrationStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceRegistration>;
  /** partially update the specified ClusterRole */
  patchRbacAuthorizationV1ClusterRole?: Maybe<Io_K8s_Api_Rbac_V1_ClusterRole>;
  /** partially update the specified ClusterRoleBinding */
  patchRbacAuthorizationV1ClusterRoleBinding?: Maybe<Io_K8s_Api_Rbac_V1_ClusterRoleBinding>;
  /** partially update the specified Role */
  patchRbacAuthorizationV1NamespacedRole?: Maybe<Io_K8s_Api_Rbac_V1_Role>;
  /** partially update the specified RoleBinding */
  patchRbacAuthorizationV1NamespacedRoleBinding?: Maybe<Io_K8s_Api_Rbac_V1_RoleBinding>;
  /** partially update the specified OrganizationMembership */
  patchResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembership>;
  /** partially update status of the specified OrganizationMembership */
  patchResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembershipStatus?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembership>;
  /** partially update the specified Organization */
  patchResourcemanagerMiloapisComV1alpha1Organization?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Organization>;
  /** partially update status of the specified Organization */
  patchResourcemanagerMiloapisComV1alpha1OrganizationStatus?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Organization>;
  /** partially update the specified Project */
  patchResourcemanagerMiloapisComV1alpha1Project?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Project>;
  /** partially update status of the specified Project */
  patchResourcemanagerMiloapisComV1alpha1ProjectStatus?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Project>;
  /** partially update the specified ExportPolicy */
  patchTelemetryMiloapisComV1alpha1NamespacedExportPolicy?: Maybe<Com_Miloapis_Telemetry_V1alpha1_ExportPolicy>;
  /** partially update status of the specified ExportPolicy */
  patchTelemetryMiloapisComV1alpha1NamespacedExportPolicyStatus?: Maybe<Com_Miloapis_Telemetry_V1alpha1_ExportPolicy>;
  /** replace the specified MutatingWebhookConfiguration */
  replaceAdmissionregistrationV1MutatingWebhookConfiguration?: Maybe<Io_K8s_Api_Admissionregistration_V1_MutatingWebhookConfiguration>;
  /** replace the specified ValidatingAdmissionPolicy */
  replaceAdmissionregistrationV1ValidatingAdmissionPolicy?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicy>;
  /** replace the specified ValidatingAdmissionPolicyBinding */
  replaceAdmissionregistrationV1ValidatingAdmissionPolicyBinding?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBinding>;
  /** replace status of the specified ValidatingAdmissionPolicy */
  replaceAdmissionregistrationV1ValidatingAdmissionPolicyStatus?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicy>;
  /** replace the specified ValidatingWebhookConfiguration */
  replaceAdmissionregistrationV1ValidatingWebhookConfiguration?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingWebhookConfiguration>;
  /** replace the specified DocumentAcceptance */
  replaceAgreementMiloapisComV1alpha1NamespacedDocumentAcceptance?: Maybe<Com_Miloapis_Agreement_V1alpha1_DocumentAcceptance>;
  /** replace status of the specified DocumentAcceptance */
  replaceAgreementMiloapisComV1alpha1NamespacedDocumentAcceptanceStatus?: Maybe<Com_Miloapis_Agreement_V1alpha1_DocumentAcceptance>;
  /** replace the specified CustomResourceDefinition */
  replaceApiextensionsV1CustomResourceDefinition?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinition>;
  /** replace status of the specified CustomResourceDefinition */
  replaceApiextensionsV1CustomResourceDefinitionStatus?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinition>;
  /** replace the specified APIService */
  replaceApiregistrationV1APIService?: Maybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiService>;
  /** replace status of the specified APIService */
  replaceApiregistrationV1APIServiceStatus?: Maybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiService>;
  /** replace the specified Instance */
  replaceComputeDatumapisComV1alphaNamespacedInstance?: Maybe<Com_Datumapis_Compute_V1alpha_Instance>;
  /** replace status of the specified Instance */
  replaceComputeDatumapisComV1alphaNamespacedInstanceStatus?: Maybe<Com_Datumapis_Compute_V1alpha_Instance>;
  /** replace the specified Workload */
  replaceComputeDatumapisComV1alphaNamespacedWorkload?: Maybe<Com_Datumapis_Compute_V1alpha_Workload>;
  /** replace the specified WorkloadDeployment */
  replaceComputeDatumapisComV1alphaNamespacedWorkloadDeployment?: Maybe<Com_Datumapis_Compute_V1alpha_WorkloadDeployment>;
  /** replace status of the specified WorkloadDeployment */
  replaceComputeDatumapisComV1alphaNamespacedWorkloadDeploymentStatus?: Maybe<Com_Datumapis_Compute_V1alpha_WorkloadDeployment>;
  /** replace status of the specified Workload */
  replaceComputeDatumapisComV1alphaNamespacedWorkloadStatus?: Maybe<Com_Datumapis_Compute_V1alpha_Workload>;
  /** replace the specified Lease */
  replaceCoordinationV1NamespacedLease?: Maybe<Io_K8s_Api_Coordination_V1_Lease>;
  /** replace the specified Namespace */
  replaceCoreV1Namespace?: Maybe<Io_K8s_Api_Core_V1_Namespace>;
  /** replace finalize of the specified Namespace */
  replaceCoreV1NamespaceFinalize?: Maybe<Io_K8s_Api_Core_V1_Namespace>;
  /** replace status of the specified Namespace */
  replaceCoreV1NamespaceStatus?: Maybe<Io_K8s_Api_Core_V1_Namespace>;
  /** replace the specified ConfigMap */
  replaceCoreV1NamespacedConfigMap?: Maybe<Io_K8s_Api_Core_V1_ConfigMap>;
  /** replace the specified Event */
  replaceCoreV1NamespacedEvent?: Maybe<Io_K8s_Api_Core_V1_Event>;
  /** replace the specified Secret */
  replaceCoreV1NamespacedSecret?: Maybe<Io_K8s_Api_Core_V1_Secret>;
  /** replace the specified Note */
  replaceCrmMiloapisComV1alpha1Note?: Maybe<Com_Miloapis_Crm_V1alpha1_Note>;
  /** replace status of the specified Note */
  replaceCrmMiloapisComV1alpha1NoteStatus?: Maybe<Com_Miloapis_Crm_V1alpha1_Note>;
  /** replace the specified EndpointSlice */
  replaceDiscoveryV1NamespacedEndpointSlice?: Maybe<Io_K8s_Api_Discovery_V1_EndpointSlice>;
  /** replace the specified DNSZoneClass */
  replaceDnsNetworkingMiloapisComV1alpha1DNSZoneClass?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClass>;
  /** replace status of the specified DNSZoneClass */
  replaceDnsNetworkingMiloapisComV1alpha1DNSZoneClassStatus?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClass>;
  /** replace the specified DNSRecordSet */
  replaceDnsNetworkingMiloapisComV1alpha1NamespacedDNSRecordSet?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSet>;
  /** replace status of the specified DNSRecordSet */
  replaceDnsNetworkingMiloapisComV1alpha1NamespacedDNSRecordSetStatus?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSet>;
  /** replace the specified DNSZone */
  replaceDnsNetworkingMiloapisComV1alpha1NamespacedDNSZone?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZone>;
  /** replace the specified DNSZoneDiscovery */
  replaceDnsNetworkingMiloapisComV1alpha1NamespacedDNSZoneDiscovery?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscovery>;
  /** replace status of the specified DNSZoneDiscovery */
  replaceDnsNetworkingMiloapisComV1alpha1NamespacedDNSZoneDiscoveryStatus?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscovery>;
  /** replace status of the specified DNSZone */
  replaceDnsNetworkingMiloapisComV1alpha1NamespacedDNSZoneStatus?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZone>;
  /** replace the specified Document */
  replaceDocumentationMiloapisComV1alpha1NamespacedDocument?: Maybe<Com_Miloapis_Documentation_V1alpha1_Document>;
  /** replace the specified DocumentRevision */
  replaceDocumentationMiloapisComV1alpha1NamespacedDocumentRevision?: Maybe<Com_Miloapis_Documentation_V1alpha1_DocumentRevision>;
  /** replace status of the specified DocumentRevision */
  replaceDocumentationMiloapisComV1alpha1NamespacedDocumentRevisionStatus?: Maybe<Com_Miloapis_Documentation_V1alpha1_DocumentRevision>;
  /** replace status of the specified Document */
  replaceDocumentationMiloapisComV1alpha1NamespacedDocumentStatus?: Maybe<Com_Miloapis_Documentation_V1alpha1_Document>;
  /** replace the specified Event */
  replaceEventsV1NamespacedEvent?: Maybe<Io_K8s_Api_Events_V1_Event>;
  /** replace the specified FlowSchema */
  replaceFlowcontrolApiserverV1FlowSchema?: Maybe<Io_K8s_Api_Flowcontrol_V1_FlowSchema>;
  /** replace status of the specified FlowSchema */
  replaceFlowcontrolApiserverV1FlowSchemaStatus?: Maybe<Io_K8s_Api_Flowcontrol_V1_FlowSchema>;
  /** replace the specified PriorityLevelConfiguration */
  replaceFlowcontrolApiserverV1PriorityLevelConfiguration?: Maybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfiguration>;
  /** replace status of the specified PriorityLevelConfiguration */
  replaceFlowcontrolApiserverV1PriorityLevelConfigurationStatus?: Maybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfiguration>;
  /** replace the specified Backend */
  replaceGatewayEnvoyproxyIoV1alpha1NamespacedBackend?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_Backend>;
  /** replace status of the specified Backend */
  replaceGatewayEnvoyproxyIoV1alpha1NamespacedBackendStatus?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_Backend>;
  /** replace the specified BackendTrafficPolicy */
  replaceGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicy?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicy>;
  /** replace status of the specified BackendTrafficPolicy */
  replaceGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicyStatus?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicy>;
  /** replace the specified HTTPRouteFilter */
  replaceGatewayEnvoyproxyIoV1alpha1NamespacedHTTPRouteFilter?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_HttpRouteFilter>;
  /** replace the specified SecurityPolicy */
  replaceGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicy>;
  /** replace status of the specified SecurityPolicy */
  replaceGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicyStatus?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicy>;
  /** replace the specified GatewayClass */
  replaceGatewayNetworkingV1GatewayClass?: Maybe<Io_K8s_Networking_Gateway_V1_GatewayClass>;
  /** replace status of the specified GatewayClass */
  replaceGatewayNetworkingV1GatewayClassStatus?: Maybe<Io_K8s_Networking_Gateway_V1_GatewayClass>;
  /** replace the specified BackendTLSPolicy */
  replaceGatewayNetworkingV1NamespacedBackendTLSPolicy?: Maybe<Io_K8s_Networking_Gateway_V1_BackendTlsPolicy>;
  /** replace status of the specified BackendTLSPolicy */
  replaceGatewayNetworkingV1NamespacedBackendTLSPolicyStatus?: Maybe<Io_K8s_Networking_Gateway_V1_BackendTlsPolicy>;
  /** replace the specified Gateway */
  replaceGatewayNetworkingV1NamespacedGateway?: Maybe<Io_K8s_Networking_Gateway_V1_Gateway>;
  /** replace status of the specified Gateway */
  replaceGatewayNetworkingV1NamespacedGatewayStatus?: Maybe<Io_K8s_Networking_Gateway_V1_Gateway>;
  /** replace the specified HTTPRoute */
  replaceGatewayNetworkingV1NamespacedHTTPRoute?: Maybe<Io_K8s_Networking_Gateway_V1_HttpRoute>;
  /** replace status of the specified HTTPRoute */
  replaceGatewayNetworkingV1NamespacedHTTPRouteStatus?: Maybe<Io_K8s_Networking_Gateway_V1_HttpRoute>;
  /** replace the specified BackendTLSPolicy */
  replaceGatewayNetworkingV1alpha3NamespacedBackendTLSPolicy?: Maybe<Io_K8s_Networking_Gateway_V1alpha3_BackendTlsPolicy>;
  /** replace the specified GatewayClass */
  replaceGatewayNetworkingV1beta1GatewayClass?: Maybe<Io_K8s_Networking_Gateway_V1beta1_GatewayClass>;
  /** replace status of the specified GatewayClass */
  replaceGatewayNetworkingV1beta1GatewayClassStatus?: Maybe<Io_K8s_Networking_Gateway_V1beta1_GatewayClass>;
  /** replace the specified Gateway */
  replaceGatewayNetworkingV1beta1NamespacedGateway?: Maybe<Io_K8s_Networking_Gateway_V1beta1_Gateway>;
  /** replace status of the specified Gateway */
  replaceGatewayNetworkingV1beta1NamespacedGatewayStatus?: Maybe<Io_K8s_Networking_Gateway_V1beta1_Gateway>;
  /** replace the specified HTTPRoute */
  replaceGatewayNetworkingV1beta1NamespacedHTTPRoute?: Maybe<Io_K8s_Networking_Gateway_V1beta1_HttpRoute>;
  /** replace status of the specified HTTPRoute */
  replaceGatewayNetworkingV1beta1NamespacedHTTPRouteStatus?: Maybe<Io_K8s_Networking_Gateway_V1beta1_HttpRoute>;
  /** replace the specified Group */
  replaceIamMiloapisComV1alpha1NamespacedGroup?: Maybe<Com_Miloapis_Iam_V1alpha1_Group>;
  /** replace the specified GroupMembership */
  replaceIamMiloapisComV1alpha1NamespacedGroupMembership?: Maybe<Com_Miloapis_Iam_V1alpha1_GroupMembership>;
  /** replace status of the specified GroupMembership */
  replaceIamMiloapisComV1alpha1NamespacedGroupMembershipStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_GroupMembership>;
  /** replace status of the specified Group */
  replaceIamMiloapisComV1alpha1NamespacedGroupStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_Group>;
  /** replace the specified MachineAccount */
  replaceIamMiloapisComV1alpha1NamespacedMachineAccount?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccount>;
  /** replace the specified MachineAccountKey */
  replaceIamMiloapisComV1alpha1NamespacedMachineAccountKey?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccountKey>;
  /** replace status of the specified MachineAccountKey */
  replaceIamMiloapisComV1alpha1NamespacedMachineAccountKeyStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccountKey>;
  /** replace status of the specified MachineAccount */
  replaceIamMiloapisComV1alpha1NamespacedMachineAccountStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccount>;
  /** replace the specified PolicyBinding */
  replaceIamMiloapisComV1alpha1NamespacedPolicyBinding?: Maybe<Com_Miloapis_Iam_V1alpha1_PolicyBinding>;
  /** replace status of the specified PolicyBinding */
  replaceIamMiloapisComV1alpha1NamespacedPolicyBindingStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PolicyBinding>;
  /** replace the specified Role */
  replaceIamMiloapisComV1alpha1NamespacedRole?: Maybe<Com_Miloapis_Iam_V1alpha1_Role>;
  /** replace status of the specified Role */
  replaceIamMiloapisComV1alpha1NamespacedRoleStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_Role>;
  /** replace the specified UserInvitation */
  replaceIamMiloapisComV1alpha1NamespacedUserInvitation?: Maybe<Com_Miloapis_Iam_V1alpha1_UserInvitation>;
  /** replace status of the specified UserInvitation */
  replaceIamMiloapisComV1alpha1NamespacedUserInvitationStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_UserInvitation>;
  /** replace the specified PlatformAccessApproval */
  replaceIamMiloapisComV1alpha1PlatformAccessApproval?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessApproval>;
  /** replace status of the specified PlatformAccessApproval */
  replaceIamMiloapisComV1alpha1PlatformAccessApprovalStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessApproval>;
  /** replace the specified PlatformAccessDenial */
  replaceIamMiloapisComV1alpha1PlatformAccessDenial?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessDenial>;
  /** replace status of the specified PlatformAccessDenial */
  replaceIamMiloapisComV1alpha1PlatformAccessDenialStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessDenial>;
  /** replace the specified PlatformAccessRejection */
  replaceIamMiloapisComV1alpha1PlatformAccessRejection?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessRejection>;
  /** replace status of the specified PlatformAccessRejection */
  replaceIamMiloapisComV1alpha1PlatformAccessRejectionStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessRejection>;
  /** replace the specified PlatformInvitation */
  replaceIamMiloapisComV1alpha1PlatformInvitation?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformInvitation>;
  /** replace status of the specified PlatformInvitation */
  replaceIamMiloapisComV1alpha1PlatformInvitationStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformInvitation>;
  /** replace the specified ProtectedResource */
  replaceIamMiloapisComV1alpha1ProtectedResource?: Maybe<Com_Miloapis_Iam_V1alpha1_ProtectedResource>;
  /** replace status of the specified ProtectedResource */
  replaceIamMiloapisComV1alpha1ProtectedResourceStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_ProtectedResource>;
  /** replace the specified User */
  replaceIamMiloapisComV1alpha1User?: Maybe<Com_Miloapis_Iam_V1alpha1_User>;
  /** replace the specified UserDeactivation */
  replaceIamMiloapisComV1alpha1UserDeactivation?: Maybe<Com_Miloapis_Iam_V1alpha1_UserDeactivation>;
  /** replace status of the specified UserDeactivation */
  replaceIamMiloapisComV1alpha1UserDeactivationStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_UserDeactivation>;
  /** replace the specified UserPreference */
  replaceIamMiloapisComV1alpha1UserPreference?: Maybe<Com_Miloapis_Iam_V1alpha1_UserPreference>;
  /** replace status of the specified UserPreference */
  replaceIamMiloapisComV1alpha1UserPreferenceStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_UserPreference>;
  /** replace status of the specified User */
  replaceIamMiloapisComV1alpha1UserStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_User>;
  /** replace the specified Connector */
  replaceNetworkingDatumapisComV1alpha1NamespacedConnector?: Maybe<Com_Datumapis_Networking_V1alpha1_Connector>;
  /** replace the specified ConnectorAdvertisement */
  replaceNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisement?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisement>;
  /** replace status of the specified ConnectorAdvertisement */
  replaceNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisementStatus?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisement>;
  /** replace the specified ConnectorClass */
  replaceNetworkingDatumapisComV1alpha1NamespacedConnectorClass?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorClass>;
  /** replace status of the specified ConnectorClass */
  replaceNetworkingDatumapisComV1alpha1NamespacedConnectorClassStatus?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorClass>;
  /** replace status of the specified Connector */
  replaceNetworkingDatumapisComV1alpha1NamespacedConnectorStatus?: Maybe<Com_Datumapis_Networking_V1alpha1_Connector>;
  /** replace the specified Domain */
  replaceNetworkingDatumapisComV1alphaNamespacedDomain?: Maybe<Com_Datumapis_Networking_V1alpha_Domain>;
  /** replace status of the specified Domain */
  replaceNetworkingDatumapisComV1alphaNamespacedDomainStatus?: Maybe<Com_Datumapis_Networking_V1alpha_Domain>;
  /** replace the specified HTTPProxy */
  replaceNetworkingDatumapisComV1alphaNamespacedHTTPProxy?: Maybe<Com_Datumapis_Networking_V1alpha_HttpProxy>;
  /** replace status of the specified HTTPProxy */
  replaceNetworkingDatumapisComV1alphaNamespacedHTTPProxyStatus?: Maybe<Com_Datumapis_Networking_V1alpha_HttpProxy>;
  /** replace the specified Location */
  replaceNetworkingDatumapisComV1alphaNamespacedLocation?: Maybe<Com_Datumapis_Networking_V1alpha_Location>;
  /** replace status of the specified Location */
  replaceNetworkingDatumapisComV1alphaNamespacedLocationStatus?: Maybe<Com_Datumapis_Networking_V1alpha_Location>;
  /** replace the specified Network */
  replaceNetworkingDatumapisComV1alphaNamespacedNetwork?: Maybe<Com_Datumapis_Networking_V1alpha_Network>;
  /** replace the specified NetworkBinding */
  replaceNetworkingDatumapisComV1alphaNamespacedNetworkBinding?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkBinding>;
  /** replace status of the specified NetworkBinding */
  replaceNetworkingDatumapisComV1alphaNamespacedNetworkBindingStatus?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkBinding>;
  /** replace the specified NetworkContext */
  replaceNetworkingDatumapisComV1alphaNamespacedNetworkContext?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkContext>;
  /** replace status of the specified NetworkContext */
  replaceNetworkingDatumapisComV1alphaNamespacedNetworkContextStatus?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkContext>;
  /** replace the specified NetworkPolicy */
  replaceNetworkingDatumapisComV1alphaNamespacedNetworkPolicy?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkPolicy>;
  /** replace status of the specified NetworkPolicy */
  replaceNetworkingDatumapisComV1alphaNamespacedNetworkPolicyStatus?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkPolicy>;
  /** replace status of the specified Network */
  replaceNetworkingDatumapisComV1alphaNamespacedNetworkStatus?: Maybe<Com_Datumapis_Networking_V1alpha_Network>;
  /** replace the specified Subnet */
  replaceNetworkingDatumapisComV1alphaNamespacedSubnet?: Maybe<Com_Datumapis_Networking_V1alpha_Subnet>;
  /** replace the specified SubnetClaim */
  replaceNetworkingDatumapisComV1alphaNamespacedSubnetClaim?: Maybe<Com_Datumapis_Networking_V1alpha_SubnetClaim>;
  /** replace status of the specified SubnetClaim */
  replaceNetworkingDatumapisComV1alphaNamespacedSubnetClaimStatus?: Maybe<Com_Datumapis_Networking_V1alpha_SubnetClaim>;
  /** replace status of the specified Subnet */
  replaceNetworkingDatumapisComV1alphaNamespacedSubnetStatus?: Maybe<Com_Datumapis_Networking_V1alpha_Subnet>;
  /** replace the specified TrafficProtectionPolicy */
  replaceNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy?: Maybe<Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicy>;
  /** replace status of the specified TrafficProtectionPolicy */
  replaceNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicyStatus?: Maybe<Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicy>;
  /** replace the specified EmailTemplate */
  replaceNotificationMiloapisComV1alpha1EmailTemplate?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailTemplate>;
  /** replace status of the specified EmailTemplate */
  replaceNotificationMiloapisComV1alpha1EmailTemplateStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailTemplate>;
  /** replace the specified Contact */
  replaceNotificationMiloapisComV1alpha1NamespacedContact?: Maybe<Com_Miloapis_Notification_V1alpha1_Contact>;
  /** replace the specified ContactGroup */
  replaceNotificationMiloapisComV1alpha1NamespacedContactGroup?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroup>;
  /** replace the specified ContactGroupMembership */
  replaceNotificationMiloapisComV1alpha1NamespacedContactGroupMembership?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembership>;
  /** replace the specified ContactGroupMembershipRemoval */
  replaceNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemoval?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemoval>;
  /** replace status of the specified ContactGroupMembershipRemoval */
  replaceNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemovalStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemoval>;
  /** replace status of the specified ContactGroupMembership */
  replaceNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembership>;
  /** replace status of the specified ContactGroup */
  replaceNotificationMiloapisComV1alpha1NamespacedContactGroupStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroup>;
  /** replace status of the specified Contact */
  replaceNotificationMiloapisComV1alpha1NamespacedContactStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_Contact>;
  /** replace the specified Email */
  replaceNotificationMiloapisComV1alpha1NamespacedEmail?: Maybe<Com_Miloapis_Notification_V1alpha1_Email>;
  /** replace the specified EmailBroadcast */
  replaceNotificationMiloapisComV1alpha1NamespacedEmailBroadcast?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailBroadcast>;
  /** replace status of the specified EmailBroadcast */
  replaceNotificationMiloapisComV1alpha1NamespacedEmailBroadcastStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailBroadcast>;
  /** replace status of the specified Email */
  replaceNotificationMiloapisComV1alpha1NamespacedEmailStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_Email>;
  /** replace the specified Note */
  replaceNotificationMiloapisComV1alpha1NamespacedNote?: Maybe<Com_Miloapis_Notification_V1alpha1_Note>;
  /** replace status of the specified Note */
  replaceNotificationMiloapisComV1alpha1NamespacedNoteStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_Note>;
  /** replace the specified ClaimCreationPolicy */
  replaceQuotaMiloapisComV1alpha1ClaimCreationPolicy?: Maybe<Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicy>;
  /** replace status of the specified ClaimCreationPolicy */
  replaceQuotaMiloapisComV1alpha1ClaimCreationPolicyStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicy>;
  /** replace the specified GrantCreationPolicy */
  replaceQuotaMiloapisComV1alpha1GrantCreationPolicy?: Maybe<Com_Miloapis_Quota_V1alpha1_GrantCreationPolicy>;
  /** replace status of the specified GrantCreationPolicy */
  replaceQuotaMiloapisComV1alpha1GrantCreationPolicyStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_GrantCreationPolicy>;
  /** replace the specified AllowanceBucket */
  replaceQuotaMiloapisComV1alpha1NamespacedAllowanceBucket?: Maybe<Com_Miloapis_Quota_V1alpha1_AllowanceBucket>;
  /** replace status of the specified AllowanceBucket */
  replaceQuotaMiloapisComV1alpha1NamespacedAllowanceBucketStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_AllowanceBucket>;
  /** replace the specified ResourceClaim */
  replaceQuotaMiloapisComV1alpha1NamespacedResourceClaim?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceClaim>;
  /** replace status of the specified ResourceClaim */
  replaceQuotaMiloapisComV1alpha1NamespacedResourceClaimStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceClaim>;
  /** replace the specified ResourceGrant */
  replaceQuotaMiloapisComV1alpha1NamespacedResourceGrant?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceGrant>;
  /** replace status of the specified ResourceGrant */
  replaceQuotaMiloapisComV1alpha1NamespacedResourceGrantStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceGrant>;
  /** replace the specified ResourceRegistration */
  replaceQuotaMiloapisComV1alpha1ResourceRegistration?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceRegistration>;
  /** replace status of the specified ResourceRegistration */
  replaceQuotaMiloapisComV1alpha1ResourceRegistrationStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceRegistration>;
  /** replace the specified ClusterRole */
  replaceRbacAuthorizationV1ClusterRole?: Maybe<Io_K8s_Api_Rbac_V1_ClusterRole>;
  /** replace the specified ClusterRoleBinding */
  replaceRbacAuthorizationV1ClusterRoleBinding?: Maybe<Io_K8s_Api_Rbac_V1_ClusterRoleBinding>;
  /** replace the specified Role */
  replaceRbacAuthorizationV1NamespacedRole?: Maybe<Io_K8s_Api_Rbac_V1_Role>;
  /** replace the specified RoleBinding */
  replaceRbacAuthorizationV1NamespacedRoleBinding?: Maybe<Io_K8s_Api_Rbac_V1_RoleBinding>;
  /** replace the specified OrganizationMembership */
  replaceResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembership>;
  /** replace status of the specified OrganizationMembership */
  replaceResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembershipStatus?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembership>;
  /** replace the specified Organization */
  replaceResourcemanagerMiloapisComV1alpha1Organization?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Organization>;
  /** replace status of the specified Organization */
  replaceResourcemanagerMiloapisComV1alpha1OrganizationStatus?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Organization>;
  /** replace the specified Project */
  replaceResourcemanagerMiloapisComV1alpha1Project?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Project>;
  /** replace status of the specified Project */
  replaceResourcemanagerMiloapisComV1alpha1ProjectStatus?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Project>;
  /** replace the specified ExportPolicy */
  replaceTelemetryMiloapisComV1alpha1NamespacedExportPolicy?: Maybe<Com_Miloapis_Telemetry_V1alpha1_ExportPolicy>;
  /** replace status of the specified ExportPolicy */
  replaceTelemetryMiloapisComV1alpha1NamespacedExportPolicyStatus?: Maybe<Com_Miloapis_Telemetry_V1alpha1_ExportPolicy>;
};

export type MutationCreateActivityMiloapisComV1alpha1AuditLogQueryArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Go_Activity_Pkg_Apis_Activity_V1alpha1_AuditLogQuery_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateAdmissionregistrationV1MutatingWebhookConfigurationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_MutatingWebhookConfiguration_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateAdmissionregistrationV1ValidatingAdmissionPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicy_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateAdmissionregistrationV1ValidatingAdmissionPolicyBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBinding_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateAdmissionregistrationV1ValidatingWebhookConfigurationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_ValidatingWebhookConfiguration_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateAgreementMiloapisComV1alpha1NamespacedDocumentAcceptanceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Agreement_V1alpha1_DocumentAcceptance_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateApiextensionsV1CustomResourceDefinitionArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinition_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateApiregistrationV1ApiServiceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiService_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateAuthenticationV1SelfSubjectReviewArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Authentication_V1_SelfSubjectReview_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateAuthenticationV1TokenReviewArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Authentication_V1_TokenReview_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateAuthorizationV1NamespacedLocalSubjectAccessReviewArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Authorization_V1_LocalSubjectAccessReview_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateAuthorizationV1SelfSubjectAccessReviewArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Authorization_V1_SelfSubjectAccessReview_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateAuthorizationV1SelfSubjectRulesReviewArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Authorization_V1_SelfSubjectRulesReview_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateAuthorizationV1SubjectAccessReviewArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Authorization_V1_SubjectAccessReview_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateComputeDatumapisComV1alphaNamespacedInstanceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Compute_V1alpha_Instance_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateComputeDatumapisComV1alphaNamespacedWorkloadArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Compute_V1alpha_Workload_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateComputeDatumapisComV1alphaNamespacedWorkloadDeploymentArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Compute_V1alpha_WorkloadDeployment_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateCoordinationV1NamespacedLeaseArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Coordination_V1_Lease_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateCoreV1NamespaceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Core_V1_Namespace_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateCoreV1NamespacedConfigMapArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Core_V1_ConfigMap_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateCoreV1NamespacedEventArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Core_V1_Event_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateCoreV1NamespacedSecretArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Core_V1_Secret_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateCrmMiloapisComV1alpha1NoteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Crm_V1alpha1_Note_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateDiscoveryV1NamespacedEndpointSliceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Discovery_V1_EndpointSlice_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateDnsNetworkingMiloapisComV1alpha1DnsZoneClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClass_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateDnsNetworkingMiloapisComV1alpha1NamespacedDnsRecordSetArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSet_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZone_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneDiscoveryArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscovery_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateDocumentationMiloapisComV1alpha1NamespacedDocumentArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Documentation_V1alpha1_Document_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateDocumentationMiloapisComV1alpha1NamespacedDocumentRevisionArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Documentation_V1alpha1_DocumentRevision_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateEventsV1NamespacedEventArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Events_V1_Event_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateFlowcontrolApiserverV1FlowSchemaArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_FlowSchema_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateFlowcontrolApiserverV1PriorityLevelConfigurationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfiguration_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateGatewayEnvoyproxyIoV1alpha1NamespacedBackendArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_Envoyproxy_Gateway_V1alpha1_Backend_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicy_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateGatewayEnvoyproxyIoV1alpha1NamespacedHttpRouteFilterArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_Envoyproxy_Gateway_V1alpha1_HttpRouteFilter_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicy_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateGatewayNetworkingV1GatewayClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1_GatewayClass_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateGatewayNetworkingV1NamespacedBackendTlsPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1_BackendTlsPolicy_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateGatewayNetworkingV1NamespacedGatewayArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1_Gateway_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateGatewayNetworkingV1NamespacedHttpRouteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1_HttpRoute_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateGatewayNetworkingV1alpha3NamespacedBackendTlsPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1alpha3_BackendTlsPolicy_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateGatewayNetworkingV1beta1GatewayClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1beta1_GatewayClass_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateGatewayNetworkingV1beta1NamespacedGatewayArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1beta1_Gateway_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateGatewayNetworkingV1beta1NamespacedHttpRouteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1beta1_HttpRoute_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1NamespacedGroupArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_Group_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1NamespacedGroupMembershipArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_GroupMembership_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1NamespacedMachineAccountArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_MachineAccount_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1NamespacedMachineAccountKeyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_MachineAccountKey_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1NamespacedPolicyBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PolicyBinding_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1NamespacedRoleArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_Role_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1NamespacedUserInvitationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_UserInvitation_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1PlatformAccessApprovalArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessApproval_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1PlatformAccessDenialArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessDenial_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1PlatformAccessRejectionArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessRejection_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1PlatformInvitationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PlatformInvitation_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1ProtectedResourceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_ProtectedResource_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1UserArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_User_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1UserDeactivationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_UserDeactivation_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateIamMiloapisComV1alpha1UserPreferenceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_UserPreference_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNetworkingDatumapisComV1alpha1NamespacedConnectorArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha1_Connector_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisementArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisement_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNetworkingDatumapisComV1alpha1NamespacedConnectorClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha1_ConnectorClass_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNetworkingDatumapisComV1alphaNamespacedDomainArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_Domain_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNetworkingDatumapisComV1alphaNamespacedHttpProxyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_HttpProxy_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNetworkingDatumapisComV1alphaNamespacedLocationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_Location_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNetworkingDatumapisComV1alphaNamespacedNetworkArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_Network_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNetworkingDatumapisComV1alphaNamespacedNetworkBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_NetworkBinding_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNetworkingDatumapisComV1alphaNamespacedNetworkContextArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_NetworkContext_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNetworkingDatumapisComV1alphaNamespacedNetworkPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_NetworkPolicy_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNetworkingDatumapisComV1alphaNamespacedSubnetArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_Subnet_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNetworkingDatumapisComV1alphaNamespacedSubnetClaimArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_SubnetClaim_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicy_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNotificationMiloapisComV1alpha1EmailTemplateArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_EmailTemplate_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNotificationMiloapisComV1alpha1NamespacedContactArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_Contact_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNotificationMiloapisComV1alpha1NamespacedContactGroupArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_ContactGroup_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembership_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemovalArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    fieldManager?: InputMaybe<Scalars['String']['input']>;
    fieldValidation?: InputMaybe<Scalars['String']['input']>;
    input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemoval_Input>;
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationCreateNotificationMiloapisComV1alpha1NamespacedEmailArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_Email_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNotificationMiloapisComV1alpha1NamespacedEmailBroadcastArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_EmailBroadcast_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateNotificationMiloapisComV1alpha1NamespacedNoteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_Note_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateQuotaMiloapisComV1alpha1ClaimCreationPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicy_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateQuotaMiloapisComV1alpha1GrantCreationPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_GrantCreationPolicy_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateQuotaMiloapisComV1alpha1NamespacedAllowanceBucketArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_AllowanceBucket_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateQuotaMiloapisComV1alpha1NamespacedResourceClaimArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_ResourceClaim_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateQuotaMiloapisComV1alpha1NamespacedResourceGrantArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_ResourceGrant_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateQuotaMiloapisComV1alpha1ResourceRegistrationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_ResourceRegistration_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateRbacAuthorizationV1ClusterRoleArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Rbac_V1_ClusterRole_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateRbacAuthorizationV1ClusterRoleBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Rbac_V1_ClusterRoleBinding_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateRbacAuthorizationV1NamespacedRoleArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Rbac_V1_Role_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateRbacAuthorizationV1NamespacedRoleBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Rbac_V1_RoleBinding_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembershipArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembership_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateResourcemanagerMiloapisComV1alpha1OrganizationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Resourcemanager_V1alpha1_Organization_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateResourcemanagerMiloapisComV1alpha1ProjectArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Resourcemanager_V1alpha1_Project_Input>;
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationCreateTelemetryMiloapisComV1alpha1NamespacedExportPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Telemetry_V1alpha1_ExportPolicy_Input>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteAdmissionregistrationV1CollectionMutatingWebhookConfigurationArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteAdmissionregistrationV1CollectionValidatingAdmissionPolicyArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteAdmissionregistrationV1CollectionValidatingAdmissionPolicyBindingArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteAdmissionregistrationV1CollectionValidatingWebhookConfigurationArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteAdmissionregistrationV1MutatingWebhookConfigurationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteAdmissionregistrationV1ValidatingAdmissionPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteAdmissionregistrationV1ValidatingAdmissionPolicyBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteAdmissionregistrationV1ValidatingWebhookConfigurationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteAgreementMiloapisComV1alpha1CollectionNamespacedDocumentAcceptanceArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteAgreementMiloapisComV1alpha1NamespacedDocumentAcceptanceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteApiextensionsV1CollectionCustomResourceDefinitionArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteApiextensionsV1CustomResourceDefinitionArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteApiregistrationV1ApiServiceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteApiregistrationV1CollectionApiServiceArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteComputeDatumapisComV1alphaCollectionNamespacedInstanceArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteComputeDatumapisComV1alphaCollectionNamespacedWorkloadArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteComputeDatumapisComV1alphaCollectionNamespacedWorkloadDeploymentArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteComputeDatumapisComV1alphaNamespacedInstanceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteComputeDatumapisComV1alphaNamespacedWorkloadArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteComputeDatumapisComV1alphaNamespacedWorkloadDeploymentArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteCoordinationV1CollectionNamespacedLeaseArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteCoordinationV1NamespacedLeaseArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteCoreV1CollectionNamespacedConfigMapArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteCoreV1CollectionNamespacedEventArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteCoreV1CollectionNamespacedSecretArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteCoreV1NamespaceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteCoreV1NamespacedConfigMapArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteCoreV1NamespacedEventArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteCoreV1NamespacedSecretArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteCrmMiloapisComV1alpha1CollectionNoteArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteCrmMiloapisComV1alpha1NoteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteDiscoveryV1CollectionNamespacedEndpointSliceArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteDiscoveryV1NamespacedEndpointSliceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteDnsNetworkingMiloapisComV1alpha1CollectionDnsZoneClassArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteDnsNetworkingMiloapisComV1alpha1CollectionNamespacedDnsRecordSetArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteDnsNetworkingMiloapisComV1alpha1CollectionNamespacedDnsZoneArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteDnsNetworkingMiloapisComV1alpha1CollectionNamespacedDnsZoneDiscoveryArgs =
  {
    allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
    continue?: InputMaybe<Scalars['String']['input']>;
    fieldSelector?: InputMaybe<Scalars['String']['input']>;
    labelSelector?: InputMaybe<Scalars['String']['input']>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
    resourceVersion?: InputMaybe<Scalars['String']['input']>;
    resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
    sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
    timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
    watch?: InputMaybe<Scalars['Boolean']['input']>;
  };

export type MutationDeleteDnsNetworkingMiloapisComV1alpha1DnsZoneClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteDnsNetworkingMiloapisComV1alpha1NamespacedDnsRecordSetArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneDiscoveryArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteDocumentationMiloapisComV1alpha1CollectionNamespacedDocumentArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteDocumentationMiloapisComV1alpha1CollectionNamespacedDocumentRevisionArgs =
  {
    allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
    continue?: InputMaybe<Scalars['String']['input']>;
    fieldSelector?: InputMaybe<Scalars['String']['input']>;
    labelSelector?: InputMaybe<Scalars['String']['input']>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
    resourceVersion?: InputMaybe<Scalars['String']['input']>;
    resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
    sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
    timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
    watch?: InputMaybe<Scalars['Boolean']['input']>;
  };

export type MutationDeleteDocumentationMiloapisComV1alpha1NamespacedDocumentArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteDocumentationMiloapisComV1alpha1NamespacedDocumentRevisionArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteEventsV1CollectionNamespacedEventArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteEventsV1NamespacedEventArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteFlowcontrolApiserverV1CollectionFlowSchemaArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteFlowcontrolApiserverV1CollectionPriorityLevelConfigurationArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteFlowcontrolApiserverV1FlowSchemaArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteFlowcontrolApiserverV1PriorityLevelConfigurationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteGatewayEnvoyproxyIoV1alpha1CollectionNamespacedBackendArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteGatewayEnvoyproxyIoV1alpha1CollectionNamespacedBackendTrafficPolicyArgs =
  {
    allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
    continue?: InputMaybe<Scalars['String']['input']>;
    fieldSelector?: InputMaybe<Scalars['String']['input']>;
    labelSelector?: InputMaybe<Scalars['String']['input']>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
    resourceVersion?: InputMaybe<Scalars['String']['input']>;
    resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
    sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
    timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
    watch?: InputMaybe<Scalars['Boolean']['input']>;
  };

export type MutationDeleteGatewayEnvoyproxyIoV1alpha1CollectionNamespacedHttpRouteFilterArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteGatewayEnvoyproxyIoV1alpha1CollectionNamespacedSecurityPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteGatewayEnvoyproxyIoV1alpha1NamespacedBackendArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteGatewayEnvoyproxyIoV1alpha1NamespacedHttpRouteFilterArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteGatewayNetworkingV1CollectionGatewayClassArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteGatewayNetworkingV1CollectionNamespacedBackendTlsPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteGatewayNetworkingV1CollectionNamespacedGatewayArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteGatewayNetworkingV1CollectionNamespacedHttpRouteArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteGatewayNetworkingV1GatewayClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteGatewayNetworkingV1NamespacedBackendTlsPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteGatewayNetworkingV1NamespacedGatewayArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteGatewayNetworkingV1NamespacedHttpRouteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteGatewayNetworkingV1alpha3CollectionNamespacedBackendTlsPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteGatewayNetworkingV1alpha3NamespacedBackendTlsPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteGatewayNetworkingV1beta1CollectionGatewayClassArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteGatewayNetworkingV1beta1CollectionNamespacedGatewayArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteGatewayNetworkingV1beta1CollectionNamespacedHttpRouteArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteGatewayNetworkingV1beta1GatewayClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteGatewayNetworkingV1beta1NamespacedGatewayArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteGatewayNetworkingV1beta1NamespacedHttpRouteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionNamespacedGroupArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionNamespacedGroupMembershipArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionNamespacedMachineAccountArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionNamespacedMachineAccountKeyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionNamespacedPolicyBindingArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionNamespacedRoleArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionNamespacedUserInvitationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionPlatformAccessApprovalArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionPlatformAccessDenialArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionPlatformAccessRejectionArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionPlatformInvitationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionProtectedResourceArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionUserArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionUserDeactivationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1CollectionUserPreferenceArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1NamespacedGroupArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1NamespacedGroupMembershipArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1NamespacedMachineAccountArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1NamespacedMachineAccountKeyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1NamespacedPolicyBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1NamespacedRoleArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1NamespacedUserInvitationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1PlatformAccessApprovalArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1PlatformAccessDenialArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1PlatformAccessRejectionArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1PlatformInvitationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1ProtectedResourceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1UserArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1UserDeactivationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIamMiloapisComV1alpha1UserPreferenceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteIdentityMiloapisComV1alpha1SessionArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alpha1CollectionNamespacedConnectorArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alpha1CollectionNamespacedConnectorAdvertisementArgs =
  {
    allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
    continue?: InputMaybe<Scalars['String']['input']>;
    fieldSelector?: InputMaybe<Scalars['String']['input']>;
    labelSelector?: InputMaybe<Scalars['String']['input']>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
    resourceVersion?: InputMaybe<Scalars['String']['input']>;
    resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
    sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
    timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
    watch?: InputMaybe<Scalars['Boolean']['input']>;
  };

export type MutationDeleteNetworkingDatumapisComV1alpha1CollectionNamespacedConnectorClassArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alpha1NamespacedConnectorArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisementArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alpha1NamespacedConnectorClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaCollectionNamespacedDomainArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaCollectionNamespacedHttpProxyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaCollectionNamespacedLocationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaCollectionNamespacedNetworkArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaCollectionNamespacedNetworkBindingArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaCollectionNamespacedNetworkContextArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaCollectionNamespacedNetworkPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaCollectionNamespacedSubnetArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaCollectionNamespacedSubnetClaimArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaCollectionNamespacedTrafficProtectionPolicyArgs =
  {
    allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
    continue?: InputMaybe<Scalars['String']['input']>;
    fieldSelector?: InputMaybe<Scalars['String']['input']>;
    labelSelector?: InputMaybe<Scalars['String']['input']>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
    resourceVersion?: InputMaybe<Scalars['String']['input']>;
    resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
    sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
    timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
    watch?: InputMaybe<Scalars['Boolean']['input']>;
  };

export type MutationDeleteNetworkingDatumapisComV1alphaNamespacedDomainArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaNamespacedHttpProxyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaNamespacedLocationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaNamespacedNetworkArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaNamespacedNetworkBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaNamespacedNetworkContextArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaNamespacedNetworkPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaNamespacedSubnetArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaNamespacedSubnetClaimArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNotificationMiloapisComV1alpha1CollectionEmailTemplateArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNotificationMiloapisComV1alpha1CollectionNamespacedContactArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNotificationMiloapisComV1alpha1CollectionNamespacedContactGroupArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNotificationMiloapisComV1alpha1CollectionNamespacedContactGroupMembershipArgs =
  {
    allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
    continue?: InputMaybe<Scalars['String']['input']>;
    fieldSelector?: InputMaybe<Scalars['String']['input']>;
    labelSelector?: InputMaybe<Scalars['String']['input']>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
    resourceVersion?: InputMaybe<Scalars['String']['input']>;
    resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
    sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
    timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
    watch?: InputMaybe<Scalars['Boolean']['input']>;
  };

export type MutationDeleteNotificationMiloapisComV1alpha1CollectionNamespacedContactGroupMembershipRemovalArgs =
  {
    allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
    continue?: InputMaybe<Scalars['String']['input']>;
    fieldSelector?: InputMaybe<Scalars['String']['input']>;
    labelSelector?: InputMaybe<Scalars['String']['input']>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
    resourceVersion?: InputMaybe<Scalars['String']['input']>;
    resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
    sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
    timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
    watch?: InputMaybe<Scalars['Boolean']['input']>;
  };

export type MutationDeleteNotificationMiloapisComV1alpha1CollectionNamespacedEmailArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNotificationMiloapisComV1alpha1CollectionNamespacedEmailBroadcastArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNotificationMiloapisComV1alpha1CollectionNamespacedNoteArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteNotificationMiloapisComV1alpha1EmailTemplateArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNotificationMiloapisComV1alpha1NamespacedContactArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNotificationMiloapisComV1alpha1NamespacedContactGroupArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemovalArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
    ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
    input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
    pretty?: InputMaybe<Scalars['String']['input']>;
    propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationDeleteNotificationMiloapisComV1alpha1NamespacedEmailArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNotificationMiloapisComV1alpha1NamespacedEmailBroadcastArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteNotificationMiloapisComV1alpha1NamespacedNoteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteQuotaMiloapisComV1alpha1ClaimCreationPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteQuotaMiloapisComV1alpha1CollectionClaimCreationPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteQuotaMiloapisComV1alpha1CollectionGrantCreationPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteQuotaMiloapisComV1alpha1CollectionNamespacedAllowanceBucketArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteQuotaMiloapisComV1alpha1CollectionNamespacedResourceClaimArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteQuotaMiloapisComV1alpha1CollectionNamespacedResourceGrantArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteQuotaMiloapisComV1alpha1CollectionResourceRegistrationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteQuotaMiloapisComV1alpha1GrantCreationPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteQuotaMiloapisComV1alpha1NamespacedAllowanceBucketArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteQuotaMiloapisComV1alpha1NamespacedResourceClaimArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteQuotaMiloapisComV1alpha1NamespacedResourceGrantArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteQuotaMiloapisComV1alpha1ResourceRegistrationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteRbacAuthorizationV1ClusterRoleArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteRbacAuthorizationV1ClusterRoleBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteRbacAuthorizationV1CollectionClusterRoleArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteRbacAuthorizationV1CollectionClusterRoleBindingArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteRbacAuthorizationV1CollectionNamespacedRoleArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteRbacAuthorizationV1CollectionNamespacedRoleBindingArgs = {
  continue?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

export type MutationDeleteRbacAuthorizationV1NamespacedRoleArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteRbacAuthorizationV1NamespacedRoleBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteResourcemanagerMiloapisComV1alpha1CollectionNamespacedOrganizationMembershipArgs =
  {
    allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
    continue?: InputMaybe<Scalars['String']['input']>;
    fieldSelector?: InputMaybe<Scalars['String']['input']>;
    labelSelector?: InputMaybe<Scalars['String']['input']>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
    resourceVersion?: InputMaybe<Scalars['String']['input']>;
    resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
    sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
    timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
    watch?: InputMaybe<Scalars['Boolean']['input']>;
  };

export type MutationDeleteResourcemanagerMiloapisComV1alpha1CollectionOrganizationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteResourcemanagerMiloapisComV1alpha1CollectionProjectArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembershipArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteResourcemanagerMiloapisComV1alpha1OrganizationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteResourcemanagerMiloapisComV1alpha1ProjectArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationDeleteTelemetryMiloapisComV1alpha1CollectionNamespacedExportPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MutationDeleteTelemetryMiloapisComV1alpha1NamespacedExportPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  gracePeriodSeconds?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchAdmissionregistrationV1MutatingWebhookConfigurationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchAdmissionregistrationV1ValidatingAdmissionPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchAdmissionregistrationV1ValidatingAdmissionPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchAdmissionregistrationV1ValidatingWebhookConfigurationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchAgreementMiloapisComV1alpha1NamespacedDocumentAcceptanceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchAgreementMiloapisComV1alpha1NamespacedDocumentAcceptanceStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchApiextensionsV1CustomResourceDefinitionArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchApiextensionsV1CustomResourceDefinitionStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchApiregistrationV1ApiServiceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchApiregistrationV1ApiServiceStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchComputeDatumapisComV1alphaNamespacedInstanceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchComputeDatumapisComV1alphaNamespacedInstanceStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchComputeDatumapisComV1alphaNamespacedWorkloadArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchComputeDatumapisComV1alphaNamespacedWorkloadDeploymentArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchComputeDatumapisComV1alphaNamespacedWorkloadDeploymentStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchComputeDatumapisComV1alphaNamespacedWorkloadStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchCoordinationV1NamespacedLeaseArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchCoreV1NamespaceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchCoreV1NamespaceStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchCoreV1NamespacedConfigMapArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchCoreV1NamespacedEventArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchCoreV1NamespacedSecretArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchCrmMiloapisComV1alpha1NoteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchCrmMiloapisComV1alpha1NoteStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchDiscoveryV1NamespacedEndpointSliceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchDnsNetworkingMiloapisComV1alpha1DnsZoneClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchDnsNetworkingMiloapisComV1alpha1DnsZoneClassStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchDnsNetworkingMiloapisComV1alpha1NamespacedDnsRecordSetArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchDnsNetworkingMiloapisComV1alpha1NamespacedDnsRecordSetStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneDiscoveryArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneDiscoveryStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchDocumentationMiloapisComV1alpha1NamespacedDocumentArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchDocumentationMiloapisComV1alpha1NamespacedDocumentRevisionArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchDocumentationMiloapisComV1alpha1NamespacedDocumentRevisionStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchDocumentationMiloapisComV1alpha1NamespacedDocumentStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchEventsV1NamespacedEventArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchFlowcontrolApiserverV1FlowSchemaArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchFlowcontrolApiserverV1FlowSchemaStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchFlowcontrolApiserverV1PriorityLevelConfigurationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchFlowcontrolApiserverV1PriorityLevelConfigurationStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayEnvoyproxyIoV1alpha1NamespacedBackendArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayEnvoyproxyIoV1alpha1NamespacedBackendStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayEnvoyproxyIoV1alpha1NamespacedHttpRouteFilterArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1GatewayClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1GatewayClassStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1NamespacedBackendTlsPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1NamespacedBackendTlsPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1NamespacedGatewayArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1NamespacedGatewayStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1NamespacedHttpRouteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1NamespacedHttpRouteStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1alpha3NamespacedBackendTlsPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1beta1GatewayClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1beta1GatewayClassStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1beta1NamespacedGatewayArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1beta1NamespacedGatewayStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1beta1NamespacedHttpRouteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchGatewayNetworkingV1beta1NamespacedHttpRouteStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1NamespacedGroupArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1NamespacedGroupMembershipArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1NamespacedGroupMembershipStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1NamespacedGroupStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1NamespacedMachineAccountArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1NamespacedMachineAccountKeyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1NamespacedMachineAccountKeyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1NamespacedMachineAccountStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1NamespacedPolicyBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1NamespacedPolicyBindingStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1NamespacedRoleArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1NamespacedRoleStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1NamespacedUserInvitationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1NamespacedUserInvitationStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1PlatformAccessApprovalArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1PlatformAccessApprovalStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1PlatformAccessDenialArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1PlatformAccessDenialStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1PlatformAccessRejectionArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1PlatformAccessRejectionStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1PlatformInvitationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1PlatformInvitationStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1ProtectedResourceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1ProtectedResourceStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1UserArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1UserDeactivationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1UserDeactivationStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1UserPreferenceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1UserPreferenceStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchIamMiloapisComV1alpha1UserStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alpha1NamespacedConnectorArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisementArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisementStatusArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    fieldManager?: InputMaybe<Scalars['String']['input']>;
    fieldValidation?: InputMaybe<Scalars['String']['input']>;
    force?: InputMaybe<Scalars['Boolean']['input']>;
    input?: InputMaybe<Scalars['JSON']['input']>;
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationPatchNetworkingDatumapisComV1alpha1NamespacedConnectorClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alpha1NamespacedConnectorClassStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alpha1NamespacedConnectorStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedDomainArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedDomainStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedHttpProxyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedHttpProxyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedLocationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedLocationStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedNetworkArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedNetworkBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedNetworkBindingStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedNetworkContextArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedNetworkContextStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedNetworkPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedNetworkPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedNetworkStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedSubnetArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedSubnetClaimArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedSubnetClaimStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedSubnetStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicyStatusArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    fieldManager?: InputMaybe<Scalars['String']['input']>;
    fieldValidation?: InputMaybe<Scalars['String']['input']>;
    force?: InputMaybe<Scalars['Boolean']['input']>;
    input?: InputMaybe<Scalars['JSON']['input']>;
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationPatchNotificationMiloapisComV1alpha1EmailTemplateArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNotificationMiloapisComV1alpha1EmailTemplateStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNotificationMiloapisComV1alpha1NamespacedContactArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNotificationMiloapisComV1alpha1NamespacedContactGroupArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemovalArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    fieldManager?: InputMaybe<Scalars['String']['input']>;
    fieldValidation?: InputMaybe<Scalars['String']['input']>;
    force?: InputMaybe<Scalars['Boolean']['input']>;
    input?: InputMaybe<Scalars['JSON']['input']>;
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationPatchNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemovalStatusArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    fieldManager?: InputMaybe<Scalars['String']['input']>;
    fieldValidation?: InputMaybe<Scalars['String']['input']>;
    force?: InputMaybe<Scalars['Boolean']['input']>;
    input?: InputMaybe<Scalars['JSON']['input']>;
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationPatchNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipStatusArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    fieldManager?: InputMaybe<Scalars['String']['input']>;
    fieldValidation?: InputMaybe<Scalars['String']['input']>;
    force?: InputMaybe<Scalars['Boolean']['input']>;
    input?: InputMaybe<Scalars['JSON']['input']>;
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationPatchNotificationMiloapisComV1alpha1NamespacedContactGroupStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNotificationMiloapisComV1alpha1NamespacedContactStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNotificationMiloapisComV1alpha1NamespacedEmailArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNotificationMiloapisComV1alpha1NamespacedEmailBroadcastArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNotificationMiloapisComV1alpha1NamespacedEmailBroadcastStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNotificationMiloapisComV1alpha1NamespacedEmailStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNotificationMiloapisComV1alpha1NamespacedNoteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchNotificationMiloapisComV1alpha1NamespacedNoteStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchQuotaMiloapisComV1alpha1ClaimCreationPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchQuotaMiloapisComV1alpha1ClaimCreationPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchQuotaMiloapisComV1alpha1GrantCreationPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchQuotaMiloapisComV1alpha1GrantCreationPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchQuotaMiloapisComV1alpha1NamespacedAllowanceBucketArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchQuotaMiloapisComV1alpha1NamespacedAllowanceBucketStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchQuotaMiloapisComV1alpha1NamespacedResourceClaimArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchQuotaMiloapisComV1alpha1NamespacedResourceClaimStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchQuotaMiloapisComV1alpha1NamespacedResourceGrantArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchQuotaMiloapisComV1alpha1NamespacedResourceGrantStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchQuotaMiloapisComV1alpha1ResourceRegistrationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchQuotaMiloapisComV1alpha1ResourceRegistrationStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchRbacAuthorizationV1ClusterRoleArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchRbacAuthorizationV1ClusterRoleBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchRbacAuthorizationV1NamespacedRoleArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchRbacAuthorizationV1NamespacedRoleBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembershipArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembershipStatusArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    fieldManager?: InputMaybe<Scalars['String']['input']>;
    fieldValidation?: InputMaybe<Scalars['String']['input']>;
    force?: InputMaybe<Scalars['Boolean']['input']>;
    input?: InputMaybe<Scalars['JSON']['input']>;
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationPatchResourcemanagerMiloapisComV1alpha1OrganizationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchResourcemanagerMiloapisComV1alpha1OrganizationStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchResourcemanagerMiloapisComV1alpha1ProjectArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchResourcemanagerMiloapisComV1alpha1ProjectStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchTelemetryMiloapisComV1alpha1NamespacedExportPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationPatchTelemetryMiloapisComV1alpha1NamespacedExportPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  force?: InputMaybe<Scalars['Boolean']['input']>;
  input?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceAdmissionregistrationV1MutatingWebhookConfigurationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_MutatingWebhookConfiguration_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceAdmissionregistrationV1ValidatingAdmissionPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicy_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceAdmissionregistrationV1ValidatingAdmissionPolicyBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBinding_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceAdmissionregistrationV1ValidatingAdmissionPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicy_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceAdmissionregistrationV1ValidatingWebhookConfigurationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_ValidatingWebhookConfiguration_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceAgreementMiloapisComV1alpha1NamespacedDocumentAcceptanceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Agreement_V1alpha1_DocumentAcceptance_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceAgreementMiloapisComV1alpha1NamespacedDocumentAcceptanceStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Agreement_V1alpha1_DocumentAcceptance_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceApiextensionsV1CustomResourceDefinitionArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinition_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceApiextensionsV1CustomResourceDefinitionStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinition_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceApiregistrationV1ApiServiceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiService_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceApiregistrationV1ApiServiceStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiService_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceComputeDatumapisComV1alphaNamespacedInstanceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Compute_V1alpha_Instance_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceComputeDatumapisComV1alphaNamespacedInstanceStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Compute_V1alpha_Instance_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceComputeDatumapisComV1alphaNamespacedWorkloadArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Compute_V1alpha_Workload_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceComputeDatumapisComV1alphaNamespacedWorkloadDeploymentArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Compute_V1alpha_WorkloadDeployment_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceComputeDatumapisComV1alphaNamespacedWorkloadDeploymentStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Compute_V1alpha_WorkloadDeployment_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceComputeDatumapisComV1alphaNamespacedWorkloadStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Compute_V1alpha_Workload_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceCoordinationV1NamespacedLeaseArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Coordination_V1_Lease_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceCoreV1NamespaceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Core_V1_Namespace_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceCoreV1NamespaceFinalizeArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Core_V1_Namespace_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceCoreV1NamespaceStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Core_V1_Namespace_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceCoreV1NamespacedConfigMapArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Core_V1_ConfigMap_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceCoreV1NamespacedEventArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Core_V1_Event_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceCoreV1NamespacedSecretArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Core_V1_Secret_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceCrmMiloapisComV1alpha1NoteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Crm_V1alpha1_Note_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceCrmMiloapisComV1alpha1NoteStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Crm_V1alpha1_Note_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceDiscoveryV1NamespacedEndpointSliceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Discovery_V1_EndpointSlice_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceDnsNetworkingMiloapisComV1alpha1DnsZoneClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClass_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceDnsNetworkingMiloapisComV1alpha1DnsZoneClassStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClass_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceDnsNetworkingMiloapisComV1alpha1NamespacedDnsRecordSetArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSet_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceDnsNetworkingMiloapisComV1alpha1NamespacedDnsRecordSetStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSet_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZone_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneDiscoveryArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscovery_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneDiscoveryStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscovery_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZone_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceDocumentationMiloapisComV1alpha1NamespacedDocumentArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Documentation_V1alpha1_Document_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceDocumentationMiloapisComV1alpha1NamespacedDocumentRevisionArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Documentation_V1alpha1_DocumentRevision_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceDocumentationMiloapisComV1alpha1NamespacedDocumentRevisionStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Documentation_V1alpha1_DocumentRevision_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceDocumentationMiloapisComV1alpha1NamespacedDocumentStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Documentation_V1alpha1_Document_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceEventsV1NamespacedEventArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Events_V1_Event_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceFlowcontrolApiserverV1FlowSchemaArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_FlowSchema_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceFlowcontrolApiserverV1FlowSchemaStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_FlowSchema_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceFlowcontrolApiserverV1PriorityLevelConfigurationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfiguration_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceFlowcontrolApiserverV1PriorityLevelConfigurationStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfiguration_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayEnvoyproxyIoV1alpha1NamespacedBackendArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_Envoyproxy_Gateway_V1alpha1_Backend_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayEnvoyproxyIoV1alpha1NamespacedBackendStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_Envoyproxy_Gateway_V1alpha1_Backend_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicy_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicy_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayEnvoyproxyIoV1alpha1NamespacedHttpRouteFilterArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_Envoyproxy_Gateway_V1alpha1_HttpRouteFilter_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicy_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicy_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1GatewayClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1_GatewayClass_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1GatewayClassStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1_GatewayClass_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1NamespacedBackendTlsPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1_BackendTlsPolicy_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1NamespacedBackendTlsPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1_BackendTlsPolicy_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1NamespacedGatewayArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1_Gateway_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1NamespacedGatewayStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1_Gateway_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1NamespacedHttpRouteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1_HttpRoute_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1NamespacedHttpRouteStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1_HttpRoute_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1alpha3NamespacedBackendTlsPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1alpha3_BackendTlsPolicy_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1beta1GatewayClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1beta1_GatewayClass_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1beta1GatewayClassStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1beta1_GatewayClass_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1beta1NamespacedGatewayArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1beta1_Gateway_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1beta1NamespacedGatewayStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1beta1_Gateway_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1beta1NamespacedHttpRouteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1beta1_HttpRoute_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceGatewayNetworkingV1beta1NamespacedHttpRouteStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Networking_Gateway_V1beta1_HttpRoute_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1NamespacedGroupArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_Group_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1NamespacedGroupMembershipArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_GroupMembership_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1NamespacedGroupMembershipStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_GroupMembership_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1NamespacedGroupStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_Group_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1NamespacedMachineAccountArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_MachineAccount_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1NamespacedMachineAccountKeyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_MachineAccountKey_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1NamespacedMachineAccountKeyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_MachineAccountKey_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1NamespacedMachineAccountStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_MachineAccount_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1NamespacedPolicyBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PolicyBinding_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1NamespacedPolicyBindingStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PolicyBinding_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1NamespacedRoleArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_Role_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1NamespacedRoleStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_Role_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1NamespacedUserInvitationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_UserInvitation_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1NamespacedUserInvitationStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_UserInvitation_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1PlatformAccessApprovalArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessApproval_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1PlatformAccessApprovalStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessApproval_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1PlatformAccessDenialArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessDenial_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1PlatformAccessDenialStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessDenial_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1PlatformAccessRejectionArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessRejection_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1PlatformAccessRejectionStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessRejection_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1PlatformInvitationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PlatformInvitation_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1PlatformInvitationStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_PlatformInvitation_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1ProtectedResourceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_ProtectedResource_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1ProtectedResourceStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_ProtectedResource_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1UserArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_User_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1UserDeactivationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_UserDeactivation_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1UserDeactivationStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_UserDeactivation_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1UserPreferenceArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_UserPreference_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1UserPreferenceStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_UserPreference_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceIamMiloapisComV1alpha1UserStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Iam_V1alpha1_User_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alpha1NamespacedConnectorArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha1_Connector_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisementArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisement_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisementStatusArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    fieldManager?: InputMaybe<Scalars['String']['input']>;
    fieldValidation?: InputMaybe<Scalars['String']['input']>;
    input?: InputMaybe<Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisement_Input>;
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationReplaceNetworkingDatumapisComV1alpha1NamespacedConnectorClassArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha1_ConnectorClass_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alpha1NamespacedConnectorClassStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha1_ConnectorClass_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alpha1NamespacedConnectorStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha1_Connector_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedDomainArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_Domain_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedDomainStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_Domain_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedHttpProxyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_HttpProxy_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedHttpProxyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_HttpProxy_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedLocationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_Location_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedLocationStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_Location_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedNetworkArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_Network_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedNetworkBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_NetworkBinding_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedNetworkBindingStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_NetworkBinding_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedNetworkContextArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_NetworkContext_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedNetworkContextStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_NetworkContext_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedNetworkPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_NetworkPolicy_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedNetworkPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_NetworkPolicy_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedNetworkStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_Network_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedSubnetArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_Subnet_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedSubnetClaimArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_SubnetClaim_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedSubnetClaimStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_SubnetClaim_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedSubnetStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_Subnet_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicy_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicyStatusArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    fieldManager?: InputMaybe<Scalars['String']['input']>;
    fieldValidation?: InputMaybe<Scalars['String']['input']>;
    input?: InputMaybe<Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicy_Input>;
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationReplaceNotificationMiloapisComV1alpha1EmailTemplateArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_EmailTemplate_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNotificationMiloapisComV1alpha1EmailTemplateStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_EmailTemplate_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNotificationMiloapisComV1alpha1NamespacedContactArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_Contact_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNotificationMiloapisComV1alpha1NamespacedContactGroupArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_ContactGroup_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembership_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemovalArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    fieldManager?: InputMaybe<Scalars['String']['input']>;
    fieldValidation?: InputMaybe<Scalars['String']['input']>;
    input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemoval_Input>;
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationReplaceNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemovalStatusArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    fieldManager?: InputMaybe<Scalars['String']['input']>;
    fieldValidation?: InputMaybe<Scalars['String']['input']>;
    input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemoval_Input>;
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationReplaceNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipStatusArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    fieldManager?: InputMaybe<Scalars['String']['input']>;
    fieldValidation?: InputMaybe<Scalars['String']['input']>;
    input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembership_Input>;
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationReplaceNotificationMiloapisComV1alpha1NamespacedContactGroupStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_ContactGroup_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNotificationMiloapisComV1alpha1NamespacedContactStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_Contact_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNotificationMiloapisComV1alpha1NamespacedEmailArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_Email_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNotificationMiloapisComV1alpha1NamespacedEmailBroadcastArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_EmailBroadcast_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNotificationMiloapisComV1alpha1NamespacedEmailBroadcastStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_EmailBroadcast_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNotificationMiloapisComV1alpha1NamespacedEmailStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_Email_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNotificationMiloapisComV1alpha1NamespacedNoteArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_Note_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceNotificationMiloapisComV1alpha1NamespacedNoteStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Notification_V1alpha1_Note_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceQuotaMiloapisComV1alpha1ClaimCreationPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicy_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceQuotaMiloapisComV1alpha1ClaimCreationPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicy_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceQuotaMiloapisComV1alpha1GrantCreationPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_GrantCreationPolicy_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceQuotaMiloapisComV1alpha1GrantCreationPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_GrantCreationPolicy_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceQuotaMiloapisComV1alpha1NamespacedAllowanceBucketArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_AllowanceBucket_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceQuotaMiloapisComV1alpha1NamespacedAllowanceBucketStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_AllowanceBucket_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceQuotaMiloapisComV1alpha1NamespacedResourceClaimArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_ResourceClaim_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceQuotaMiloapisComV1alpha1NamespacedResourceClaimStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_ResourceClaim_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceQuotaMiloapisComV1alpha1NamespacedResourceGrantArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_ResourceGrant_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceQuotaMiloapisComV1alpha1NamespacedResourceGrantStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_ResourceGrant_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceQuotaMiloapisComV1alpha1ResourceRegistrationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_ResourceRegistration_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceQuotaMiloapisComV1alpha1ResourceRegistrationStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Quota_V1alpha1_ResourceRegistration_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceRbacAuthorizationV1ClusterRoleArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Rbac_V1_ClusterRole_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceRbacAuthorizationV1ClusterRoleBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Rbac_V1_ClusterRoleBinding_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceRbacAuthorizationV1NamespacedRoleArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Rbac_V1_Role_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceRbacAuthorizationV1NamespacedRoleBindingArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Io_K8s_Api_Rbac_V1_RoleBinding_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembershipArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    fieldManager?: InputMaybe<Scalars['String']['input']>;
    fieldValidation?: InputMaybe<Scalars['String']['input']>;
    input?: InputMaybe<Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembership_Input>;
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationReplaceResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembershipStatusArgs =
  {
    dryRun?: InputMaybe<Scalars['String']['input']>;
    fieldManager?: InputMaybe<Scalars['String']['input']>;
    fieldValidation?: InputMaybe<Scalars['String']['input']>;
    input?: InputMaybe<Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembership_Input>;
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
  };

export type MutationReplaceResourcemanagerMiloapisComV1alpha1OrganizationArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Resourcemanager_V1alpha1_Organization_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceResourcemanagerMiloapisComV1alpha1OrganizationStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Resourcemanager_V1alpha1_Organization_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceResourcemanagerMiloapisComV1alpha1ProjectArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Resourcemanager_V1alpha1_Project_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceResourcemanagerMiloapisComV1alpha1ProjectStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Resourcemanager_V1alpha1_Project_Input>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceTelemetryMiloapisComV1alpha1NamespacedExportPolicyArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Telemetry_V1alpha1_ExportPolicy_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type MutationReplaceTelemetryMiloapisComV1alpha1NamespacedExportPolicyStatusArgs = {
  dryRun?: InputMaybe<Scalars['String']['input']>;
  fieldManager?: InputMaybe<Scalars['String']['input']>;
  fieldValidation?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<Com_Miloapis_Telemetry_V1alpha1_ExportPolicy_Input>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type OwaspCoreRuleSet_Const = 'OWASPCoreRuleSet';

/** ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create. */
export type ObjectMeta_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io = {
  /** Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations */
  annotations?: Maybe<Scalars['JSON']['output']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  creationTimestamp?: Maybe<Scalars['DateTime']['output']>;
  /** Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only. */
  deletionGracePeriodSeconds?: Maybe<Scalars['BigInt']['output']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  deletionTimestamp?: Maybe<Scalars['DateTime']['output']>;
  /** Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. */
  finalizers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
   *
   * If this field is specified and the generated name exists, the server will return a 409.
   *
   * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
   */
  generateName?: Maybe<Scalars['String']['output']>;
  /** A sequence number representing a specific generation of the desired state. Populated by the system. Read-only. */
  generation?: Maybe<Scalars['BigInt']['output']>;
  /** Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels */
  labels?: Maybe<Scalars['JSON']['output']>;
  /** ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object. */
  managedFields?: Maybe<Array<Maybe<ManagedFieldsEntry_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>>>;
  /** Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
   *
   * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
   */
  namespace?: Maybe<Scalars['String']['output']>;
  /** List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. */
  ownerReferences?: Maybe<Array<Maybe<OwnerReference_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>>>;
  /**
   * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
   *
   * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   */
  resourceVersion?: Maybe<Scalars['String']['output']>;
  /** Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. */
  selfLink?: Maybe<Scalars['String']['output']>;
  /**
   * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
   *
   * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
   */
  uid?: Maybe<Scalars['String']['output']>;
};

/** ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create. */
export type ObjectMeta_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io_Input = {
  /** Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations */
  annotations?: InputMaybe<Scalars['JSON']['input']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  creationTimestamp?: InputMaybe<Scalars['DateTime']['input']>;
  /** Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only. */
  deletionGracePeriodSeconds?: InputMaybe<Scalars['BigInt']['input']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  deletionTimestamp?: InputMaybe<Scalars['DateTime']['input']>;
  /** Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. */
  finalizers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
   *
   * If this field is specified and the generated name exists, the server will return a 409.
   *
   * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
   */
  generateName?: InputMaybe<Scalars['String']['input']>;
  /** A sequence number representing a specific generation of the desired state. Populated by the system. Read-only. */
  generation?: InputMaybe<Scalars['BigInt']['input']>;
  /** Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels */
  labels?: InputMaybe<Scalars['JSON']['input']>;
  /** ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object. */
  managedFields?: InputMaybe<
    Array<InputMaybe<ManagedFieldsEntry_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io_Input>>
  >;
  /** Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names */
  name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
   *
   * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
   */
  namespace?: InputMaybe<Scalars['String']['input']>;
  /** List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. */
  ownerReferences?: InputMaybe<
    Array<InputMaybe<OwnerReference_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io_Input>>
  >;
  /**
   * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
   *
   * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   */
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  /** Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. */
  selfLink?: InputMaybe<Scalars['String']['input']>;
  /**
   * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
   *
   * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
   */
  uid?: InputMaybe<Scalars['String']['input']>;
};

export type Organization_Const = 'Organization';

/** OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. */
export type OwnerReference_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io = {
  /** API version of the referent. */
  apiVersion: Scalars['String']['output'];
  /** If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. */
  blockOwnerDeletion?: Maybe<Scalars['Boolean']['output']>;
  /** If true, this reference points to the managing controller. */
  controller?: Maybe<Scalars['Boolean']['output']>;
  /** Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind: Scalars['String']['output'];
  /** Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names */
  name: Scalars['String']['output'];
  /** UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
  uid: Scalars['String']['output'];
};

/** OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. */
export type OwnerReference_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io_Input = {
  /** API version of the referent. */
  apiVersion: Scalars['String']['input'];
  /** If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. */
  blockOwnerDeletion?: InputMaybe<Scalars['Boolean']['input']>;
  /** If true, this reference points to the managing controller. */
  controller?: InputMaybe<Scalars['Boolean']['input']>;
  /** Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind: Scalars['String']['input'];
  /** Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names */
  name: Scalars['String']['input'];
  /** UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
  uid: Scalars['String']['input'];
};

export type PublicKey_Const = 'PublicKey';

export type Query = {
  /** get available API versions */
  getAPIVersions?: Maybe<ApiGroupList_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>;
  /** get information of a group */
  getActivityMiloapisComAPIGroup?: Maybe<ApiGroup_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>;
  /** get available resources */
  getActivityMiloapisComV1alpha1APIResources?: Maybe<ApiResourceList_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>;
  /** get information of a group */
  getAdmissionregistrationAPIGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiGroup>;
  /** get available resources */
  getAdmissionregistrationV1APIResources?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResourceList>;
  /** get information of a group */
  getApiextensionsAPIGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiGroup>;
  /** get available resources */
  getApiextensionsV1APIResources?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResourceList>;
  /** get information of a group */
  getApiregistrationAPIGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiGroup>;
  /** get available resources */
  getApiregistrationV1APIResources?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResourceList>;
  /** get information of a group */
  getAuthenticationAPIGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiGroup>;
  /** get available resources */
  getAuthenticationV1APIResources?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResourceList>;
  /** get information of a group */
  getAuthorizationAPIGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiGroup>;
  /** get available resources */
  getAuthorizationV1APIResources?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResourceList>;
  /** get the version information for this server */
  getCodeVersion?: Maybe<Info_Version_Pkg_Apimachinery_K8s_Io>;
  /** get information of a group */
  getCoordinationAPIGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiGroup>;
  /** get available resources */
  getCoordinationV1APIResources?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResourceList>;
  /** get available API versions */
  getCoreAPIVersions?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiVersions>;
  /** get available resources */
  getCoreV1APIResources?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResourceList>;
  /** get information of a group */
  getDiscoveryAPIGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiGroup>;
  /** get available resources */
  getDiscoveryV1APIResources?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResourceList>;
  /** get information of a group */
  getEventsAPIGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiGroup>;
  /** get available resources */
  getEventsV1APIResources?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResourceList>;
  /** get information of a group */
  getFlowcontrolApiserverAPIGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiGroup>;
  /** get available resources */
  getFlowcontrolApiserverV1APIResources?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResourceList>;
  /** get information of a group */
  getIdentityMiloapisComAPIGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiGroup>;
  /** get available resources */
  getIdentityMiloapisComV1alpha1APIResources?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResourceList>;
  /** get information of a group */
  getRbacAuthorizationAPIGroup?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiGroup>;
  /** get available resources */
  getRbacAuthorizationV1APIResources?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResourceList>;
  /** get service account issuer OpenID configuration, also known as the 'OIDC discovery doc' */
  getServiceAccountIssuerOpenIDConfiguration?: Maybe<Scalars['String']['output']>;
  /** get service account issuer OpenID JSON Web Key Set (contains public token verification keys) */
  getServiceAccountIssuerOpenIDKeyset?: Maybe<Scalars['String']['output']>;
  /** list or watch objects of kind MutatingWebhookConfiguration */
  listAdmissionregistrationV1MutatingWebhookConfiguration?: Maybe<Io_K8s_Api_Admissionregistration_V1_MutatingWebhookConfigurationList>;
  /** list or watch objects of kind ValidatingAdmissionPolicy */
  listAdmissionregistrationV1ValidatingAdmissionPolicy?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyList>;
  /** list or watch objects of kind ValidatingAdmissionPolicyBinding */
  listAdmissionregistrationV1ValidatingAdmissionPolicyBinding?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBindingList>;
  /** list or watch objects of kind ValidatingWebhookConfiguration */
  listAdmissionregistrationV1ValidatingWebhookConfiguration?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingWebhookConfigurationList>;
  /** list objects of kind DocumentAcceptance */
  listAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces?: Maybe<Com_Miloapis_Agreement_V1alpha1_DocumentAcceptanceList>;
  /** list objects of kind DocumentAcceptance */
  listAgreementMiloapisComV1alpha1NamespacedDocumentAcceptance?: Maybe<Com_Miloapis_Agreement_V1alpha1_DocumentAcceptanceList>;
  /** list or watch objects of kind CustomResourceDefinition */
  listApiextensionsV1CustomResourceDefinition?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionList>;
  /** list or watch objects of kind APIService */
  listApiregistrationV1APIService?: Maybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiServiceList>;
  /** list objects of kind Instance */
  listComputeDatumapisComV1alphaInstanceForAllNamespaces?: Maybe<Com_Datumapis_Compute_V1alpha_InstanceList>;
  /** list objects of kind Instance */
  listComputeDatumapisComV1alphaNamespacedInstance?: Maybe<Com_Datumapis_Compute_V1alpha_InstanceList>;
  /** list objects of kind Workload */
  listComputeDatumapisComV1alphaNamespacedWorkload?: Maybe<Com_Datumapis_Compute_V1alpha_WorkloadList>;
  /** list objects of kind WorkloadDeployment */
  listComputeDatumapisComV1alphaNamespacedWorkloadDeployment?: Maybe<Com_Datumapis_Compute_V1alpha_WorkloadDeploymentList>;
  /** list objects of kind WorkloadDeployment */
  listComputeDatumapisComV1alphaWorkloadDeploymentForAllNamespaces?: Maybe<Com_Datumapis_Compute_V1alpha_WorkloadDeploymentList>;
  /** list objects of kind Workload */
  listComputeDatumapisComV1alphaWorkloadForAllNamespaces?: Maybe<Com_Datumapis_Compute_V1alpha_WorkloadList>;
  /** list or watch objects of kind Lease */
  listCoordinationV1LeaseForAllNamespaces?: Maybe<Io_K8s_Api_Coordination_V1_LeaseList>;
  /** list or watch objects of kind Lease */
  listCoordinationV1NamespacedLease?: Maybe<Io_K8s_Api_Coordination_V1_LeaseList>;
  /** list or watch objects of kind ConfigMap */
  listCoreV1ConfigMapForAllNamespaces?: Maybe<Io_K8s_Api_Core_V1_ConfigMapList>;
  /** list or watch objects of kind Event */
  listCoreV1EventForAllNamespaces?: Maybe<Io_K8s_Api_Core_V1_EventList>;
  /** list or watch objects of kind Namespace */
  listCoreV1Namespace?: Maybe<Io_K8s_Api_Core_V1_NamespaceList>;
  /** list or watch objects of kind ConfigMap */
  listCoreV1NamespacedConfigMap?: Maybe<Io_K8s_Api_Core_V1_ConfigMapList>;
  /** list or watch objects of kind Event */
  listCoreV1NamespacedEvent?: Maybe<Io_K8s_Api_Core_V1_EventList>;
  /** list or watch objects of kind Secret */
  listCoreV1NamespacedSecret?: Maybe<Io_K8s_Api_Core_V1_SecretList>;
  /** list or watch objects of kind Secret */
  listCoreV1SecretForAllNamespaces?: Maybe<Io_K8s_Api_Core_V1_SecretList>;
  /** list objects of kind Note */
  listCrmMiloapisComV1alpha1Note?: Maybe<Com_Miloapis_Crm_V1alpha1_NoteList>;
  /** list or watch objects of kind EndpointSlice */
  listDiscoveryV1EndpointSliceForAllNamespaces?: Maybe<Io_K8s_Api_Discovery_V1_EndpointSliceList>;
  /** list or watch objects of kind EndpointSlice */
  listDiscoveryV1NamespacedEndpointSlice?: Maybe<Io_K8s_Api_Discovery_V1_EndpointSliceList>;
  /** list objects of kind DNSRecordSet */
  listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSetList>;
  /** list objects of kind DNSZoneClass */
  listDnsNetworkingMiloapisComV1alpha1DNSZoneClass?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClassList>;
  /** list objects of kind DNSZoneDiscovery */
  listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscoveryList>;
  /** list objects of kind DNSZone */
  listDnsNetworkingMiloapisComV1alpha1DNSZoneForAllNamespaces?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneList>;
  /** list objects of kind DNSRecordSet */
  listDnsNetworkingMiloapisComV1alpha1NamespacedDNSRecordSet?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSetList>;
  /** list objects of kind DNSZone */
  listDnsNetworkingMiloapisComV1alpha1NamespacedDNSZone?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneList>;
  /** list objects of kind DNSZoneDiscovery */
  listDnsNetworkingMiloapisComV1alpha1NamespacedDNSZoneDiscovery?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscoveryList>;
  /** list objects of kind Document */
  listDocumentationMiloapisComV1alpha1DocumentForAllNamespaces?: Maybe<Com_Miloapis_Documentation_V1alpha1_DocumentList>;
  /** list objects of kind DocumentRevision */
  listDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces?: Maybe<Com_Miloapis_Documentation_V1alpha1_DocumentRevisionList>;
  /** list objects of kind Document */
  listDocumentationMiloapisComV1alpha1NamespacedDocument?: Maybe<Com_Miloapis_Documentation_V1alpha1_DocumentList>;
  /** list objects of kind DocumentRevision */
  listDocumentationMiloapisComV1alpha1NamespacedDocumentRevision?: Maybe<Com_Miloapis_Documentation_V1alpha1_DocumentRevisionList>;
  /** list or watch objects of kind Event */
  listEventsV1EventForAllNamespaces?: Maybe<Io_K8s_Api_Events_V1_EventList>;
  /** list or watch objects of kind Event */
  listEventsV1NamespacedEvent?: Maybe<Io_K8s_Api_Events_V1_EventList>;
  /** list or watch objects of kind FlowSchema */
  listFlowcontrolApiserverV1FlowSchema?: Maybe<Io_K8s_Api_Flowcontrol_V1_FlowSchemaList>;
  /** list or watch objects of kind PriorityLevelConfiguration */
  listFlowcontrolApiserverV1PriorityLevelConfiguration?: Maybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationList>;
  /** list objects of kind Backend */
  listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_BackendList>;
  /** list objects of kind BackendTrafficPolicy */
  listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicyList>;
  /** list objects of kind HTTPRouteFilter */
  listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_HttpRouteFilterList>;
  /** list objects of kind Backend */
  listGatewayEnvoyproxyIoV1alpha1NamespacedBackend?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_BackendList>;
  /** list objects of kind BackendTrafficPolicy */
  listGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicy?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicyList>;
  /** list objects of kind HTTPRouteFilter */
  listGatewayEnvoyproxyIoV1alpha1NamespacedHTTPRouteFilter?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_HttpRouteFilterList>;
  /** list objects of kind SecurityPolicy */
  listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicyList>;
  /** list objects of kind SecurityPolicy */
  listGatewayEnvoyproxyIoV1alpha1SecurityPolicyForAllNamespaces?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicyList>;
  /** list objects of kind BackendTLSPolicy */
  listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces?: Maybe<Io_K8s_Networking_Gateway_V1_BackendTlsPolicyList>;
  /** list objects of kind GatewayClass */
  listGatewayNetworkingV1GatewayClass?: Maybe<Io_K8s_Networking_Gateway_V1_GatewayClassList>;
  /** list objects of kind Gateway */
  listGatewayNetworkingV1GatewayForAllNamespaces?: Maybe<Io_K8s_Networking_Gateway_V1_GatewayList>;
  /** list objects of kind HTTPRoute */
  listGatewayNetworkingV1HTTPRouteForAllNamespaces?: Maybe<Io_K8s_Networking_Gateway_V1_HttpRouteList>;
  /** list objects of kind BackendTLSPolicy */
  listGatewayNetworkingV1NamespacedBackendTLSPolicy?: Maybe<Io_K8s_Networking_Gateway_V1_BackendTlsPolicyList>;
  /** list objects of kind Gateway */
  listGatewayNetworkingV1NamespacedGateway?: Maybe<Io_K8s_Networking_Gateway_V1_GatewayList>;
  /** list objects of kind HTTPRoute */
  listGatewayNetworkingV1NamespacedHTTPRoute?: Maybe<Io_K8s_Networking_Gateway_V1_HttpRouteList>;
  /** list objects of kind BackendTLSPolicy */
  listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces?: Maybe<Io_K8s_Networking_Gateway_V1alpha3_BackendTlsPolicyList>;
  /** list objects of kind BackendTLSPolicy */
  listGatewayNetworkingV1alpha3NamespacedBackendTLSPolicy?: Maybe<Io_K8s_Networking_Gateway_V1alpha3_BackendTlsPolicyList>;
  /** list objects of kind GatewayClass */
  listGatewayNetworkingV1beta1GatewayClass?: Maybe<Io_K8s_Networking_Gateway_V1beta1_GatewayClassList>;
  /** list objects of kind Gateway */
  listGatewayNetworkingV1beta1GatewayForAllNamespaces?: Maybe<Io_K8s_Networking_Gateway_V1beta1_GatewayList>;
  /** list objects of kind HTTPRoute */
  listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces?: Maybe<Io_K8s_Networking_Gateway_V1beta1_HttpRouteList>;
  /** list objects of kind Gateway */
  listGatewayNetworkingV1beta1NamespacedGateway?: Maybe<Io_K8s_Networking_Gateway_V1beta1_GatewayList>;
  /** list objects of kind HTTPRoute */
  listGatewayNetworkingV1beta1NamespacedHTTPRoute?: Maybe<Io_K8s_Networking_Gateway_V1beta1_HttpRouteList>;
  /** list objects of kind Group */
  listIamMiloapisComV1alpha1GroupForAllNamespaces?: Maybe<Com_Miloapis_Iam_V1alpha1_GroupList>;
  /** list objects of kind GroupMembership */
  listIamMiloapisComV1alpha1GroupMembershipForAllNamespaces?: Maybe<Com_Miloapis_Iam_V1alpha1_GroupMembershipList>;
  /** list objects of kind MachineAccount */
  listIamMiloapisComV1alpha1MachineAccountForAllNamespaces?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccountList>;
  /** list objects of kind MachineAccountKey */
  listIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccountKeyList>;
  /** list objects of kind Group */
  listIamMiloapisComV1alpha1NamespacedGroup?: Maybe<Com_Miloapis_Iam_V1alpha1_GroupList>;
  /** list objects of kind GroupMembership */
  listIamMiloapisComV1alpha1NamespacedGroupMembership?: Maybe<Com_Miloapis_Iam_V1alpha1_GroupMembershipList>;
  /** list objects of kind MachineAccount */
  listIamMiloapisComV1alpha1NamespacedMachineAccount?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccountList>;
  /** list objects of kind MachineAccountKey */
  listIamMiloapisComV1alpha1NamespacedMachineAccountKey?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccountKeyList>;
  /** list objects of kind PolicyBinding */
  listIamMiloapisComV1alpha1NamespacedPolicyBinding?: Maybe<Com_Miloapis_Iam_V1alpha1_PolicyBindingList>;
  /** list objects of kind Role */
  listIamMiloapisComV1alpha1NamespacedRole?: Maybe<Com_Miloapis_Iam_V1alpha1_RoleList>;
  /** list objects of kind UserInvitation */
  listIamMiloapisComV1alpha1NamespacedUserInvitation?: Maybe<Com_Miloapis_Iam_V1alpha1_UserInvitationList>;
  /** list objects of kind PlatformAccessApproval */
  listIamMiloapisComV1alpha1PlatformAccessApproval?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessApprovalList>;
  /** list objects of kind PlatformAccessDenial */
  listIamMiloapisComV1alpha1PlatformAccessDenial?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessDenialList>;
  /** list objects of kind PlatformAccessRejection */
  listIamMiloapisComV1alpha1PlatformAccessRejection?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessRejectionList>;
  /** list objects of kind PlatformInvitation */
  listIamMiloapisComV1alpha1PlatformInvitation?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformInvitationList>;
  /** list objects of kind PolicyBinding */
  listIamMiloapisComV1alpha1PolicyBindingForAllNamespaces?: Maybe<Com_Miloapis_Iam_V1alpha1_PolicyBindingList>;
  /** list objects of kind ProtectedResource */
  listIamMiloapisComV1alpha1ProtectedResource?: Maybe<Com_Miloapis_Iam_V1alpha1_ProtectedResourceList>;
  /** list objects of kind Role */
  listIamMiloapisComV1alpha1RoleForAllNamespaces?: Maybe<Com_Miloapis_Iam_V1alpha1_RoleList>;
  /** list objects of kind User */
  listIamMiloapisComV1alpha1User?: Maybe<Com_Miloapis_Iam_V1alpha1_UserList>;
  /** list objects of kind UserDeactivation */
  listIamMiloapisComV1alpha1UserDeactivation?: Maybe<Com_Miloapis_Iam_V1alpha1_UserDeactivationList>;
  /** list objects of kind UserInvitation */
  listIamMiloapisComV1alpha1UserInvitationForAllNamespaces?: Maybe<Com_Miloapis_Iam_V1alpha1_UserInvitationList>;
  /** list objects of kind UserPreference */
  listIamMiloapisComV1alpha1UserPreference?: Maybe<Com_Miloapis_Iam_V1alpha1_UserPreferenceList>;
  /** list objects of kind Session */
  listIdentityMiloapisComV1alpha1Session?: Maybe<Com_Miloapis_Go_Milo_Pkg_Apis_Identity_V1alpha1_SessionList>;
  /** list objects of kind UserIdentity */
  listIdentityMiloapisComV1alpha1UserIdentity?: Maybe<Com_Miloapis_Go_Milo_Pkg_Apis_Identity_V1alpha1_UserIdentityList>;
  /** list objects of kind ConnectorAdvertisement */
  listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisementList>;
  /** list objects of kind ConnectorClass */
  listNetworkingDatumapisComV1alpha1ConnectorClassForAllNamespaces?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorClassList>;
  /** list objects of kind Connector */
  listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorList>;
  /** list objects of kind Connector */
  listNetworkingDatumapisComV1alpha1NamespacedConnector?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorList>;
  /** list objects of kind ConnectorAdvertisement */
  listNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisement?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisementList>;
  /** list objects of kind ConnectorClass */
  listNetworkingDatumapisComV1alpha1NamespacedConnectorClass?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorClassList>;
  /** list objects of kind Domain */
  listNetworkingDatumapisComV1alphaDomainForAllNamespaces?: Maybe<Com_Datumapis_Networking_V1alpha_DomainList>;
  /** list objects of kind HTTPProxy */
  listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces?: Maybe<Com_Datumapis_Networking_V1alpha_HttpProxyList>;
  /** list objects of kind Location */
  listNetworkingDatumapisComV1alphaLocationForAllNamespaces?: Maybe<Com_Datumapis_Networking_V1alpha_LocationList>;
  /** list objects of kind Domain */
  listNetworkingDatumapisComV1alphaNamespacedDomain?: Maybe<Com_Datumapis_Networking_V1alpha_DomainList>;
  /** list objects of kind HTTPProxy */
  listNetworkingDatumapisComV1alphaNamespacedHTTPProxy?: Maybe<Com_Datumapis_Networking_V1alpha_HttpProxyList>;
  /** list objects of kind Location */
  listNetworkingDatumapisComV1alphaNamespacedLocation?: Maybe<Com_Datumapis_Networking_V1alpha_LocationList>;
  /** list objects of kind Network */
  listNetworkingDatumapisComV1alphaNamespacedNetwork?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkList>;
  /** list objects of kind NetworkBinding */
  listNetworkingDatumapisComV1alphaNamespacedNetworkBinding?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkBindingList>;
  /** list objects of kind NetworkContext */
  listNetworkingDatumapisComV1alphaNamespacedNetworkContext?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkContextList>;
  /** list objects of kind NetworkPolicy */
  listNetworkingDatumapisComV1alphaNamespacedNetworkPolicy?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkPolicyList>;
  /** list objects of kind Subnet */
  listNetworkingDatumapisComV1alphaNamespacedSubnet?: Maybe<Com_Datumapis_Networking_V1alpha_SubnetList>;
  /** list objects of kind SubnetClaim */
  listNetworkingDatumapisComV1alphaNamespacedSubnetClaim?: Maybe<Com_Datumapis_Networking_V1alpha_SubnetClaimList>;
  /** list objects of kind TrafficProtectionPolicy */
  listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy?: Maybe<Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicyList>;
  /** list objects of kind NetworkBinding */
  listNetworkingDatumapisComV1alphaNetworkBindingForAllNamespaces?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkBindingList>;
  /** list objects of kind NetworkContext */
  listNetworkingDatumapisComV1alphaNetworkContextForAllNamespaces?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkContextList>;
  /** list objects of kind Network */
  listNetworkingDatumapisComV1alphaNetworkForAllNamespaces?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkList>;
  /** list objects of kind NetworkPolicy */
  listNetworkingDatumapisComV1alphaNetworkPolicyForAllNamespaces?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkPolicyList>;
  /** list objects of kind SubnetClaim */
  listNetworkingDatumapisComV1alphaSubnetClaimForAllNamespaces?: Maybe<Com_Datumapis_Networking_V1alpha_SubnetClaimList>;
  /** list objects of kind Subnet */
  listNetworkingDatumapisComV1alphaSubnetForAllNamespaces?: Maybe<Com_Datumapis_Networking_V1alpha_SubnetList>;
  /** list objects of kind TrafficProtectionPolicy */
  listNetworkingDatumapisComV1alphaTrafficProtectionPolicyForAllNamespaces?: Maybe<Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicyList>;
  /** list objects of kind Contact */
  listNotificationMiloapisComV1alpha1ContactForAllNamespaces?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactList>;
  /** list objects of kind ContactGroup */
  listNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupList>;
  /** list objects of kind ContactGroupMembership */
  listNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipList>;
  /** list objects of kind ContactGroupMembershipRemoval */
  listNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemovalList>;
  /** list objects of kind EmailBroadcast */
  listNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailBroadcastList>;
  /** list objects of kind Email */
  listNotificationMiloapisComV1alpha1EmailForAllNamespaces?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailList>;
  /** list objects of kind EmailTemplate */
  listNotificationMiloapisComV1alpha1EmailTemplate?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailTemplateList>;
  /** list objects of kind Contact */
  listNotificationMiloapisComV1alpha1NamespacedContact?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactList>;
  /** list objects of kind ContactGroup */
  listNotificationMiloapisComV1alpha1NamespacedContactGroup?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupList>;
  /** list objects of kind ContactGroupMembership */
  listNotificationMiloapisComV1alpha1NamespacedContactGroupMembership?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipList>;
  /** list objects of kind ContactGroupMembershipRemoval */
  listNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemoval?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemovalList>;
  /** list objects of kind Email */
  listNotificationMiloapisComV1alpha1NamespacedEmail?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailList>;
  /** list objects of kind EmailBroadcast */
  listNotificationMiloapisComV1alpha1NamespacedEmailBroadcast?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailBroadcastList>;
  /** list objects of kind Note */
  listNotificationMiloapisComV1alpha1NamespacedNote?: Maybe<Com_Miloapis_Notification_V1alpha1_NoteList>;
  /** list objects of kind Note */
  listNotificationMiloapisComV1alpha1NoteForAllNamespaces?: Maybe<Com_Miloapis_Notification_V1alpha1_NoteList>;
  /** list objects of kind AllowanceBucket */
  listQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces?: Maybe<Com_Miloapis_Quota_V1alpha1_AllowanceBucketList>;
  /** list objects of kind ClaimCreationPolicy */
  listQuotaMiloapisComV1alpha1ClaimCreationPolicy?: Maybe<Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicyList>;
  /** list objects of kind GrantCreationPolicy */
  listQuotaMiloapisComV1alpha1GrantCreationPolicy?: Maybe<Com_Miloapis_Quota_V1alpha1_GrantCreationPolicyList>;
  /** list objects of kind AllowanceBucket */
  listQuotaMiloapisComV1alpha1NamespacedAllowanceBucket?: Maybe<Com_Miloapis_Quota_V1alpha1_AllowanceBucketList>;
  /** list objects of kind ResourceClaim */
  listQuotaMiloapisComV1alpha1NamespacedResourceClaim?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceClaimList>;
  /** list objects of kind ResourceGrant */
  listQuotaMiloapisComV1alpha1NamespacedResourceGrant?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceGrantList>;
  /** list objects of kind ResourceClaim */
  listQuotaMiloapisComV1alpha1ResourceClaimForAllNamespaces?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceClaimList>;
  /** list objects of kind ResourceGrant */
  listQuotaMiloapisComV1alpha1ResourceGrantForAllNamespaces?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceGrantList>;
  /** list objects of kind ResourceRegistration */
  listQuotaMiloapisComV1alpha1ResourceRegistration?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceRegistrationList>;
  /** list or watch objects of kind ClusterRole */
  listRbacAuthorizationV1ClusterRole?: Maybe<Io_K8s_Api_Rbac_V1_ClusterRoleList>;
  /** list or watch objects of kind ClusterRoleBinding */
  listRbacAuthorizationV1ClusterRoleBinding?: Maybe<Io_K8s_Api_Rbac_V1_ClusterRoleBindingList>;
  /** list or watch objects of kind Role */
  listRbacAuthorizationV1NamespacedRole?: Maybe<Io_K8s_Api_Rbac_V1_RoleList>;
  /** list or watch objects of kind RoleBinding */
  listRbacAuthorizationV1NamespacedRoleBinding?: Maybe<Io_K8s_Api_Rbac_V1_RoleBindingList>;
  /** list or watch objects of kind RoleBinding */
  listRbacAuthorizationV1RoleBindingForAllNamespaces?: Maybe<Io_K8s_Api_Rbac_V1_RoleBindingList>;
  /** list or watch objects of kind Role */
  listRbacAuthorizationV1RoleForAllNamespaces?: Maybe<Io_K8s_Api_Rbac_V1_RoleList>;
  /** list objects of kind OrganizationMembership */
  listResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembershipList>;
  /** list objects of kind Organization */
  listResourcemanagerMiloapisComV1alpha1Organization?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_OrganizationList>;
  /** list objects of kind OrganizationMembership */
  listResourcemanagerMiloapisComV1alpha1OrganizationMembershipForAllNamespaces?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembershipList>;
  /** list objects of kind Project */
  listResourcemanagerMiloapisComV1alpha1Project?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_ProjectList>;
  /** list objects of kind ExportPolicy */
  listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces?: Maybe<Com_Miloapis_Telemetry_V1alpha1_ExportPolicyList>;
  /** list objects of kind ExportPolicy */
  listTelemetryMiloapisComV1alpha1NamespacedExportPolicy?: Maybe<Com_Miloapis_Telemetry_V1alpha1_ExportPolicyList>;
  /** read the specified MutatingWebhookConfiguration */
  readAdmissionregistrationV1MutatingWebhookConfiguration?: Maybe<Io_K8s_Api_Admissionregistration_V1_MutatingWebhookConfiguration>;
  /** read the specified ValidatingAdmissionPolicy */
  readAdmissionregistrationV1ValidatingAdmissionPolicy?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicy>;
  /** read the specified ValidatingAdmissionPolicyBinding */
  readAdmissionregistrationV1ValidatingAdmissionPolicyBinding?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBinding>;
  /** read status of the specified ValidatingAdmissionPolicy */
  readAdmissionregistrationV1ValidatingAdmissionPolicyStatus?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicy>;
  /** read the specified ValidatingWebhookConfiguration */
  readAdmissionregistrationV1ValidatingWebhookConfiguration?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingWebhookConfiguration>;
  /** read the specified DocumentAcceptance */
  readAgreementMiloapisComV1alpha1NamespacedDocumentAcceptance?: Maybe<Com_Miloapis_Agreement_V1alpha1_DocumentAcceptance>;
  /** read status of the specified DocumentAcceptance */
  readAgreementMiloapisComV1alpha1NamespacedDocumentAcceptanceStatus?: Maybe<Com_Miloapis_Agreement_V1alpha1_DocumentAcceptance>;
  /** read the specified CustomResourceDefinition */
  readApiextensionsV1CustomResourceDefinition?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinition>;
  /** read status of the specified CustomResourceDefinition */
  readApiextensionsV1CustomResourceDefinitionStatus?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinition>;
  /** read the specified APIService */
  readApiregistrationV1APIService?: Maybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiService>;
  /** read status of the specified APIService */
  readApiregistrationV1APIServiceStatus?: Maybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiService>;
  /** read the specified Instance */
  readComputeDatumapisComV1alphaNamespacedInstance?: Maybe<Com_Datumapis_Compute_V1alpha_Instance>;
  /** read status of the specified Instance */
  readComputeDatumapisComV1alphaNamespacedInstanceStatus?: Maybe<Com_Datumapis_Compute_V1alpha_Instance>;
  /** read the specified Workload */
  readComputeDatumapisComV1alphaNamespacedWorkload?: Maybe<Com_Datumapis_Compute_V1alpha_Workload>;
  /** read the specified WorkloadDeployment */
  readComputeDatumapisComV1alphaNamespacedWorkloadDeployment?: Maybe<Com_Datumapis_Compute_V1alpha_WorkloadDeployment>;
  /** read status of the specified WorkloadDeployment */
  readComputeDatumapisComV1alphaNamespacedWorkloadDeploymentStatus?: Maybe<Com_Datumapis_Compute_V1alpha_WorkloadDeployment>;
  /** read status of the specified Workload */
  readComputeDatumapisComV1alphaNamespacedWorkloadStatus?: Maybe<Com_Datumapis_Compute_V1alpha_Workload>;
  /** read the specified Lease */
  readCoordinationV1NamespacedLease?: Maybe<Io_K8s_Api_Coordination_V1_Lease>;
  /** read the specified Namespace */
  readCoreV1Namespace?: Maybe<Io_K8s_Api_Core_V1_Namespace>;
  /** read status of the specified Namespace */
  readCoreV1NamespaceStatus?: Maybe<Io_K8s_Api_Core_V1_Namespace>;
  /** read the specified ConfigMap */
  readCoreV1NamespacedConfigMap?: Maybe<Io_K8s_Api_Core_V1_ConfigMap>;
  /** read the specified Event */
  readCoreV1NamespacedEvent?: Maybe<Io_K8s_Api_Core_V1_Event>;
  /** read the specified Secret */
  readCoreV1NamespacedSecret?: Maybe<Io_K8s_Api_Core_V1_Secret>;
  /** read the specified Note */
  readCrmMiloapisComV1alpha1Note?: Maybe<Com_Miloapis_Crm_V1alpha1_Note>;
  /** read status of the specified Note */
  readCrmMiloapisComV1alpha1NoteStatus?: Maybe<Com_Miloapis_Crm_V1alpha1_Note>;
  /** read the specified EndpointSlice */
  readDiscoveryV1NamespacedEndpointSlice?: Maybe<Io_K8s_Api_Discovery_V1_EndpointSlice>;
  /** read the specified DNSZoneClass */
  readDnsNetworkingMiloapisComV1alpha1DNSZoneClass?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClass>;
  /** read status of the specified DNSZoneClass */
  readDnsNetworkingMiloapisComV1alpha1DNSZoneClassStatus?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClass>;
  /** read the specified DNSRecordSet */
  readDnsNetworkingMiloapisComV1alpha1NamespacedDNSRecordSet?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSet>;
  /** read status of the specified DNSRecordSet */
  readDnsNetworkingMiloapisComV1alpha1NamespacedDNSRecordSetStatus?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSet>;
  /** read the specified DNSZone */
  readDnsNetworkingMiloapisComV1alpha1NamespacedDNSZone?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZone>;
  /** read the specified DNSZoneDiscovery */
  readDnsNetworkingMiloapisComV1alpha1NamespacedDNSZoneDiscovery?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscovery>;
  /** read status of the specified DNSZoneDiscovery */
  readDnsNetworkingMiloapisComV1alpha1NamespacedDNSZoneDiscoveryStatus?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscovery>;
  /** read status of the specified DNSZone */
  readDnsNetworkingMiloapisComV1alpha1NamespacedDNSZoneStatus?: Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZone>;
  /** read the specified Document */
  readDocumentationMiloapisComV1alpha1NamespacedDocument?: Maybe<Com_Miloapis_Documentation_V1alpha1_Document>;
  /** read the specified DocumentRevision */
  readDocumentationMiloapisComV1alpha1NamespacedDocumentRevision?: Maybe<Com_Miloapis_Documentation_V1alpha1_DocumentRevision>;
  /** read status of the specified DocumentRevision */
  readDocumentationMiloapisComV1alpha1NamespacedDocumentRevisionStatus?: Maybe<Com_Miloapis_Documentation_V1alpha1_DocumentRevision>;
  /** read status of the specified Document */
  readDocumentationMiloapisComV1alpha1NamespacedDocumentStatus?: Maybe<Com_Miloapis_Documentation_V1alpha1_Document>;
  /** read the specified Event */
  readEventsV1NamespacedEvent?: Maybe<Io_K8s_Api_Events_V1_Event>;
  /** read the specified FlowSchema */
  readFlowcontrolApiserverV1FlowSchema?: Maybe<Io_K8s_Api_Flowcontrol_V1_FlowSchema>;
  /** read status of the specified FlowSchema */
  readFlowcontrolApiserverV1FlowSchemaStatus?: Maybe<Io_K8s_Api_Flowcontrol_V1_FlowSchema>;
  /** read the specified PriorityLevelConfiguration */
  readFlowcontrolApiserverV1PriorityLevelConfiguration?: Maybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfiguration>;
  /** read status of the specified PriorityLevelConfiguration */
  readFlowcontrolApiserverV1PriorityLevelConfigurationStatus?: Maybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfiguration>;
  /** read the specified Backend */
  readGatewayEnvoyproxyIoV1alpha1NamespacedBackend?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_Backend>;
  /** read status of the specified Backend */
  readGatewayEnvoyproxyIoV1alpha1NamespacedBackendStatus?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_Backend>;
  /** read the specified BackendTrafficPolicy */
  readGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicy?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicy>;
  /** read status of the specified BackendTrafficPolicy */
  readGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicyStatus?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicy>;
  /** read the specified HTTPRouteFilter */
  readGatewayEnvoyproxyIoV1alpha1NamespacedHTTPRouteFilter?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_HttpRouteFilter>;
  /** read the specified SecurityPolicy */
  readGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicy>;
  /** read status of the specified SecurityPolicy */
  readGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicyStatus?: Maybe<Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicy>;
  /** read the specified GatewayClass */
  readGatewayNetworkingV1GatewayClass?: Maybe<Io_K8s_Networking_Gateway_V1_GatewayClass>;
  /** read status of the specified GatewayClass */
  readGatewayNetworkingV1GatewayClassStatus?: Maybe<Io_K8s_Networking_Gateway_V1_GatewayClass>;
  /** read the specified BackendTLSPolicy */
  readGatewayNetworkingV1NamespacedBackendTLSPolicy?: Maybe<Io_K8s_Networking_Gateway_V1_BackendTlsPolicy>;
  /** read status of the specified BackendTLSPolicy */
  readGatewayNetworkingV1NamespacedBackendTLSPolicyStatus?: Maybe<Io_K8s_Networking_Gateway_V1_BackendTlsPolicy>;
  /** read the specified Gateway */
  readGatewayNetworkingV1NamespacedGateway?: Maybe<Io_K8s_Networking_Gateway_V1_Gateway>;
  /** read status of the specified Gateway */
  readGatewayNetworkingV1NamespacedGatewayStatus?: Maybe<Io_K8s_Networking_Gateway_V1_Gateway>;
  /** read the specified HTTPRoute */
  readGatewayNetworkingV1NamespacedHTTPRoute?: Maybe<Io_K8s_Networking_Gateway_V1_HttpRoute>;
  /** read status of the specified HTTPRoute */
  readGatewayNetworkingV1NamespacedHTTPRouteStatus?: Maybe<Io_K8s_Networking_Gateway_V1_HttpRoute>;
  /** read the specified BackendTLSPolicy */
  readGatewayNetworkingV1alpha3NamespacedBackendTLSPolicy?: Maybe<Io_K8s_Networking_Gateway_V1alpha3_BackendTlsPolicy>;
  /** read the specified GatewayClass */
  readGatewayNetworkingV1beta1GatewayClass?: Maybe<Io_K8s_Networking_Gateway_V1beta1_GatewayClass>;
  /** read status of the specified GatewayClass */
  readGatewayNetworkingV1beta1GatewayClassStatus?: Maybe<Io_K8s_Networking_Gateway_V1beta1_GatewayClass>;
  /** read the specified Gateway */
  readGatewayNetworkingV1beta1NamespacedGateway?: Maybe<Io_K8s_Networking_Gateway_V1beta1_Gateway>;
  /** read status of the specified Gateway */
  readGatewayNetworkingV1beta1NamespacedGatewayStatus?: Maybe<Io_K8s_Networking_Gateway_V1beta1_Gateway>;
  /** read the specified HTTPRoute */
  readGatewayNetworkingV1beta1NamespacedHTTPRoute?: Maybe<Io_K8s_Networking_Gateway_V1beta1_HttpRoute>;
  /** read status of the specified HTTPRoute */
  readGatewayNetworkingV1beta1NamespacedHTTPRouteStatus?: Maybe<Io_K8s_Networking_Gateway_V1beta1_HttpRoute>;
  /** read the specified Group */
  readIamMiloapisComV1alpha1NamespacedGroup?: Maybe<Com_Miloapis_Iam_V1alpha1_Group>;
  /** read the specified GroupMembership */
  readIamMiloapisComV1alpha1NamespacedGroupMembership?: Maybe<Com_Miloapis_Iam_V1alpha1_GroupMembership>;
  /** read status of the specified GroupMembership */
  readIamMiloapisComV1alpha1NamespacedGroupMembershipStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_GroupMembership>;
  /** read status of the specified Group */
  readIamMiloapisComV1alpha1NamespacedGroupStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_Group>;
  /** read the specified MachineAccount */
  readIamMiloapisComV1alpha1NamespacedMachineAccount?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccount>;
  /** read the specified MachineAccountKey */
  readIamMiloapisComV1alpha1NamespacedMachineAccountKey?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccountKey>;
  /** read status of the specified MachineAccountKey */
  readIamMiloapisComV1alpha1NamespacedMachineAccountKeyStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccountKey>;
  /** read status of the specified MachineAccount */
  readIamMiloapisComV1alpha1NamespacedMachineAccountStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccount>;
  /** read the specified PolicyBinding */
  readIamMiloapisComV1alpha1NamespacedPolicyBinding?: Maybe<Com_Miloapis_Iam_V1alpha1_PolicyBinding>;
  /** read status of the specified PolicyBinding */
  readIamMiloapisComV1alpha1NamespacedPolicyBindingStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PolicyBinding>;
  /** read the specified Role */
  readIamMiloapisComV1alpha1NamespacedRole?: Maybe<Com_Miloapis_Iam_V1alpha1_Role>;
  /** read status of the specified Role */
  readIamMiloapisComV1alpha1NamespacedRoleStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_Role>;
  /** read the specified UserInvitation */
  readIamMiloapisComV1alpha1NamespacedUserInvitation?: Maybe<Com_Miloapis_Iam_V1alpha1_UserInvitation>;
  /** read status of the specified UserInvitation */
  readIamMiloapisComV1alpha1NamespacedUserInvitationStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_UserInvitation>;
  /** read the specified PlatformAccessApproval */
  readIamMiloapisComV1alpha1PlatformAccessApproval?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessApproval>;
  /** read status of the specified PlatformAccessApproval */
  readIamMiloapisComV1alpha1PlatformAccessApprovalStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessApproval>;
  /** read the specified PlatformAccessDenial */
  readIamMiloapisComV1alpha1PlatformAccessDenial?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessDenial>;
  /** read status of the specified PlatformAccessDenial */
  readIamMiloapisComV1alpha1PlatformAccessDenialStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessDenial>;
  /** read the specified PlatformAccessRejection */
  readIamMiloapisComV1alpha1PlatformAccessRejection?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessRejection>;
  /** read status of the specified PlatformAccessRejection */
  readIamMiloapisComV1alpha1PlatformAccessRejectionStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessRejection>;
  /** read the specified PlatformInvitation */
  readIamMiloapisComV1alpha1PlatformInvitation?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformInvitation>;
  /** read status of the specified PlatformInvitation */
  readIamMiloapisComV1alpha1PlatformInvitationStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_PlatformInvitation>;
  /** read the specified ProtectedResource */
  readIamMiloapisComV1alpha1ProtectedResource?: Maybe<Com_Miloapis_Iam_V1alpha1_ProtectedResource>;
  /** read status of the specified ProtectedResource */
  readIamMiloapisComV1alpha1ProtectedResourceStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_ProtectedResource>;
  /** read the specified User */
  readIamMiloapisComV1alpha1User?: Maybe<Com_Miloapis_Iam_V1alpha1_User>;
  /** read the specified UserDeactivation */
  readIamMiloapisComV1alpha1UserDeactivation?: Maybe<Com_Miloapis_Iam_V1alpha1_UserDeactivation>;
  /** read status of the specified UserDeactivation */
  readIamMiloapisComV1alpha1UserDeactivationStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_UserDeactivation>;
  /** read the specified UserPreference */
  readIamMiloapisComV1alpha1UserPreference?: Maybe<Com_Miloapis_Iam_V1alpha1_UserPreference>;
  /** read status of the specified UserPreference */
  readIamMiloapisComV1alpha1UserPreferenceStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_UserPreference>;
  /** read status of the specified User */
  readIamMiloapisComV1alpha1UserStatus?: Maybe<Com_Miloapis_Iam_V1alpha1_User>;
  /** read the specified Session */
  readIdentityMiloapisComV1alpha1Session?: Maybe<Com_Miloapis_Go_Milo_Pkg_Apis_Identity_V1alpha1_Session>;
  /** read the specified UserIdentity */
  readIdentityMiloapisComV1alpha1UserIdentity?: Maybe<Com_Miloapis_Go_Milo_Pkg_Apis_Identity_V1alpha1_UserIdentity>;
  /** read the specified Connector */
  readNetworkingDatumapisComV1alpha1NamespacedConnector?: Maybe<Com_Datumapis_Networking_V1alpha1_Connector>;
  /** read the specified ConnectorAdvertisement */
  readNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisement?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisement>;
  /** read status of the specified ConnectorAdvertisement */
  readNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisementStatus?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisement>;
  /** read the specified ConnectorClass */
  readNetworkingDatumapisComV1alpha1NamespacedConnectorClass?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorClass>;
  /** read status of the specified ConnectorClass */
  readNetworkingDatumapisComV1alpha1NamespacedConnectorClassStatus?: Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorClass>;
  /** read status of the specified Connector */
  readNetworkingDatumapisComV1alpha1NamespacedConnectorStatus?: Maybe<Com_Datumapis_Networking_V1alpha1_Connector>;
  /** read the specified Domain */
  readNetworkingDatumapisComV1alphaNamespacedDomain?: Maybe<Com_Datumapis_Networking_V1alpha_Domain>;
  /** read status of the specified Domain */
  readNetworkingDatumapisComV1alphaNamespacedDomainStatus?: Maybe<Com_Datumapis_Networking_V1alpha_Domain>;
  /** read the specified HTTPProxy */
  readNetworkingDatumapisComV1alphaNamespacedHTTPProxy?: Maybe<Com_Datumapis_Networking_V1alpha_HttpProxy>;
  /** read status of the specified HTTPProxy */
  readNetworkingDatumapisComV1alphaNamespacedHTTPProxyStatus?: Maybe<Com_Datumapis_Networking_V1alpha_HttpProxy>;
  /** read the specified Location */
  readNetworkingDatumapisComV1alphaNamespacedLocation?: Maybe<Com_Datumapis_Networking_V1alpha_Location>;
  /** read status of the specified Location */
  readNetworkingDatumapisComV1alphaNamespacedLocationStatus?: Maybe<Com_Datumapis_Networking_V1alpha_Location>;
  /** read the specified Network */
  readNetworkingDatumapisComV1alphaNamespacedNetwork?: Maybe<Com_Datumapis_Networking_V1alpha_Network>;
  /** read the specified NetworkBinding */
  readNetworkingDatumapisComV1alphaNamespacedNetworkBinding?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkBinding>;
  /** read status of the specified NetworkBinding */
  readNetworkingDatumapisComV1alphaNamespacedNetworkBindingStatus?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkBinding>;
  /** read the specified NetworkContext */
  readNetworkingDatumapisComV1alphaNamespacedNetworkContext?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkContext>;
  /** read status of the specified NetworkContext */
  readNetworkingDatumapisComV1alphaNamespacedNetworkContextStatus?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkContext>;
  /** read the specified NetworkPolicy */
  readNetworkingDatumapisComV1alphaNamespacedNetworkPolicy?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkPolicy>;
  /** read status of the specified NetworkPolicy */
  readNetworkingDatumapisComV1alphaNamespacedNetworkPolicyStatus?: Maybe<Com_Datumapis_Networking_V1alpha_NetworkPolicy>;
  /** read status of the specified Network */
  readNetworkingDatumapisComV1alphaNamespacedNetworkStatus?: Maybe<Com_Datumapis_Networking_V1alpha_Network>;
  /** read the specified Subnet */
  readNetworkingDatumapisComV1alphaNamespacedSubnet?: Maybe<Com_Datumapis_Networking_V1alpha_Subnet>;
  /** read the specified SubnetClaim */
  readNetworkingDatumapisComV1alphaNamespacedSubnetClaim?: Maybe<Com_Datumapis_Networking_V1alpha_SubnetClaim>;
  /** read status of the specified SubnetClaim */
  readNetworkingDatumapisComV1alphaNamespacedSubnetClaimStatus?: Maybe<Com_Datumapis_Networking_V1alpha_SubnetClaim>;
  /** read status of the specified Subnet */
  readNetworkingDatumapisComV1alphaNamespacedSubnetStatus?: Maybe<Com_Datumapis_Networking_V1alpha_Subnet>;
  /** read the specified TrafficProtectionPolicy */
  readNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy?: Maybe<Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicy>;
  /** read status of the specified TrafficProtectionPolicy */
  readNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicyStatus?: Maybe<Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicy>;
  /** read the specified EmailTemplate */
  readNotificationMiloapisComV1alpha1EmailTemplate?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailTemplate>;
  /** read status of the specified EmailTemplate */
  readNotificationMiloapisComV1alpha1EmailTemplateStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailTemplate>;
  /** read the specified Contact */
  readNotificationMiloapisComV1alpha1NamespacedContact?: Maybe<Com_Miloapis_Notification_V1alpha1_Contact>;
  /** read the specified ContactGroup */
  readNotificationMiloapisComV1alpha1NamespacedContactGroup?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroup>;
  /** read the specified ContactGroupMembership */
  readNotificationMiloapisComV1alpha1NamespacedContactGroupMembership?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembership>;
  /** read the specified ContactGroupMembershipRemoval */
  readNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemoval?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemoval>;
  /** read status of the specified ContactGroupMembershipRemoval */
  readNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemovalStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemoval>;
  /** read status of the specified ContactGroupMembership */
  readNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembership>;
  /** read status of the specified ContactGroup */
  readNotificationMiloapisComV1alpha1NamespacedContactGroupStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroup>;
  /** read status of the specified Contact */
  readNotificationMiloapisComV1alpha1NamespacedContactStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_Contact>;
  /** read the specified Email */
  readNotificationMiloapisComV1alpha1NamespacedEmail?: Maybe<Com_Miloapis_Notification_V1alpha1_Email>;
  /** read the specified EmailBroadcast */
  readNotificationMiloapisComV1alpha1NamespacedEmailBroadcast?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailBroadcast>;
  /** read status of the specified EmailBroadcast */
  readNotificationMiloapisComV1alpha1NamespacedEmailBroadcastStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_EmailBroadcast>;
  /** read status of the specified Email */
  readNotificationMiloapisComV1alpha1NamespacedEmailStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_Email>;
  /** read the specified Note */
  readNotificationMiloapisComV1alpha1NamespacedNote?: Maybe<Com_Miloapis_Notification_V1alpha1_Note>;
  /** read status of the specified Note */
  readNotificationMiloapisComV1alpha1NamespacedNoteStatus?: Maybe<Com_Miloapis_Notification_V1alpha1_Note>;
  /** read the specified ClaimCreationPolicy */
  readQuotaMiloapisComV1alpha1ClaimCreationPolicy?: Maybe<Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicy>;
  /** read status of the specified ClaimCreationPolicy */
  readQuotaMiloapisComV1alpha1ClaimCreationPolicyStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicy>;
  /** read the specified GrantCreationPolicy */
  readQuotaMiloapisComV1alpha1GrantCreationPolicy?: Maybe<Com_Miloapis_Quota_V1alpha1_GrantCreationPolicy>;
  /** read status of the specified GrantCreationPolicy */
  readQuotaMiloapisComV1alpha1GrantCreationPolicyStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_GrantCreationPolicy>;
  /** read the specified AllowanceBucket */
  readQuotaMiloapisComV1alpha1NamespacedAllowanceBucket?: Maybe<Com_Miloapis_Quota_V1alpha1_AllowanceBucket>;
  /** read status of the specified AllowanceBucket */
  readQuotaMiloapisComV1alpha1NamespacedAllowanceBucketStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_AllowanceBucket>;
  /** read the specified ResourceClaim */
  readQuotaMiloapisComV1alpha1NamespacedResourceClaim?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceClaim>;
  /** read status of the specified ResourceClaim */
  readQuotaMiloapisComV1alpha1NamespacedResourceClaimStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceClaim>;
  /** read the specified ResourceGrant */
  readQuotaMiloapisComV1alpha1NamespacedResourceGrant?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceGrant>;
  /** read status of the specified ResourceGrant */
  readQuotaMiloapisComV1alpha1NamespacedResourceGrantStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceGrant>;
  /** read the specified ResourceRegistration */
  readQuotaMiloapisComV1alpha1ResourceRegistration?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceRegistration>;
  /** read status of the specified ResourceRegistration */
  readQuotaMiloapisComV1alpha1ResourceRegistrationStatus?: Maybe<Com_Miloapis_Quota_V1alpha1_ResourceRegistration>;
  /** read the specified ClusterRole */
  readRbacAuthorizationV1ClusterRole?: Maybe<Io_K8s_Api_Rbac_V1_ClusterRole>;
  /** read the specified ClusterRoleBinding */
  readRbacAuthorizationV1ClusterRoleBinding?: Maybe<Io_K8s_Api_Rbac_V1_ClusterRoleBinding>;
  /** read the specified Role */
  readRbacAuthorizationV1NamespacedRole?: Maybe<Io_K8s_Api_Rbac_V1_Role>;
  /** read the specified RoleBinding */
  readRbacAuthorizationV1NamespacedRoleBinding?: Maybe<Io_K8s_Api_Rbac_V1_RoleBinding>;
  /** read the specified OrganizationMembership */
  readResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembership>;
  /** read status of the specified OrganizationMembership */
  readResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembershipStatus?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembership>;
  /** read the specified Organization */
  readResourcemanagerMiloapisComV1alpha1Organization?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Organization>;
  /** read status of the specified Organization */
  readResourcemanagerMiloapisComV1alpha1OrganizationStatus?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Organization>;
  /** read the specified Project */
  readResourcemanagerMiloapisComV1alpha1Project?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Project>;
  /** read status of the specified Project */
  readResourcemanagerMiloapisComV1alpha1ProjectStatus?: Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Project>;
  /** read the specified ExportPolicy */
  readTelemetryMiloapisComV1alpha1NamespacedExportPolicy?: Maybe<Com_Miloapis_Telemetry_V1alpha1_ExportPolicy>;
  /** read status of the specified ExportPolicy */
  readTelemetryMiloapisComV1alpha1NamespacedExportPolicyStatus?: Maybe<Com_Miloapis_Telemetry_V1alpha1_ExportPolicy>;
  /** watch changes to an object of kind MutatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchAdmissionregistrationV1MutatingWebhookConfiguration?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of MutatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead. */
  watchAdmissionregistrationV1MutatingWebhookConfigurationList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind ValidatingAdmissionPolicy. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchAdmissionregistrationV1ValidatingAdmissionPolicy?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind ValidatingAdmissionPolicyBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchAdmissionregistrationV1ValidatingAdmissionPolicyBinding?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of ValidatingAdmissionPolicyBinding. deprecated: use the 'watch' parameter with a list operation instead. */
  watchAdmissionregistrationV1ValidatingAdmissionPolicyBindingList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of ValidatingAdmissionPolicy. deprecated: use the 'watch' parameter with a list operation instead. */
  watchAdmissionregistrationV1ValidatingAdmissionPolicyList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind ValidatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchAdmissionregistrationV1ValidatingWebhookConfiguration?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of ValidatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead. */
  watchAdmissionregistrationV1ValidatingWebhookConfigurationList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind CustomResourceDefinition. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchApiextensionsV1CustomResourceDefinition?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of CustomResourceDefinition. deprecated: use the 'watch' parameter with a list operation instead. */
  watchApiextensionsV1CustomResourceDefinitionList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind APIService. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchApiregistrationV1APIService?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of APIService. deprecated: use the 'watch' parameter with a list operation instead. */
  watchApiregistrationV1APIServiceList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of Lease. deprecated: use the 'watch' parameter with a list operation instead. */
  watchCoordinationV1LeaseListForAllNamespaces?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind Lease. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchCoordinationV1NamespacedLease?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of Lease. deprecated: use the 'watch' parameter with a list operation instead. */
  watchCoordinationV1NamespacedLeaseList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of ConfigMap. deprecated: use the 'watch' parameter with a list operation instead. */
  watchCoreV1ConfigMapListForAllNamespaces?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead. */
  watchCoreV1EventListForAllNamespaces?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind Namespace. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchCoreV1Namespace?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of Namespace. deprecated: use the 'watch' parameter with a list operation instead. */
  watchCoreV1NamespaceList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind ConfigMap. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchCoreV1NamespacedConfigMap?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of ConfigMap. deprecated: use the 'watch' parameter with a list operation instead. */
  watchCoreV1NamespacedConfigMapList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind Event. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchCoreV1NamespacedEvent?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead. */
  watchCoreV1NamespacedEventList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind Secret. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchCoreV1NamespacedSecret?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of Secret. deprecated: use the 'watch' parameter with a list operation instead. */
  watchCoreV1NamespacedSecretList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of Secret. deprecated: use the 'watch' parameter with a list operation instead. */
  watchCoreV1SecretListForAllNamespaces?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of EndpointSlice. deprecated: use the 'watch' parameter with a list operation instead. */
  watchDiscoveryV1EndpointSliceListForAllNamespaces?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind EndpointSlice. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchDiscoveryV1NamespacedEndpointSlice?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of EndpointSlice. deprecated: use the 'watch' parameter with a list operation instead. */
  watchDiscoveryV1NamespacedEndpointSliceList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead. */
  watchEventsV1EventListForAllNamespaces?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind Event. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchEventsV1NamespacedEvent?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead. */
  watchEventsV1NamespacedEventList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind FlowSchema. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchFlowcontrolApiserverV1FlowSchema?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of FlowSchema. deprecated: use the 'watch' parameter with a list operation instead. */
  watchFlowcontrolApiserverV1FlowSchemaList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind PriorityLevelConfiguration. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchFlowcontrolApiserverV1PriorityLevelConfiguration?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of PriorityLevelConfiguration. deprecated: use the 'watch' parameter with a list operation instead. */
  watchFlowcontrolApiserverV1PriorityLevelConfigurationList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind ClusterRole. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchRbacAuthorizationV1ClusterRole?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind ClusterRoleBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchRbacAuthorizationV1ClusterRoleBinding?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of ClusterRoleBinding. deprecated: use the 'watch' parameter with a list operation instead. */
  watchRbacAuthorizationV1ClusterRoleBindingList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of ClusterRole. deprecated: use the 'watch' parameter with a list operation instead. */
  watchRbacAuthorizationV1ClusterRoleList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind Role. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchRbacAuthorizationV1NamespacedRole?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch changes to an object of kind RoleBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter. */
  watchRbacAuthorizationV1NamespacedRoleBinding?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a list operation instead. */
  watchRbacAuthorizationV1NamespacedRoleBindingList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list operation instead. */
  watchRbacAuthorizationV1NamespacedRoleList?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a list operation instead. */
  watchRbacAuthorizationV1RoleBindingListForAllNamespaces?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
  /** watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list operation instead. */
  watchRbacAuthorizationV1RoleListForAllNamespaces?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent>;
};

export type QueryListAdmissionregistrationV1MutatingWebhookConfigurationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListAdmissionregistrationV1ValidatingAdmissionPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListAdmissionregistrationV1ValidatingAdmissionPolicyBindingArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListAdmissionregistrationV1ValidatingWebhookConfigurationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListAgreementMiloapisComV1alpha1NamespacedDocumentAcceptanceArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListApiextensionsV1CustomResourceDefinitionArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListApiregistrationV1ApiServiceArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListComputeDatumapisComV1alphaInstanceForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListComputeDatumapisComV1alphaNamespacedInstanceArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListComputeDatumapisComV1alphaNamespacedWorkloadArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListComputeDatumapisComV1alphaNamespacedWorkloadDeploymentArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListComputeDatumapisComV1alphaWorkloadDeploymentForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListComputeDatumapisComV1alphaWorkloadForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListCoordinationV1LeaseForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListCoordinationV1NamespacedLeaseArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListCoreV1ConfigMapForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListCoreV1EventForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListCoreV1NamespaceArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListCoreV1NamespacedConfigMapArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListCoreV1NamespacedEventArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListCoreV1NamespacedSecretArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListCoreV1SecretForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListCrmMiloapisComV1alpha1NoteArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListDiscoveryV1EndpointSliceForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListDiscoveryV1NamespacedEndpointSliceArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListDnsNetworkingMiloapisComV1alpha1DnsZoneClassArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListDnsNetworkingMiloapisComV1alpha1NamespacedDnsRecordSetArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneDiscoveryArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListDocumentationMiloapisComV1alpha1DocumentForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListDocumentationMiloapisComV1alpha1NamespacedDocumentArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListDocumentationMiloapisComV1alpha1NamespacedDocumentRevisionArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListEventsV1EventForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListEventsV1NamespacedEventArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListFlowcontrolApiserverV1FlowSchemaArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListFlowcontrolApiserverV1PriorityLevelConfigurationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayEnvoyproxyIoV1alpha1NamespacedBackendArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayEnvoyproxyIoV1alpha1NamespacedHttpRouteFilterArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayEnvoyproxyIoV1alpha1SecurityPolicyForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayNetworkingV1BackendTlsPolicyForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayNetworkingV1GatewayClassArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayNetworkingV1GatewayForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayNetworkingV1HttpRouteForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayNetworkingV1NamespacedBackendTlsPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayNetworkingV1NamespacedGatewayArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayNetworkingV1NamespacedHttpRouteArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayNetworkingV1alpha3NamespacedBackendTlsPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayNetworkingV1beta1GatewayClassArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayNetworkingV1beta1GatewayForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayNetworkingV1beta1HttpRouteForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayNetworkingV1beta1NamespacedGatewayArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListGatewayNetworkingV1beta1NamespacedHttpRouteArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1GroupForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1GroupMembershipForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1MachineAccountForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1NamespacedGroupArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1NamespacedGroupMembershipArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1NamespacedMachineAccountArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1NamespacedMachineAccountKeyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1NamespacedPolicyBindingArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1NamespacedRoleArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1NamespacedUserInvitationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1PlatformAccessApprovalArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1PlatformAccessDenialArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1PlatformAccessRejectionArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1PlatformInvitationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1PolicyBindingForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1ProtectedResourceArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1RoleForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1UserArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1UserDeactivationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1UserInvitationForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIamMiloapisComV1alpha1UserPreferenceArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIdentityMiloapisComV1alpha1SessionArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListIdentityMiloapisComV1alpha1UserIdentityArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alpha1ConnectorClassForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alpha1ConnectorForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alpha1NamespacedConnectorArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisementArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alpha1NamespacedConnectorClassArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaDomainForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaHttpProxyForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaLocationForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaNamespacedDomainArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaNamespacedHttpProxyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaNamespacedLocationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaNamespacedNetworkArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaNamespacedNetworkBindingArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaNamespacedNetworkContextArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaNamespacedNetworkPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaNamespacedSubnetArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaNamespacedSubnetClaimArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaNetworkBindingForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaNetworkContextForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaNetworkForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaNetworkPolicyForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaSubnetClaimForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaSubnetForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNetworkingDatumapisComV1alphaTrafficProtectionPolicyForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNotificationMiloapisComV1alpha1ContactForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNotificationMiloapisComV1alpha1ContactGroupForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespacesArgs =
  {
    allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
    continue?: InputMaybe<Scalars['String']['input']>;
    fieldSelector?: InputMaybe<Scalars['String']['input']>;
    labelSelector?: InputMaybe<Scalars['String']['input']>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    pretty?: InputMaybe<Scalars['String']['input']>;
    resourceVersion?: InputMaybe<Scalars['String']['input']>;
    resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
    sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
    timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
    watch?: InputMaybe<Scalars['Boolean']['input']>;
  };

export type QueryListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNotificationMiloapisComV1alpha1EmailForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNotificationMiloapisComV1alpha1EmailTemplateArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNotificationMiloapisComV1alpha1NamespacedContactArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNotificationMiloapisComV1alpha1NamespacedContactGroupArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemovalArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNotificationMiloapisComV1alpha1NamespacedEmailArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNotificationMiloapisComV1alpha1NamespacedEmailBroadcastArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNotificationMiloapisComV1alpha1NamespacedNoteArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListNotificationMiloapisComV1alpha1NoteForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListQuotaMiloapisComV1alpha1ClaimCreationPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListQuotaMiloapisComV1alpha1GrantCreationPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListQuotaMiloapisComV1alpha1NamespacedAllowanceBucketArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListQuotaMiloapisComV1alpha1NamespacedResourceClaimArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListQuotaMiloapisComV1alpha1NamespacedResourceGrantArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListQuotaMiloapisComV1alpha1ResourceClaimForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListQuotaMiloapisComV1alpha1ResourceGrantForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListQuotaMiloapisComV1alpha1ResourceRegistrationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListRbacAuthorizationV1ClusterRoleArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListRbacAuthorizationV1ClusterRoleBindingArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListRbacAuthorizationV1NamespacedRoleArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListRbacAuthorizationV1NamespacedRoleBindingArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListRbacAuthorizationV1RoleBindingForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListRbacAuthorizationV1RoleForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembershipArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListResourcemanagerMiloapisComV1alpha1OrganizationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListResourcemanagerMiloapisComV1alpha1OrganizationMembershipForAllNamespacesArgs =
  {
    allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
    continue?: InputMaybe<Scalars['String']['input']>;
    fieldSelector?: InputMaybe<Scalars['String']['input']>;
    labelSelector?: InputMaybe<Scalars['String']['input']>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    pretty?: InputMaybe<Scalars['String']['input']>;
    resourceVersion?: InputMaybe<Scalars['String']['input']>;
    resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
    sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
    timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
    watch?: InputMaybe<Scalars['Boolean']['input']>;
  };

export type QueryListResourcemanagerMiloapisComV1alpha1ProjectArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryListTelemetryMiloapisComV1alpha1NamespacedExportPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryReadAdmissionregistrationV1MutatingWebhookConfigurationArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadAdmissionregistrationV1ValidatingAdmissionPolicyArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadAdmissionregistrationV1ValidatingAdmissionPolicyBindingArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadAdmissionregistrationV1ValidatingAdmissionPolicyStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadAdmissionregistrationV1ValidatingWebhookConfigurationArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadAgreementMiloapisComV1alpha1NamespacedDocumentAcceptanceArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadAgreementMiloapisComV1alpha1NamespacedDocumentAcceptanceStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadApiextensionsV1CustomResourceDefinitionArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadApiextensionsV1CustomResourceDefinitionStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadApiregistrationV1ApiServiceArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadApiregistrationV1ApiServiceStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadComputeDatumapisComV1alphaNamespacedInstanceArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadComputeDatumapisComV1alphaNamespacedInstanceStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadComputeDatumapisComV1alphaNamespacedWorkloadArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadComputeDatumapisComV1alphaNamespacedWorkloadDeploymentArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadComputeDatumapisComV1alphaNamespacedWorkloadDeploymentStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadComputeDatumapisComV1alphaNamespacedWorkloadStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadCoordinationV1NamespacedLeaseArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadCoreV1NamespaceArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadCoreV1NamespaceStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadCoreV1NamespacedConfigMapArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadCoreV1NamespacedEventArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadCoreV1NamespacedSecretArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadCrmMiloapisComV1alpha1NoteArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadCrmMiloapisComV1alpha1NoteStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadDiscoveryV1NamespacedEndpointSliceArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadDnsNetworkingMiloapisComV1alpha1DnsZoneClassArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadDnsNetworkingMiloapisComV1alpha1DnsZoneClassStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadDnsNetworkingMiloapisComV1alpha1NamespacedDnsRecordSetArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadDnsNetworkingMiloapisComV1alpha1NamespacedDnsRecordSetStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneDiscoveryArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneDiscoveryStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadDnsNetworkingMiloapisComV1alpha1NamespacedDnsZoneStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadDocumentationMiloapisComV1alpha1NamespacedDocumentArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadDocumentationMiloapisComV1alpha1NamespacedDocumentRevisionArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadDocumentationMiloapisComV1alpha1NamespacedDocumentRevisionStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadDocumentationMiloapisComV1alpha1NamespacedDocumentStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadEventsV1NamespacedEventArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadFlowcontrolApiserverV1FlowSchemaArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadFlowcontrolApiserverV1FlowSchemaStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadFlowcontrolApiserverV1PriorityLevelConfigurationArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadFlowcontrolApiserverV1PriorityLevelConfigurationStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayEnvoyproxyIoV1alpha1NamespacedBackendArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayEnvoyproxyIoV1alpha1NamespacedBackendStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicyArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayEnvoyproxyIoV1alpha1NamespacedBackendTrafficPolicyStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayEnvoyproxyIoV1alpha1NamespacedHttpRouteFilterArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicyArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicyStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1GatewayClassArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1GatewayClassStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1NamespacedBackendTlsPolicyArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1NamespacedBackendTlsPolicyStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1NamespacedGatewayArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1NamespacedGatewayStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1NamespacedHttpRouteArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1NamespacedHttpRouteStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1alpha3NamespacedBackendTlsPolicyArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1beta1GatewayClassArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1beta1GatewayClassStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1beta1NamespacedGatewayArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1beta1NamespacedGatewayStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1beta1NamespacedHttpRouteArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadGatewayNetworkingV1beta1NamespacedHttpRouteStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1NamespacedGroupArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1NamespacedGroupMembershipArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1NamespacedGroupMembershipStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1NamespacedGroupStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1NamespacedMachineAccountArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1NamespacedMachineAccountKeyArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1NamespacedMachineAccountKeyStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1NamespacedMachineAccountStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1NamespacedPolicyBindingArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1NamespacedPolicyBindingStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1NamespacedRoleArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1NamespacedRoleStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1NamespacedUserInvitationArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1NamespacedUserInvitationStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1PlatformAccessApprovalArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1PlatformAccessApprovalStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1PlatformAccessDenialArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1PlatformAccessDenialStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1PlatformAccessRejectionArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1PlatformAccessRejectionStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1PlatformInvitationArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1PlatformInvitationStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1ProtectedResourceArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1ProtectedResourceStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1UserArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1UserDeactivationArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1UserDeactivationStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1UserPreferenceArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1UserPreferenceStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIamMiloapisComV1alpha1UserStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIdentityMiloapisComV1alpha1SessionArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadIdentityMiloapisComV1alpha1UserIdentityArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alpha1NamespacedConnectorArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisementArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alpha1NamespacedConnectorAdvertisementStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alpha1NamespacedConnectorClassArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alpha1NamespacedConnectorClassStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alpha1NamespacedConnectorStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedDomainArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedDomainStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedHttpProxyArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedHttpProxyStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedLocationArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedLocationStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedNetworkArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedNetworkBindingArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedNetworkBindingStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedNetworkContextArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedNetworkContextStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedNetworkPolicyArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedNetworkPolicyStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedNetworkStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedSubnetArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedSubnetClaimArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedSubnetClaimStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedSubnetStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicyArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicyStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1EmailTemplateArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1EmailTemplateStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1NamespacedContactArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1NamespacedContactGroupArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemovalArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipRemovalStatusArgs =
  {
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
    resourceVersion?: InputMaybe<Scalars['String']['input']>;
  };

export type QueryReadNotificationMiloapisComV1alpha1NamespacedContactGroupMembershipStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1NamespacedContactGroupStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1NamespacedContactStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1NamespacedEmailArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1NamespacedEmailBroadcastArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1NamespacedEmailBroadcastStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1NamespacedEmailStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1NamespacedNoteArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadNotificationMiloapisComV1alpha1NamespacedNoteStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadQuotaMiloapisComV1alpha1ClaimCreationPolicyArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadQuotaMiloapisComV1alpha1ClaimCreationPolicyStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadQuotaMiloapisComV1alpha1GrantCreationPolicyArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadQuotaMiloapisComV1alpha1GrantCreationPolicyStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadQuotaMiloapisComV1alpha1NamespacedAllowanceBucketArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadQuotaMiloapisComV1alpha1NamespacedAllowanceBucketStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadQuotaMiloapisComV1alpha1NamespacedResourceClaimArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadQuotaMiloapisComV1alpha1NamespacedResourceClaimStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadQuotaMiloapisComV1alpha1NamespacedResourceGrantArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadQuotaMiloapisComV1alpha1NamespacedResourceGrantStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadQuotaMiloapisComV1alpha1ResourceRegistrationArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadQuotaMiloapisComV1alpha1ResourceRegistrationStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadRbacAuthorizationV1ClusterRoleArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadRbacAuthorizationV1ClusterRoleBindingArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadRbacAuthorizationV1NamespacedRoleArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadRbacAuthorizationV1NamespacedRoleBindingArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembershipArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembershipStatusArgs =
  {
    name: Scalars['String']['input'];
    namespace: Scalars['String']['input'];
    pretty?: InputMaybe<Scalars['String']['input']>;
    resourceVersion?: InputMaybe<Scalars['String']['input']>;
  };

export type QueryReadResourcemanagerMiloapisComV1alpha1OrganizationArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadResourcemanagerMiloapisComV1alpha1OrganizationStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadResourcemanagerMiloapisComV1alpha1ProjectArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadResourcemanagerMiloapisComV1alpha1ProjectStatusArgs = {
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadTelemetryMiloapisComV1alpha1NamespacedExportPolicyArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryReadTelemetryMiloapisComV1alpha1NamespacedExportPolicyStatusArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
};

export type QueryWatchAdmissionregistrationV1MutatingWebhookConfigurationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchAdmissionregistrationV1MutatingWebhookConfigurationListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchAdmissionregistrationV1ValidatingAdmissionPolicyArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchAdmissionregistrationV1ValidatingAdmissionPolicyListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchAdmissionregistrationV1ValidatingWebhookConfigurationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchAdmissionregistrationV1ValidatingWebhookConfigurationListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchApiextensionsV1CustomResourceDefinitionArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchApiextensionsV1CustomResourceDefinitionListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchApiregistrationV1ApiServiceArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchApiregistrationV1ApiServiceListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchCoordinationV1LeaseListForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchCoordinationV1NamespacedLeaseArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchCoordinationV1NamespacedLeaseListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchCoreV1ConfigMapListForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchCoreV1EventListForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchCoreV1NamespaceArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchCoreV1NamespaceListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchCoreV1NamespacedConfigMapArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchCoreV1NamespacedConfigMapListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchCoreV1NamespacedEventArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchCoreV1NamespacedEventListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchCoreV1NamespacedSecretArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchCoreV1NamespacedSecretListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchCoreV1SecretListForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchDiscoveryV1EndpointSliceListForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchDiscoveryV1NamespacedEndpointSliceArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchDiscoveryV1NamespacedEndpointSliceListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchEventsV1EventListForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchEventsV1NamespacedEventArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchEventsV1NamespacedEventListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchFlowcontrolApiserverV1FlowSchemaArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchFlowcontrolApiserverV1FlowSchemaListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchFlowcontrolApiserverV1PriorityLevelConfigurationArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchFlowcontrolApiserverV1PriorityLevelConfigurationListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchRbacAuthorizationV1ClusterRoleArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchRbacAuthorizationV1ClusterRoleBindingArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchRbacAuthorizationV1ClusterRoleBindingListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchRbacAuthorizationV1ClusterRoleListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchRbacAuthorizationV1NamespacedRoleArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchRbacAuthorizationV1NamespacedRoleBindingArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchRbacAuthorizationV1NamespacedRoleBindingListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchRbacAuthorizationV1NamespacedRoleListArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  namespace: Scalars['String']['input'];
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchRbacAuthorizationV1RoleBindingListForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QueryWatchRbacAuthorizationV1RoleListForAllNamespacesArgs = {
  allowWatchBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  continue?: InputMaybe<Scalars['String']['input']>;
  fieldSelector?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  pretty?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  resourceVersionMatch?: InputMaybe<Scalars['String']['input']>;
  sendInitialEvents?: InputMaybe<Scalars['Boolean']['input']>;
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
  watch?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ReplaceRegexMatch_Const = 'ReplaceRegexMatch';

/** ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match. */
export type ServerAddressByClientCidr_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io = {
  /** The CIDR with which clients can match their IP to figure out the server address that they should use. */
  clientCIDR: Scalars['String']['output'];
  /** Address of this server, suitable for a client that matches the above CIDR. This can be a hostname, hostname:port, IP or IP:port. */
  serverAddress: Scalars['String']['output'];
};

export type Static_Const = 'Static';

/** StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered. */
export type StatusCause_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io = {
  /**
   * The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.
   *
   * Examples:
   *   "name" - the field "name" on the current resource
   *   "items[0].name" - the field "name" on the first array entry in "items"
   */
  field?: Maybe<Scalars['String']['output']>;
  /** A human-readable description of the cause of the error.  This field may be presented as-is to a reader. */
  message?: Maybe<Scalars['String']['output']>;
  /** A machine-readable description of the cause of the error. If this value is empty there is no information available. */
  reason?: Maybe<Scalars['String']['output']>;
};

/** StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered. */
export type StatusCause_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io_Input = {
  /**
   * The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.
   *
   * Examples:
   *   "name" - the field "name" on the current resource
   *   "items[0].name" - the field "name" on the first array entry in "items"
   */
  field?: InputMaybe<Scalars['String']['input']>;
  /** A human-readable description of the cause of the error.  This field may be presented as-is to a reader. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** A machine-readable description of the cause of the error. If this value is empty there is no information available. */
  reason?: InputMaybe<Scalars['String']['input']>;
};

/** StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined. */
export type StatusDetails_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io = {
  /** The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes. */
  causes?: Maybe<Array<Maybe<StatusCause_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>>>;
  /** The group attribute of the resource associated with the status StatusReason. */
  group?: Maybe<Scalars['String']['output']>;
  /** The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  /** The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described). */
  name?: Maybe<Scalars['String']['output']>;
  /** If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action. */
  retryAfterSeconds?: Maybe<Scalars['Int']['output']>;
  /** UID of the resource. (when there is a single resource which can be described). More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
  uid?: Maybe<Scalars['String']['output']>;
};

/** StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined. */
export type StatusDetails_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io_Input = {
  /** The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes. */
  causes?: InputMaybe<Array<InputMaybe<StatusCause_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io_Input>>>;
  /** The group attribute of the resource associated with the status StatusReason. */
  group?: InputMaybe<Scalars['String']['input']>;
  /** The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  /** The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described). */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action. */
  retryAfterSeconds?: InputMaybe<Scalars['Int']['input']>;
  /** UID of the resource. (when there is a single resource which can be described). More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
  uid?: InputMaybe<Scalars['String']['input']>;
};

/** Status is a return value for calls that don't return other objects. */
export type Status_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Suggested HTTP return code for this status, 0 if not set. */
  code?: Maybe<Scalars['Int']['output']>;
  details?: Maybe<StatusDetails_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  /** A human-readable description of the status of this operation. */
  message?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<ListMeta_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>;
  /** A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it. */
  reason?: Maybe<Scalars['String']['output']>;
  /** Status of the operation. One of: "Success" or "Failure". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status */
  status?: Maybe<Scalars['String']['output']>;
};

/** Status is a return value for calls that don't return other objects. */
export type Status_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Suggested HTTP return code for this status, 0 if not set. */
  code?: InputMaybe<Scalars['Int']['input']>;
  details?: InputMaybe<StatusDetails_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io_Input>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  /** A human-readable description of the status of this operation. */
  message?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<ListMeta_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io_Input>;
  /** A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it. */
  reason?: InputMaybe<Scalars['String']['input']>;
  /** Status of the operation. One of: "Success" or "Failure". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status */
  status?: InputMaybe<Scalars['String']['input']>;
};

export type System_Const = 'System';

/** Unknown allows api objects with unknown types to be passed-through. This can be used to deal with the API objects from a plug-in. Unknown objects still have functioning TypeMeta features-- kind, version, etc. metadata and field mutatation. */
export type Unknown_Runtime_Pkg_Apimachinery_K8s_Io = {
  /** ContentEncoding is encoding used to encode 'Raw' data. Unspecified means no encoding. */
  ContentEncoding: Scalars['String']['output'];
  /** ContentType  is serialization method used to serialize 'Raw'. Unspecified means ContentTypeJSON. */
  ContentType: Scalars['String']['output'];
  apiVersion?: Maybe<Scalars['String']['output']>;
  kind?: Maybe<Scalars['String']['output']>;
};

/** Unknown allows api objects with unknown types to be passed-through. This can be used to deal with the API objects from a plug-in. Unknown objects still have functioning TypeMeta features-- kind, version, etc. metadata and field mutatation. */
export type Unknown_Runtime_Pkg_Apimachinery_K8s_Io_Input = {
  /** ContentEncoding is encoding used to encode 'Raw' data. Unspecified means no encoding. */
  ContentEncoding: Scalars['String']['input'];
  /** ContentType  is serialization method used to serialize 'Raw'. Unspecified means ContentTypeJSON. */
  ContentType: Scalars['String']['input'];
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  kind?: InputMaybe<Scalars['String']['input']>;
};

export type User_Const = 'User';

export type AdditionalProperties_Not_OneOf_Items_PatternProperties = {
  additionalProperties?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps3_Entry>>
  >;
};

export type AdditionalProperties_Not_OneOf_Items_PatternProperties_AdditionalProperties = {
  additionalProperties?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps4_Entry>>
  >;
};

/**
 * reason provides a machine-readable validation failure reason that is returned to the caller when a request fails this validation rule. The HTTP status code returned to the caller will match the reason of the reason of the first failed validation rule. The currently supported reasons are: "FieldValueInvalid", "FieldValueForbidden", "FieldValueRequired", "FieldValueDuplicate". If not set, default to use "FieldValueInvalid". All future added reasons must be accepted by clients when reading this value and unknown reasons should be treated as FieldValueInvalid.
 *
 * Possible enum values:
 *  - `"FieldValueDuplicate"` is used to report collisions of values that must be unique (e.g. unique IDs).
 *  - `"FieldValueForbidden"` is used to report valid (as per formatting rules) values which would be accepted under some conditions, but which are not permitted by the current conditions (such as security policy).
 *  - `"FieldValueInvalid"` is used to report malformed values (e.g. failed regex match, too long, out of bounds).
 *  - `"FieldValueRequired"` is used to report required values that are not provided (e.g. empty strings, null values, or empty arrays).
 */
export type AdditionalProperties_Not_OneOf_Items_PatternProperties_AdditionalProperties_AdditionalProperties_X_Kubernetes_Validations_Items_Reason =
  'FieldValueDuplicate' | 'FieldValueForbidden' | 'FieldValueInvalid' | 'FieldValueRequired';

export type Checkbox_Const = 'checkbox';

/** Instance is the Schema for the instances API */
export type Com_Datumapis_Compute_V1alpha_Instance = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec>;
  status?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status>;
};

/** InstanceList is a list of Instance */
export type Com_Datumapis_Compute_V1alpha_InstanceList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of instances. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Compute_V1alpha_Instance>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** Instance is the Schema for the instances API */
export type Com_Datumapis_Compute_V1alpha_Instance_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_Input>;
};

/** Workload is the Schema for the workloads API */
export type Com_Datumapis_Compute_V1alpha_Workload = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec;
  status?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status>;
};

/** WorkloadDeployment is the Schema for the workloaddeployments API */
export type Com_Datumapis_Compute_V1alpha_WorkloadDeployment = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec>;
  status?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status>;
};

/** WorkloadDeploymentList is a list of WorkloadDeployment */
export type Com_Datumapis_Compute_V1alpha_WorkloadDeploymentList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of workloaddeployments. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Compute_V1alpha_WorkloadDeployment>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** WorkloadDeployment is the Schema for the workloaddeployments API */
export type Com_Datumapis_Compute_V1alpha_WorkloadDeployment_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status_Input>;
};

/** WorkloadList is a list of Workload */
export type Com_Datumapis_Compute_V1alpha_WorkloadList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of workloads. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Compute_V1alpha_Workload>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** Workload is the Schema for the workloads API */
export type Com_Datumapis_Compute_V1alpha_Workload_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Input>;
};

/** Connector is the Schema for the connectors API. */
export type Com_Datumapis_Networking_V1alpha1_Connector = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status>;
};

/** ConnectorAdvertisement is the Schema for the connectoradvertisements API. */
export type Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisement = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Status>;
};

/** ConnectorAdvertisementList is a list of ConnectorAdvertisement */
export type Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisementList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of connectoradvertisements. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisement>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** ConnectorAdvertisement is the Schema for the connectoradvertisements API. */
export type Com_Datumapis_Networking_V1alpha1_ConnectorAdvertisement_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Status_Input>;
};

/** ConnectorClass is the Schema for the connectorclasses API. */
export type Com_Datumapis_Networking_V1alpha1_ConnectorClass = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListNetworkingDatumapisComV1alpha1ConnectorClassForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Scalars['JSON']['output']>;
};

/** ConnectorClassList is a list of ConnectorClass */
export type Com_Datumapis_Networking_V1alpha1_ConnectorClassList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of connectorclasses. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Networking_V1alpha1_ConnectorClass>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** ConnectorClass is the Schema for the connectorclasses API. */
export type Com_Datumapis_Networking_V1alpha1_ConnectorClass_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListNetworkingDatumapisComV1alpha1ConnectorClassForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Scalars['JSON']['input']>;
};

/** ConnectorList is a list of Connector */
export type Com_Datumapis_Networking_V1alpha1_ConnectorList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of connectors. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Networking_V1alpha1_Connector>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** Connector is the Schema for the connectors API. */
export type Com_Datumapis_Networking_V1alpha1_Connector_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Input>;
};

/** Domain represents a domain name in the Datum system */
export type Com_Datumapis_Networking_V1alpha_Domain = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status>;
};

/** DomainList is a list of Domain */
export type Com_Datumapis_Networking_V1alpha_DomainList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of domains. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Networking_V1alpha_Domain>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** Domain represents a domain name in the Datum system */
export type Com_Datumapis_Networking_V1alpha_Domain_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * An HTTPProxy builds on top of Gateway API resources to provide a more convenient
 * method to manage simple reverse proxy use cases.
 */
export type Com_Datumapis_Networking_V1alpha_HttpProxy = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status>;
};

/** HTTPProxyList is a list of HTTPProxy */
export type Com_Datumapis_Networking_V1alpha_HttpProxyList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of httpproxies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Networking_V1alpha_HttpProxy>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * An HTTPProxy builds on top of Gateway API resources to provide a more convenient
 * method to manage simple reverse proxy use cases.
 */
export type Com_Datumapis_Networking_V1alpha_HttpProxy_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status_Input>;
};

/** Location is the Schema for the locations API. */
export type Com_Datumapis_Networking_V1alpha_Location = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Spec>;
  status?: Maybe<Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Status>;
};

/** LocationList is a list of Location */
export type Com_Datumapis_Networking_V1alpha_LocationList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of locations. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Networking_V1alpha_Location>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** Location is the Schema for the locations API. */
export type Com_Datumapis_Networking_V1alpha_Location_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Status_Input>;
};

/** Network is the Schema for the networks API */
export type Com_Datumapis_Networking_V1alpha_Network = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Spec;
  status?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Status>;
};

/** NetworkBinding is the Schema for the networkbindings API */
export type Com_Datumapis_Networking_V1alpha_NetworkBinding = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Spec;
  status?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status>;
};

/** NetworkBindingList is a list of NetworkBinding */
export type Com_Datumapis_Networking_V1alpha_NetworkBindingList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of networkbindings. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Networking_V1alpha_NetworkBinding>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** NetworkBinding is the Schema for the networkbindings API */
export type Com_Datumapis_Networking_V1alpha_NetworkBinding_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status_Input>;
};

/** NetworkContext is the Schema for the networkcontexts API */
export type Com_Datumapis_Networking_V1alpha_NetworkContext = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Spec>;
  status?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Status>;
};

/** NetworkContextList is a list of NetworkContext */
export type Com_Datumapis_Networking_V1alpha_NetworkContextList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of networkcontexts. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Networking_V1alpha_NetworkContext>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** NetworkContext is the Schema for the networkcontexts API */
export type Com_Datumapis_Networking_V1alpha_NetworkContext_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Status_Input>;
};

/** NetworkList is a list of Network */
export type Com_Datumapis_Networking_V1alpha_NetworkList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of networks. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Networking_V1alpha_Network>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** NetworkPolicy is the Schema for the networkpolicies API */
export type Com_Datumapis_Networking_V1alpha_NetworkPolicy = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Scalars['JSON']['output']>;
  status?: Maybe<Scalars['JSON']['output']>;
};

/** NetworkPolicyList is a list of NetworkPolicy */
export type Com_Datumapis_Networking_V1alpha_NetworkPolicyList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of networkpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Networking_V1alpha_NetworkPolicy>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** NetworkPolicy is the Schema for the networkpolicies API */
export type Com_Datumapis_Networking_V1alpha_NetworkPolicy_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<Scalars['JSON']['input']>;
};

/** Network is the Schema for the networks API */
export type Com_Datumapis_Networking_V1alpha_Network_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Status_Input>;
};

/** Subnet is the Schema for the subnets API */
export type Com_Datumapis_Networking_V1alpha_Subnet = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec>;
  status?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Status>;
};

/** SubnetClaim is the Schema for the subnetclaims API */
export type Com_Datumapis_Networking_V1alpha_SubnetClaim = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec>;
  status?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status>;
};

/** SubnetClaimList is a list of SubnetClaim */
export type Com_Datumapis_Networking_V1alpha_SubnetClaimList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of subnetclaims. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Networking_V1alpha_SubnetClaim>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** SubnetClaim is the Schema for the subnetclaims API */
export type Com_Datumapis_Networking_V1alpha_SubnetClaim_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status_Input>;
};

/** SubnetList is a list of Subnet */
export type Com_Datumapis_Networking_V1alpha_SubnetList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of subnets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Networking_V1alpha_Subnet>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** Subnet is the Schema for the subnets API */
export type Com_Datumapis_Networking_V1alpha_Subnet_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Status_Input>;
};

/** TrafficProtectionPolicy is the Schema for the trafficprotectionpolicies API. */
export type Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicy = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec;
  status?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status>;
};

/** TrafficProtectionPolicyList is a list of TrafficProtectionPolicy */
export type Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicyList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of trafficprotectionpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicy>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** TrafficProtectionPolicy is the Schema for the trafficprotectionpolicies API. */
export type Com_Datumapis_Networking_V1alpha_TrafficProtectionPolicy_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Input>;
};

/**
 * DocumentAcceptance is the Schema for the documentacceptances API.
 * It represents a document acceptance.
 */
export type Com_Miloapis_Agreement_V1alpha1_DocumentAcceptance = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec>;
  status?: Maybe<Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Status>;
};

/** DocumentAcceptanceList is a list of DocumentAcceptance */
export type Com_Miloapis_Agreement_V1alpha1_DocumentAcceptanceList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of documentacceptances. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Agreement_V1alpha1_DocumentAcceptance>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * DocumentAcceptance is the Schema for the documentacceptances API.
 * It represents a document acceptance.
 */
export type Com_Miloapis_Agreement_V1alpha1_DocumentAcceptance_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * Note is the Schema for the notes API.
 * It represents a note attached to a subject (e.g. Contact or User).
 */
export type Com_Miloapis_Crm_V1alpha1_Note = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec>;
  status?: Maybe<Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Status>;
};

/** NoteList is a list of Note */
export type Com_Miloapis_Crm_V1alpha1_NoteList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of notes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Crm_V1alpha1_Note>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * Note is the Schema for the notes API.
 * It represents a note attached to a subject (e.g. Contact or User).
 */
export type Com_Miloapis_Crm_V1alpha1_Note_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Status_Input>;
};

/**
 * Document is the Schema for the documents API.
 * It represents a document that can be used to create a document revision.
 */
export type Com_Miloapis_Documentation_V1alpha1_Document = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  documentMetadata?: Maybe<Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_DocumentMetadata>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Spec>;
  status?: Maybe<Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status>;
};

/** DocumentList is a list of Document */
export type Com_Miloapis_Documentation_V1alpha1_DocumentList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of documents. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Documentation_V1alpha1_Document>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * DocumentRevision is the Schema for the documentrevisions API.
 * It represents a revision of a document.
 */
export type Com_Miloapis_Documentation_V1alpha1_DocumentRevision = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec>;
  status?: Maybe<Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Status>;
};

/** DocumentRevisionList is a list of DocumentRevision */
export type Com_Miloapis_Documentation_V1alpha1_DocumentRevisionList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of documentrevisions. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Documentation_V1alpha1_DocumentRevision>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * DocumentRevision is the Schema for the documentrevisions API.
 * It represents a revision of a document.
 */
export type Com_Miloapis_Documentation_V1alpha1_DocumentRevision_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * Document is the Schema for the documents API.
 * It represents a document that can be used to create a document revision.
 */
export type Com_Miloapis_Documentation_V1alpha1_Document_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  documentMetadata?: InputMaybe<Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_DocumentMetadata_Input>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * AuditLogQuery searches your control plane's audit logs.
 *
 * Use this to investigate incidents, track resource changes, generate compliance reports, or analyze user activity. Results are returned in the Status field, ordered newest-first.
 *
 * Quick Start:
 *
 * 	apiVersion: activity.miloapis.com/v1alpha1
 * 	kind: AuditLogQuery
 * 	metadata:
 * 	  name: recent-deletions
 * 	spec:
 * 	  startTime: "now-30d"       # last 30 days
 * 	  endTime: "now"
 * 	  filter: "verb == 'delete'" # optional: narrow your search
 * 	  limit: 100
 *
 * Time Formats: - Relative: "now-30d" (great for dashboards and recurring queries) - Absolute: "2024-01-01T00:00:00Z" (great for historical analysis)
 */
export type Com_Miloapis_Go_Activity_Pkg_Apis_Activity_V1alpha1_AuditLogQuery = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<ObjectMeta_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>;
  spec: Com_Miloapis_Go_Activity_Pkg_Apis_Activity_V1alpha1_AuditLogQuerySpec;
  status?: Maybe<Com_Miloapis_Go_Activity_Pkg_Apis_Activity_V1alpha1_AuditLogQueryStatus>;
};

/**
 * AuditLogQuerySpec defines the search parameters.
 *
 * Required: startTime and endTime define your search window. Optional: filter (narrow results), limit (page size, default 100), continue (pagination).
 *
 * Performance: Smaller time ranges and specific filters perform better. The maximum time window is typically 30 days. If your range is too large, you'll get an error with guidance on splitting your query into smaller chunks.
 */
export type Com_Miloapis_Go_Activity_Pkg_Apis_Activity_V1alpha1_AuditLogQuerySpec = {
  /**
   * Continue is the pagination cursor for fetching additional pages.
   *
   * Leave empty for the first page. If status.continue is non-empty after a query, copy that value here in a new query with identical parameters to get the next page. Repeat until status.continue is empty.
   *
   * Important: Keep all other parameters (startTime, endTime, filter, limit) identical across paginated requests. The cursor is opaque - copy it exactly without modification.
   */
  continue?: Maybe<Scalars['String']['output']>;
  /**
   * EndTime is the end of your search window (exclusive).
   *
   * Uses the same formats as StartTime. Commonly "now" for current moment. Must be greater than StartTime.
   *
   * Examples:
   *   "now"                   current time
   *   "2024-01-02T00:00:00Z"  specific end point
   */
  endTime: Scalars['String']['output'];
  /**
   * Filter narrows results using CEL (Common Expression Language). Leave empty to get all events.
   *
   * Available Fields:
   *   verb               - API action: get, list, create, update, patch, delete, watch
   *   auditID            - unique event identifier
   *   requestReceivedTimestamp - when the API server received the request (RFC3339 timestamp)
   *   user.username      - who made the request (user or service account)
   *   user.uid           - unique user identifier (stable across username changes)
   *   responseStatus.code - HTTP response code (200, 201, 404, 500, etc.)
   *   objectRef.namespace - target resource namespace
   *   objectRef.resource  - resource type (pods, deployments, secrets, configmaps, etc.)
   *   objectRef.name     - specific resource name
   *
   * Operators: ==, !=, <, >, <=, >=, &&, ||, in String Functions: startsWith(), endsWith(), contains()
   *
   * Common Patterns:
   *   "verb == 'delete'"                                    - All deletions
   *   "objectRef.namespace == 'production'"                 - Activity in production namespace
   *   "verb in ['create', 'update', 'delete', 'patch']"     - All write operations
   *   "responseStatus.code >= 400"                          - Failed requests
   *   "user.username.startsWith('system:serviceaccount:')"  - Service account activity
   *   "user.uid == '550e8400-e29b-41d4-a716-446655440000'"  - Specific user by UID
   *   "objectRef.resource == 'secrets'"                     - Secret access
   *   "verb == 'delete' && objectRef.namespace == 'production'" - Production deletions
   *
   * Note: Use single quotes for strings. Field names are case-sensitive. CEL reference: https://cel.dev
   */
  filter?: Maybe<Scalars['String']['output']>;
  /**
   * Limit sets the maximum number of results per page. Default: 100, Maximum: 1000.
   *
   * Use smaller values (10-50) for exploration, larger (500-1000) for data collection. Use continue to fetch additional pages.
   */
  limit?: Maybe<Scalars['Int']['output']>;
  /**
   * StartTime is the beginning of your search window (inclusive).
   *
   * Format Options: - Relative: "now-30d", "now-2h", "now-30m" (units: s, m, h, d, w)
   *   Use for dashboards and recurring queries - they adjust automatically.
   * - Absolute: "2024-01-01T00:00:00Z" (RFC3339 with timezone)
   *   Use for historical analysis of specific time periods.
   *
   * Examples:
   *   "now-30d"                      30 days ago
   *   "2024-06-15T14:30:00-05:00"    specific time with timezone offset
   */
  startTime: Scalars['String']['output'];
};

/**
 * AuditLogQuerySpec defines the search parameters.
 *
 * Required: startTime and endTime define your search window. Optional: filter (narrow results), limit (page size, default 100), continue (pagination).
 *
 * Performance: Smaller time ranges and specific filters perform better. The maximum time window is typically 30 days. If your range is too large, you'll get an error with guidance on splitting your query into smaller chunks.
 */
export type Com_Miloapis_Go_Activity_Pkg_Apis_Activity_V1alpha1_AuditLogQuerySpec_Input = {
  /**
   * Continue is the pagination cursor for fetching additional pages.
   *
   * Leave empty for the first page. If status.continue is non-empty after a query, copy that value here in a new query with identical parameters to get the next page. Repeat until status.continue is empty.
   *
   * Important: Keep all other parameters (startTime, endTime, filter, limit) identical across paginated requests. The cursor is opaque - copy it exactly without modification.
   */
  continue?: InputMaybe<Scalars['String']['input']>;
  /**
   * EndTime is the end of your search window (exclusive).
   *
   * Uses the same formats as StartTime. Commonly "now" for current moment. Must be greater than StartTime.
   *
   * Examples:
   *   "now"                   current time
   *   "2024-01-02T00:00:00Z"  specific end point
   */
  endTime: Scalars['String']['input'];
  /**
   * Filter narrows results using CEL (Common Expression Language). Leave empty to get all events.
   *
   * Available Fields:
   *   verb               - API action: get, list, create, update, patch, delete, watch
   *   auditID            - unique event identifier
   *   requestReceivedTimestamp - when the API server received the request (RFC3339 timestamp)
   *   user.username      - who made the request (user or service account)
   *   user.uid           - unique user identifier (stable across username changes)
   *   responseStatus.code - HTTP response code (200, 201, 404, 500, etc.)
   *   objectRef.namespace - target resource namespace
   *   objectRef.resource  - resource type (pods, deployments, secrets, configmaps, etc.)
   *   objectRef.name     - specific resource name
   *
   * Operators: ==, !=, <, >, <=, >=, &&, ||, in String Functions: startsWith(), endsWith(), contains()
   *
   * Common Patterns:
   *   "verb == 'delete'"                                    - All deletions
   *   "objectRef.namespace == 'production'"                 - Activity in production namespace
   *   "verb in ['create', 'update', 'delete', 'patch']"     - All write operations
   *   "responseStatus.code >= 400"                          - Failed requests
   *   "user.username.startsWith('system:serviceaccount:')"  - Service account activity
   *   "user.uid == '550e8400-e29b-41d4-a716-446655440000'"  - Specific user by UID
   *   "objectRef.resource == 'secrets'"                     - Secret access
   *   "verb == 'delete' && objectRef.namespace == 'production'" - Production deletions
   *
   * Note: Use single quotes for strings. Field names are case-sensitive. CEL reference: https://cel.dev
   */
  filter?: InputMaybe<Scalars['String']['input']>;
  /**
   * Limit sets the maximum number of results per page. Default: 100, Maximum: 1000.
   *
   * Use smaller values (10-50) for exploration, larger (500-1000) for data collection. Use continue to fetch additional pages.
   */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /**
   * StartTime is the beginning of your search window (inclusive).
   *
   * Format Options: - Relative: "now-30d", "now-2h", "now-30m" (units: s, m, h, d, w)
   *   Use for dashboards and recurring queries - they adjust automatically.
   * - Absolute: "2024-01-01T00:00:00Z" (RFC3339 with timezone)
   *   Use for historical analysis of specific time periods.
   *
   * Examples:
   *   "now-30d"                      30 days ago
   *   "2024-06-15T14:30:00-05:00"    specific time with timezone offset
   */
  startTime: Scalars['String']['input'];
};

/** AuditLogQueryStatus contains the query results and pagination state. */
export type Com_Miloapis_Go_Activity_Pkg_Apis_Activity_V1alpha1_AuditLogQueryStatus = {
  /** Continue is the pagination cursor. Non-empty means more results are available - copy this to spec.continue for the next page. Empty means you have all results. */
  continue?: Maybe<Scalars['String']['output']>;
  /**
   * EffectiveEndTime is the actual end time used for this query (RFC3339 format).
   *
   * When you use relative times like "now", this shows the exact timestamp that was calculated. Useful for understanding exactly what time range was queried.
   *
   * Example: If you query with endTime="now" at 2025-12-17T12:00:00Z, this will be "2025-12-17T12:00:00Z".
   */
  effectiveEndTime?: Maybe<Scalars['String']['output']>;
  /**
   * EffectiveStartTime is the actual start time used for this query (RFC3339 format).
   *
   * When you use relative times like "now-7d", this shows the exact timestamp that was calculated. Useful for understanding exactly what time range was queried, especially for auditing, debugging, or recreating queries with absolute timestamps.
   *
   * Example: If you query with startTime="now-7d" at 2025-12-17T12:00:00Z, this will be "2025-12-10T12:00:00Z".
   */
  effectiveStartTime?: Maybe<Scalars['String']['output']>;
  /**
   * Results contains matching audit events, sorted newest-first.
   *
   * Each event follows the Kubernetes audit.Event format with fields like:
   *   verb, user.username, objectRef.{namespace,resource,name}, requestReceivedTimestamp,
   *   stageTimestamp, responseStatus.code, requestObject, responseObject
   *
   * Empty results? Try broadening your filter or time range. Full documentation: https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/
   */
  results?: Maybe<Array<Maybe<Io_K8s_Apiserver_Pkg_Apis_Audit_V1_Event>>>;
};

/** AuditLogQueryStatus contains the query results and pagination state. */
export type Com_Miloapis_Go_Activity_Pkg_Apis_Activity_V1alpha1_AuditLogQueryStatus_Input = {
  /** Continue is the pagination cursor. Non-empty means more results are available - copy this to spec.continue for the next page. Empty means you have all results. */
  continue?: InputMaybe<Scalars['String']['input']>;
  /**
   * EffectiveEndTime is the actual end time used for this query (RFC3339 format).
   *
   * When you use relative times like "now", this shows the exact timestamp that was calculated. Useful for understanding exactly what time range was queried.
   *
   * Example: If you query with endTime="now" at 2025-12-17T12:00:00Z, this will be "2025-12-17T12:00:00Z".
   */
  effectiveEndTime?: InputMaybe<Scalars['String']['input']>;
  /**
   * EffectiveStartTime is the actual start time used for this query (RFC3339 format).
   *
   * When you use relative times like "now-7d", this shows the exact timestamp that was calculated. Useful for understanding exactly what time range was queried, especially for auditing, debugging, or recreating queries with absolute timestamps.
   *
   * Example: If you query with startTime="now-7d" at 2025-12-17T12:00:00Z, this will be "2025-12-10T12:00:00Z".
   */
  effectiveStartTime?: InputMaybe<Scalars['String']['input']>;
  /**
   * Results contains matching audit events, sorted newest-first.
   *
   * Each event follows the Kubernetes audit.Event format with fields like:
   *   verb, user.username, objectRef.{namespace,resource,name}, requestReceivedTimestamp,
   *   stageTimestamp, responseStatus.code, requestObject, responseObject
   *
   * Empty results? Try broadening your filter or time range. Full documentation: https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/
   */
  results?: InputMaybe<Array<InputMaybe<Io_K8s_Apiserver_Pkg_Apis_Audit_V1_Event_Input>>>;
};

/**
 * AuditLogQuery searches your control plane's audit logs.
 *
 * Use this to investigate incidents, track resource changes, generate compliance reports, or analyze user activity. Results are returned in the Status field, ordered newest-first.
 *
 * Quick Start:
 *
 * 	apiVersion: activity.miloapis.com/v1alpha1
 * 	kind: AuditLogQuery
 * 	metadata:
 * 	  name: recent-deletions
 * 	spec:
 * 	  startTime: "now-30d"       # last 30 days
 * 	  endTime: "now"
 * 	  filter: "verb == 'delete'" # optional: narrow your search
 * 	  limit: 100
 *
 * Time Formats: - Relative: "now-30d" (great for dashboards and recurring queries) - Absolute: "2024-01-01T00:00:00Z" (great for historical analysis)
 */
export type Com_Miloapis_Go_Activity_Pkg_Apis_Activity_V1alpha1_AuditLogQuery_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<ObjectMeta_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io_Input>;
  spec: Com_Miloapis_Go_Activity_Pkg_Apis_Activity_V1alpha1_AuditLogQuerySpec_Input;
  status?: InputMaybe<Com_Miloapis_Go_Activity_Pkg_Apis_Activity_V1alpha1_AuditLogQueryStatus_Input>;
};

export type Com_Miloapis_Go_Milo_Pkg_Apis_Identity_V1alpha1_Session = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  status?: Maybe<Com_Miloapis_Go_Milo_Pkg_Apis_Identity_V1alpha1_SessionStatus>;
};

export type Com_Miloapis_Go_Milo_Pkg_Apis_Identity_V1alpha1_SessionList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  items: Array<Maybe<Com_Miloapis_Go_Milo_Pkg_Apis_Identity_V1alpha1_Session>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

export type Com_Miloapis_Go_Milo_Pkg_Apis_Identity_V1alpha1_SessionStatus = {
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  createdAt: Scalars['DateTime']['output'];
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  expiresAt?: Maybe<Scalars['DateTime']['output']>;
  fingerprintID?: Maybe<Scalars['String']['output']>;
  ip?: Maybe<Scalars['String']['output']>;
  provider: Scalars['String']['output'];
  userUID: Scalars['String']['output'];
};

/**
 * UserIdentity represents a user's linked identity within an external identity provider.
 *
 * This resource describes the connection between a Milo user and their account in an external authentication provider (e.g., GitHub, Google, Microsoft). It is NOT the identity provider itself, but rather the user's specific identity within that provider.
 *
 * Use cases:
 *   - Display all authentication methods linked to a user account in the UI
 *   - Show which external accounts a user has connected
 *   - Provide visibility into federated identity mappings
 *
 * Important notes:
 *   - This is a read-only resource for display purposes only
 *   - Identity management (linking/unlinking providers) is handled by the external
 *     authentication provider (e.g., Zitadel), not through this API
 *   - No sensitive credentials or tokens are exposed through this resource
 */
export type Com_Miloapis_Go_Milo_Pkg_Apis_Identity_V1alpha1_UserIdentity = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  status?: Maybe<Com_Miloapis_Go_Milo_Pkg_Apis_Identity_V1alpha1_UserIdentityStatus>;
};

/** UserIdentityList is a list of UserIdentity resources. */
export type Com_Miloapis_Go_Milo_Pkg_Apis_Identity_V1alpha1_UserIdentityList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  items: Array<Maybe<Com_Miloapis_Go_Milo_Pkg_Apis_Identity_V1alpha1_UserIdentity>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** UserIdentityStatus contains the details of a user's identity within an external provider. All fields are read-only and populated by the authentication provider. */
export type Com_Miloapis_Go_Milo_Pkg_Apis_Identity_V1alpha1_UserIdentityStatus = {
  /** ProviderID is the unique identifier of the external identity provider instance. This is typically an internal ID from the authentication system. */
  providerID: Scalars['String']['output'];
  /** ProviderName is the human-readable name of the identity provider. Examples: "GitHub", "Google", "Microsoft", "GitLab" */
  providerName: Scalars['String']['output'];
  /** UserUID is the unique identifier of the Milo user who owns this identity. */
  userUID: Scalars['String']['output'];
  /** Username is the user's username or identifier within the external identity provider. This is the name the user is known by in the external system (e.g., GitHub username). */
  username: Scalars['String']['output'];
};

/** Group is the Schema for the groups API */
export type Com_Miloapis_Iam_V1alpha1_Group = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  status?: Maybe<Query_ListIamMiloapisComV1alpha1GroupForAllNamespaces_Items_Items_Status>;
};

/** GroupList is a list of Group */
export type Com_Miloapis_Iam_V1alpha1_GroupList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of groups. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_Group>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** GroupMembership is the Schema for the groupmemberships API */
export type Com_Miloapis_Iam_V1alpha1_GroupMembership = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Spec>;
  status?: Maybe<Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Status>;
};

/** GroupMembershipList is a list of GroupMembership */
export type Com_Miloapis_Iam_V1alpha1_GroupMembershipList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of groupmemberships. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_GroupMembership>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** GroupMembership is the Schema for the groupmemberships API */
export type Com_Miloapis_Iam_V1alpha1_GroupMembership_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Status_Input>;
};

/** Group is the Schema for the groups API */
export type Com_Miloapis_Iam_V1alpha1_Group_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  status?: InputMaybe<Query_ListIamMiloapisComV1alpha1GroupForAllNamespaces_Items_Items_Status_Input>;
};

/** MachineAccount is the Schema for the machine accounts API */
export type Com_Miloapis_Iam_V1alpha1_MachineAccount = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Spec>;
  status?: Maybe<Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Status>;
};

/** MachineAccountKey is the Schema for the machineaccountkeys API */
export type Com_Miloapis_Iam_V1alpha1_MachineAccountKey = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Spec>;
  status?: Maybe<Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Status>;
};

/** MachineAccountKeyList is a list of MachineAccountKey */
export type Com_Miloapis_Iam_V1alpha1_MachineAccountKeyList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of machineaccountkeys. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccountKey>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** MachineAccountKey is the Schema for the machineaccountkeys API */
export type Com_Miloapis_Iam_V1alpha1_MachineAccountKey_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Status_Input>;
};

/** MachineAccountList is a list of MachineAccount */
export type Com_Miloapis_Iam_V1alpha1_MachineAccountList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of machineaccounts. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_MachineAccount>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** MachineAccount is the Schema for the machine accounts API */
export type Com_Miloapis_Iam_V1alpha1_MachineAccount_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * PlatformAccessApproval is the Schema for the platformaccessapprovals API.
 * It represents a platform access approval for a user. Once the platform access approval is created, an email will be sent to the user.
 */
export type Com_Miloapis_Iam_V1alpha1_PlatformAccessApproval = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec>;
};

/** PlatformAccessApprovalList is a list of PlatformAccessApproval */
export type Com_Miloapis_Iam_V1alpha1_PlatformAccessApprovalList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of platformaccessapprovals. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessApproval>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * PlatformAccessApproval is the Schema for the platformaccessapprovals API.
 * It represents a platform access approval for a user. Once the platform access approval is created, an email will be sent to the user.
 */
export type Com_Miloapis_Iam_V1alpha1_PlatformAccessApproval_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec_Input>;
};

/**
 * PlatformAccessDenial is the Schema for the platformaccessapprovals API.
 * It represents a platform access approval for a user. Once the platform access approval is created, an email will be sent to the user.
 */
export type Com_Miloapis_Iam_V1alpha1_PlatformAccessDenial = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec>;
  status?: Maybe<Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Status>;
};

/** PlatformAccessDenialList is a list of PlatformAccessDenial */
export type Com_Miloapis_Iam_V1alpha1_PlatformAccessDenialList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of platformaccessdenials. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessDenial>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * PlatformAccessDenial is the Schema for the platformaccessapprovals API.
 * It represents a platform access approval for a user. Once the platform access approval is created, an email will be sent to the user.
 */
export type Com_Miloapis_Iam_V1alpha1_PlatformAccessDenial_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Status_Input>;
};

/**
 * PlatformAccessRejection is the Schema for the platformaccessrejections API.
 * It represents a formal denial of platform access for a user. Once the rejection is created, a notification can be sent to the user.
 */
export type Com_Miloapis_Iam_V1alpha1_PlatformAccessRejection = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListIamMiloapisComV1alpha1PlatformAccessRejection_Items_Items_Spec>;
};

/** PlatformAccessRejectionList is a list of PlatformAccessRejection */
export type Com_Miloapis_Iam_V1alpha1_PlatformAccessRejectionList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of platformaccessrejections. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_PlatformAccessRejection>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * PlatformAccessRejection is the Schema for the platformaccessrejections API.
 * It represents a formal denial of platform access for a user. Once the rejection is created, a notification can be sent to the user.
 */
export type Com_Miloapis_Iam_V1alpha1_PlatformAccessRejection_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformAccessRejection_Items_Items_Spec_Input>;
};

/**
 * PlatformInvitation is the Schema for the platforminvitations API
 * It represents a platform invitation for a user. Once the platform invitation is created, an email will be sent to the user to invite them to the platform.
 * The invited user will have access to the platform after they create an account using the asociated email.
 * It represents a platform invitation for a user.
 */
export type Com_Miloapis_Iam_V1alpha1_PlatformInvitation = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Spec>;
  status?: Maybe<Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status>;
};

/** PlatformInvitationList is a list of PlatformInvitation */
export type Com_Miloapis_Iam_V1alpha1_PlatformInvitationList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of platforminvitations. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_PlatformInvitation>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * PlatformInvitation is the Schema for the platforminvitations API
 * It represents a platform invitation for a user. Once the platform invitation is created, an email will be sent to the user to invite them to the platform.
 * The invited user will have access to the platform after they create an account using the asociated email.
 * It represents a platform invitation for a user.
 */
export type Com_Miloapis_Iam_V1alpha1_PlatformInvitation_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status_Input>;
};

/** PolicyBinding is the Schema for the policybindings API */
export type Com_Miloapis_Iam_V1alpha1_PolicyBinding = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec>;
  status?: Maybe<Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Status>;
};

/** PolicyBindingList is a list of PolicyBinding */
export type Com_Miloapis_Iam_V1alpha1_PolicyBindingList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of policybindings. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_PolicyBinding>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** PolicyBinding is the Schema for the policybindings API */
export type Com_Miloapis_Iam_V1alpha1_PolicyBinding_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Status_Input>;
};

/** ProtectedResource is the Schema for the protectedresources API */
export type Com_Miloapis_Iam_V1alpha1_ProtectedResource = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Spec>;
  status?: Maybe<Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Status>;
};

/** ProtectedResourceList is a list of ProtectedResource */
export type Com_Miloapis_Iam_V1alpha1_ProtectedResourceList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of protectedresources. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_ProtectedResource>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** ProtectedResource is the Schema for the protectedresources API */
export type Com_Miloapis_Iam_V1alpha1_ProtectedResource_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Status_Input>;
};

/** Role is the Schema for the roles API */
export type Com_Miloapis_Iam_V1alpha1_Role = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Spec>;
  status?: Maybe<Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Status>;
};

/** RoleList is a list of Role */
export type Com_Miloapis_Iam_V1alpha1_RoleList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of roles. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_Role>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** Role is the Schema for the roles API */
export type Com_Miloapis_Iam_V1alpha1_Role_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Status_Input>;
};

/** User is the Schema for the users API */
export type Com_Miloapis_Iam_V1alpha1_User = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListIamMiloapisComV1alpha1User_Items_Items_Spec>;
  status?: Maybe<Query_ListIamMiloapisComV1alpha1User_Items_Items_Status>;
};

/** UserDeactivation is the Schema for the userdeactivations API */
export type Com_Miloapis_Iam_V1alpha1_UserDeactivation = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Spec>;
  status?: Maybe<Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Status>;
};

/** UserDeactivationList is a list of UserDeactivation */
export type Com_Miloapis_Iam_V1alpha1_UserDeactivationList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of userdeactivations. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_UserDeactivation>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** UserDeactivation is the Schema for the userdeactivations API */
export type Com_Miloapis_Iam_V1alpha1_UserDeactivation_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Status_Input>;
};

/** UserInvitation is the Schema for the userinvitations API */
export type Com_Miloapis_Iam_V1alpha1_UserInvitation = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec>;
  status?: Maybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status>;
};

/** UserInvitationList is a list of UserInvitation */
export type Com_Miloapis_Iam_V1alpha1_UserInvitationList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of userinvitations. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_UserInvitation>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** UserInvitation is the Schema for the userinvitations API */
export type Com_Miloapis_Iam_V1alpha1_UserInvitation_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_Input>;
};

/** UserList is a list of User */
export type Com_Miloapis_Iam_V1alpha1_UserList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of users. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_User>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** UserPreference is the Schema for the userpreferences API */
export type Com_Miloapis_Iam_V1alpha1_UserPreference = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Spec>;
  status?: Maybe<Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Status>;
};

/** UserPreferenceList is a list of UserPreference */
export type Com_Miloapis_Iam_V1alpha1_UserPreferenceList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of userpreferences. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Iam_V1alpha1_UserPreference>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** UserPreference is the Schema for the userpreferences API */
export type Com_Miloapis_Iam_V1alpha1_UserPreference_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Status_Input>;
};

/** User is the Schema for the users API */
export type Com_Miloapis_Iam_V1alpha1_User_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListIamMiloapisComV1alpha1User_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_Input>;
};

/** DNSRecordSet is the Schema for the dnsrecordsets API */
export type Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSet = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status>;
};

/** DNSRecordSetList is a list of DNSRecordSet */
export type Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSetList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of dnsrecordsets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSet>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** DNSRecordSet is the Schema for the dnsrecordsets API */
export type Com_Miloapis_Networking_Dns_V1alpha1_DnsRecordSet_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_Input>;
};

/** DNSZone is the Schema for the dnszones API */
export type Com_Miloapis_Networking_Dns_V1alpha1_DnsZone = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status>;
};

/** DNSZoneClass is the Schema for the dnszoneclasses API */
export type Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClass = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec;
  status?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Status>;
};

/** DNSZoneClassList is a list of DNSZoneClass */
export type Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClassList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of dnszoneclasses. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClass>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** DNSZoneClass is the Schema for the dnszoneclasses API */
export type Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneClass_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Status_Input>;
};

/** DNSZoneDiscovery is the Schema for the DNSZone discovery API. */
export type Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscovery = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status>;
};

/** DNSZoneDiscoveryList is a list of DNSZoneDiscovery */
export type Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscoveryList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of dnszonediscoveries. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscovery>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** DNSZoneDiscovery is the Schema for the DNSZone discovery API. */
export type Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneDiscovery_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_Input>;
};

/** DNSZoneList is a list of DNSZone */
export type Com_Miloapis_Networking_Dns_V1alpha1_DnsZoneList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of dnszones. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Networking_Dns_V1alpha1_DnsZone>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** DNSZone is the Schema for the dnszones API */
export type Com_Miloapis_Networking_Dns_V1alpha1_DnsZone_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * Contact is the Schema for the contacts API.
 * It represents a contact for a user.
 */
export type Com_Miloapis_Notification_V1alpha1_Contact = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Spec>;
  status?: Maybe<Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status>;
};

/**
 * ContactGroup is the Schema for the contactgroups API.
 * It represents a logical grouping of Contacts.
 */
export type Com_Miloapis_Notification_V1alpha1_ContactGroup = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Spec>;
  status?: Maybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status>;
};

/** ContactGroupList is a list of ContactGroup */
export type Com_Miloapis_Notification_V1alpha1_ContactGroupList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of contactgroups. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroup>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * ContactGroupMembership is the Schema for the contactgroupmemberships API.
 * It represents a membership of a Contact in a ContactGroup.
 */
export type Com_Miloapis_Notification_V1alpha1_ContactGroupMembership = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Spec>;
  status?: Maybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status>;
};

/** ContactGroupMembershipList is a list of ContactGroupMembership */
export type Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of contactgroupmemberships. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembership>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * ContactGroupMembershipRemoval is the Schema for the contactgroupmembershipremovals API.
 * It represents a removal of a Contact from a ContactGroup, it also prevents the Contact from being added to the ContactGroup.
 */
export type Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemoval = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Spec>;
  status?: Maybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Status>;
};

/** ContactGroupMembershipRemovalList is a list of ContactGroupMembershipRemoval */
export type Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemovalList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of contactgroupmembershipremovals. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemoval>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * ContactGroupMembershipRemoval is the Schema for the contactgroupmembershipremovals API.
 * It represents a removal of a Contact from a ContactGroup, it also prevents the Contact from being added to the ContactGroup.
 */
export type Com_Miloapis_Notification_V1alpha1_ContactGroupMembershipRemoval_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * ContactGroupMembership is the Schema for the contactgroupmemberships API.
 * It represents a membership of a Contact in a ContactGroup.
 */
export type Com_Miloapis_Notification_V1alpha1_ContactGroupMembership_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * ContactGroup is the Schema for the contactgroups API.
 * It represents a logical grouping of Contacts.
 */
export type Com_Miloapis_Notification_V1alpha1_ContactGroup_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Input>;
};

/** ContactList is a list of Contact */
export type Com_Miloapis_Notification_V1alpha1_ContactList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of contacts. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Notification_V1alpha1_Contact>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * Contact is the Schema for the contacts API.
 * It represents a contact for a user.
 */
export type Com_Miloapis_Notification_V1alpha1_Contact_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * Email is the Schema for the emails API.
 * It represents a concrete e-mail that should be sent to the referenced users.
 * For idempotency purposes, controllers can use metadata.uid as a unique identifier
 * to prevent duplicate email delivery, since it's guaranteed to be unique per resource instance.
 */
export type Com_Miloapis_Notification_V1alpha1_Email = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec>;
  status?: Maybe<Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Status>;
};

/**
 * EmailBroadcast is the Schema for the emailbroadcasts API.
 * It represents a broadcast of an email to a set of contacts (ContactGroup).
 * If the broadcast needs to be updated, delete and recreate the resource.
 */
export type Com_Miloapis_Notification_V1alpha1_EmailBroadcast = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Spec>;
  status?: Maybe<Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Status>;
};

/** EmailBroadcastList is a list of EmailBroadcast */
export type Com_Miloapis_Notification_V1alpha1_EmailBroadcastList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of emailbroadcasts. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Notification_V1alpha1_EmailBroadcast>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * EmailBroadcast is the Schema for the emailbroadcasts API.
 * It represents a broadcast of an email to a set of contacts (ContactGroup).
 * If the broadcast needs to be updated, delete and recreate the resource.
 */
export type Com_Miloapis_Notification_V1alpha1_EmailBroadcast_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Status_Input>;
};

/** EmailList is a list of Email */
export type Com_Miloapis_Notification_V1alpha1_EmailList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of emails. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Notification_V1alpha1_Email>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * EmailTemplate is the Schema for the email templates API.
 * It represents a reusable e-mail template that can be rendered by substituting
 * the declared variables.
 */
export type Com_Miloapis_Notification_V1alpha1_EmailTemplate = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Spec>;
  status?: Maybe<Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Status>;
};

/** EmailTemplateList is a list of EmailTemplate */
export type Com_Miloapis_Notification_V1alpha1_EmailTemplateList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of emailtemplates. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Notification_V1alpha1_EmailTemplate>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * EmailTemplate is the Schema for the email templates API.
 * It represents a reusable e-mail template that can be rendered by substituting
 * the declared variables.
 */
export type Com_Miloapis_Notification_V1alpha1_EmailTemplate_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Status_Input>;
};

/**
 * Email is the Schema for the emails API.
 * It represents a concrete e-mail that should be sent to the referenced users.
 * For idempotency purposes, controllers can use metadata.uid as a unique identifier
 * to prevent duplicate email delivery, since it's guaranteed to be unique per resource instance.
 */
export type Com_Miloapis_Notification_V1alpha1_Email_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * Note is the Schema for the notes API.
 * It represents a note attached to a contact.
 */
export type Com_Miloapis_Notification_V1alpha1_Note = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Spec>;
  status?: Maybe<Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Status>;
};

/** NoteList is a list of Note */
export type Com_Miloapis_Notification_V1alpha1_NoteList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of notes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Notification_V1alpha1_Note>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * Note is the Schema for the notes API.
 * It represents a note attached to a contact.
 */
export type Com_Miloapis_Notification_V1alpha1_Note_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Status_Input>;
};

/**
 * **AllowanceBucket** aggregates quota limits and usage for a single (consumer, resourceType) combination.
 * The system automatically creates buckets to provide real-time quota availability information
 * for **ResourceClaim** evaluation during admission.
 *
 * ### How It Works
 * 1. **Auto-Creation**: Quota system creates buckets automatically for each unique (consumer, resourceType) pair found in active **ResourceGrants**
 * 2. **Aggregation**: Quota system continuously aggregates capacity from active **ResourceGrants** and consumption from granted **ResourceClaims**
 * 3. **Decision Support**: Quota system uses bucket `status.available` to determine if **ResourceClaims** can be granted
 * 4. **Updates**: Quota system updates bucket status whenever contributing grants or claims change
 *
 * ### Aggregation Logic
 * **AllowanceBuckets** serve as the central aggregation point where quota capacity meets quota consumption.
 * The quota system continuously scans for **ResourceGrants** that match both the bucket's consumer
 * and resource type, but only considers grants with an `Active` status condition. For each qualifying
 * grant, the quota system examines all allowances targeting the bucket's resource type and sums the
 * amounts from every bucket within those allowances. This sum becomes the bucket's limit - the total
 * quota capacity available to the consumer for that specific resource type.
 *
 * Simultaneously, the quota system tracks quota consumption by finding all **ResourceClaims** with matching
 * consumer and resource type specifications. However, only claims that have been successfully granted
 * contribute to the allocated total. The quota system sums the allocated amounts from all granted
 * requests, creating a running total of consumed quota capacity.
 *
 * The available quota emerges from this simple relationship: Available = Limit - Allocated. The
 * system ensures this value never goes negative, treating any calculated negative as zero. This
 * available amount represents the quota capacity remaining for new **ResourceClaims** and drives
 * real-time admission decisions throughout the cluster.
 *
 * ### Real-Time Admission Decisions
 * When a **ResourceClaim** is created:
 * 1. Quota system identifies the relevant bucket (matching consumer and resource type)
 * 2. Compares requested amount with bucket's `status.available`
 * 3. Grants claim if requested amount <= available capacity
 * 4. Denies claim if requested amount > available capacity
 * 5. Updates bucket status to reflect the new allocation (if granted)
 *
 * ### Bucket Lifecycle
 * 1. **Auto-Created**: When first ResourceGrant creates allowance for (consumer, resourceType)
 * 2. **Active**: Continuously aggregated while ResourceGrants or ResourceClaims exist
 * 3. **Updated**: Status refreshed whenever contributing resources change
 * 4. **Persistent**: Buckets remain even when limit drops to 0 (for monitoring)
 *
 * ### Consistency and Performance
 * **Eventual Consistency:**
 * - Status may lag briefly after ResourceGrant or ResourceClaim changes
 * - Controller processes updates asynchronously for performance
 * - LastReconciliation timestamp indicates data freshness
 *
 * **Scale Optimization:**
 * - Stores aggregates (limit, allocated, available) rather than individual entries
 * - ContributingGrantRefs tracks grants (few) but not claims (many)
 * - Single bucket per (consumer, resourceType) regardless of claim count
 *
 * ### Status Information
 * - **Limit**: Total quota capacity from all contributing ResourceGrants
 * - **Allocated**: Total quota consumed by all granted ResourceClaims
 * - **Available**: Remaining quota capacity (Limit - Allocated)
 * - **ClaimCount**: Number of granted claims consuming from this bucket
 * - **GrantCount**: Number of active grants contributing to this bucket
 * - **ContributingGrantRefs**: Detailed information about contributing grants
 *
 * ### Monitoring and Troubleshooting
 * **Quota Monitoring:**
 * - Monitor status.available to track quota usage trends
 * - Check status.allocated vs status.limit for utilization ratios
 * - Use status.claimCount to understand resource creation patterns
 *
 * **Troubleshooting Issues:**
 * When investigating quota problems, start with the bucket's limit value. A limit of zero typically
 * indicates that no ResourceGrants are contributing capacity for this consumer and resource type
 * combination. Verify that ResourceGrants exist with matching consumer and resource type specifications,
 * and confirm their status conditions show Active=True. Grants with validation failures or pending
 * states won't contribute to bucket limits.
 *
 * High allocation values relative to limits suggest quota consumption issues. Review the ResourceClaims
 * that match this bucket's consumer and resource type to identify which resources are consuming large
 * amounts of quota. Check the claim allocation details to understand consumption patterns and identify
 * potential quota leaks where claims aren't being cleaned up properly.
 *
 * Stale bucket data manifests as allocation or limit values that don't reflect recent changes to
 * grants or claims. Check the lastReconciliation timestamp to determine data freshness, then examine
 * quota system logs for aggregation errors or performance issues. The quota system should process
 * changes within seconds under normal conditions.
 *
 * ### System Architecture
 * - **Single Writer**: Only the quota system updates bucket status (prevents races)
 * - **Dedicated Processing**: Separate components focus solely on bucket aggregation
 * - **Event-Driven**: Responds to ResourceGrant and ResourceClaim changes
 * - **Efficient Queries**: Uses indexes and field selectors for fast aggregation
 *
 * ### Selectors and Filtering
 * - **Field selectors**: spec.consumerRef.kind, spec.consumerRef.name, spec.resourceType
 * - **System labels** (set automatically by quota system):
 *   - quota.miloapis.com/consumer-kind: Organization
 *   - quota.miloapis.com/consumer-name: acme-corp
 *
 * ### Common Queries
 * - All buckets for a consumer: label selector quota.miloapis.com/consumer-kind + quota.miloapis.com/consumer-name
 * - All buckets for a resource type: field selector spec.resourceType=<value>
 * - Specific bucket: field selector spec.consumerRef.name + spec.resourceType
 * - Overutilized buckets: filter by status.available < threshold
 * - Empty buckets: filter by status.limit = 0
 *
 * ### Performance Considerations
 * - Bucket status updates are asynchronous and may lag resource changes
 * - Large numbers of ResourceClaims can impact aggregation performance
 * - Controller uses efficient aggregation queries to handle scale
 * - Status updates are batched to reduce API server load
 */
export type Com_Miloapis_Quota_V1alpha1_AllowanceBucket = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Status>;
};

/** AllowanceBucketList is a list of AllowanceBucket */
export type Com_Miloapis_Quota_V1alpha1_AllowanceBucketList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of allowancebuckets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Quota_V1alpha1_AllowanceBucket>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * **AllowanceBucket** aggregates quota limits and usage for a single (consumer, resourceType) combination.
 * The system automatically creates buckets to provide real-time quota availability information
 * for **ResourceClaim** evaluation during admission.
 *
 * ### How It Works
 * 1. **Auto-Creation**: Quota system creates buckets automatically for each unique (consumer, resourceType) pair found in active **ResourceGrants**
 * 2. **Aggregation**: Quota system continuously aggregates capacity from active **ResourceGrants** and consumption from granted **ResourceClaims**
 * 3. **Decision Support**: Quota system uses bucket `status.available` to determine if **ResourceClaims** can be granted
 * 4. **Updates**: Quota system updates bucket status whenever contributing grants or claims change
 *
 * ### Aggregation Logic
 * **AllowanceBuckets** serve as the central aggregation point where quota capacity meets quota consumption.
 * The quota system continuously scans for **ResourceGrants** that match both the bucket's consumer
 * and resource type, but only considers grants with an `Active` status condition. For each qualifying
 * grant, the quota system examines all allowances targeting the bucket's resource type and sums the
 * amounts from every bucket within those allowances. This sum becomes the bucket's limit - the total
 * quota capacity available to the consumer for that specific resource type.
 *
 * Simultaneously, the quota system tracks quota consumption by finding all **ResourceClaims** with matching
 * consumer and resource type specifications. However, only claims that have been successfully granted
 * contribute to the allocated total. The quota system sums the allocated amounts from all granted
 * requests, creating a running total of consumed quota capacity.
 *
 * The available quota emerges from this simple relationship: Available = Limit - Allocated. The
 * system ensures this value never goes negative, treating any calculated negative as zero. This
 * available amount represents the quota capacity remaining for new **ResourceClaims** and drives
 * real-time admission decisions throughout the cluster.
 *
 * ### Real-Time Admission Decisions
 * When a **ResourceClaim** is created:
 * 1. Quota system identifies the relevant bucket (matching consumer and resource type)
 * 2. Compares requested amount with bucket's `status.available`
 * 3. Grants claim if requested amount <= available capacity
 * 4. Denies claim if requested amount > available capacity
 * 5. Updates bucket status to reflect the new allocation (if granted)
 *
 * ### Bucket Lifecycle
 * 1. **Auto-Created**: When first ResourceGrant creates allowance for (consumer, resourceType)
 * 2. **Active**: Continuously aggregated while ResourceGrants or ResourceClaims exist
 * 3. **Updated**: Status refreshed whenever contributing resources change
 * 4. **Persistent**: Buckets remain even when limit drops to 0 (for monitoring)
 *
 * ### Consistency and Performance
 * **Eventual Consistency:**
 * - Status may lag briefly after ResourceGrant or ResourceClaim changes
 * - Controller processes updates asynchronously for performance
 * - LastReconciliation timestamp indicates data freshness
 *
 * **Scale Optimization:**
 * - Stores aggregates (limit, allocated, available) rather than individual entries
 * - ContributingGrantRefs tracks grants (few) but not claims (many)
 * - Single bucket per (consumer, resourceType) regardless of claim count
 *
 * ### Status Information
 * - **Limit**: Total quota capacity from all contributing ResourceGrants
 * - **Allocated**: Total quota consumed by all granted ResourceClaims
 * - **Available**: Remaining quota capacity (Limit - Allocated)
 * - **ClaimCount**: Number of granted claims consuming from this bucket
 * - **GrantCount**: Number of active grants contributing to this bucket
 * - **ContributingGrantRefs**: Detailed information about contributing grants
 *
 * ### Monitoring and Troubleshooting
 * **Quota Monitoring:**
 * - Monitor status.available to track quota usage trends
 * - Check status.allocated vs status.limit for utilization ratios
 * - Use status.claimCount to understand resource creation patterns
 *
 * **Troubleshooting Issues:**
 * When investigating quota problems, start with the bucket's limit value. A limit of zero typically
 * indicates that no ResourceGrants are contributing capacity for this consumer and resource type
 * combination. Verify that ResourceGrants exist with matching consumer and resource type specifications,
 * and confirm their status conditions show Active=True. Grants with validation failures or pending
 * states won't contribute to bucket limits.
 *
 * High allocation values relative to limits suggest quota consumption issues. Review the ResourceClaims
 * that match this bucket's consumer and resource type to identify which resources are consuming large
 * amounts of quota. Check the claim allocation details to understand consumption patterns and identify
 * potential quota leaks where claims aren't being cleaned up properly.
 *
 * Stale bucket data manifests as allocation or limit values that don't reflect recent changes to
 * grants or claims. Check the lastReconciliation timestamp to determine data freshness, then examine
 * quota system logs for aggregation errors or performance issues. The quota system should process
 * changes within seconds under normal conditions.
 *
 * ### System Architecture
 * - **Single Writer**: Only the quota system updates bucket status (prevents races)
 * - **Dedicated Processing**: Separate components focus solely on bucket aggregation
 * - **Event-Driven**: Responds to ResourceGrant and ResourceClaim changes
 * - **Efficient Queries**: Uses indexes and field selectors for fast aggregation
 *
 * ### Selectors and Filtering
 * - **Field selectors**: spec.consumerRef.kind, spec.consumerRef.name, spec.resourceType
 * - **System labels** (set automatically by quota system):
 *   - quota.miloapis.com/consumer-kind: Organization
 *   - quota.miloapis.com/consumer-name: acme-corp
 *
 * ### Common Queries
 * - All buckets for a consumer: label selector quota.miloapis.com/consumer-kind + quota.miloapis.com/consumer-name
 * - All buckets for a resource type: field selector spec.resourceType=<value>
 * - Specific bucket: field selector spec.consumerRef.name + spec.resourceType
 * - Overutilized buckets: filter by status.available < threshold
 * - Empty buckets: filter by status.limit = 0
 *
 * ### Performance Considerations
 * - Bucket status updates are asynchronous and may lag resource changes
 * - Large numbers of ResourceClaims can impact aggregation performance
 * - Controller uses efficient aggregation queries to handle scale
 * - Status updates are batched to reduce API server load
 */
export type Com_Miloapis_Quota_V1alpha1_AllowanceBucket_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * ClaimCreationPolicy automatically creates ResourceClaims during admission to enforce quota in real-time.
 * Policies intercept resource creation requests, evaluate trigger conditions, and generate
 * quota claims that prevent resource creation when quota limits are exceeded.
 *
 * ### How It Works
 * 1. **Trigger Matching**: Admission webhook matches incoming resource creates against spec.trigger.resource
 * 2. **Constraint Evaluation**: All CEL expressions in spec.trigger.constraints must evaluate to true
 * 3. **Template Rendering**: Policy renders spec.target.resourceClaimTemplate using available template variables
 * 4. **Claim Creation**: System creates the rendered ResourceClaim in the specified namespace
 * 5. **Quota Evaluation**: Claim is immediately evaluated against AllowanceBucket capacity
 * 6. **Admission Decision**: Original resource creation succeeds or fails based on claim result
 *
 * ### Policy Processing Flow
 * **Active Policies** (spec.disabled=false):
 * 1. Admission webhook receives resource creation request
 * 2. Finds all ClaimCreationPolicies matching the resource type
 * 3. Evaluates trigger constraints for each matching policy
 * 4. Creates ResourceClaim for each policy where all constraints are true
 * 5. Evaluates all created claims against quota buckets
 * 6. Allows resource creation only if all claims are granted
 *
 * **Disabled Policies** (spec.disabled=true):
 * - Completely ignored during admission processing
 * - No constraints evaluated, no claims created
 * - Useful for temporarily disabling quota enforcement
 *
 * ### Template Expressions
 * Template expressions generate dynamic content for ResourceClaim fields including metadata and specification.
 * Content inside `{{ }}` delimiters is evaluated as CEL expressions, while content outside is treated as literal text.
 *
 * **Template Expression Rules:**
 * - `{{expression}}` - Pure CEL expression, evaluated and substituted
 * - `literal-text` - Used as-is without any evaluation
 * - `{{expression}}-literal` - CEL output combined with literal text
 * - `prefix-{{expression}}-suffix` - Literal text surrounding CEL expression
 *
 * **Template Expression Examples:**
 * - `{{trigger.metadata.name + '-claim'}}` - Pure CEL expression (metadata)
 * - `{{trigger.metadata.name}}-quota-claim` - CEL + literal suffix (metadata)
 * - `{{trigger.spec.organization}}` - Extract spec field for consumer name (spec)
 * - `{{trigger.metadata.labels["tier"] + "-tier"}}` - Label-based naming (spec)
 * - `fixed-claim-name` - Literal string only (no evaluation)
 *
 * **Use Template Expressions For:** ResourceClaimTemplate fields (metadata and spec)
 *
 * ### Constraint Expressions
 * Constraint expressions determine whether a policy should trigger by evaluating boolean conditions.
 * These are pure CEL expressions without delimiters that must return true/false values.
 *
 * **Constraint Expression Rules:**
 * - Write pure CEL expressions directly (no wrapping syntax)
 * - Must return boolean values (true = trigger policy, false = skip)
 * - All constraints in a policy must return true for the policy to activate
 *
 * **Constraint Expression Examples:**
 * - `trigger.spec.tier == "premium"` - Field equality check
 * - `trigger.metadata.labels["environment"] == "prod"` - Label-based filtering
 * - `user.groups.exists(g, g == "admin")` - User authorization check
 * - `has(trigger.spec.quotaProfile)` - Field existence check
 *
 * **Use Constraint Expressions For:** spec.trigger.constraints fields
 *
 * ### Expression Variables
 * Both template and constraint expressions have access to the same context variables:
 *
 * **trigger**: The complete resource that triggered the policy, including all metadata, spec,
 * and status fields. Navigate using CEL property access: `trigger.metadata.name`, `trigger.spec.replicas`.
 *
 * **user**: Authentication context providing access to the requester's name, unique identifier,
 * group memberships, and additional attributes. Enables user-based quota policies.
 *
 * **requestInfo**: Operational context including the API verb being performed and resource type
 * being manipulated. Useful for distinguishing between create, update, and delete operations.
 *
 * **CEL Functions**: Standard CEL functions available for data manipulation including conditional
 * expressions (`condition ? value1 : value2`), string methods (`lowerAscii()`, `upperAscii()`, `trim()`),
 * and collection operations (`exists()`, `all()`, `filter()`).
 *
 * ### Consumer Resolution
 * The system automatically resolves spec.consumerRef for created claims:
 * - Uses parent context resolution to find the appropriate consumer
 * - Typically resolves to Organization for Project resources, Project for User resources, etc.
 * - Consumer must match the ResourceRegistration.spec.consumerType for the requested resource type
 *
 * ### Validation and Dependencies
 * **Policy Validation:**
 * - Target resource type must exist and be accessible
 * - All resource types in claim specification must have active ResourceRegistrations
 * - Consumer resolution must be resolvable for target resources
 * - CEL expressions must be syntactically valid
 *
 * **Runtime Dependencies:**
 * - ResourceRegistration must be Active for each requested resource type
 * - Triggering resource kind must be listed in ResourceRegistration.spec.claimingResources
 * - AllowanceBucket must exist (created automatically when ResourceGrants are active)
 *
 * ### Policy Lifecycle
 * 1. **Creation**: Administrator creates ClaimCreationPolicy
 * 2. **Validation**: System validates target resource and expressions
 * 3. **Activation**: System sets Ready=True when validation passes
 * 4. **Operation**: Admission webhook uses active policies to create claims
 * 5. **Updates**: Changes trigger re-validation; only Ready policies are used
 *
 * ### Status Conditions
 * - **Ready=True**: Policy is validated and actively creating claims
 * - **Ready=False, reason=ValidationFailed**: Configuration errors prevent activation (check message)
 * - **Ready=False, reason=PolicyDisabled**: Policy is disabled (spec.disabled=true)
 *
 * ### Automatic Claim Features
 * Claims created by ClaimCreationPolicy include:
 * - **Standard Labels**: quota.miloapis.com/auto-created=true, quota.miloapis.com/policy=<policy-name>
 * - **Standard Annotations**: quota.miloapis.com/created-by=claim-creation-plugin, timestamps
 * - **Owner References**: Set to triggering resource when possible for lifecycle management
 * - **Cleanup**: Automatically cleaned up when denied to prevent accumulation
 *
 * ### Field Constraints and Limits
 * - Maximum 10 constraints per trigger (spec.trigger.constraints)
 * - Static amounts only in v1alpha1 (no expression-based quota amounts)
 * - Template metadata labels are literal strings (no expression processing)
 * - Template annotation values support CEL expressions
 *
 * ### Selectors and Filtering
 * - **Field selectors**: spec.trigger.resource.kind, spec.trigger.resource.apiVersion, spec.disabled
 * - **Recommended labels** (add manually):
 *   - quota.miloapis.com/target-kind: Project
 *   - quota.miloapis.com/environment: production
 *   - quota.miloapis.com/tier: premium
 *
 * ### Common Queries
 * - All policies for a resource kind: label selector quota.miloapis.com/target-kind=<kind>
 * - Active policies only: field selector spec.disabled=false
 * - Environment-specific policies: label selector quota.miloapis.com/environment=<env>
 * - Failed policies: filter by status.conditions[type=Ready].status=False
 *
 * ### Troubleshooting
 * - **Policy not triggering**: Check spec.disabled=false and status.conditions[type=Ready]=True
 * - **Template errors**: Review status condition message for CEL expression syntax issues
 * - **CEL expression failures**: Validate expression syntax and available variables
 * - **Claims not created**: Verify trigger constraints match the incoming resource
 * - **Consumer resolution errors**: Check parent context resolution and ResourceRegistration setup
 *
 * ### Performance Considerations
 * - Policies are evaluated synchronously during admission (affects API latency)
 * - Complex CEL expressions can impact admission performance
 * - Template rendering occurs for every matching admission request
 * - Consider using specific trigger constraints to limit policy evaluation scope
 *
 * ### Security Considerations
 * - Templates can access complete trigger resource data (sensitive field exposure)
 * - CEL expressions have access to user information and request details
 * - Only trusted administrators should create or modify policies
 * - Review template output to ensure no sensitive data leakage in claim metadata
 */
export type Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicy = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec;
  status?: Maybe<Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Status>;
};

/** ClaimCreationPolicyList is a list of ClaimCreationPolicy */
export type Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicyList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of claimcreationpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicy>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * ClaimCreationPolicy automatically creates ResourceClaims during admission to enforce quota in real-time.
 * Policies intercept resource creation requests, evaluate trigger conditions, and generate
 * quota claims that prevent resource creation when quota limits are exceeded.
 *
 * ### How It Works
 * 1. **Trigger Matching**: Admission webhook matches incoming resource creates against spec.trigger.resource
 * 2. **Constraint Evaluation**: All CEL expressions in spec.trigger.constraints must evaluate to true
 * 3. **Template Rendering**: Policy renders spec.target.resourceClaimTemplate using available template variables
 * 4. **Claim Creation**: System creates the rendered ResourceClaim in the specified namespace
 * 5. **Quota Evaluation**: Claim is immediately evaluated against AllowanceBucket capacity
 * 6. **Admission Decision**: Original resource creation succeeds or fails based on claim result
 *
 * ### Policy Processing Flow
 * **Active Policies** (spec.disabled=false):
 * 1. Admission webhook receives resource creation request
 * 2. Finds all ClaimCreationPolicies matching the resource type
 * 3. Evaluates trigger constraints for each matching policy
 * 4. Creates ResourceClaim for each policy where all constraints are true
 * 5. Evaluates all created claims against quota buckets
 * 6. Allows resource creation only if all claims are granted
 *
 * **Disabled Policies** (spec.disabled=true):
 * - Completely ignored during admission processing
 * - No constraints evaluated, no claims created
 * - Useful for temporarily disabling quota enforcement
 *
 * ### Template Expressions
 * Template expressions generate dynamic content for ResourceClaim fields including metadata and specification.
 * Content inside `{{ }}` delimiters is evaluated as CEL expressions, while content outside is treated as literal text.
 *
 * **Template Expression Rules:**
 * - `{{expression}}` - Pure CEL expression, evaluated and substituted
 * - `literal-text` - Used as-is without any evaluation
 * - `{{expression}}-literal` - CEL output combined with literal text
 * - `prefix-{{expression}}-suffix` - Literal text surrounding CEL expression
 *
 * **Template Expression Examples:**
 * - `{{trigger.metadata.name + '-claim'}}` - Pure CEL expression (metadata)
 * - `{{trigger.metadata.name}}-quota-claim` - CEL + literal suffix (metadata)
 * - `{{trigger.spec.organization}}` - Extract spec field for consumer name (spec)
 * - `{{trigger.metadata.labels["tier"] + "-tier"}}` - Label-based naming (spec)
 * - `fixed-claim-name` - Literal string only (no evaluation)
 *
 * **Use Template Expressions For:** ResourceClaimTemplate fields (metadata and spec)
 *
 * ### Constraint Expressions
 * Constraint expressions determine whether a policy should trigger by evaluating boolean conditions.
 * These are pure CEL expressions without delimiters that must return true/false values.
 *
 * **Constraint Expression Rules:**
 * - Write pure CEL expressions directly (no wrapping syntax)
 * - Must return boolean values (true = trigger policy, false = skip)
 * - All constraints in a policy must return true for the policy to activate
 *
 * **Constraint Expression Examples:**
 * - `trigger.spec.tier == "premium"` - Field equality check
 * - `trigger.metadata.labels["environment"] == "prod"` - Label-based filtering
 * - `user.groups.exists(g, g == "admin")` - User authorization check
 * - `has(trigger.spec.quotaProfile)` - Field existence check
 *
 * **Use Constraint Expressions For:** spec.trigger.constraints fields
 *
 * ### Expression Variables
 * Both template and constraint expressions have access to the same context variables:
 *
 * **trigger**: The complete resource that triggered the policy, including all metadata, spec,
 * and status fields. Navigate using CEL property access: `trigger.metadata.name`, `trigger.spec.replicas`.
 *
 * **user**: Authentication context providing access to the requester's name, unique identifier,
 * group memberships, and additional attributes. Enables user-based quota policies.
 *
 * **requestInfo**: Operational context including the API verb being performed and resource type
 * being manipulated. Useful for distinguishing between create, update, and delete operations.
 *
 * **CEL Functions**: Standard CEL functions available for data manipulation including conditional
 * expressions (`condition ? value1 : value2`), string methods (`lowerAscii()`, `upperAscii()`, `trim()`),
 * and collection operations (`exists()`, `all()`, `filter()`).
 *
 * ### Consumer Resolution
 * The system automatically resolves spec.consumerRef for created claims:
 * - Uses parent context resolution to find the appropriate consumer
 * - Typically resolves to Organization for Project resources, Project for User resources, etc.
 * - Consumer must match the ResourceRegistration.spec.consumerType for the requested resource type
 *
 * ### Validation and Dependencies
 * **Policy Validation:**
 * - Target resource type must exist and be accessible
 * - All resource types in claim specification must have active ResourceRegistrations
 * - Consumer resolution must be resolvable for target resources
 * - CEL expressions must be syntactically valid
 *
 * **Runtime Dependencies:**
 * - ResourceRegistration must be Active for each requested resource type
 * - Triggering resource kind must be listed in ResourceRegistration.spec.claimingResources
 * - AllowanceBucket must exist (created automatically when ResourceGrants are active)
 *
 * ### Policy Lifecycle
 * 1. **Creation**: Administrator creates ClaimCreationPolicy
 * 2. **Validation**: System validates target resource and expressions
 * 3. **Activation**: System sets Ready=True when validation passes
 * 4. **Operation**: Admission webhook uses active policies to create claims
 * 5. **Updates**: Changes trigger re-validation; only Ready policies are used
 *
 * ### Status Conditions
 * - **Ready=True**: Policy is validated and actively creating claims
 * - **Ready=False, reason=ValidationFailed**: Configuration errors prevent activation (check message)
 * - **Ready=False, reason=PolicyDisabled**: Policy is disabled (spec.disabled=true)
 *
 * ### Automatic Claim Features
 * Claims created by ClaimCreationPolicy include:
 * - **Standard Labels**: quota.miloapis.com/auto-created=true, quota.miloapis.com/policy=<policy-name>
 * - **Standard Annotations**: quota.miloapis.com/created-by=claim-creation-plugin, timestamps
 * - **Owner References**: Set to triggering resource when possible for lifecycle management
 * - **Cleanup**: Automatically cleaned up when denied to prevent accumulation
 *
 * ### Field Constraints and Limits
 * - Maximum 10 constraints per trigger (spec.trigger.constraints)
 * - Static amounts only in v1alpha1 (no expression-based quota amounts)
 * - Template metadata labels are literal strings (no expression processing)
 * - Template annotation values support CEL expressions
 *
 * ### Selectors and Filtering
 * - **Field selectors**: spec.trigger.resource.kind, spec.trigger.resource.apiVersion, spec.disabled
 * - **Recommended labels** (add manually):
 *   - quota.miloapis.com/target-kind: Project
 *   - quota.miloapis.com/environment: production
 *   - quota.miloapis.com/tier: premium
 *
 * ### Common Queries
 * - All policies for a resource kind: label selector quota.miloapis.com/target-kind=<kind>
 * - Active policies only: field selector spec.disabled=false
 * - Environment-specific policies: label selector quota.miloapis.com/environment=<env>
 * - Failed policies: filter by status.conditions[type=Ready].status=False
 *
 * ### Troubleshooting
 * - **Policy not triggering**: Check spec.disabled=false and status.conditions[type=Ready]=True
 * - **Template errors**: Review status condition message for CEL expression syntax issues
 * - **CEL expression failures**: Validate expression syntax and available variables
 * - **Claims not created**: Verify trigger constraints match the incoming resource
 * - **Consumer resolution errors**: Check parent context resolution and ResourceRegistration setup
 *
 * ### Performance Considerations
 * - Policies are evaluated synchronously during admission (affects API latency)
 * - Complex CEL expressions can impact admission performance
 * - Template rendering occurs for every matching admission request
 * - Consider using specific trigger constraints to limit policy evaluation scope
 *
 * ### Security Considerations
 * - Templates can access complete trigger resource data (sensitive field exposure)
 * - CEL expressions have access to user information and request details
 * - Only trusted administrators should create or modify policies
 * - Review template output to ensure no sensitive data leakage in claim metadata
 */
export type Com_Miloapis_Quota_V1alpha1_ClaimCreationPolicy_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Status_Input>;
};

/**
 * GrantCreationPolicy automates ResourceGrant creation when observed resources meet conditions.
 * Use it to provision quota based on resource lifecycle events and attributes.
 *
 * ### How It Works
 * - Watch the kind in `spec.trigger.resource` and evaluate all `spec.trigger.constraints[]`.
 * - When all constraints are true, evaluate `spec.target.resourceGrantTemplate` and create a `ResourceGrant`.
 * - Optionally target a parent control plane via `spec.target.parentContext` (CEL-resolved name) for cross-cluster allocation.
 * - Allowances (resource types and amounts) are static in `v1alpha1`.
 *
 * ### Template Expressions
 * Template expressions generate dynamic content for ResourceGrant fields including metadata and specification.
 * Content inside `{{ }}` delimiters is evaluated as CEL expressions, while content outside is treated as literal text.
 *
 * **Template Expression Rules:**
 * - `{{expression}}` - Pure CEL expression, evaluated and substituted
 * - `literal-text` - Used as-is without any evaluation
 * - `{{expression}}-literal` - CEL output combined with literal text
 * - `prefix-{{expression}}-suffix` - Literal text surrounding CEL expression
 *
 * **Template Expression Examples:**
 * - `{{trigger.metadata.name + '-grant'}}` - Pure CEL expression (metadata)
 * - `{{trigger.metadata.name}}-quota-grant` - CEL + literal suffix (metadata)
 * - `{{trigger.spec.type + "-consumer"}}` - Extract spec field for consumer name (spec)
 * - `{{trigger.metadata.labels["environment"] + "-grants"}}` - Label-based naming (spec)
 * - `fixed-grant-name` - Literal string only (no evaluation)
 *
 * **Use Template Expressions For:** ResourceGrantTemplate fields (metadata and spec)
 *
 * ### Constraint Expressions
 * Constraint expressions determine whether a policy should trigger by evaluating boolean conditions.
 * These are pure CEL expressions without delimiters that must return true/false values.
 *
 * **Constraint Expression Rules:**
 * - Write pure CEL expressions directly (no wrapping syntax)
 * - Must return boolean values (true = trigger policy, false = skip)
 * - All constraints in a policy must return true for the policy to activate
 *
 * **Constraint Expression Examples:**
 * - `trigger.spec.tier == "premium"` - Field equality check
 * - `trigger.metadata.labels["environment"] == "prod"` - Label-based filtering
 * - `trigger.status.phase == "Active"` - Status condition check
 * - `has(trigger.spec.quotaProfile)` - Field existence check
 *
 * **Use Constraint Expressions For:** spec.trigger.constraints fields
 *
 * ### Expression Variables
 * Both template and constraint expressions have access to the resource context variables:
 *
 * **trigger**: The complete resource that triggered the policy, including all metadata, spec,
 * and status fields. Navigate using CEL property access: `trigger.metadata.name`, `trigger.spec.tier`.
 * This is the only variable available since GrantCreationPolicy runs during resource watching,
 * not during admission processing.
 *
 * **CEL Functions**: Standard CEL functions available for data manipulation including conditional
 * expressions (`condition ? value1 : value2`), string methods (`lowerAscii()`, `upperAscii()`, `trim()`),
 * and collection operations (`exists()`, `all()`, `filter()`).
 *
 * ### Works With
 * - Creates [ResourceGrant](#resourcegrant) objects whose `allowances[].resourceType` must exist in a [ResourceRegistration](#resourceregistration).
 * - May target a parent control plane via `spec.target.parentContext` for cross-plane quota allocation.
 * - Policy readiness (`status.conditions[type=Ready]`) signals expression/constraint validity.
 *
 * ### Status
 * - `status.conditions[type=Ready]`: Policy validated and active.
 * - `status.conditions[type=ParentContextReady]`: Crosscluster targeting is resolvable.
 * - `status.observedGeneration`: Latest spec generation processed.
 *
 * ### Selectors and Filtering
 *   - Field selectors (server-side):
 *     `spec.trigger.resource.kind`, `spec.trigger.resource.apiVersion`,
 *     `spec.target.parentContext.kind`, `spec.target.parentContext.apiGroup`.
 *   - Label selectors (add your own):
 *   - `quota.miloapis.com/trigger-kind`: `Organization`
 *   - `quota.miloapis.com/environment`: `prod`
 *   - Common queries:
 *   - All policies for a trigger kind: label selector `quota.miloapis.com/trigger-kind`.
 *   - All active policies: field selector `spec.disabled=false`.
 *
 * ### Defaults and Limits
 * - Resource grant allowances are static (no expression-based amounts) in `v1alpha1`.
 *
 * ### Notes
 * - If `ParentContextReady=False`, verify `nameExpression` and referenced attributes.
 * - Disabled policies (`spec.disabled=true`) do not create grants.
 *
 * ### See Also
 * - [ResourceGrant](#resourcegrant): The object created by this policy.
 * - [ResourceRegistration](#resourceregistration): Resource types that grants must reference.
 * - [ClaimCreationPolicy](#claimcreationpolicy): Creates claims at admission for enforcement.
 */
export type Com_Miloapis_Quota_V1alpha1_GrantCreationPolicy = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec;
  status?: Maybe<Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Status>;
};

/** GrantCreationPolicyList is a list of GrantCreationPolicy */
export type Com_Miloapis_Quota_V1alpha1_GrantCreationPolicyList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of grantcreationpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Quota_V1alpha1_GrantCreationPolicy>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * GrantCreationPolicy automates ResourceGrant creation when observed resources meet conditions.
 * Use it to provision quota based on resource lifecycle events and attributes.
 *
 * ### How It Works
 * - Watch the kind in `spec.trigger.resource` and evaluate all `spec.trigger.constraints[]`.
 * - When all constraints are true, evaluate `spec.target.resourceGrantTemplate` and create a `ResourceGrant`.
 * - Optionally target a parent control plane via `spec.target.parentContext` (CEL-resolved name) for cross-cluster allocation.
 * - Allowances (resource types and amounts) are static in `v1alpha1`.
 *
 * ### Template Expressions
 * Template expressions generate dynamic content for ResourceGrant fields including metadata and specification.
 * Content inside `{{ }}` delimiters is evaluated as CEL expressions, while content outside is treated as literal text.
 *
 * **Template Expression Rules:**
 * - `{{expression}}` - Pure CEL expression, evaluated and substituted
 * - `literal-text` - Used as-is without any evaluation
 * - `{{expression}}-literal` - CEL output combined with literal text
 * - `prefix-{{expression}}-suffix` - Literal text surrounding CEL expression
 *
 * **Template Expression Examples:**
 * - `{{trigger.metadata.name + '-grant'}}` - Pure CEL expression (metadata)
 * - `{{trigger.metadata.name}}-quota-grant` - CEL + literal suffix (metadata)
 * - `{{trigger.spec.type + "-consumer"}}` - Extract spec field for consumer name (spec)
 * - `{{trigger.metadata.labels["environment"] + "-grants"}}` - Label-based naming (spec)
 * - `fixed-grant-name` - Literal string only (no evaluation)
 *
 * **Use Template Expressions For:** ResourceGrantTemplate fields (metadata and spec)
 *
 * ### Constraint Expressions
 * Constraint expressions determine whether a policy should trigger by evaluating boolean conditions.
 * These are pure CEL expressions without delimiters that must return true/false values.
 *
 * **Constraint Expression Rules:**
 * - Write pure CEL expressions directly (no wrapping syntax)
 * - Must return boolean values (true = trigger policy, false = skip)
 * - All constraints in a policy must return true for the policy to activate
 *
 * **Constraint Expression Examples:**
 * - `trigger.spec.tier == "premium"` - Field equality check
 * - `trigger.metadata.labels["environment"] == "prod"` - Label-based filtering
 * - `trigger.status.phase == "Active"` - Status condition check
 * - `has(trigger.spec.quotaProfile)` - Field existence check
 *
 * **Use Constraint Expressions For:** spec.trigger.constraints fields
 *
 * ### Expression Variables
 * Both template and constraint expressions have access to the resource context variables:
 *
 * **trigger**: The complete resource that triggered the policy, including all metadata, spec,
 * and status fields. Navigate using CEL property access: `trigger.metadata.name`, `trigger.spec.tier`.
 * This is the only variable available since GrantCreationPolicy runs during resource watching,
 * not during admission processing.
 *
 * **CEL Functions**: Standard CEL functions available for data manipulation including conditional
 * expressions (`condition ? value1 : value2`), string methods (`lowerAscii()`, `upperAscii()`, `trim()`),
 * and collection operations (`exists()`, `all()`, `filter()`).
 *
 * ### Works With
 * - Creates [ResourceGrant](#resourcegrant) objects whose `allowances[].resourceType` must exist in a [ResourceRegistration](#resourceregistration).
 * - May target a parent control plane via `spec.target.parentContext` for cross-plane quota allocation.
 * - Policy readiness (`status.conditions[type=Ready]`) signals expression/constraint validity.
 *
 * ### Status
 * - `status.conditions[type=Ready]`: Policy validated and active.
 * - `status.conditions[type=ParentContextReady]`: Crosscluster targeting is resolvable.
 * - `status.observedGeneration`: Latest spec generation processed.
 *
 * ### Selectors and Filtering
 *   - Field selectors (server-side):
 *     `spec.trigger.resource.kind`, `spec.trigger.resource.apiVersion`,
 *     `spec.target.parentContext.kind`, `spec.target.parentContext.apiGroup`.
 *   - Label selectors (add your own):
 *   - `quota.miloapis.com/trigger-kind`: `Organization`
 *   - `quota.miloapis.com/environment`: `prod`
 *   - Common queries:
 *   - All policies for a trigger kind: label selector `quota.miloapis.com/trigger-kind`.
 *   - All active policies: field selector `spec.disabled=false`.
 *
 * ### Defaults and Limits
 * - Resource grant allowances are static (no expression-based amounts) in `v1alpha1`.
 *
 * ### Notes
 * - If `ParentContextReady=False`, verify `nameExpression` and referenced attributes.
 * - Disabled policies (`spec.disabled=true`) do not create grants.
 *
 * ### See Also
 * - [ResourceGrant](#resourcegrant): The object created by this policy.
 * - [ResourceRegistration](#resourceregistration): Resource types that grants must reference.
 * - [ClaimCreationPolicy](#claimcreationpolicy): Creates claims at admission for enforcement.
 */
export type Com_Miloapis_Quota_V1alpha1_GrantCreationPolicy_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Status_Input>;
};

/**
 * ResourceClaim requests quota allocation during resource creation. Claims
 * consume quota capacity from AllowanceBuckets and link to the triggering
 * Kubernetes resource for lifecycle management and auditing.
 *
 * ### How It Works
 *
 * **ResourceClaims** follow a straightforward lifecycle from creation to
 * resolution. When a **ClaimCreationPolicy** triggers during admission, it
 * creates a **ResourceClaim** that immediately enters the quota evaluation
 * pipeline. The quota system first validates that the consumer type matches the
 * expected `ConsumerType` from the **ResourceRegistration**, then verifies
 * that the triggering resource kind is authorized to claim the requested
 * resource types.
 *
 * Once validation passes, the quota system checks quota availability by
 * consulting the relevant **AllowanceBuckets**, one for each (consumer,
 * resourceType) combination in the claim's requests. The quota system treats
 * all requests in a claim as an atomic unit: either sufficient quota exists for
 * every request and the entire claim is granted, or any shortage results in
 * denying the complete claim. This atomic approach ensures consistency and
 * prevents partial resource allocations that could leave the system in an
 * inconsistent state.
 *
 * When a claim is granted, it permanently reserves the requested quota amounts
 * until the claim is deleted. This consumption immediately reduces the
 * available quota in the corresponding **AllowanceBuckets**, preventing other
 * claims from accessing that capacity. The quota system updates the claim's
 * status with detailed results for each resource request, including which
 * **AllowanceBucket** provided the quota and any relevant error messages.
 *
 * ### Core Relationships
 *
 *   - **Created by**: **ClaimCreationPolicy** during admission (automatically) or
 *     administrators (manually)
 *   - **Consumes from**: **AllowanceBucket** matching
 *     (`spec.consumerRef`, `spec.requests[].resourceType`)
 *   - **Capacity sourced from**: **ResourceGrant** objects aggregated by the bucket
 *   - **Linked to**: Triggering resource via `spec.resourceRef` for lifecycle management
 *   - **Validated against**: **ResourceRegistration** for each `spec.requests[].resourceType`
 *
 * ### Claim Lifecycle States
 *
 *   - **Initial**: `Granted=False`, `reason=PendingEvaluation` (claim created, awaiting processing)
 *   - **Granted**: `Granted=True`, `reason=QuotaAvailable` (all requests allocated successfully)
 *   - **Denied**: `Granted=False`, `reason=QuotaExceeded` or `ValidationFailed` (requests could not be satisfied)
 *
 * ### Automatic vs Manual Claims
 *
 * **Automatic Claims** (created by **ClaimCreationPolicy**):
 *
 *   - Include standard labels and annotations for tracking
 *   - Set owner references to triggering resource when possible
 *   - Automatically cleaned up when denied to prevent accumulation
 *   - Marked with `quota.miloapis.com/auto-created=true` label
 *
 * **Manual Claims** (created by administrators):
 *
 *   - Require explicit metadata and references
 *   - Not automatically cleaned up when denied
 *   - Used for testing or special allocation scenarios
 *
 * ### Status Information
 *
 *   - **Overall Status**: `status.conditions[type=Granted]` indicates claim approval
 *   - **Detailed Results**: `status.allocations[]` provides per-request allocation details
 *   - **Bucket References**: `status.allocations[].allocatingBucket` identifies quota sources
 *
 * ### Field Constraints and Validation
 *
 *   - Maximum 20 resource requests per claim
 *   - Each resource type can appear only once in requests
 *   - Consumer type must match `ResourceRegistration.spec.consumerType` for each requested type
 *   - Triggering resource kind must be listed in `ResourceRegistration.spec.claimingResources`
 *
 * ### Selectors and Filtering
 *
 *   - **Field selectors**: spec.consumerRef.kind, spec.consumerRef.name, spec.resourceRef.apiGroup, spec.resourceRef.kind, spec.resourceRef.name, spec.resourceRef.namespace
 *   - **Auto-created labels**: quota.miloapis.com/auto-created, quota.miloapis.com/policy, quota.miloapis.com/gvk
 *   - **Auto-created annotations**: quota.miloapis.com/created-by, quota.miloapis.com/created-at,  quota.miloapis.com/resource-name
 *
 * ### Common Queries
 *
 *   - All claims for a consumer: field selector spec.consumerRef.kind + spec.consumerRef.name
 *   - Claims from a specific policy: label selector quota.miloapis.com/policy=<policy-name>
 *   - Claims for a resource type: add custom labels via policy template
 *   - Failed claims: field  selector on status conditions
 *
 * ### Troubleshooting
 *
 *   - **Denied claims**: Check status.allocations[].message for specific quota or validation errors
 *   - **Pending claims**: Verify ResourceRegistration is Active and AllowanceBucket exists
 *   - **Missing claims**: Check ClaimCreationPolicy conditions and trigger expressions
 *
 * ### Performance Considerations
 *
 *   - Claims are processed synchronously during admission (affects API latency)
 *   - Large numbers of claims can impact bucket aggregation performance
 *   - Consider batch processing for bulk resource creation
 */
export type Com_Miloapis_Quota_V1alpha1_ResourceClaim = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec;
  status?: Maybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status>;
};

/** ResourceClaimList is a list of ResourceClaim */
export type Com_Miloapis_Quota_V1alpha1_ResourceClaimList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of resourceclaims. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Quota_V1alpha1_ResourceClaim>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * ResourceClaim requests quota allocation during resource creation. Claims
 * consume quota capacity from AllowanceBuckets and link to the triggering
 * Kubernetes resource for lifecycle management and auditing.
 *
 * ### How It Works
 *
 * **ResourceClaims** follow a straightforward lifecycle from creation to
 * resolution. When a **ClaimCreationPolicy** triggers during admission, it
 * creates a **ResourceClaim** that immediately enters the quota evaluation
 * pipeline. The quota system first validates that the consumer type matches the
 * expected `ConsumerType` from the **ResourceRegistration**, then verifies
 * that the triggering resource kind is authorized to claim the requested
 * resource types.
 *
 * Once validation passes, the quota system checks quota availability by
 * consulting the relevant **AllowanceBuckets**, one for each (consumer,
 * resourceType) combination in the claim's requests. The quota system treats
 * all requests in a claim as an atomic unit: either sufficient quota exists for
 * every request and the entire claim is granted, or any shortage results in
 * denying the complete claim. This atomic approach ensures consistency and
 * prevents partial resource allocations that could leave the system in an
 * inconsistent state.
 *
 * When a claim is granted, it permanently reserves the requested quota amounts
 * until the claim is deleted. This consumption immediately reduces the
 * available quota in the corresponding **AllowanceBuckets**, preventing other
 * claims from accessing that capacity. The quota system updates the claim's
 * status with detailed results for each resource request, including which
 * **AllowanceBucket** provided the quota and any relevant error messages.
 *
 * ### Core Relationships
 *
 *   - **Created by**: **ClaimCreationPolicy** during admission (automatically) or
 *     administrators (manually)
 *   - **Consumes from**: **AllowanceBucket** matching
 *     (`spec.consumerRef`, `spec.requests[].resourceType`)
 *   - **Capacity sourced from**: **ResourceGrant** objects aggregated by the bucket
 *   - **Linked to**: Triggering resource via `spec.resourceRef` for lifecycle management
 *   - **Validated against**: **ResourceRegistration** for each `spec.requests[].resourceType`
 *
 * ### Claim Lifecycle States
 *
 *   - **Initial**: `Granted=False`, `reason=PendingEvaluation` (claim created, awaiting processing)
 *   - **Granted**: `Granted=True`, `reason=QuotaAvailable` (all requests allocated successfully)
 *   - **Denied**: `Granted=False`, `reason=QuotaExceeded` or `ValidationFailed` (requests could not be satisfied)
 *
 * ### Automatic vs Manual Claims
 *
 * **Automatic Claims** (created by **ClaimCreationPolicy**):
 *
 *   - Include standard labels and annotations for tracking
 *   - Set owner references to triggering resource when possible
 *   - Automatically cleaned up when denied to prevent accumulation
 *   - Marked with `quota.miloapis.com/auto-created=true` label
 *
 * **Manual Claims** (created by administrators):
 *
 *   - Require explicit metadata and references
 *   - Not automatically cleaned up when denied
 *   - Used for testing or special allocation scenarios
 *
 * ### Status Information
 *
 *   - **Overall Status**: `status.conditions[type=Granted]` indicates claim approval
 *   - **Detailed Results**: `status.allocations[]` provides per-request allocation details
 *   - **Bucket References**: `status.allocations[].allocatingBucket` identifies quota sources
 *
 * ### Field Constraints and Validation
 *
 *   - Maximum 20 resource requests per claim
 *   - Each resource type can appear only once in requests
 *   - Consumer type must match `ResourceRegistration.spec.consumerType` for each requested type
 *   - Triggering resource kind must be listed in `ResourceRegistration.spec.claimingResources`
 *
 * ### Selectors and Filtering
 *
 *   - **Field selectors**: spec.consumerRef.kind, spec.consumerRef.name, spec.resourceRef.apiGroup, spec.resourceRef.kind, spec.resourceRef.name, spec.resourceRef.namespace
 *   - **Auto-created labels**: quota.miloapis.com/auto-created, quota.miloapis.com/policy, quota.miloapis.com/gvk
 *   - **Auto-created annotations**: quota.miloapis.com/created-by, quota.miloapis.com/created-at,  quota.miloapis.com/resource-name
 *
 * ### Common Queries
 *
 *   - All claims for a consumer: field selector spec.consumerRef.kind + spec.consumerRef.name
 *   - Claims from a specific policy: label selector quota.miloapis.com/policy=<policy-name>
 *   - Claims for a resource type: add custom labels via policy template
 *   - Failed claims: field  selector on status conditions
 *
 * ### Troubleshooting
 *
 *   - **Denied claims**: Check status.allocations[].message for specific quota or validation errors
 *   - **Pending claims**: Verify ResourceRegistration is Active and AllowanceBucket exists
 *   - **Missing claims**: Check ClaimCreationPolicy conditions and trigger expressions
 *
 * ### Performance Considerations
 *
 *   - Claims are processed synchronously during admission (affects API latency)
 *   - Large numbers of claims can impact bucket aggregation performance
 *   - Consider batch processing for bulk resource creation
 */
export type Com_Miloapis_Quota_V1alpha1_ResourceClaim_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Input>;
};

/**
 * ResourceGrant allocates quota capacity to a consumer for specific resource types.
 * Grants provide the allowances that AllowanceBuckets aggregate to determine
 * available quota for ResourceClaim evaluation.
 *
 * ### How It Works
 * **ResourceGrants** begin their lifecycle when either an administrator creates them manually or a
 * **GrantCreationPolicy** generates them automatically in response to observed resource changes. Upon
 * creation, the grant enters a validation phase where the quota system examines the consumer type
 * to ensure it matches the expected `ConsumerType` from each **ResourceRegistration** targeted by
 * the grant's allowances. The quota system also verifies that all specified resource types correspond
 * to active registrations and that the allowance amounts are valid non-negative integers.
 *
 * When validation succeeds, the quota system marks the grant as `Active`, signaling to **AllowanceBucket**
 * resources that this grant should contribute to quota calculations. The bucket resources
 * continuously monitor for active grants and aggregate their allowance amounts into the appropriate
 * buckets based on consumer and resource type matching. This aggregation process makes the granted
 * quota capacity available for **ResourceClaim** consumption.
 *
 * **ResourceClaims** then consume the capacity that active grants provide, creating a flow from grants
 * through buckets to claims. The grant's capacity remains reserved as long as claims reference it,
 * ensuring that quota allocations persist until the consuming resources are removed. This creates
 * a stable quota environment where capacity allocations remain consistent across resource lifecycles.
 *
 * ### Core Relationships
 * - **Provides capacity to**: AllowanceBucket matching (spec.consumerRef, spec.allowances[].resourceType)
 * - **Consumed by**: ResourceClaim objects processed against the aggregated buckets
 * - **Validated against**: ResourceRegistration for each spec.allowances[].resourceType
 * - **Created by**: Administrators manually or GrantCreationPolicy automatically
 *
 * ### Quota Aggregation Logic
 * Multiple ResourceGrants for the same (consumer, resourceType) combination:
 * - Aggregate into a single AllowanceBucket for that combination
 * - All bucket amounts from all allowances are summed for total capacity
 * - Only Active grants contribute to the aggregated limit
 * - Inactive grants are excluded from quota calculations
 *
 * ### Grant vs Bucket Relationship
 * - **ResourceGrant**: Specifies intended quota allocations
 * - **AllowanceBucket**: Aggregates actual available quota from active grants
 * - **ResourceClaim**: Consumes quota from buckets (which source from grants)
 *
 * ### Allowance Structure
 * Each grant can contain multiple allowances for different resource types:
 * - All allowances share the same consumer (spec.consumerRef)
 * - Each allowance can have multiple buckets (for tracking, attribution, or incremental increases)
 * - Bucket amounts within an allowance are summed for that resource type
 *
 * ### Manual vs Automated Grants
 * **Manual Grants** (created by administrators):
 * - Explicit quota allocations for specific consumers
 * - Require direct management and updates
 * - Useful for base quotas, special allocations, or testing
 *
 * **Automated Grants** (created by GrantCreationPolicy):
 * - Generated based on resource lifecycle events
 * - Include labels/annotations for tracking policy source
 * - Automatically managed based on trigger conditions
 *
 * ### Validation Requirements
 * - Consumer type must match ResourceRegistration.spec.consumerType for each resource type
 * - All resource types must reference active ResourceRegistration objects
 * - Maximum 20 allowances per grant
 * - All amounts must be non-negative integers in BaseUnit
 *
 * ### Field Constraints and Limits
 * - Maximum 20 allowances per grant
 * - Each allowance must have at least 1 bucket
 * - Bucket amounts must be non-negative (0 is allowed but provides no quota)
 * - All amounts measured in BaseUnit from ResourceRegistration
 *
 * ### Status Information
 * - **Active condition**: Indicates whether grant is contributing to quota buckets
 * - **Validation errors**: Reported in condition message when Active=False
 * - **Processing status**: ObservedGeneration tracks spec changes
 *
 * ### Selectors and Filtering
 * - **Field selectors**: spec.consumerRef.kind, spec.consumerRef.name
 * - **Recommended labels** (add manually for better organization):
 *   - quota.miloapis.com/consumer-kind: Organization
 *   - quota.miloapis.com/consumer-name: acme-corp
 *   - quota.miloapis.com/source: policy-name or manual
 *   - quota.miloapis.com/tier: basic, premium, enterprise
 *
 * ### Common Queries
 * - All grants for a consumer: field selector spec.consumerRef.kind + spec.consumerRef.name
 * - Grants by source policy: label selector quota.miloapis.com/source=<policy-name>
 * - Grants by resource tier: label selector quota.miloapis.com/tier=<tier-name>
 * - Active vs inactive grants: check status.conditions[type=Active].status
 *
 * ### Cross-Cluster Allocation
 * GrantCreationPolicy can create grants in parent control planes for cross-cluster quota:
 * - Policy running in child cluster creates grants in parent cluster
 * - Grants provide capacity that spans multiple child clusters
 * - Enables centralized quota management across cluster hierarchies
 *
 * ### Troubleshooting
 * - **Inactive grants**: Check status.conditions[type=Active] for validation errors
 * - **Missing quota**: Verify grants are Active and contributing to correct buckets
 * - **Grant conflicts**: Multiple grants for same consumer+resourceType are aggregated, not conflicting
 *
 * ### Performance Considerations
 * - Large numbers of grants can impact bucket aggregation performance
 * - Consider consolidating grants where possible to reduce aggregation overhead
 * - Grant status updates are asynchronous and may lag spec changes
 */
export type Com_Miloapis_Quota_V1alpha1_ResourceGrant = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec;
  status?: Maybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Status>;
};

/** ResourceGrantList is a list of ResourceGrant */
export type Com_Miloapis_Quota_V1alpha1_ResourceGrantList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of resourcegrants. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Quota_V1alpha1_ResourceGrant>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * ResourceGrant allocates quota capacity to a consumer for specific resource types.
 * Grants provide the allowances that AllowanceBuckets aggregate to determine
 * available quota for ResourceClaim evaluation.
 *
 * ### How It Works
 * **ResourceGrants** begin their lifecycle when either an administrator creates them manually or a
 * **GrantCreationPolicy** generates them automatically in response to observed resource changes. Upon
 * creation, the grant enters a validation phase where the quota system examines the consumer type
 * to ensure it matches the expected `ConsumerType` from each **ResourceRegistration** targeted by
 * the grant's allowances. The quota system also verifies that all specified resource types correspond
 * to active registrations and that the allowance amounts are valid non-negative integers.
 *
 * When validation succeeds, the quota system marks the grant as `Active`, signaling to **AllowanceBucket**
 * resources that this grant should contribute to quota calculations. The bucket resources
 * continuously monitor for active grants and aggregate their allowance amounts into the appropriate
 * buckets based on consumer and resource type matching. This aggregation process makes the granted
 * quota capacity available for **ResourceClaim** consumption.
 *
 * **ResourceClaims** then consume the capacity that active grants provide, creating a flow from grants
 * through buckets to claims. The grant's capacity remains reserved as long as claims reference it,
 * ensuring that quota allocations persist until the consuming resources are removed. This creates
 * a stable quota environment where capacity allocations remain consistent across resource lifecycles.
 *
 * ### Core Relationships
 * - **Provides capacity to**: AllowanceBucket matching (spec.consumerRef, spec.allowances[].resourceType)
 * - **Consumed by**: ResourceClaim objects processed against the aggregated buckets
 * - **Validated against**: ResourceRegistration for each spec.allowances[].resourceType
 * - **Created by**: Administrators manually or GrantCreationPolicy automatically
 *
 * ### Quota Aggregation Logic
 * Multiple ResourceGrants for the same (consumer, resourceType) combination:
 * - Aggregate into a single AllowanceBucket for that combination
 * - All bucket amounts from all allowances are summed for total capacity
 * - Only Active grants contribute to the aggregated limit
 * - Inactive grants are excluded from quota calculations
 *
 * ### Grant vs Bucket Relationship
 * - **ResourceGrant**: Specifies intended quota allocations
 * - **AllowanceBucket**: Aggregates actual available quota from active grants
 * - **ResourceClaim**: Consumes quota from buckets (which source from grants)
 *
 * ### Allowance Structure
 * Each grant can contain multiple allowances for different resource types:
 * - All allowances share the same consumer (spec.consumerRef)
 * - Each allowance can have multiple buckets (for tracking, attribution, or incremental increases)
 * - Bucket amounts within an allowance are summed for that resource type
 *
 * ### Manual vs Automated Grants
 * **Manual Grants** (created by administrators):
 * - Explicit quota allocations for specific consumers
 * - Require direct management and updates
 * - Useful for base quotas, special allocations, or testing
 *
 * **Automated Grants** (created by GrantCreationPolicy):
 * - Generated based on resource lifecycle events
 * - Include labels/annotations for tracking policy source
 * - Automatically managed based on trigger conditions
 *
 * ### Validation Requirements
 * - Consumer type must match ResourceRegistration.spec.consumerType for each resource type
 * - All resource types must reference active ResourceRegistration objects
 * - Maximum 20 allowances per grant
 * - All amounts must be non-negative integers in BaseUnit
 *
 * ### Field Constraints and Limits
 * - Maximum 20 allowances per grant
 * - Each allowance must have at least 1 bucket
 * - Bucket amounts must be non-negative (0 is allowed but provides no quota)
 * - All amounts measured in BaseUnit from ResourceRegistration
 *
 * ### Status Information
 * - **Active condition**: Indicates whether grant is contributing to quota buckets
 * - **Validation errors**: Reported in condition message when Active=False
 * - **Processing status**: ObservedGeneration tracks spec changes
 *
 * ### Selectors and Filtering
 * - **Field selectors**: spec.consumerRef.kind, spec.consumerRef.name
 * - **Recommended labels** (add manually for better organization):
 *   - quota.miloapis.com/consumer-kind: Organization
 *   - quota.miloapis.com/consumer-name: acme-corp
 *   - quota.miloapis.com/source: policy-name or manual
 *   - quota.miloapis.com/tier: basic, premium, enterprise
 *
 * ### Common Queries
 * - All grants for a consumer: field selector spec.consumerRef.kind + spec.consumerRef.name
 * - Grants by source policy: label selector quota.miloapis.com/source=<policy-name>
 * - Grants by resource tier: label selector quota.miloapis.com/tier=<tier-name>
 * - Active vs inactive grants: check status.conditions[type=Active].status
 *
 * ### Cross-Cluster Allocation
 * GrantCreationPolicy can create grants in parent control planes for cross-cluster quota:
 * - Policy running in child cluster creates grants in parent cluster
 * - Grants provide capacity that spans multiple child clusters
 * - Enables centralized quota management across cluster hierarchies
 *
 * ### Troubleshooting
 * - **Inactive grants**: Check status.conditions[type=Active] for validation errors
 * - **Missing quota**: Verify grants are Active and contributing to correct buckets
 * - **Grant conflicts**: Multiple grants for same consumer+resourceType are aggregated, not conflicting
 *
 * ### Performance Considerations
 * - Large numbers of grants can impact bucket aggregation performance
 * - Consider consolidating grants where possible to reduce aggregation overhead
 * - Grant status updates are asynchronous and may lag spec changes
 */
export type Com_Miloapis_Quota_V1alpha1_ResourceGrant_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Status_Input>;
};

/**
 * ResourceRegistration enables quota tracking for a specific resource type.
 * Administrators create registrations to define measurement units, consumer relationships,
 * and claiming permissions.
 *
 * ### How It Works
 * - Administrators create registrations to enable quota tracking for specific resource types
 * - The system validates the registration and sets the "Active" condition when ready
 * - ResourceGrants can then allocate capacity for the registered resource type
 * - ResourceClaims can consume capacity when allowed resources are created
 *
 * ### Core Relationships
 * - **ResourceGrant.spec.allowances[].resourceType** must match this registration's **spec.resourceType**
 * - **ResourceClaim.spec.requests[].resourceType** must match this registration's **spec.resourceType**
 * - **ResourceClaim.spec.consumerRef** must match this registration's **spec.consumerType** type
 * - **ResourceClaim.spec.resourceRef** kind must be listed in this registration's **spec.claimingResources**
 *
 * ### Registration Lifecycle
 * 1. **Creation**: Administrator creates **ResourceRegistration** with resource type and consumer type
 * 2. **Validation**: System validates that referenced resource types exist and are accessible
 * 3. **Activation**: System sets `Active=True` condition when validation passes
 * 4. **Operation**: **ResourceGrants** and **ResourceClaims** can reference the active registration
 * 5. **Updates**: Only mutable fields (`description`, `claimingResources`) can be changed
 *
 * ### Status Conditions
 * - **Active=True**: Registration is validated and operational; grants and claims can use it
 * - **Active=False, reason=ValidationFailed**: Configuration errors prevent activation (check message)
 * - **Active=False, reason=RegistrationPending**: Quota system is processing the registration
 *
 * ### Measurement Types
 * - **Entity registrations** (`spec.type=Entity`): Count discrete resource instances (**Projects**, **Users**)
 * - **Allocation registrations** (`spec.type=Allocation`): Measure capacity amounts (CPU, memory, storage)
 *
 * ### Field Constraints and Limits
 * - Maximum 20 entries in **spec.claimingResources**
 * - **spec.resourceType**, **spec.consumerType**, and **spec.type** are immutable after creation
 * - **spec.description** maximum 500 characters
 * - **spec.baseUnit** and **spec.displayUnit** maximum 50 characters each
 * - **spec.unitConversionFactor** minimum value is 1
 *
 * ### Selectors and Filtering
 * - **Field selectors**: spec.consumerType.kind, spec.consumerType.apiGroup, spec.resourceType
 * - **Recommended labels** (add manually):
 *   - quota.miloapis.com/resource-kind: Project
 *   - quota.miloapis.com/resource-apigroup: resourcemanager.miloapis.com
 *   - quota.miloapis.com/consumer-kind: Organization
 *
 * ### Security Considerations
 * - Only include trusted resource types in **spec.claimingResources**
 * - Registrations are cluster-scoped and affect quota system-wide
 * - Consumer types must have appropriate RBAC permissions to create claims
 */
export type Com_Miloapis_Quota_V1alpha1_ResourceRegistration = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec;
  status?: Maybe<Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Status>;
};

/** ResourceRegistrationList is a list of ResourceRegistration */
export type Com_Miloapis_Quota_V1alpha1_ResourceRegistrationList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of resourceregistrations. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Quota_V1alpha1_ResourceRegistration>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * ResourceRegistration enables quota tracking for a specific resource type.
 * Administrators create registrations to define measurement units, consumer relationships,
 * and claiming permissions.
 *
 * ### How It Works
 * - Administrators create registrations to enable quota tracking for specific resource types
 * - The system validates the registration and sets the "Active" condition when ready
 * - ResourceGrants can then allocate capacity for the registered resource type
 * - ResourceClaims can consume capacity when allowed resources are created
 *
 * ### Core Relationships
 * - **ResourceGrant.spec.allowances[].resourceType** must match this registration's **spec.resourceType**
 * - **ResourceClaim.spec.requests[].resourceType** must match this registration's **spec.resourceType**
 * - **ResourceClaim.spec.consumerRef** must match this registration's **spec.consumerType** type
 * - **ResourceClaim.spec.resourceRef** kind must be listed in this registration's **spec.claimingResources**
 *
 * ### Registration Lifecycle
 * 1. **Creation**: Administrator creates **ResourceRegistration** with resource type and consumer type
 * 2. **Validation**: System validates that referenced resource types exist and are accessible
 * 3. **Activation**: System sets `Active=True` condition when validation passes
 * 4. **Operation**: **ResourceGrants** and **ResourceClaims** can reference the active registration
 * 5. **Updates**: Only mutable fields (`description`, `claimingResources`) can be changed
 *
 * ### Status Conditions
 * - **Active=True**: Registration is validated and operational; grants and claims can use it
 * - **Active=False, reason=ValidationFailed**: Configuration errors prevent activation (check message)
 * - **Active=False, reason=RegistrationPending**: Quota system is processing the registration
 *
 * ### Measurement Types
 * - **Entity registrations** (`spec.type=Entity`): Count discrete resource instances (**Projects**, **Users**)
 * - **Allocation registrations** (`spec.type=Allocation`): Measure capacity amounts (CPU, memory, storage)
 *
 * ### Field Constraints and Limits
 * - Maximum 20 entries in **spec.claimingResources**
 * - **spec.resourceType**, **spec.consumerType**, and **spec.type** are immutable after creation
 * - **spec.description** maximum 500 characters
 * - **spec.baseUnit** and **spec.displayUnit** maximum 50 characters each
 * - **spec.unitConversionFactor** minimum value is 1
 *
 * ### Selectors and Filtering
 * - **Field selectors**: spec.consumerType.kind, spec.consumerType.apiGroup, spec.resourceType
 * - **Recommended labels** (add manually):
 *   - quota.miloapis.com/resource-kind: Project
 *   - quota.miloapis.com/resource-apigroup: resourcemanager.miloapis.com
 *   - quota.miloapis.com/consumer-kind: Organization
 *
 * ### Security Considerations
 * - Only include trusted resource types in **spec.claimingResources**
 * - Registrations are cluster-scoped and affect quota system-wide
 * - Consumer types must have appropriate RBAC permissions to create claims
 */
export type Com_Miloapis_Quota_V1alpha1_ResourceRegistration_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Status_Input>;
};

/**
 * Use lowercase for path, which influences plural name. Ensure kind is Organization.
 * Organization is the Schema for the Organizations API
 */
export type Com_Miloapis_Resourcemanager_V1alpha1_Organization = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Spec;
  status?: Maybe<Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Status>;
};

/** OrganizationList is a list of Organization */
export type Com_Miloapis_Resourcemanager_V1alpha1_OrganizationList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of organizations. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Organization>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * OrganizationMembership establishes a user's membership in an organization and
 * optionally assigns roles to grant permissions. The controller automatically
 * manages PolicyBinding resources for each assigned role, simplifying access
 * control management.
 *
 * Key features:
 *   - Establishes user-organization relationship
 *   - Automatic PolicyBinding creation and deletion for assigned roles
 *   - Supports multiple roles per membership
 *   - Cross-namespace role references
 *   - Detailed status tracking with per-role reconciliation state
 *
 * Prerequisites:
 *   - User resource must exist
 *   - Organization resource must exist
 *   - Referenced Role resources must exist in their respective namespaces
 *
 * Example - Basic membership with role assignment:
 *
 * 	apiVersion: resourcemanager.miloapis.com/v1alpha1
 * 	kind: OrganizationMembership
 * 	metadata:
 * 	  name: jane-acme-membership
 * 	  namespace: organization-acme-corp
 * 	spec:
 * 	  organizationRef:
 * 	    name: acme-corp
 * 	  userRef:
 * 	    name: jane-doe
 * 	  roles:
 * 	  - name: organization-viewer
 * 	    namespace: organization-acme-corp
 *
 * Related resources:
 *   - User: The user being granted membership
 *   - Organization: The organization the user joins
 *   - Role: Defines permissions granted to the user
 *   - PolicyBinding: Automatically created by the controller for each role
 */
export type Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembership = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec>;
  status?: Maybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status>;
};

/** OrganizationMembershipList is a list of OrganizationMembership */
export type Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembershipList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of organizationmemberships. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembership>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * OrganizationMembership establishes a user's membership in an organization and
 * optionally assigns roles to grant permissions. The controller automatically
 * manages PolicyBinding resources for each assigned role, simplifying access
 * control management.
 *
 * Key features:
 *   - Establishes user-organization relationship
 *   - Automatic PolicyBinding creation and deletion for assigned roles
 *   - Supports multiple roles per membership
 *   - Cross-namespace role references
 *   - Detailed status tracking with per-role reconciliation state
 *
 * Prerequisites:
 *   - User resource must exist
 *   - Organization resource must exist
 *   - Referenced Role resources must exist in their respective namespaces
 *
 * Example - Basic membership with role assignment:
 *
 * 	apiVersion: resourcemanager.miloapis.com/v1alpha1
 * 	kind: OrganizationMembership
 * 	metadata:
 * 	  name: jane-acme-membership
 * 	  namespace: organization-acme-corp
 * 	spec:
 * 	  organizationRef:
 * 	    name: acme-corp
 * 	  userRef:
 * 	    name: jane-doe
 * 	  roles:
 * 	  - name: organization-viewer
 * 	    namespace: organization-acme-corp
 *
 * Related resources:
 *   - User: The user being granted membership
 *   - Organization: The organization the user joins
 *   - Role: Defines permissions granted to the user
 *   - PolicyBinding: Automatically created by the controller for each role
 */
export type Com_Miloapis_Resourcemanager_V1alpha1_OrganizationMembership_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec_Input>;
  status?: InputMaybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_Input>;
};

/**
 * Use lowercase for path, which influences plural name. Ensure kind is Organization.
 * Organization is the Schema for the Organizations API
 */
export type Com_Miloapis_Resourcemanager_V1alpha1_Organization_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Status_Input>;
};

/** Project is the Schema for the projects API. */
export type Com_Miloapis_Resourcemanager_V1alpha1_Project = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Spec;
  status?: Maybe<Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Status>;
};

/** ProjectList is a list of Project */
export type Com_Miloapis_Resourcemanager_V1alpha1_ProjectList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of projects. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Resourcemanager_V1alpha1_Project>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** Project is the Schema for the projects API. */
export type Com_Miloapis_Resourcemanager_V1alpha1_Project_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Status_Input>;
};

/** ExportPolicy is the Schema for the export policy API. */
export type Com_Miloapis_Telemetry_V1alpha1_ExportPolicy = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status>;
};

/** ExportPolicyList is a list of ExportPolicy */
export type Com_Miloapis_Telemetry_V1alpha1_ExportPolicyList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of exportpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Com_Miloapis_Telemetry_V1alpha1_ExportPolicy>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** ExportPolicy is the Schema for the export policy API. */
export type Com_Miloapis_Telemetry_V1alpha1_ExportPolicy_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Input>;
};

export type Ext4_Const = 'ext4';

export type Iam_Miloapis_Com_Const = 'iam_miloapis_com';

/**
 * Backend allows the user to configure the endpoints of a backend and
 * the behavior of the connection from Envoy Proxy to the backend.
 */
export type Io_Envoyproxy_Gateway_V1alpha1_Backend = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Status>;
};

/** BackendList is a list of Backend */
export type Io_Envoyproxy_Gateway_V1alpha1_BackendList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of backends. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Io_Envoyproxy_Gateway_V1alpha1_Backend>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * BackendTrafficPolicy allows the user to configure the behavior of the connection
 * between the Envoy Proxy listener and the backend service.
 */
export type Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicy = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status>;
};

/** BackendTrafficPolicyList is a list of BackendTrafficPolicy */
export type Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicyList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of backendtrafficpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicy>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * BackendTrafficPolicy allows the user to configure the behavior of the connection
 * between the Envoy Proxy listener and the backend service.
 */
export type Io_Envoyproxy_Gateway_V1alpha1_BackendTrafficPolicy_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * Backend allows the user to configure the endpoints of a backend and
 * the behavior of the connection from Envoy Proxy to the backend.
 */
export type Io_Envoyproxy_Gateway_V1alpha1_Backend_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * HTTPRouteFilter is a custom Envoy Gateway HTTPRouteFilter which provides extended
 * traffic processing options such as path regex rewrite, direct response and more.
 */
export type Io_Envoyproxy_Gateway_V1alpha1_HttpRouteFilter = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec;
};

/** HTTPRouteFilterList is a list of HTTPRouteFilter */
export type Io_Envoyproxy_Gateway_V1alpha1_HttpRouteFilterList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of httproutefilters. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Io_Envoyproxy_Gateway_V1alpha1_HttpRouteFilter>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * HTTPRouteFilter is a custom Envoy Gateway HTTPRouteFilter which provides extended
 * traffic processing options such as path regex rewrite, direct response and more.
 */
export type Io_Envoyproxy_Gateway_V1alpha1_HttpRouteFilter_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_Input;
};

/**
 * SecurityPolicy allows the user to configure various security settings for a
 * Gateway.
 */
export type Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicy = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec;
  status?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status>;
};

/** SecurityPolicyList is a list of SecurityPolicy */
export type Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicyList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of securitypolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicy>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * SecurityPolicy allows the user to configure various security settings for a
 * Gateway.
 */
export type Io_Envoyproxy_Gateway_V1alpha1_SecurityPolicy_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Input>;
};

/** AuditAnnotation describes how to produce an audit annotation for an API request. */
export type Io_K8s_Api_Admissionregistration_V1_AuditAnnotation = {
  /**
   * key specifies the audit annotation key. The audit annotation keys of a ValidatingAdmissionPolicy must be unique. The key must be a qualified name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
   *
   * The key is combined with the resource name of the ValidatingAdmissionPolicy to construct an audit annotation key: "{ValidatingAdmissionPolicy name}/{key}".
   *
   * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy and the same audit annotation key, the annotation key will be identical. In this case, the first annotation written with the key will be included in the audit event and all subsequent annotations with the same key will be discarded.
   *
   * Required.
   */
  key: Scalars['String']['output'];
  /**
   * valueExpression represents the expression which is evaluated by CEL to produce an audit annotation value. The expression must evaluate to either a string or null value. If the expression evaluates to a string, the audit annotation is included with the string value. If the expression evaluates to null or empty string the audit annotation will be omitted. The valueExpression may be no longer than 5kb in length. If the result of the valueExpression is more than 10kb in length, it will be truncated to 10kb.
   *
   * If multiple ValidatingAdmissionPolicyBinding resources match an API request, then the valueExpression will be evaluated for each binding. All unique values produced by the valueExpressions will be joined together in a comma-separated list.
   *
   * Required.
   */
  valueExpression: Scalars['String']['output'];
};

/** AuditAnnotation describes how to produce an audit annotation for an API request. */
export type Io_K8s_Api_Admissionregistration_V1_AuditAnnotation_Input = {
  /**
   * key specifies the audit annotation key. The audit annotation keys of a ValidatingAdmissionPolicy must be unique. The key must be a qualified name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
   *
   * The key is combined with the resource name of the ValidatingAdmissionPolicy to construct an audit annotation key: "{ValidatingAdmissionPolicy name}/{key}".
   *
   * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy and the same audit annotation key, the annotation key will be identical. In this case, the first annotation written with the key will be included in the audit event and all subsequent annotations with the same key will be discarded.
   *
   * Required.
   */
  key: Scalars['String']['input'];
  /**
   * valueExpression represents the expression which is evaluated by CEL to produce an audit annotation value. The expression must evaluate to either a string or null value. If the expression evaluates to a string, the audit annotation is included with the string value. If the expression evaluates to null or empty string the audit annotation will be omitted. The valueExpression may be no longer than 5kb in length. If the result of the valueExpression is more than 10kb in length, it will be truncated to 10kb.
   *
   * If multiple ValidatingAdmissionPolicyBinding resources match an API request, then the valueExpression will be evaluated for each binding. All unique values produced by the valueExpressions will be joined together in a comma-separated list.
   *
   * Required.
   */
  valueExpression: Scalars['String']['input'];
};

/** ExpressionWarning is a warning information that targets a specific expression. */
export type Io_K8s_Api_Admissionregistration_V1_ExpressionWarning = {
  /** The path to the field that refers the expression. For example, the reference to the expression of the first item of validations is "spec.validations[0].expression" */
  fieldRef: Scalars['String']['output'];
  /** The content of type checking information in a human-readable form. Each line of the warning contains the type that the expression is checked against, followed by the type check error from the compiler. */
  warning: Scalars['String']['output'];
};

/** ExpressionWarning is a warning information that targets a specific expression. */
export type Io_K8s_Api_Admissionregistration_V1_ExpressionWarning_Input = {
  /** The path to the field that refers the expression. For example, the reference to the expression of the first item of validations is "spec.validations[0].expression" */
  fieldRef: Scalars['String']['input'];
  /** The content of type checking information in a human-readable form. Each line of the warning contains the type that the expression is checked against, followed by the type check error from the compiler. */
  warning: Scalars['String']['input'];
};

/** MatchCondition represents a condition which must by fulfilled for a request to be sent to a webhook. */
export type Io_K8s_Api_Admissionregistration_V1_MatchCondition = {
  /**
   * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool. CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
   *
   * 'object' - The object from the incoming request. The value is null for DELETE requests. 'oldObject' - The existing object. The value is null for CREATE requests. 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest). 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
   *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
   * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
   *   request resource.
   * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
   *
   * Required.
   */
  expression: Scalars['String']['output'];
  /**
   * Name is an identifier for this match condition, used for strategic merging of MatchConditions, as well as providing an identifier for logging purposes. A good name should be descriptive of the associated expression. Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
   *
   * Required.
   */
  name: Scalars['String']['output'];
};

/** MatchCondition represents a condition which must by fulfilled for a request to be sent to a webhook. */
export type Io_K8s_Api_Admissionregistration_V1_MatchCondition_Input = {
  /**
   * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool. CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
   *
   * 'object' - The object from the incoming request. The value is null for DELETE requests. 'oldObject' - The existing object. The value is null for CREATE requests. 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest). 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
   *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
   * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
   *   request resource.
   * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
   *
   * Required.
   */
  expression: Scalars['String']['input'];
  /**
   * Name is an identifier for this match condition, used for strategic merging of MatchConditions, as well as providing an identifier for logging purposes. A good name should be descriptive of the associated expression. Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
   *
   * Required.
   */
  name: Scalars['String']['input'];
};

/** MatchResources decides whether to run the admission control policy on an object based on whether it meets the match criteria. The exclude rules take precedence over include rules (if a resource matches both, it is excluded) */
export type Io_K8s_Api_Admissionregistration_V1_MatchResources = {
  /** ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about. The exclude rules take precedence over include rules (if a resource matches both, it is excluded) */
  excludeResourceRules?: Maybe<
    Array<Maybe<Io_K8s_Api_Admissionregistration_V1_NamedRuleWithOperations>>
  >;
  matchPolicy?: Maybe<Query_ListAdmissionregistrationV1ValidatingAdmissionPolicy_OneOf_0_Items_Items_Spec_MatchConstraints_MatchPolicy>;
  namespaceSelector?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector>;
  objectSelector?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector>;
  /** ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches. The policy cares about an operation if it matches _any_ Rule. */
  resourceRules?: Maybe<Array<Maybe<Io_K8s_Api_Admissionregistration_V1_NamedRuleWithOperations>>>;
};

/** MatchResources decides whether to run the admission control policy on an object based on whether it meets the match criteria. The exclude rules take precedence over include rules (if a resource matches both, it is excluded) */
export type Io_K8s_Api_Admissionregistration_V1_MatchResources_Input = {
  /** ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about. The exclude rules take precedence over include rules (if a resource matches both, it is excluded) */
  excludeResourceRules?: InputMaybe<
    Array<InputMaybe<Io_K8s_Api_Admissionregistration_V1_NamedRuleWithOperations_Input>>
  >;
  matchPolicy?: InputMaybe<Query_ListAdmissionregistrationV1ValidatingAdmissionPolicy_OneOf_0_Items_Items_Spec_MatchConstraints_MatchPolicy>;
  namespaceSelector?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector_Input>;
  objectSelector?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector_Input>;
  /** ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches. The policy cares about an operation if it matches _any_ Rule. */
  resourceRules?: InputMaybe<
    Array<InputMaybe<Io_K8s_Api_Admissionregistration_V1_NamedRuleWithOperations_Input>>
  >;
};

/** MutatingWebhook describes an admission webhook and the resources and operations it applies to. */
export type Io_K8s_Api_Admissionregistration_V1_MutatingWebhook = {
  /** AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the Webhook expects. API server will try to use first version in the list which it supports. If none of the versions specified in this list supported by API server, validation will fail for this object. If a persisted webhook configuration specifies allowed versions and does not include any versions known to the API Server, calls to the webhook will fail and be subject to the failure policy. */
  admissionReviewVersions: Array<Maybe<Scalars['String']['output']>>;
  clientConfig: Io_K8s_Api_Admissionregistration_V1_WebhookClientConfig;
  failurePolicy?: Maybe<Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_FailurePolicy>;
  /**
   * MatchConditions is a list of conditions that must be met for a request to be sent to this webhook. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.
   *
   * The exact matching logic is (in order):
   *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
   *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
   *   3. If any matchCondition evaluates to an error (but none are FALSE):
   *      - If failurePolicy=Fail, reject the request
   *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
   */
  matchConditions?: Maybe<Array<Maybe<Io_K8s_Api_Admissionregistration_V1_MatchCondition>>>;
  matchPolicy?: Maybe<Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_MatchPolicy>;
  /** The name of the admission webhook. Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and kubernetes.io is the name of the organization. Required. */
  name: Scalars['String']['output'];
  namespaceSelector?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector>;
  objectSelector?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector>;
  reinvocationPolicy?: Maybe<Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_ReinvocationPolicy>;
  /** Rules describes what operations on what resources/subresources the webhook cares about. The webhook cares about an operation if it matches _any_ Rule. However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the cluster in a state which cannot be recovered from without completely disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects. */
  rules?: Maybe<Array<Maybe<Io_K8s_Api_Admissionregistration_V1_RuleWithOperations>>>;
  sideEffects: Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_SideEffects;
  /** TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the webhook call will be ignored or the API call will fail based on the failure policy. The timeout value must be between 1 and 30 seconds. Default to 10 seconds. */
  timeoutSeconds?: Maybe<Scalars['Int']['output']>;
};

/** MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object. */
export type Io_K8s_Api_Admissionregistration_V1_MutatingWebhookConfiguration = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  /** Webhooks is a list of webhooks and the affected resources and operations. */
  webhooks?: Maybe<Array<Maybe<Io_K8s_Api_Admissionregistration_V1_MutatingWebhook>>>;
};

/** MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration. */
export type Io_K8s_Api_Admissionregistration_V1_MutatingWebhookConfigurationList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of MutatingWebhookConfiguration. */
  items: Array<Maybe<Io_K8s_Api_Admissionregistration_V1_MutatingWebhookConfiguration>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object. */
export type Io_K8s_Api_Admissionregistration_V1_MutatingWebhookConfiguration_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  /** Webhooks is a list of webhooks and the affected resources and operations. */
  webhooks?: InputMaybe<
    Array<InputMaybe<Io_K8s_Api_Admissionregistration_V1_MutatingWebhook_Input>>
  >;
};

/** MutatingWebhook describes an admission webhook and the resources and operations it applies to. */
export type Io_K8s_Api_Admissionregistration_V1_MutatingWebhook_Input = {
  /** AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the Webhook expects. API server will try to use first version in the list which it supports. If none of the versions specified in this list supported by API server, validation will fail for this object. If a persisted webhook configuration specifies allowed versions and does not include any versions known to the API Server, calls to the webhook will fail and be subject to the failure policy. */
  admissionReviewVersions: Array<InputMaybe<Scalars['String']['input']>>;
  clientConfig: Io_K8s_Api_Admissionregistration_V1_WebhookClientConfig_Input;
  failurePolicy?: InputMaybe<Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_FailurePolicy>;
  /**
   * MatchConditions is a list of conditions that must be met for a request to be sent to this webhook. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.
   *
   * The exact matching logic is (in order):
   *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
   *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
   *   3. If any matchCondition evaluates to an error (but none are FALSE):
   *      - If failurePolicy=Fail, reject the request
   *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
   */
  matchConditions?: InputMaybe<
    Array<InputMaybe<Io_K8s_Api_Admissionregistration_V1_MatchCondition_Input>>
  >;
  matchPolicy?: InputMaybe<Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_MatchPolicy>;
  /** The name of the admission webhook. Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and kubernetes.io is the name of the organization. Required. */
  name: Scalars['String']['input'];
  namespaceSelector?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector_Input>;
  objectSelector?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector_Input>;
  reinvocationPolicy?: InputMaybe<Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_ReinvocationPolicy>;
  /** Rules describes what operations on what resources/subresources the webhook cares about. The webhook cares about an operation if it matches _any_ Rule. However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the cluster in a state which cannot be recovered from without completely disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects. */
  rules?: InputMaybe<
    Array<InputMaybe<Io_K8s_Api_Admissionregistration_V1_RuleWithOperations_Input>>
  >;
  sideEffects: Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_SideEffects;
  /** TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the webhook call will be ignored or the API call will fail based on the failure policy. The timeout value must be between 1 and 30 seconds. Default to 10 seconds. */
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

/** NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames. */
export type Io_K8s_Api_Admissionregistration_V1_NamedRuleWithOperations = {
  /** APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is present, the length of the slice must be one. Required. */
  apiGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is present, the length of the slice must be one. Required. */
  apiVersions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or * for all of those operations and any future admission operations that are added. If '*' is present, the length of the slice must be one. Required. */
  operations?: Maybe<
    Array<
      Maybe<Query_ListAdmissionregistrationV1ValidatingAdmissionPolicy_OneOf_0_Items_Items_Spec_MatchConstraints_ExcludeResourceRules_Items_Operations_Items>
    >
  >;
  /** ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed. */
  resourceNames?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * Resources is a list of resources this rule applies to.
   *
   * For example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means all resources, but not subresources. 'pods/*' means all subresources of pods. '*\/scale' means all scale subresources. '*\/*' means all resources and their subresources.
   *
   * If wildcard is present, the validation rule will ensure resources do not overlap with each other.
   *
   * Depending on the enclosing object, subresources might not be allowed. Required.
   */
  resources?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** scope specifies the scope of this rule. Valid values are "Cluster", "Namespaced", and "*" "Cluster" means that only cluster-scoped resources will match this rule. Namespace API objects are cluster-scoped. "Namespaced" means that only namespaced resources will match this rule. "*" means that there are no scope restrictions. Subresources match the scope of their parent resource. Default is "*". */
  scope?: Maybe<Scalars['String']['output']>;
};

/** NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames. */
export type Io_K8s_Api_Admissionregistration_V1_NamedRuleWithOperations_Input = {
  /** APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is present, the length of the slice must be one. Required. */
  apiGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is present, the length of the slice must be one. Required. */
  apiVersions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or * for all of those operations and any future admission operations that are added. If '*' is present, the length of the slice must be one. Required. */
  operations?: InputMaybe<
    Array<
      InputMaybe<Query_ListAdmissionregistrationV1ValidatingAdmissionPolicy_OneOf_0_Items_Items_Spec_MatchConstraints_ExcludeResourceRules_Items_Operations_Items>
    >
  >;
  /** ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed. */
  resourceNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Resources is a list of resources this rule applies to.
   *
   * For example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means all resources, but not subresources. 'pods/*' means all subresources of pods. '*\/scale' means all scale subresources. '*\/*' means all resources and their subresources.
   *
   * If wildcard is present, the validation rule will ensure resources do not overlap with each other.
   *
   * Depending on the enclosing object, subresources might not be allowed. Required.
   */
  resources?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** scope specifies the scope of this rule. Valid values are "Cluster", "Namespaced", and "*" "Cluster" means that only cluster-scoped resources will match this rule. Namespace API objects are cluster-scoped. "Namespaced" means that only namespaced resources will match this rule. "*" means that there are no scope restrictions. Subresources match the scope of their parent resource. Default is "*". */
  scope?: InputMaybe<Scalars['String']['input']>;
};

/** ParamKind is a tuple of Group Kind and Version. */
export type Io_K8s_Api_Admissionregistration_V1_ParamKind = {
  /** APIVersion is the API group version the resources belong to. In format of "group/version". Required. */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is the API kind the resources belong to. Required. */
  kind?: Maybe<Scalars['String']['output']>;
};

/** ParamKind is a tuple of Group Kind and Version. */
export type Io_K8s_Api_Admissionregistration_V1_ParamKind_Input = {
  /** APIVersion is the API group version the resources belong to. In format of "group/version". Required. */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is the API kind the resources belong to. Required. */
  kind?: InputMaybe<Scalars['String']['input']>;
};

/** ParamRef describes how to locate the params to be used as input to expressions of rules applied by a policy binding. */
export type Io_K8s_Api_Admissionregistration_V1_ParamRef = {
  /**
   * name is the name of the resource being referenced.
   *
   * One of `name` or `selector` must be set, but `name` and `selector` are mutually exclusive properties. If one is set, the other must be unset.
   *
   * A single parameter used for all admission requests can be configured by setting the `name` field, leaving `selector` blank, and setting namespace if `paramKind` is namespace-scoped.
   */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * namespace is the namespace of the referenced resource. Allows limiting the search for params to a specific namespace. Applies to both `name` and `selector` fields.
   *
   * A per-namespace parameter may be used by specifying a namespace-scoped `paramKind` in the policy and leaving this field empty.
   *
   * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this field results in a configuration error.
   *
   * - If `paramKind` is namespace-scoped, the namespace of the object being evaluated for admission will be used when this field is left unset. Take care that if this is left empty the binding must not match any cluster-scoped resources, which will result in an error.
   */
  namespace?: Maybe<Scalars['String']['output']>;
  /**
   * `parameterNotFoundAction` controls the behavior of the binding when the resource exists, and name or selector is valid, but there are no parameters matched by the binding. If the value is set to `Allow`, then no matched parameters will be treated as successful validation by the binding. If set to `Deny`, then no matched parameters will be subject to the `failurePolicy` of the policy.
   *
   * Allowed values are `Allow` or `Deny`
   *
   * Required
   */
  parameterNotFoundAction?: Maybe<Scalars['String']['output']>;
  selector?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector>;
};

/** ParamRef describes how to locate the params to be used as input to expressions of rules applied by a policy binding. */
export type Io_K8s_Api_Admissionregistration_V1_ParamRef_Input = {
  /**
   * name is the name of the resource being referenced.
   *
   * One of `name` or `selector` must be set, but `name` and `selector` are mutually exclusive properties. If one is set, the other must be unset.
   *
   * A single parameter used for all admission requests can be configured by setting the `name` field, leaving `selector` blank, and setting namespace if `paramKind` is namespace-scoped.
   */
  name?: InputMaybe<Scalars['String']['input']>;
  /**
   * namespace is the namespace of the referenced resource. Allows limiting the search for params to a specific namespace. Applies to both `name` and `selector` fields.
   *
   * A per-namespace parameter may be used by specifying a namespace-scoped `paramKind` in the policy and leaving this field empty.
   *
   * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this field results in a configuration error.
   *
   * - If `paramKind` is namespace-scoped, the namespace of the object being evaluated for admission will be used when this field is left unset. Take care that if this is left empty the binding must not match any cluster-scoped resources, which will result in an error.
   */
  namespace?: InputMaybe<Scalars['String']['input']>;
  /**
   * `parameterNotFoundAction` controls the behavior of the binding when the resource exists, and name or selector is valid, but there are no parameters matched by the binding. If the value is set to `Allow`, then no matched parameters will be treated as successful validation by the binding. If set to `Deny`, then no matched parameters will be subject to the `failurePolicy` of the policy.
   *
   * Allowed values are `Allow` or `Deny`
   *
   * Required
   */
  parameterNotFoundAction?: InputMaybe<Scalars['String']['input']>;
  selector?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector_Input>;
};

/** RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure that all the tuple expansions are valid. */
export type Io_K8s_Api_Admissionregistration_V1_RuleWithOperations = {
  /** APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is present, the length of the slice must be one. Required. */
  apiGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is present, the length of the slice must be one. Required. */
  apiVersions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or * for all of those operations and any future admission operations that are added. If '*' is present, the length of the slice must be one. Required. */
  operations?: Maybe<
    Array<
      Maybe<Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_Rules_Items_Operations_Items>
    >
  >;
  /**
   * Resources is a list of resources this rule applies to.
   *
   * For example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means all resources, but not subresources. 'pods/*' means all subresources of pods. '*\/scale' means all scale subresources. '*\/*' means all resources and their subresources.
   *
   * If wildcard is present, the validation rule will ensure resources do not overlap with each other.
   *
   * Depending on the enclosing object, subresources might not be allowed. Required.
   */
  resources?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** scope specifies the scope of this rule. Valid values are "Cluster", "Namespaced", and "*" "Cluster" means that only cluster-scoped resources will match this rule. Namespace API objects are cluster-scoped. "Namespaced" means that only namespaced resources will match this rule. "*" means that there are no scope restrictions. Subresources match the scope of their parent resource. Default is "*". */
  scope?: Maybe<Scalars['String']['output']>;
};

/** RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure that all the tuple expansions are valid. */
export type Io_K8s_Api_Admissionregistration_V1_RuleWithOperations_Input = {
  /** APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is present, the length of the slice must be one. Required. */
  apiGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is present, the length of the slice must be one. Required. */
  apiVersions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or * for all of those operations and any future admission operations that are added. If '*' is present, the length of the slice must be one. Required. */
  operations?: InputMaybe<
    Array<
      InputMaybe<Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_Rules_Items_Operations_Items>
    >
  >;
  /**
   * Resources is a list of resources this rule applies to.
   *
   * For example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means all resources, but not subresources. 'pods/*' means all subresources of pods. '*\/scale' means all scale subresources. '*\/*' means all resources and their subresources.
   *
   * If wildcard is present, the validation rule will ensure resources do not overlap with each other.
   *
   * Depending on the enclosing object, subresources might not be allowed. Required.
   */
  resources?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** scope specifies the scope of this rule. Valid values are "Cluster", "Namespaced", and "*" "Cluster" means that only cluster-scoped resources will match this rule. Namespace API objects are cluster-scoped. "Namespaced" means that only namespaced resources will match this rule. "*" means that there are no scope restrictions. Subresources match the scope of their parent resource. Default is "*". */
  scope?: InputMaybe<Scalars['String']['input']>;
};

/** ServiceReference holds a reference to Service.legacy.k8s.io */
export type Io_K8s_Api_Admissionregistration_V1_ServiceReference = {
  /** `name` is the name of the service. Required */
  name: Scalars['String']['output'];
  /** `namespace` is the namespace of the service. Required */
  namespace: Scalars['String']['output'];
  /** `path` is an optional URL path which will be sent in any request to this service. */
  path?: Maybe<Scalars['String']['output']>;
  /** If specified, the port on the service that hosting webhook. Default to 443 for backward compatibility. `port` should be a valid port number (1-65535, inclusive). */
  port?: Maybe<Scalars['Int']['output']>;
};

/** ServiceReference holds a reference to Service.legacy.k8s.io */
export type Io_K8s_Api_Admissionregistration_V1_ServiceReference_Input = {
  /** `name` is the name of the service. Required */
  name: Scalars['String']['input'];
  /** `namespace` is the namespace of the service. Required */
  namespace: Scalars['String']['input'];
  /** `path` is an optional URL path which will be sent in any request to this service. */
  path?: InputMaybe<Scalars['String']['input']>;
  /** If specified, the port on the service that hosting webhook. Default to 443 for backward compatibility. `port` should be a valid port number (1-65535, inclusive). */
  port?: InputMaybe<Scalars['Int']['input']>;
};

/** TypeChecking contains results of type checking the expressions in the ValidatingAdmissionPolicy */
export type Io_K8s_Api_Admissionregistration_V1_TypeChecking = {
  /** The type checking warnings for each expression. */
  expressionWarnings?: Maybe<Array<Maybe<Io_K8s_Api_Admissionregistration_V1_ExpressionWarning>>>;
};

/** TypeChecking contains results of type checking the expressions in the ValidatingAdmissionPolicy */
export type Io_K8s_Api_Admissionregistration_V1_TypeChecking_Input = {
  /** The type checking warnings for each expression. */
  expressionWarnings?: InputMaybe<
    Array<InputMaybe<Io_K8s_Api_Admissionregistration_V1_ExpressionWarning_Input>>
  >;
};

/** ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicy = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicySpec>;
  status?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyStatus>;
};

/**
 * ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters.
 *
 * For a given admission request, each binding will cause its policy to be evaluated N times, where N is 1 for policies/bindings that don't use params, otherwise N is the number of parameters selected by the binding.
 *
 * The CEL expressions of a policy must have a computed CEL cost below the maximum CEL budget. Each evaluation of the policy is given an independent CEL cost budget. Adding/removing policies, bindings, or params can not affect whether a given (policy, binding, param) combination is within its own CEL budget.
 */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBinding = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBindingSpec>;
};

/** ValidatingAdmissionPolicyBindingList is a list of ValidatingAdmissionPolicyBinding. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBindingList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of PolicyBinding. */
  items: Array<Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBinding>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** ValidatingAdmissionPolicyBindingSpec is the specification of the ValidatingAdmissionPolicyBinding. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBindingSpec = {
  matchResources?: Maybe<Io_K8s_Api_Admissionregistration_V1_MatchResources>;
  paramRef?: Maybe<Io_K8s_Api_Admissionregistration_V1_ParamRef>;
  /** PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to. If the referenced resource does not exist, this binding is considered invalid and will be ignored Required. */
  policyName?: Maybe<Scalars['String']['output']>;
  /**
   * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced. If a validation evaluates to false it is always enforced according to these actions.
   *
   * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according to these actions only if the FailurePolicy is set to Fail, otherwise the failures are ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
   *
   * validationActions is declared as a set of action values. Order does not matter. validationActions may not contain duplicates of the same action.
   *
   * The supported actions values are:
   *
   * "Deny" specifies that a validation failure results in a denied request.
   *
   * "Warn" specifies that a validation failure is reported to the request client in HTTP Warning headers, with a warning code of 299. Warnings can be sent both for allowed or denied admission responses.
   *
   * "Audit" specifies that a validation failure is included in the published audit event for the request. The audit event will contain a `validation.policy.admission.k8s.io/validation_failure` audit annotation with a value containing the details of the validation failures, formatted as a JSON list of objects, each with the following fields: - message: The validation failure message string - policy: The resource name of the ValidatingAdmissionPolicy - binding: The resource name of the ValidatingAdmissionPolicyBinding - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy - validationActions: The enforcement actions enacted for the validation failure Example audit annotation: `"validation.policy.admission.k8s.io/validation_failure": "[{\"message\": \"Invalid value\", {\"policy\": \"policy.example.com\", {\"binding\": \"policybinding.example.com\", {\"expressionIndex\": \"1\", {\"validationActions\": [\"Audit\"]}]"`
   *
   * Clients should expect to handle additional values by ignoring any values not recognized.
   *
   * "Deny" and "Warn" may not be used together since this combination needlessly duplicates the validation failure both in the API response body and the HTTP warning headers.
   *
   * Required.
   */
  validationActions?: Maybe<
    Array<
      Maybe<Query_ListAdmissionregistrationV1ValidatingAdmissionPolicyBinding_OneOf_0_Items_Items_Spec_ValidationActions_Items>
    >
  >;
};

/** ValidatingAdmissionPolicyBindingSpec is the specification of the ValidatingAdmissionPolicyBinding. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBindingSpec_Input = {
  matchResources?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_MatchResources_Input>;
  paramRef?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_ParamRef_Input>;
  /** PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to. If the referenced resource does not exist, this binding is considered invalid and will be ignored Required. */
  policyName?: InputMaybe<Scalars['String']['input']>;
  /**
   * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced. If a validation evaluates to false it is always enforced according to these actions.
   *
   * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according to these actions only if the FailurePolicy is set to Fail, otherwise the failures are ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
   *
   * validationActions is declared as a set of action values. Order does not matter. validationActions may not contain duplicates of the same action.
   *
   * The supported actions values are:
   *
   * "Deny" specifies that a validation failure results in a denied request.
   *
   * "Warn" specifies that a validation failure is reported to the request client in HTTP Warning headers, with a warning code of 299. Warnings can be sent both for allowed or denied admission responses.
   *
   * "Audit" specifies that a validation failure is included in the published audit event for the request. The audit event will contain a `validation.policy.admission.k8s.io/validation_failure` audit annotation with a value containing the details of the validation failures, formatted as a JSON list of objects, each with the following fields: - message: The validation failure message string - policy: The resource name of the ValidatingAdmissionPolicy - binding: The resource name of the ValidatingAdmissionPolicyBinding - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy - validationActions: The enforcement actions enacted for the validation failure Example audit annotation: `"validation.policy.admission.k8s.io/validation_failure": "[{\"message\": \"Invalid value\", {\"policy\": \"policy.example.com\", {\"binding\": \"policybinding.example.com\", {\"expressionIndex\": \"1\", {\"validationActions\": [\"Audit\"]}]"`
   *
   * Clients should expect to handle additional values by ignoring any values not recognized.
   *
   * "Deny" and "Warn" may not be used together since this combination needlessly duplicates the validation failure both in the API response body and the HTTP warning headers.
   *
   * Required.
   */
  validationActions?: InputMaybe<
    Array<
      InputMaybe<Query_ListAdmissionregistrationV1ValidatingAdmissionPolicyBinding_OneOf_0_Items_Items_Spec_ValidationActions_Items>
    >
  >;
};

/**
 * ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters.
 *
 * For a given admission request, each binding will cause its policy to be evaluated N times, where N is 1 for policies/bindings that don't use params, otherwise N is the number of parameters selected by the binding.
 *
 * The CEL expressions of a policy must have a computed CEL cost below the maximum CEL budget. Each evaluation of the policy is given an independent CEL cost budget. Adding/removing policies, bindings, or params can not affect whether a given (policy, binding, param) combination is within its own CEL budget.
 */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBinding_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyBindingSpec_Input>;
};

/** ValidatingAdmissionPolicyList is a list of ValidatingAdmissionPolicy. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of ValidatingAdmissionPolicy. */
  items: Array<Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicy>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** ValidatingAdmissionPolicySpec is the specification of the desired behavior of the AdmissionPolicy. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicySpec = {
  /** auditAnnotations contains CEL expressions which are used to produce audit annotations for the audit event of the API request. validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is required. */
  auditAnnotations?: Maybe<Array<Maybe<Io_K8s_Api_Admissionregistration_V1_AuditAnnotation>>>;
  failurePolicy?: Maybe<Query_ListAdmissionregistrationV1ValidatingAdmissionPolicy_OneOf_0_Items_Items_Spec_FailurePolicy>;
  /**
   * MatchConditions is a list of conditions that must be met for a request to be validated. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.
   *
   * If a parameter object is provided, it can be accessed via the `params` handle in the same manner as validation expressions.
   *
   * The exact matching logic is (in order):
   *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
   *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
   *   3. If any matchCondition evaluates to an error (but none are FALSE):
   *      - If failurePolicy=Fail, reject the request
   *      - If failurePolicy=Ignore, the policy is skipped
   */
  matchConditions?: Maybe<Array<Maybe<Io_K8s_Api_Admissionregistration_V1_MatchCondition>>>;
  matchConstraints?: Maybe<Io_K8s_Api_Admissionregistration_V1_MatchResources>;
  paramKind?: Maybe<Io_K8s_Api_Admissionregistration_V1_ParamKind>;
  /** Validations contain CEL expressions which is used to apply the validation. Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is required. */
  validations?: Maybe<Array<Maybe<Io_K8s_Api_Admissionregistration_V1_Validation>>>;
  /**
   * Variables contain definitions of variables that can be used in composition of other expressions. Each variable is defined as a named CEL expression. The variables defined here will be available under `variables` in other expressions of the policy except MatchConditions because MatchConditions are evaluated before the rest of the policy.
   *
   * The expression of a variable can refer to other variables defined earlier in the list but not those after. Thus, Variables must be sorted by the order of first appearance and acyclic.
   */
  variables?: Maybe<Array<Maybe<Io_K8s_Api_Admissionregistration_V1_Variable>>>;
};

/** ValidatingAdmissionPolicySpec is the specification of the desired behavior of the AdmissionPolicy. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicySpec_Input = {
  /** auditAnnotations contains CEL expressions which are used to produce audit annotations for the audit event of the API request. validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is required. */
  auditAnnotations?: InputMaybe<
    Array<InputMaybe<Io_K8s_Api_Admissionregistration_V1_AuditAnnotation_Input>>
  >;
  failurePolicy?: InputMaybe<Query_ListAdmissionregistrationV1ValidatingAdmissionPolicy_OneOf_0_Items_Items_Spec_FailurePolicy>;
  /**
   * MatchConditions is a list of conditions that must be met for a request to be validated. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.
   *
   * If a parameter object is provided, it can be accessed via the `params` handle in the same manner as validation expressions.
   *
   * The exact matching logic is (in order):
   *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
   *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
   *   3. If any matchCondition evaluates to an error (but none are FALSE):
   *      - If failurePolicy=Fail, reject the request
   *      - If failurePolicy=Ignore, the policy is skipped
   */
  matchConditions?: InputMaybe<
    Array<InputMaybe<Io_K8s_Api_Admissionregistration_V1_MatchCondition_Input>>
  >;
  matchConstraints?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_MatchResources_Input>;
  paramKind?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_ParamKind_Input>;
  /** Validations contain CEL expressions which is used to apply the validation. Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is required. */
  validations?: InputMaybe<Array<InputMaybe<Io_K8s_Api_Admissionregistration_V1_Validation_Input>>>;
  /**
   * Variables contain definitions of variables that can be used in composition of other expressions. Each variable is defined as a named CEL expression. The variables defined here will be available under `variables` in other expressions of the policy except MatchConditions because MatchConditions are evaluated before the rest of the policy.
   *
   * The expression of a variable can refer to other variables defined earlier in the list but not those after. Thus, Variables must be sorted by the order of first appearance and acyclic.
   */
  variables?: InputMaybe<Array<InputMaybe<Io_K8s_Api_Admissionregistration_V1_Variable_Input>>>;
};

/** ValidatingAdmissionPolicyStatus represents the status of an admission validation policy. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyStatus = {
  /** The conditions represent the latest available observations of a policy's current state. */
  conditions?: Maybe<Array<Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Condition>>>;
  /** The generation observed by the controller. */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
  typeChecking?: Maybe<Io_K8s_Api_Admissionregistration_V1_TypeChecking>;
};

/** ValidatingAdmissionPolicyStatus represents the status of an admission validation policy. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyStatus_Input = {
  /** The conditions represent the latest available observations of a policy's current state. */
  conditions?: InputMaybe<Array<InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Condition_Input>>>;
  /** The generation observed by the controller. */
  observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
  typeChecking?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_TypeChecking_Input>;
};

/** ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicy_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicySpec_Input>;
  status?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_ValidatingAdmissionPolicyStatus_Input>;
};

/** ValidatingWebhook describes an admission webhook and the resources and operations it applies to. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingWebhook = {
  /** AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the Webhook expects. API server will try to use first version in the list which it supports. If none of the versions specified in this list supported by API server, validation will fail for this object. If a persisted webhook configuration specifies allowed versions and does not include any versions known to the API Server, calls to the webhook will fail and be subject to the failure policy. */
  admissionReviewVersions: Array<Maybe<Scalars['String']['output']>>;
  clientConfig: Io_K8s_Api_Admissionregistration_V1_WebhookClientConfig;
  failurePolicy?: Maybe<Query_ListAdmissionregistrationV1ValidatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_FailurePolicy>;
  /**
   * MatchConditions is a list of conditions that must be met for a request to be sent to this webhook. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.
   *
   * The exact matching logic is (in order):
   *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
   *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
   *   3. If any matchCondition evaluates to an error (but none are FALSE):
   *      - If failurePolicy=Fail, reject the request
   *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
   */
  matchConditions?: Maybe<Array<Maybe<Io_K8s_Api_Admissionregistration_V1_MatchCondition>>>;
  matchPolicy?: Maybe<Query_ListAdmissionregistrationV1ValidatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_MatchPolicy>;
  /** The name of the admission webhook. Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and kubernetes.io is the name of the organization. Required. */
  name: Scalars['String']['output'];
  namespaceSelector?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector>;
  objectSelector?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector>;
  /** Rules describes what operations on what resources/subresources the webhook cares about. The webhook cares about an operation if it matches _any_ Rule. However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the cluster in a state which cannot be recovered from without completely disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects. */
  rules?: Maybe<Array<Maybe<Io_K8s_Api_Admissionregistration_V1_RuleWithOperations>>>;
  sideEffects: Query_ListAdmissionregistrationV1ValidatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_SideEffects;
  /** TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the webhook call will be ignored or the API call will fail based on the failure policy. The timeout value must be between 1 and 30 seconds. Default to 10 seconds. */
  timeoutSeconds?: Maybe<Scalars['Int']['output']>;
};

/** ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingWebhookConfiguration = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  /** Webhooks is a list of webhooks and the affected resources and operations. */
  webhooks?: Maybe<Array<Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingWebhook>>>;
};

/** ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingWebhookConfigurationList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of ValidatingWebhookConfiguration. */
  items: Array<Maybe<Io_K8s_Api_Admissionregistration_V1_ValidatingWebhookConfiguration>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingWebhookConfiguration_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  /** Webhooks is a list of webhooks and the affected resources and operations. */
  webhooks?: InputMaybe<
    Array<InputMaybe<Io_K8s_Api_Admissionregistration_V1_ValidatingWebhook_Input>>
  >;
};

/** ValidatingWebhook describes an admission webhook and the resources and operations it applies to. */
export type Io_K8s_Api_Admissionregistration_V1_ValidatingWebhook_Input = {
  /** AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the Webhook expects. API server will try to use first version in the list which it supports. If none of the versions specified in this list supported by API server, validation will fail for this object. If a persisted webhook configuration specifies allowed versions and does not include any versions known to the API Server, calls to the webhook will fail and be subject to the failure policy. */
  admissionReviewVersions: Array<InputMaybe<Scalars['String']['input']>>;
  clientConfig: Io_K8s_Api_Admissionregistration_V1_WebhookClientConfig_Input;
  failurePolicy?: InputMaybe<Query_ListAdmissionregistrationV1ValidatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_FailurePolicy>;
  /**
   * MatchConditions is a list of conditions that must be met for a request to be sent to this webhook. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.
   *
   * The exact matching logic is (in order):
   *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
   *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
   *   3. If any matchCondition evaluates to an error (but none are FALSE):
   *      - If failurePolicy=Fail, reject the request
   *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
   */
  matchConditions?: InputMaybe<
    Array<InputMaybe<Io_K8s_Api_Admissionregistration_V1_MatchCondition_Input>>
  >;
  matchPolicy?: InputMaybe<Query_ListAdmissionregistrationV1ValidatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_MatchPolicy>;
  /** The name of the admission webhook. Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and kubernetes.io is the name of the organization. Required. */
  name: Scalars['String']['input'];
  namespaceSelector?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector_Input>;
  objectSelector?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector_Input>;
  /** Rules describes what operations on what resources/subresources the webhook cares about. The webhook cares about an operation if it matches _any_ Rule. However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the cluster in a state which cannot be recovered from without completely disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects. */
  rules?: InputMaybe<
    Array<InputMaybe<Io_K8s_Api_Admissionregistration_V1_RuleWithOperations_Input>>
  >;
  sideEffects: Query_ListAdmissionregistrationV1ValidatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_SideEffects;
  /** TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the webhook call will be ignored or the API call will fail based on the failure policy. The timeout value must be between 1 and 30 seconds. Default to 10 seconds. */
  timeoutSeconds?: InputMaybe<Scalars['Int']['input']>;
};

/** Validation specifies the CEL expression which is used to apply the validation. */
export type Io_K8s_Api_Admissionregistration_V1_Validation = {
  /**
   * Expression represents the expression which will be evaluated by CEL. ref: https://github.com/google/cel-spec CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
   *
   * - 'object' - The object from the incoming request. The value is null for DELETE requests. - 'oldObject' - The existing object. The value is null for CREATE requests. - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)). - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind. - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources. - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
   *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
   * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
   *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
   * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
   *   request resource.
   *
   * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the object. No other metadata properties are accessible.
   *
   * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible. Accessible property names are escaped according to the following rules when accessed in the expression: - '__' escapes to '__underscores__' - '.' escapes to '__dot__' - '-' escapes to '__dash__' - '/' escapes to '__slash__' - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
   * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
   * 	  "import", "let", "loop", "package", "namespace", "return".
   * Examples:
   *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ > 0"}
   *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop > 0"}
   *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d > 0"}
   *
   * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1]. Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
   *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
   *     non-intersecting elements in `Y` are appended, retaining their partial order.
   *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
   *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
   *     non-intersecting keys are appended, retaining their partial order.
   * Required.
   */
  expression: Scalars['String']['output'];
  /** Message represents the message displayed when validation fails. The message is required if the Expression contains line breaks. The message must not contain line breaks. If unset, the message is "failed rule: {Rule}". e.g. "must be a URL with the host matching spec.host" If the Expression contains line breaks. Message is required. The message must not contain line breaks. If unset, the message is "failed Expression: {Expression}". */
  message?: Maybe<Scalars['String']['output']>;
  /** messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails. Since messageExpression is used as a failure message, it must evaluate to a string. If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails. If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged. messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'. Example: "object.x must be less than max ("+string(params.max)+")" */
  messageExpression?: Maybe<Scalars['String']['output']>;
  /** Reason represents a machine-readable description of why this validation failed. If this is the first validation in the list to fail, this reason, as well as the corresponding HTTP response code, are used in the HTTP response to the client. The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge". If not set, StatusReasonInvalid is used in the response to the client. */
  reason?: Maybe<Scalars['String']['output']>;
};

/** Validation specifies the CEL expression which is used to apply the validation. */
export type Io_K8s_Api_Admissionregistration_V1_Validation_Input = {
  /**
   * Expression represents the expression which will be evaluated by CEL. ref: https://github.com/google/cel-spec CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
   *
   * - 'object' - The object from the incoming request. The value is null for DELETE requests. - 'oldObject' - The existing object. The value is null for CREATE requests. - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)). - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind. - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources. - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
   *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
   * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
   *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
   * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
   *   request resource.
   *
   * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the object. No other metadata properties are accessible.
   *
   * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible. Accessible property names are escaped according to the following rules when accessed in the expression: - '__' escapes to '__underscores__' - '.' escapes to '__dot__' - '-' escapes to '__dash__' - '/' escapes to '__slash__' - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
   * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
   * 	  "import", "let", "loop", "package", "namespace", "return".
   * Examples:
   *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ > 0"}
   *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop > 0"}
   *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d > 0"}
   *
   * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1]. Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
   *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
   *     non-intersecting elements in `Y` are appended, retaining their partial order.
   *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
   *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
   *     non-intersecting keys are appended, retaining their partial order.
   * Required.
   */
  expression: Scalars['String']['input'];
  /** Message represents the message displayed when validation fails. The message is required if the Expression contains line breaks. The message must not contain line breaks. If unset, the message is "failed rule: {Rule}". e.g. "must be a URL with the host matching spec.host" If the Expression contains line breaks. Message is required. The message must not contain line breaks. If unset, the message is "failed Expression: {Expression}". */
  message?: InputMaybe<Scalars['String']['input']>;
  /** messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails. Since messageExpression is used as a failure message, it must evaluate to a string. If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails. If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged. messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'. Example: "object.x must be less than max ("+string(params.max)+")" */
  messageExpression?: InputMaybe<Scalars['String']['input']>;
  /** Reason represents a machine-readable description of why this validation failed. If this is the first validation in the list to fail, this reason, as well as the corresponding HTTP response code, are used in the HTTP response to the client. The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge". If not set, StatusReasonInvalid is used in the response to the client. */
  reason?: InputMaybe<Scalars['String']['input']>;
};

/** Variable is the definition of a variable that is used for composition. A variable is defined as a named expression. */
export type Io_K8s_Api_Admissionregistration_V1_Variable = {
  /** Expression is the expression that will be evaluated as the value of the variable. The CEL expression has access to the same identifiers as the CEL expressions in Validation. */
  expression: Scalars['String']['output'];
  /** Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables. The variable can be accessed in other expressions through `variables` For example, if name is "foo", the variable will be available as `variables.foo` */
  name: Scalars['String']['output'];
};

/** Variable is the definition of a variable that is used for composition. A variable is defined as a named expression. */
export type Io_K8s_Api_Admissionregistration_V1_Variable_Input = {
  /** Expression is the expression that will be evaluated as the value of the variable. The CEL expression has access to the same identifiers as the CEL expressions in Validation. */
  expression: Scalars['String']['input'];
  /** Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables. The variable can be accessed in other expressions through `variables` For example, if name is "foo", the variable will be available as `variables.foo` */
  name: Scalars['String']['input'];
};

/** WebhookClientConfig contains the information to make a TLS connection with the webhook */
export type Io_K8s_Api_Admissionregistration_V1_WebhookClientConfig = {
  /** `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate. If unspecified, system trust roots on the apiserver are used. */
  caBundle?: Maybe<Scalars['Byte']['output']>;
  service?: Maybe<Io_K8s_Api_Admissionregistration_V1_ServiceReference>;
  /**
   * `url` gives the location of the webhook, in standard URL form (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.
   *
   * The `host` should not refer to a service running in the cluster; use the `service` field instead. The host might be resolved via external DNS in some apiservers (e.g., `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation). `host` may also be an IP address.
   *
   * Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take great care to run this webhook on all hosts which run an apiserver which might need to make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn up in a new cluster.
   *
   * The scheme must be "https"; the URL must begin with "https://".
   *
   * A path is optional, and if present may be any string permissible in a URL. You may use the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
   *
   * Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments ("#...") and query parameters ("?...") are not allowed, either.
   */
  url?: Maybe<Scalars['String']['output']>;
};

/** WebhookClientConfig contains the information to make a TLS connection with the webhook */
export type Io_K8s_Api_Admissionregistration_V1_WebhookClientConfig_Input = {
  /** `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate. If unspecified, system trust roots on the apiserver are used. */
  caBundle?: InputMaybe<Scalars['Byte']['input']>;
  service?: InputMaybe<Io_K8s_Api_Admissionregistration_V1_ServiceReference_Input>;
  /**
   * `url` gives the location of the webhook, in standard URL form (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.
   *
   * The `host` should not refer to a service running in the cluster; use the `service` field instead. The host might be resolved via external DNS in some apiservers (e.g., `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation). `host` may also be an IP address.
   *
   * Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take great care to run this webhook on all hosts which run an apiserver which might need to make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn up in a new cluster.
   *
   * The scheme must be "https"; the URL must begin with "https://".
   *
   * A path is optional, and if present may be any string permissible in a URL. You may use the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
   *
   * Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments ("#...") and query parameters ("?...") are not allowed, either.
   */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** SelfSubjectReview contains the user information that the kube-apiserver has about the user making this request. When using impersonation, users will receive the user info of the user being impersonated.  If impersonation or request header authentication is used, any extra keys will have their case ignored and returned as lowercase. */
export type Io_K8s_Api_Authentication_V1_SelfSubjectReview = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  status?: Maybe<Io_K8s_Api_Authentication_V1_SelfSubjectReviewStatus>;
};

/** SelfSubjectReviewStatus is filled by the kube-apiserver and sent back to a user. */
export type Io_K8s_Api_Authentication_V1_SelfSubjectReviewStatus = {
  userInfo?: Maybe<Io_K8s_Api_Authentication_V1_UserInfo>;
};

/** SelfSubjectReviewStatus is filled by the kube-apiserver and sent back to a user. */
export type Io_K8s_Api_Authentication_V1_SelfSubjectReviewStatus_Input = {
  userInfo?: InputMaybe<Io_K8s_Api_Authentication_V1_UserInfo_Input>;
};

/** SelfSubjectReview contains the user information that the kube-apiserver has about the user making this request. When using impersonation, users will receive the user info of the user being impersonated.  If impersonation or request header authentication is used, any extra keys will have their case ignored and returned as lowercase. */
export type Io_K8s_Api_Authentication_V1_SelfSubjectReview_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  status?: InputMaybe<Io_K8s_Api_Authentication_V1_SelfSubjectReviewStatus_Input>;
};

/** TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver. */
export type Io_K8s_Api_Authentication_V1_TokenReview = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Io_K8s_Api_Authentication_V1_TokenReviewSpec;
  status?: Maybe<Io_K8s_Api_Authentication_V1_TokenReviewStatus>;
};

/** TokenReviewSpec is a description of the token authentication request. */
export type Io_K8s_Api_Authentication_V1_TokenReviewSpec = {
  /** Audiences is a list of the identifiers that the resource server presented with the token identifies as. Audience-aware token authenticators will verify that the token was intended for at least one of the audiences in this list. If no audiences are provided, the audience will default to the audience of the Kubernetes apiserver. */
  audiences?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Token is the opaque bearer token. */
  token?: Maybe<Scalars['String']['output']>;
};

/** TokenReviewSpec is a description of the token authentication request. */
export type Io_K8s_Api_Authentication_V1_TokenReviewSpec_Input = {
  /** Audiences is a list of the identifiers that the resource server presented with the token identifies as. Audience-aware token authenticators will verify that the token was intended for at least one of the audiences in this list. If no audiences are provided, the audience will default to the audience of the Kubernetes apiserver. */
  audiences?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Token is the opaque bearer token. */
  token?: InputMaybe<Scalars['String']['input']>;
};

/** TokenReviewStatus is the result of the token authentication request. */
export type Io_K8s_Api_Authentication_V1_TokenReviewStatus = {
  /** Audiences are audience identifiers chosen by the authenticator that are compatible with both the TokenReview and token. An identifier is any identifier in the intersection of the TokenReviewSpec audiences and the token's audiences. A client of the TokenReview API that sets the spec.audiences field should validate that a compatible audience identifier is returned in the status.audiences field to ensure that the TokenReview server is audience aware. If a TokenReview returns an empty status.audience field where status.authenticated is "true", the token is valid against the audience of the Kubernetes API server. */
  audiences?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Authenticated indicates that the token was associated with a known user. */
  authenticated?: Maybe<Scalars['Boolean']['output']>;
  /** Error indicates that the token couldn't be checked */
  error?: Maybe<Scalars['String']['output']>;
  user?: Maybe<Io_K8s_Api_Authentication_V1_UserInfo>;
};

/** TokenReviewStatus is the result of the token authentication request. */
export type Io_K8s_Api_Authentication_V1_TokenReviewStatus_Input = {
  /** Audiences are audience identifiers chosen by the authenticator that are compatible with both the TokenReview and token. An identifier is any identifier in the intersection of the TokenReviewSpec audiences and the token's audiences. A client of the TokenReview API that sets the spec.audiences field should validate that a compatible audience identifier is returned in the status.audiences field to ensure that the TokenReview server is audience aware. If a TokenReview returns an empty status.audience field where status.authenticated is "true", the token is valid against the audience of the Kubernetes API server. */
  audiences?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Authenticated indicates that the token was associated with a known user. */
  authenticated?: InputMaybe<Scalars['Boolean']['input']>;
  /** Error indicates that the token couldn't be checked */
  error?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Io_K8s_Api_Authentication_V1_UserInfo_Input>;
};

/** TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver. */
export type Io_K8s_Api_Authentication_V1_TokenReview_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Io_K8s_Api_Authentication_V1_TokenReviewSpec_Input;
  status?: InputMaybe<Io_K8s_Api_Authentication_V1_TokenReviewStatus_Input>;
};

/** UserInfo holds the information about the user needed to implement the user.Info interface. */
export type Io_K8s_Api_Authentication_V1_UserInfo = {
  /** Any additional information provided by the authenticator. */
  extra?: Maybe<Scalars['JSON']['output']>;
  /** The names of groups this user is a part of. */
  groups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** A unique value that identifies this user across time. If this user is deleted and another user by the same name is added, they will have different UIDs. */
  uid?: Maybe<Scalars['String']['output']>;
  /** The name that uniquely identifies this user among all active users. */
  username?: Maybe<Scalars['String']['output']>;
};

/** UserInfo holds the information about the user needed to implement the user.Info interface. */
export type Io_K8s_Api_Authentication_V1_UserInfo_Input = {
  /** Any additional information provided by the authenticator. */
  extra?: InputMaybe<Scalars['JSON']['input']>;
  /** The names of groups this user is a part of. */
  groups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** A unique value that identifies this user across time. If this user is deleted and another user by the same name is added, they will have different UIDs. */
  uid?: InputMaybe<Scalars['String']['input']>;
  /** The name that uniquely identifies this user among all active users. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** FieldSelectorAttributes indicates a field limited access. Webhook authors are encouraged to * ensure rawSelector and requirements are not both set * consider the requirements field if set * not try to parse or consider the rawSelector field if set. This is to avoid another CVE-2022-2880 (i.e. getting different systems to agree on how exactly to parse a query is not something we want), see https://www.oxeye.io/resources/golang-parameter-smuggling-attack for more details. For the *SubjectAccessReview endpoints of the kube-apiserver: * If rawSelector is empty and requirements are empty, the request is not limited. * If rawSelector is present and requirements are empty, the rawSelector will be parsed and limited if the parsing succeeds. * If rawSelector is empty and requirements are present, the requirements should be honored * If rawSelector is present and requirements are present, the request is invalid. */
export type Io_K8s_Api_Authorization_V1_FieldSelectorAttributes = {
  /** rawSelector is the serialization of a field selector that would be included in a query parameter. Webhook implementations are encouraged to ignore rawSelector. The kube-apiserver's *SubjectAccessReview will parse the rawSelector as long as the requirements are not present. */
  rawSelector?: Maybe<Scalars['String']['output']>;
  /** requirements is the parsed interpretation of a field selector. All requirements must be met for a resource instance to match the selector. Webhook implementations should handle requirements, but how to handle them is up to the webhook. Since requirements can only limit the request, it is safe to authorize as unlimited request if the requirements are not understood. */
  requirements?: Maybe<Array<Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_FieldSelectorRequirement>>>;
};

/** FieldSelectorAttributes indicates a field limited access. Webhook authors are encouraged to * ensure rawSelector and requirements are not both set * consider the requirements field if set * not try to parse or consider the rawSelector field if set. This is to avoid another CVE-2022-2880 (i.e. getting different systems to agree on how exactly to parse a query is not something we want), see https://www.oxeye.io/resources/golang-parameter-smuggling-attack for more details. For the *SubjectAccessReview endpoints of the kube-apiserver: * If rawSelector is empty and requirements are empty, the request is not limited. * If rawSelector is present and requirements are empty, the rawSelector will be parsed and limited if the parsing succeeds. * If rawSelector is empty and requirements are present, the requirements should be honored * If rawSelector is present and requirements are present, the request is invalid. */
export type Io_K8s_Api_Authorization_V1_FieldSelectorAttributes_Input = {
  /** rawSelector is the serialization of a field selector that would be included in a query parameter. Webhook implementations are encouraged to ignore rawSelector. The kube-apiserver's *SubjectAccessReview will parse the rawSelector as long as the requirements are not present. */
  rawSelector?: InputMaybe<Scalars['String']['input']>;
  /** requirements is the parsed interpretation of a field selector. All requirements must be met for a resource instance to match the selector. Webhook implementations should handle requirements, but how to handle them is up to the webhook. Since requirements can only limit the request, it is safe to authorize as unlimited request if the requirements are not understood. */
  requirements?: InputMaybe<
    Array<InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_FieldSelectorRequirement_Input>>
  >;
};

/** LabelSelectorAttributes indicates a label limited access. Webhook authors are encouraged to * ensure rawSelector and requirements are not both set * consider the requirements field if set * not try to parse or consider the rawSelector field if set. This is to avoid another CVE-2022-2880 (i.e. getting different systems to agree on how exactly to parse a query is not something we want), see https://www.oxeye.io/resources/golang-parameter-smuggling-attack for more details. For the *SubjectAccessReview endpoints of the kube-apiserver: * If rawSelector is empty and requirements are empty, the request is not limited. * If rawSelector is present and requirements are empty, the rawSelector will be parsed and limited if the parsing succeeds. * If rawSelector is empty and requirements are present, the requirements should be honored * If rawSelector is present and requirements are present, the request is invalid. */
export type Io_K8s_Api_Authorization_V1_LabelSelectorAttributes = {
  /** rawSelector is the serialization of a field selector that would be included in a query parameter. Webhook implementations are encouraged to ignore rawSelector. The kube-apiserver's *SubjectAccessReview will parse the rawSelector as long as the requirements are not present. */
  rawSelector?: Maybe<Scalars['String']['output']>;
  /** requirements is the parsed interpretation of a label selector. All requirements must be met for a resource instance to match the selector. Webhook implementations should handle requirements, but how to handle them is up to the webhook. Since requirements can only limit the request, it is safe to authorize as unlimited request if the requirements are not understood. */
  requirements?: Maybe<Array<Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelectorRequirement>>>;
};

/** LabelSelectorAttributes indicates a label limited access. Webhook authors are encouraged to * ensure rawSelector and requirements are not both set * consider the requirements field if set * not try to parse or consider the rawSelector field if set. This is to avoid another CVE-2022-2880 (i.e. getting different systems to agree on how exactly to parse a query is not something we want), see https://www.oxeye.io/resources/golang-parameter-smuggling-attack for more details. For the *SubjectAccessReview endpoints of the kube-apiserver: * If rawSelector is empty and requirements are empty, the request is not limited. * If rawSelector is present and requirements are empty, the rawSelector will be parsed and limited if the parsing succeeds. * If rawSelector is empty and requirements are present, the requirements should be honored * If rawSelector is present and requirements are present, the request is invalid. */
export type Io_K8s_Api_Authorization_V1_LabelSelectorAttributes_Input = {
  /** rawSelector is the serialization of a field selector that would be included in a query parameter. Webhook implementations are encouraged to ignore rawSelector. The kube-apiserver's *SubjectAccessReview will parse the rawSelector as long as the requirements are not present. */
  rawSelector?: InputMaybe<Scalars['String']['input']>;
  /** requirements is the parsed interpretation of a label selector. All requirements must be met for a resource instance to match the selector. Webhook implementations should handle requirements, but how to handle them is up to the webhook. Since requirements can only limit the request, it is safe to authorize as unlimited request if the requirements are not understood. */
  requirements?: InputMaybe<
    Array<InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelectorRequirement_Input>>
  >;
};

/** LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking. */
export type Io_K8s_Api_Authorization_V1_LocalSubjectAccessReview = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Io_K8s_Api_Authorization_V1_SubjectAccessReviewSpec;
  status?: Maybe<Io_K8s_Api_Authorization_V1_SubjectAccessReviewStatus>;
};

/** LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking. */
export type Io_K8s_Api_Authorization_V1_LocalSubjectAccessReview_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Io_K8s_Api_Authorization_V1_SubjectAccessReviewSpec_Input;
  status?: InputMaybe<Io_K8s_Api_Authorization_V1_SubjectAccessReviewStatus_Input>;
};

/** NonResourceAttributes includes the authorization attributes available for non-resource requests to the Authorizer interface */
export type Io_K8s_Api_Authorization_V1_NonResourceAttributes = {
  /** Path is the URL path of the request */
  path?: Maybe<Scalars['String']['output']>;
  /** Verb is the standard HTTP verb */
  verb?: Maybe<Scalars['String']['output']>;
};

/** NonResourceAttributes includes the authorization attributes available for non-resource requests to the Authorizer interface */
export type Io_K8s_Api_Authorization_V1_NonResourceAttributes_Input = {
  /** Path is the URL path of the request */
  path?: InputMaybe<Scalars['String']['input']>;
  /** Verb is the standard HTTP verb */
  verb?: InputMaybe<Scalars['String']['input']>;
};

/** NonResourceRule holds information that describes a rule for the non-resource */
export type Io_K8s_Api_Authorization_V1_NonResourceRule = {
  /** NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path.  "*" means all. */
  nonResourceURLs?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Verb is a list of kubernetes non-resource API verbs, like: get, post, put, delete, patch, head, options.  "*" means all. */
  verbs: Array<Maybe<Scalars['String']['output']>>;
};

/** NonResourceRule holds information that describes a rule for the non-resource */
export type Io_K8s_Api_Authorization_V1_NonResourceRule_Input = {
  /** NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path.  "*" means all. */
  nonResourceURLs?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Verb is a list of kubernetes non-resource API verbs, like: get, post, put, delete, patch, head, options.  "*" means all. */
  verbs: Array<InputMaybe<Scalars['String']['input']>>;
};

/** ResourceAttributes includes the authorization attributes available for resource requests to the Authorizer interface */
export type Io_K8s_Api_Authorization_V1_ResourceAttributes = {
  fieldSelector?: Maybe<Io_K8s_Api_Authorization_V1_FieldSelectorAttributes>;
  /** Group is the API Group of the Resource.  "*" means all. */
  group?: Maybe<Scalars['String']['output']>;
  labelSelector?: Maybe<Io_K8s_Api_Authorization_V1_LabelSelectorAttributes>;
  /** Name is the name of the resource being requested for a "get" or deleted for a "delete". "" (empty) means all. */
  name?: Maybe<Scalars['String']['output']>;
  /** Namespace is the namespace of the action being requested.  Currently, there is no distinction between no namespace and all namespaces "" (empty) is defaulted for LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty) means "all" for namespace scoped resources from a SubjectAccessReview or SelfSubjectAccessReview */
  namespace?: Maybe<Scalars['String']['output']>;
  /** Resource is one of the existing resource types.  "*" means all. */
  resource?: Maybe<Scalars['String']['output']>;
  /** Subresource is one of the existing resource types.  "" means none. */
  subresource?: Maybe<Scalars['String']['output']>;
  /** Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete, proxy.  "*" means all. */
  verb?: Maybe<Scalars['String']['output']>;
  /** Version is the API Version of the Resource.  "*" means all. */
  version?: Maybe<Scalars['String']['output']>;
};

/** ResourceAttributes includes the authorization attributes available for resource requests to the Authorizer interface */
export type Io_K8s_Api_Authorization_V1_ResourceAttributes_Input = {
  fieldSelector?: InputMaybe<Io_K8s_Api_Authorization_V1_FieldSelectorAttributes_Input>;
  /** Group is the API Group of the Resource.  "*" means all. */
  group?: InputMaybe<Scalars['String']['input']>;
  labelSelector?: InputMaybe<Io_K8s_Api_Authorization_V1_LabelSelectorAttributes_Input>;
  /** Name is the name of the resource being requested for a "get" or deleted for a "delete". "" (empty) means all. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Namespace is the namespace of the action being requested.  Currently, there is no distinction between no namespace and all namespaces "" (empty) is defaulted for LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty) means "all" for namespace scoped resources from a SubjectAccessReview or SelfSubjectAccessReview */
  namespace?: InputMaybe<Scalars['String']['input']>;
  /** Resource is one of the existing resource types.  "*" means all. */
  resource?: InputMaybe<Scalars['String']['input']>;
  /** Subresource is one of the existing resource types.  "" means none. */
  subresource?: InputMaybe<Scalars['String']['input']>;
  /** Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete, proxy.  "*" means all. */
  verb?: InputMaybe<Scalars['String']['input']>;
  /** Version is the API Version of the Resource.  "*" means all. */
  version?: InputMaybe<Scalars['String']['input']>;
};

/** ResourceRule is the list of actions the subject is allowed to perform on resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete. */
export type Io_K8s_Api_Authorization_V1_ResourceRule = {
  /** APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed.  "*" means all. */
  apiGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.  "*" means all. */
  resourceNames?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * Resources is a list of resources this rule applies to.  "*" means all in the specified apiGroups.
   *  "*\/foo" represents the subresource 'foo' for all resources in the specified apiGroups.
   */
  resources?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Verb is a list of kubernetes resource API verbs, like: get, list, watch, create, update, delete, proxy.  "*" means all. */
  verbs: Array<Maybe<Scalars['String']['output']>>;
};

/** ResourceRule is the list of actions the subject is allowed to perform on resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete. */
export type Io_K8s_Api_Authorization_V1_ResourceRule_Input = {
  /** APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed.  "*" means all. */
  apiGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.  "*" means all. */
  resourceNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * Resources is a list of resources this rule applies to.  "*" means all in the specified apiGroups.
   *  "*\/foo" represents the subresource 'foo' for all resources in the specified apiGroups.
   */
  resources?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Verb is a list of kubernetes resource API verbs, like: get, list, watch, create, update, delete, proxy.  "*" means all. */
  verbs: Array<InputMaybe<Scalars['String']['input']>>;
};

/** SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means "in all namespaces".  Self is a special case, because users should always be able to check whether they can perform an action */
export type Io_K8s_Api_Authorization_V1_SelfSubjectAccessReview = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Io_K8s_Api_Authorization_V1_SelfSubjectAccessReviewSpec;
  status?: Maybe<Io_K8s_Api_Authorization_V1_SubjectAccessReviewStatus>;
};

/** SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set */
export type Io_K8s_Api_Authorization_V1_SelfSubjectAccessReviewSpec = {
  nonResourceAttributes?: Maybe<Io_K8s_Api_Authorization_V1_NonResourceAttributes>;
  resourceAttributes?: Maybe<Io_K8s_Api_Authorization_V1_ResourceAttributes>;
};

/** SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set */
export type Io_K8s_Api_Authorization_V1_SelfSubjectAccessReviewSpec_Input = {
  nonResourceAttributes?: InputMaybe<Io_K8s_Api_Authorization_V1_NonResourceAttributes_Input>;
  resourceAttributes?: InputMaybe<Io_K8s_Api_Authorization_V1_ResourceAttributes_Input>;
};

/** SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means "in all namespaces".  Self is a special case, because users should always be able to check whether they can perform an action */
export type Io_K8s_Api_Authorization_V1_SelfSubjectAccessReview_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Io_K8s_Api_Authorization_V1_SelfSubjectAccessReviewSpec_Input;
  status?: InputMaybe<Io_K8s_Api_Authorization_V1_SubjectAccessReviewStatus_Input>;
};

/** SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server. */
export type Io_K8s_Api_Authorization_V1_SelfSubjectRulesReview = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Io_K8s_Api_Authorization_V1_SelfSubjectRulesReviewSpec;
  status?: Maybe<Io_K8s_Api_Authorization_V1_SubjectRulesReviewStatus>;
};

/** SelfSubjectRulesReviewSpec defines the specification for SelfSubjectRulesReview. */
export type Io_K8s_Api_Authorization_V1_SelfSubjectRulesReviewSpec = {
  /** Namespace to evaluate rules for. Required. */
  namespace?: Maybe<Scalars['String']['output']>;
};

/** SelfSubjectRulesReviewSpec defines the specification for SelfSubjectRulesReview. */
export type Io_K8s_Api_Authorization_V1_SelfSubjectRulesReviewSpec_Input = {
  /** Namespace to evaluate rules for. Required. */
  namespace?: InputMaybe<Scalars['String']['input']>;
};

/** SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server. */
export type Io_K8s_Api_Authorization_V1_SelfSubjectRulesReview_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Io_K8s_Api_Authorization_V1_SelfSubjectRulesReviewSpec_Input;
  status?: InputMaybe<Io_K8s_Api_Authorization_V1_SubjectRulesReviewStatus_Input>;
};

/** SubjectAccessReview checks whether or not a user or group can perform an action. */
export type Io_K8s_Api_Authorization_V1_SubjectAccessReview = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Io_K8s_Api_Authorization_V1_SubjectAccessReviewSpec;
  status?: Maybe<Io_K8s_Api_Authorization_V1_SubjectAccessReviewStatus>;
};

/** SubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set */
export type Io_K8s_Api_Authorization_V1_SubjectAccessReviewSpec = {
  /** Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that is input to the authorizer it needs a reflection here. */
  extra?: Maybe<Scalars['JSON']['output']>;
  /** Groups is the groups you're testing for. */
  groups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  nonResourceAttributes?: Maybe<Io_K8s_Api_Authorization_V1_NonResourceAttributes>;
  resourceAttributes?: Maybe<Io_K8s_Api_Authorization_V1_ResourceAttributes>;
  /** UID information about the requesting user. */
  uid?: Maybe<Scalars['String']['output']>;
  /** User is the user you're testing for. If you specify "User" but not "Groups", then is it interpreted as "What if User were not a member of any groups */
  user?: Maybe<Scalars['String']['output']>;
};

/** SubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set */
export type Io_K8s_Api_Authorization_V1_SubjectAccessReviewSpec_Input = {
  /** Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that is input to the authorizer it needs a reflection here. */
  extra?: InputMaybe<Scalars['JSON']['input']>;
  /** Groups is the groups you're testing for. */
  groups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  nonResourceAttributes?: InputMaybe<Io_K8s_Api_Authorization_V1_NonResourceAttributes_Input>;
  resourceAttributes?: InputMaybe<Io_K8s_Api_Authorization_V1_ResourceAttributes_Input>;
  /** UID information about the requesting user. */
  uid?: InputMaybe<Scalars['String']['input']>;
  /** User is the user you're testing for. If you specify "User" but not "Groups", then is it interpreted as "What if User were not a member of any groups */
  user?: InputMaybe<Scalars['String']['input']>;
};

/** SubjectAccessReviewStatus */
export type Io_K8s_Api_Authorization_V1_SubjectAccessReviewStatus = {
  /** Allowed is required. True if the action would be allowed, false otherwise. */
  allowed: Scalars['Boolean']['output'];
  /** Denied is optional. True if the action would be denied, otherwise false. If both allowed is false and denied is false, then the authorizer has no opinion on whether to authorize the action. Denied may not be true if Allowed is true. */
  denied?: Maybe<Scalars['Boolean']['output']>;
  /** EvaluationError is an indication that some error occurred during the authorization check. It is entirely possible to get an error and be able to continue determine authorization status in spite of it. For instance, RBAC can be missing a role, but enough roles are still present and bound to reason about the request. */
  evaluationError?: Maybe<Scalars['String']['output']>;
  /** Reason is optional.  It indicates why a request was allowed or denied. */
  reason?: Maybe<Scalars['String']['output']>;
};

/** SubjectAccessReviewStatus */
export type Io_K8s_Api_Authorization_V1_SubjectAccessReviewStatus_Input = {
  /** Allowed is required. True if the action would be allowed, false otherwise. */
  allowed: Scalars['Boolean']['input'];
  /** Denied is optional. True if the action would be denied, otherwise false. If both allowed is false and denied is false, then the authorizer has no opinion on whether to authorize the action. Denied may not be true if Allowed is true. */
  denied?: InputMaybe<Scalars['Boolean']['input']>;
  /** EvaluationError is an indication that some error occurred during the authorization check. It is entirely possible to get an error and be able to continue determine authorization status in spite of it. For instance, RBAC can be missing a role, but enough roles are still present and bound to reason about the request. */
  evaluationError?: InputMaybe<Scalars['String']['input']>;
  /** Reason is optional.  It indicates why a request was allowed or denied. */
  reason?: InputMaybe<Scalars['String']['input']>;
};

/** SubjectAccessReview checks whether or not a user or group can perform an action. */
export type Io_K8s_Api_Authorization_V1_SubjectAccessReview_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Io_K8s_Api_Authorization_V1_SubjectAccessReviewSpec_Input;
  status?: InputMaybe<Io_K8s_Api_Authorization_V1_SubjectAccessReviewStatus_Input>;
};

/** SubjectRulesReviewStatus contains the result of a rules check. This check can be incomplete depending on the set of authorizers the server is configured with and any errors experienced during evaluation. Because authorization rules are additive, if a rule appears in a list it's safe to assume the subject has that permission, even if that list is incomplete. */
export type Io_K8s_Api_Authorization_V1_SubjectRulesReviewStatus = {
  /** EvaluationError can appear in combination with Rules. It indicates an error occurred during rule evaluation, such as an authorizer that doesn't support rule evaluation, and that ResourceRules and/or NonResourceRules may be incomplete. */
  evaluationError?: Maybe<Scalars['String']['output']>;
  /** Incomplete is true when the rules returned by this call are incomplete. This is most commonly encountered when an authorizer, such as an external authorizer, doesn't support rules evaluation. */
  incomplete: Scalars['Boolean']['output'];
  /** NonResourceRules is the list of actions the subject is allowed to perform on non-resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete. */
  nonResourceRules: Array<Maybe<Io_K8s_Api_Authorization_V1_NonResourceRule>>;
  /** ResourceRules is the list of actions the subject is allowed to perform on resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete. */
  resourceRules: Array<Maybe<Io_K8s_Api_Authorization_V1_ResourceRule>>;
};

/** SubjectRulesReviewStatus contains the result of a rules check. This check can be incomplete depending on the set of authorizers the server is configured with and any errors experienced during evaluation. Because authorization rules are additive, if a rule appears in a list it's safe to assume the subject has that permission, even if that list is incomplete. */
export type Io_K8s_Api_Authorization_V1_SubjectRulesReviewStatus_Input = {
  /** EvaluationError can appear in combination with Rules. It indicates an error occurred during rule evaluation, such as an authorizer that doesn't support rule evaluation, and that ResourceRules and/or NonResourceRules may be incomplete. */
  evaluationError?: InputMaybe<Scalars['String']['input']>;
  /** Incomplete is true when the rules returned by this call are incomplete. This is most commonly encountered when an authorizer, such as an external authorizer, doesn't support rules evaluation. */
  incomplete: Scalars['Boolean']['input'];
  /** NonResourceRules is the list of actions the subject is allowed to perform on non-resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete. */
  nonResourceRules: Array<InputMaybe<Io_K8s_Api_Authorization_V1_NonResourceRule_Input>>;
  /** ResourceRules is the list of actions the subject is allowed to perform on resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete. */
  resourceRules: Array<InputMaybe<Io_K8s_Api_Authorization_V1_ResourceRule_Input>>;
};

/** Lease defines a lease concept. */
export type Io_K8s_Api_Coordination_V1_Lease = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Io_K8s_Api_Coordination_V1_LeaseSpec>;
};

/** LeaseList is a list of Lease objects. */
export type Io_K8s_Api_Coordination_V1_LeaseList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** items is a list of schema objects. */
  items: Array<Maybe<Io_K8s_Api_Coordination_V1_Lease>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** LeaseSpec is a specification of a Lease. */
export type Io_K8s_Api_Coordination_V1_LeaseSpec = {
  /** MicroTime is version of Time with microsecond level precision. */
  acquireTime?: Maybe<Scalars['DateTime']['output']>;
  /** holderIdentity contains the identity of the holder of a current lease. If Coordinated Leader Election is used, the holder identity must be equal to the elected LeaseCandidate.metadata.name field. */
  holderIdentity?: Maybe<Scalars['String']['output']>;
  /** leaseDurationSeconds is a duration that candidates for a lease need to wait to force acquire it. This is measured against the time of last observed renewTime. */
  leaseDurationSeconds?: Maybe<Scalars['Int']['output']>;
  /** leaseTransitions is the number of transitions of a lease between holders. */
  leaseTransitions?: Maybe<Scalars['Int']['output']>;
  /** PreferredHolder signals to a lease holder that the lease has a more optimal holder and should be given up. This field can only be set if Strategy is also set. */
  preferredHolder?: Maybe<Scalars['String']['output']>;
  /** MicroTime is version of Time with microsecond level precision. */
  renewTime?: Maybe<Scalars['DateTime']['output']>;
  /** Strategy indicates the strategy for picking the leader for coordinated leader election. If the field is not specified, there is no active coordination for this lease. (Alpha) Using this field requires the CoordinatedLeaderElection feature gate to be enabled. */
  strategy?: Maybe<Scalars['String']['output']>;
};

/** LeaseSpec is a specification of a Lease. */
export type Io_K8s_Api_Coordination_V1_LeaseSpec_Input = {
  /** MicroTime is version of Time with microsecond level precision. */
  acquireTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** holderIdentity contains the identity of the holder of a current lease. If Coordinated Leader Election is used, the holder identity must be equal to the elected LeaseCandidate.metadata.name field. */
  holderIdentity?: InputMaybe<Scalars['String']['input']>;
  /** leaseDurationSeconds is a duration that candidates for a lease need to wait to force acquire it. This is measured against the time of last observed renewTime. */
  leaseDurationSeconds?: InputMaybe<Scalars['Int']['input']>;
  /** leaseTransitions is the number of transitions of a lease between holders. */
  leaseTransitions?: InputMaybe<Scalars['Int']['input']>;
  /** PreferredHolder signals to a lease holder that the lease has a more optimal holder and should be given up. This field can only be set if Strategy is also set. */
  preferredHolder?: InputMaybe<Scalars['String']['input']>;
  /** MicroTime is version of Time with microsecond level precision. */
  renewTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** Strategy indicates the strategy for picking the leader for coordinated leader election. If the field is not specified, there is no active coordination for this lease. (Alpha) Using this field requires the CoordinatedLeaderElection feature gate to be enabled. */
  strategy?: InputMaybe<Scalars['String']['input']>;
};

/** Lease defines a lease concept. */
export type Io_K8s_Api_Coordination_V1_Lease_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Io_K8s_Api_Coordination_V1_LeaseSpec_Input>;
};

/** ConfigMap holds configuration data for pods to consume. */
export type Io_K8s_Api_Core_V1_ConfigMap = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** BinaryData contains the binary data. Each key must consist of alphanumeric characters, '-', '_' or '.'. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. */
  binaryData?: Maybe<Scalars['JSON']['output']>;
  /** Data contains the configuration data. Each key must consist of alphanumeric characters, '-', '_' or '.'. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. */
  data?: Maybe<Scalars['JSON']['output']>;
  /** Immutable, if set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Defaulted to nil. */
  immutable?: Maybe<Scalars['Boolean']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
};

/** ConfigMapList is a resource containing a list of ConfigMap objects. */
export type Io_K8s_Api_Core_V1_ConfigMapList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Items is the list of ConfigMaps. */
  items: Array<Maybe<Io_K8s_Api_Core_V1_ConfigMap>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** ConfigMap holds configuration data for pods to consume. */
export type Io_K8s_Api_Core_V1_ConfigMap_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** BinaryData contains the binary data. Each key must consist of alphanumeric characters, '-', '_' or '.'. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. */
  binaryData?: InputMaybe<Scalars['JSON']['input']>;
  /** Data contains the configuration data. Each key must consist of alphanumeric characters, '-', '_' or '.'. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. */
  data?: InputMaybe<Scalars['JSON']['input']>;
  /** Immutable, if set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Defaulted to nil. */
  immutable?: InputMaybe<Scalars['Boolean']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
};

/** Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data. */
export type Io_K8s_Api_Core_V1_Event = {
  /** What action was taken/failed regarding to the Regarding object. */
  action?: Maybe<Scalars['String']['output']>;
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** The number of times this event has occurred. */
  count?: Maybe<Scalars['Int']['output']>;
  /** MicroTime is version of Time with microsecond level precision. */
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  firstTimestamp?: Maybe<Scalars['DateTime']['output']>;
  involvedObject: Io_K8s_Api_Core_V1_ObjectReference;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  lastTimestamp?: Maybe<Scalars['DateTime']['output']>;
  /** A human-readable description of the status of this operation. */
  message?: Maybe<Scalars['String']['output']>;
  metadata: Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta;
  /** This should be a short, machine understandable string that gives the reason for the transition into the object's current status. */
  reason?: Maybe<Scalars['String']['output']>;
  related?: Maybe<Io_K8s_Api_Core_V1_ObjectReference>;
  /** Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`. */
  reportingComponent?: Maybe<Scalars['String']['output']>;
  /** ID of the controller instance, e.g. `kubelet-xyzf`. */
  reportingInstance?: Maybe<Scalars['String']['output']>;
  series?: Maybe<Io_K8s_Api_Core_V1_EventSeries>;
  source?: Maybe<Io_K8s_Api_Core_V1_EventSource>;
  /** Type of this event (Normal, Warning), new types could be added in the future */
  type?: Maybe<Scalars['String']['output']>;
};

/** EventList is a list of events. */
export type Io_K8s_Api_Core_V1_EventList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of events */
  items: Array<Maybe<Io_K8s_Api_Core_V1_Event>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time. */
export type Io_K8s_Api_Core_V1_EventSeries = {
  /** Number of occurrences in this series up to the last heartbeat time */
  count?: Maybe<Scalars['Int']['output']>;
  /** MicroTime is version of Time with microsecond level precision. */
  lastObservedTime?: Maybe<Scalars['DateTime']['output']>;
};

/** EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time. */
export type Io_K8s_Api_Core_V1_EventSeries_Input = {
  /** Number of occurrences in this series up to the last heartbeat time */
  count?: InputMaybe<Scalars['Int']['input']>;
  /** MicroTime is version of Time with microsecond level precision. */
  lastObservedTime?: InputMaybe<Scalars['DateTime']['input']>;
};

/** EventSource contains information for an event. */
export type Io_K8s_Api_Core_V1_EventSource = {
  /** Component from which the event is generated. */
  component?: Maybe<Scalars['String']['output']>;
  /** Node name on which the event is generated. */
  host?: Maybe<Scalars['String']['output']>;
};

/** EventSource contains information for an event. */
export type Io_K8s_Api_Core_V1_EventSource_Input = {
  /** Component from which the event is generated. */
  component?: InputMaybe<Scalars['String']['input']>;
  /** Node name on which the event is generated. */
  host?: InputMaybe<Scalars['String']['input']>;
};

/** Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data. */
export type Io_K8s_Api_Core_V1_Event_Input = {
  /** What action was taken/failed regarding to the Regarding object. */
  action?: InputMaybe<Scalars['String']['input']>;
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** The number of times this event has occurred. */
  count?: InputMaybe<Scalars['Int']['input']>;
  /** MicroTime is version of Time with microsecond level precision. */
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  firstTimestamp?: InputMaybe<Scalars['DateTime']['input']>;
  involvedObject: Io_K8s_Api_Core_V1_ObjectReference_Input;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  lastTimestamp?: InputMaybe<Scalars['DateTime']['input']>;
  /** A human-readable description of the status of this operation. */
  message?: InputMaybe<Scalars['String']['input']>;
  metadata: Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input;
  /** This should be a short, machine understandable string that gives the reason for the transition into the object's current status. */
  reason?: InputMaybe<Scalars['String']['input']>;
  related?: InputMaybe<Io_K8s_Api_Core_V1_ObjectReference_Input>;
  /** Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`. */
  reportingComponent?: InputMaybe<Scalars['String']['input']>;
  /** ID of the controller instance, e.g. `kubelet-xyzf`. */
  reportingInstance?: InputMaybe<Scalars['String']['input']>;
  series?: InputMaybe<Io_K8s_Api_Core_V1_EventSeries_Input>;
  source?: InputMaybe<Io_K8s_Api_Core_V1_EventSource_Input>;
  /** Type of this event (Normal, Warning), new types could be added in the future */
  type?: InputMaybe<Scalars['String']['input']>;
};

/** Namespace provides a scope for Names. Use of multiple namespaces is optional. */
export type Io_K8s_Api_Core_V1_Namespace = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Io_K8s_Api_Core_V1_NamespaceSpec>;
  status?: Maybe<Io_K8s_Api_Core_V1_NamespaceStatus>;
};

/** NamespaceCondition contains details about state of namespace. */
export type Io_K8s_Api_Core_V1_NamespaceCondition = {
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  lastTransitionTime?: Maybe<Scalars['DateTime']['output']>;
  /** Human-readable message indicating details about last transition. */
  message?: Maybe<Scalars['String']['output']>;
  /** Unique, one-word, CamelCase reason for the condition's last transition. */
  reason?: Maybe<Scalars['String']['output']>;
  /** Status of the condition, one of True, False, Unknown. */
  status: Scalars['String']['output'];
  /** Type of namespace controller condition. */
  type: Scalars['String']['output'];
};

/** NamespaceCondition contains details about state of namespace. */
export type Io_K8s_Api_Core_V1_NamespaceCondition_Input = {
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  lastTransitionTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** Human-readable message indicating details about last transition. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Unique, one-word, CamelCase reason for the condition's last transition. */
  reason?: InputMaybe<Scalars['String']['input']>;
  /** Status of the condition, one of True, False, Unknown. */
  status: Scalars['String']['input'];
  /** Type of namespace controller condition. */
  type: Scalars['String']['input'];
};

/** NamespaceList is a list of Namespaces. */
export type Io_K8s_Api_Core_V1_NamespaceList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Items is the list of Namespace objects in the list. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ */
  items: Array<Maybe<Io_K8s_Api_Core_V1_Namespace>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** NamespaceSpec describes the attributes on a Namespace. */
export type Io_K8s_Api_Core_V1_NamespaceSpec = {
  /** Finalizers is an opaque list of values that must be empty to permanently remove object from storage. More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/ */
  finalizers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** NamespaceSpec describes the attributes on a Namespace. */
export type Io_K8s_Api_Core_V1_NamespaceSpec_Input = {
  /** Finalizers is an opaque list of values that must be empty to permanently remove object from storage. More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/ */
  finalizers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** NamespaceStatus is information about the current status of a Namespace. */
export type Io_K8s_Api_Core_V1_NamespaceStatus = {
  /** Represents the latest available observations of a namespace's current state. */
  conditions?: Maybe<Array<Maybe<Io_K8s_Api_Core_V1_NamespaceCondition>>>;
  phase?: Maybe<Query_ListCoreV1Namespace_OneOf_0_Items_Items_Status_Phase>;
};

/** NamespaceStatus is information about the current status of a Namespace. */
export type Io_K8s_Api_Core_V1_NamespaceStatus_Input = {
  /** Represents the latest available observations of a namespace's current state. */
  conditions?: InputMaybe<Array<InputMaybe<Io_K8s_Api_Core_V1_NamespaceCondition_Input>>>;
  phase?: InputMaybe<Query_ListCoreV1Namespace_OneOf_0_Items_Items_Status_Phase>;
};

/** Namespace provides a scope for Names. Use of multiple namespaces is optional. */
export type Io_K8s_Api_Core_V1_Namespace_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Io_K8s_Api_Core_V1_NamespaceSpec_Input>;
  status?: InputMaybe<Io_K8s_Api_Core_V1_NamespaceStatus_Input>;
};

/** ObjectReference contains enough information to let you inspect or modify the referred object. */
export type Io_K8s_Api_Core_V1_ObjectReference = {
  /** API version of the referent. */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. */
  fieldPath?: Maybe<Scalars['String']['output']>;
  /** Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  /** Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names */
  name?: Maybe<Scalars['String']['output']>;
  /** Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ */
  namespace?: Maybe<Scalars['String']['output']>;
  /** Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency */
  resourceVersion?: Maybe<Scalars['String']['output']>;
  /** UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids */
  uid?: Maybe<Scalars['String']['output']>;
};

/** ObjectReference contains enough information to let you inspect or modify the referred object. */
export type Io_K8s_Api_Core_V1_ObjectReference_Input = {
  /** API version of the referent. */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. */
  fieldPath?: InputMaybe<Scalars['String']['input']>;
  /** Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  /** Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ */
  namespace?: InputMaybe<Scalars['String']['input']>;
  /** Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency */
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  /** UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids */
  uid?: InputMaybe<Scalars['String']['input']>;
};

/** Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes. */
export type Io_K8s_Api_Core_V1_Secret = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Data contains the secret data. Each key must consist of alphanumeric characters, '-', '_' or '.'. The serialized form of the secret data is a base64 encoded string, representing the arbitrary (possibly non-string) data value here. Described in https://tools.ietf.org/html/rfc4648#section-4 */
  data?: Maybe<Scalars['JSON']['output']>;
  /** Immutable, if set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Defaulted to nil. */
  immutable?: Maybe<Scalars['Boolean']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  /** stringData allows specifying non-binary secret data in string form. It is provided as a write-only input field for convenience. All keys and values are merged into the data field on write, overwriting any existing values. The stringData field is never output when reading from the API. */
  stringData?: Maybe<Scalars['JSON']['output']>;
  /** Used to facilitate programmatic handling of secret data. More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types */
  type?: Maybe<Scalars['String']['output']>;
};

/** SecretList is a list of Secret. */
export type Io_K8s_Api_Core_V1_SecretList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Items is a list of secret objects. More info: https://kubernetes.io/docs/concepts/configuration/secret */
  items: Array<Maybe<Io_K8s_Api_Core_V1_Secret>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes. */
export type Io_K8s_Api_Core_V1_Secret_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Data contains the secret data. Each key must consist of alphanumeric characters, '-', '_' or '.'. The serialized form of the secret data is a base64 encoded string, representing the arbitrary (possibly non-string) data value here. Described in https://tools.ietf.org/html/rfc4648#section-4 */
  data?: InputMaybe<Scalars['JSON']['input']>;
  /** Immutable, if set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Defaulted to nil. */
  immutable?: InputMaybe<Scalars['Boolean']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  /** stringData allows specifying non-binary secret data in string form. It is provided as a write-only input field for convenience. All keys and values are merged into the data field on write, overwriting any existing values. The stringData field is never output when reading from the API. */
  stringData?: InputMaybe<Scalars['JSON']['input']>;
  /** Used to facilitate programmatic handling of secret data. More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types */
  type?: InputMaybe<Scalars['String']['input']>;
};

/** Endpoint represents a single logical "backend" implementing a service. */
export type Io_K8s_Api_Discovery_V1_Endpoint = {
  /** addresses of this endpoint. The contents of this field are interpreted according to the corresponding EndpointSlice addressType field. Consumers must handle different types of addresses in the context of their own capabilities. This must contain at least one address but no more than 100. These are all assumed to be fungible and clients may choose to only use the first element. Refer to: https://issue.k8s.io/106267 */
  addresses: Array<Maybe<Scalars['String']['output']>>;
  conditions?: Maybe<Io_K8s_Api_Discovery_V1_EndpointConditions>;
  /** deprecatedTopology contains topology information part of the v1beta1 API. This field is deprecated, and will be removed when the v1beta1 API is removed (no sooner than kubernetes v1.24).  While this field can hold values, it is not writable through the v1 API, and any attempts to write to it will be silently ignored. Topology information can be found in the zone and nodeName fields instead. */
  deprecatedTopology?: Maybe<Scalars['JSON']['output']>;
  hints?: Maybe<Io_K8s_Api_Discovery_V1_EndpointHints>;
  /** hostname of this endpoint. This field may be used by consumers of endpoints to distinguish endpoints from each other (e.g. in DNS names). Multiple endpoints which use the same hostname should be considered fungible (e.g. multiple A values in DNS). Must be lowercase and pass DNS Label (RFC 1123) validation. */
  hostname?: Maybe<Scalars['String']['output']>;
  /** nodeName represents the name of the Node hosting this endpoint. This can be used to determine endpoints local to a Node. */
  nodeName?: Maybe<Scalars['String']['output']>;
  targetRef?: Maybe<Io_K8s_Api_Core_V1_ObjectReference>;
  /** zone is the name of the Zone this endpoint exists in. */
  zone?: Maybe<Scalars['String']['output']>;
};

/** EndpointConditions represents the current condition of an endpoint. */
export type Io_K8s_Api_Discovery_V1_EndpointConditions = {
  /** ready indicates that this endpoint is prepared to receive traffic, according to whatever system is managing the endpoint. A nil value indicates an unknown state. In most cases consumers should interpret this unknown state as ready. For compatibility reasons, ready should never be "true" for terminating endpoints, except when the normal readiness behavior is being explicitly overridden, for example when the associated Service has set the publishNotReadyAddresses flag. */
  ready?: Maybe<Scalars['Boolean']['output']>;
  /** serving is identical to ready except that it is set regardless of the terminating state of endpoints. This condition should be set to true for a ready endpoint that is terminating. If nil, consumers should defer to the ready condition. */
  serving?: Maybe<Scalars['Boolean']['output']>;
  /** terminating indicates that this endpoint is terminating. A nil value indicates an unknown state. Consumers should interpret this unknown state to mean that the endpoint is not terminating. */
  terminating?: Maybe<Scalars['Boolean']['output']>;
};

/** EndpointConditions represents the current condition of an endpoint. */
export type Io_K8s_Api_Discovery_V1_EndpointConditions_Input = {
  /** ready indicates that this endpoint is prepared to receive traffic, according to whatever system is managing the endpoint. A nil value indicates an unknown state. In most cases consumers should interpret this unknown state as ready. For compatibility reasons, ready should never be "true" for terminating endpoints, except when the normal readiness behavior is being explicitly overridden, for example when the associated Service has set the publishNotReadyAddresses flag. */
  ready?: InputMaybe<Scalars['Boolean']['input']>;
  /** serving is identical to ready except that it is set regardless of the terminating state of endpoints. This condition should be set to true for a ready endpoint that is terminating. If nil, consumers should defer to the ready condition. */
  serving?: InputMaybe<Scalars['Boolean']['input']>;
  /** terminating indicates that this endpoint is terminating. A nil value indicates an unknown state. Consumers should interpret this unknown state to mean that the endpoint is not terminating. */
  terminating?: InputMaybe<Scalars['Boolean']['input']>;
};

/** EndpointHints provides hints describing how an endpoint should be consumed. */
export type Io_K8s_Api_Discovery_V1_EndpointHints = {
  /** forZones indicates the zone(s) this endpoint should be consumed by to enable topology aware routing. */
  forZones?: Maybe<Array<Maybe<Io_K8s_Api_Discovery_V1_ForZone>>>;
};

/** EndpointHints provides hints describing how an endpoint should be consumed. */
export type Io_K8s_Api_Discovery_V1_EndpointHints_Input = {
  /** forZones indicates the zone(s) this endpoint should be consumed by to enable topology aware routing. */
  forZones?: InputMaybe<Array<InputMaybe<Io_K8s_Api_Discovery_V1_ForZone_Input>>>;
};

/** EndpointPort represents a Port used by an EndpointSlice */
export type Io_K8s_Api_Discovery_V1_EndpointPort = {
  /**
   * The application protocol for this port. This is used as a hint for implementations to offer richer behavior for protocols that they understand. This field follows standard Kubernetes label syntax. Valid values are either:
   *
   * * Un-prefixed protocol names - reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names).
   *
   * * Kubernetes-defined prefixed names:
   *   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
   *   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
   *   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
   *
   * * Other protocols should use implementation-defined prefixed names such as mycompany.com/my-custom-protocol.
   */
  appProtocol?: Maybe<Scalars['String']['output']>;
  /** name represents the name of this port. All ports in an EndpointSlice must have a unique name. If the EndpointSlice is derived from a Kubernetes service, this corresponds to the Service.ports[].name. Name must either be an empty string or pass DNS_LABEL validation: * must be no more than 63 characters long. * must consist of lower case alphanumeric characters or '-'. * must start and end with an alphanumeric character. Default is empty string. */
  name?: Maybe<Scalars['String']['output']>;
  /** port represents the port number of the endpoint. If this is not specified, ports are not restricted and must be interpreted in the context of the specific consumer. */
  port?: Maybe<Scalars['Int']['output']>;
  protocol?: Maybe<Query_ListDiscoveryV1EndpointSliceForAllNamespaces_OneOf_0_Items_Items_Ports_Items_Protocol>;
};

/** EndpointPort represents a Port used by an EndpointSlice */
export type Io_K8s_Api_Discovery_V1_EndpointPort_Input = {
  /**
   * The application protocol for this port. This is used as a hint for implementations to offer richer behavior for protocols that they understand. This field follows standard Kubernetes label syntax. Valid values are either:
   *
   * * Un-prefixed protocol names - reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names).
   *
   * * Kubernetes-defined prefixed names:
   *   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
   *   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
   *   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
   *
   * * Other protocols should use implementation-defined prefixed names such as mycompany.com/my-custom-protocol.
   */
  appProtocol?: InputMaybe<Scalars['String']['input']>;
  /** name represents the name of this port. All ports in an EndpointSlice must have a unique name. If the EndpointSlice is derived from a Kubernetes service, this corresponds to the Service.ports[].name. Name must either be an empty string or pass DNS_LABEL validation: * must be no more than 63 characters long. * must consist of lower case alphanumeric characters or '-'. * must start and end with an alphanumeric character. Default is empty string. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** port represents the port number of the endpoint. If this is not specified, ports are not restricted and must be interpreted in the context of the specific consumer. */
  port?: InputMaybe<Scalars['Int']['input']>;
  protocol?: InputMaybe<Query_ListDiscoveryV1EndpointSliceForAllNamespaces_OneOf_0_Items_Items_Ports_Items_Protocol>;
};

/** EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints. */
export type Io_K8s_Api_Discovery_V1_EndpointSlice = {
  addressType: Query_ListDiscoveryV1EndpointSliceForAllNamespaces_OneOf_0_Items_Items_AddressType;
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** endpoints is a list of unique endpoints in this slice. Each slice may include a maximum of 1000 endpoints. */
  endpoints: Array<Maybe<Io_K8s_Api_Discovery_V1_Endpoint>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  /** ports specifies the list of network ports exposed by each endpoint in this slice. Each port must have a unique name. When ports is empty, it indicates that there are no defined ports. When a port is defined with a nil port value, it indicates "all ports". Each slice may include a maximum of 100 ports. */
  ports?: Maybe<Array<Maybe<Io_K8s_Api_Discovery_V1_EndpointPort>>>;
};

/** EndpointSliceList represents a list of endpoint slices */
export type Io_K8s_Api_Discovery_V1_EndpointSliceList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** items is the list of endpoint slices */
  items: Array<Maybe<Io_K8s_Api_Discovery_V1_EndpointSlice>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints. */
export type Io_K8s_Api_Discovery_V1_EndpointSlice_Input = {
  addressType: Query_ListDiscoveryV1EndpointSliceForAllNamespaces_OneOf_0_Items_Items_AddressType;
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** endpoints is a list of unique endpoints in this slice. Each slice may include a maximum of 1000 endpoints. */
  endpoints: Array<InputMaybe<Io_K8s_Api_Discovery_V1_Endpoint_Input>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  /** ports specifies the list of network ports exposed by each endpoint in this slice. Each port must have a unique name. When ports is empty, it indicates that there are no defined ports. When a port is defined with a nil port value, it indicates "all ports". Each slice may include a maximum of 100 ports. */
  ports?: InputMaybe<Array<InputMaybe<Io_K8s_Api_Discovery_V1_EndpointPort_Input>>>;
};

/** Endpoint represents a single logical "backend" implementing a service. */
export type Io_K8s_Api_Discovery_V1_Endpoint_Input = {
  /** addresses of this endpoint. The contents of this field are interpreted according to the corresponding EndpointSlice addressType field. Consumers must handle different types of addresses in the context of their own capabilities. This must contain at least one address but no more than 100. These are all assumed to be fungible and clients may choose to only use the first element. Refer to: https://issue.k8s.io/106267 */
  addresses: Array<InputMaybe<Scalars['String']['input']>>;
  conditions?: InputMaybe<Io_K8s_Api_Discovery_V1_EndpointConditions_Input>;
  /** deprecatedTopology contains topology information part of the v1beta1 API. This field is deprecated, and will be removed when the v1beta1 API is removed (no sooner than kubernetes v1.24).  While this field can hold values, it is not writable through the v1 API, and any attempts to write to it will be silently ignored. Topology information can be found in the zone and nodeName fields instead. */
  deprecatedTopology?: InputMaybe<Scalars['JSON']['input']>;
  hints?: InputMaybe<Io_K8s_Api_Discovery_V1_EndpointHints_Input>;
  /** hostname of this endpoint. This field may be used by consumers of endpoints to distinguish endpoints from each other (e.g. in DNS names). Multiple endpoints which use the same hostname should be considered fungible (e.g. multiple A values in DNS). Must be lowercase and pass DNS Label (RFC 1123) validation. */
  hostname?: InputMaybe<Scalars['String']['input']>;
  /** nodeName represents the name of the Node hosting this endpoint. This can be used to determine endpoints local to a Node. */
  nodeName?: InputMaybe<Scalars['String']['input']>;
  targetRef?: InputMaybe<Io_K8s_Api_Core_V1_ObjectReference_Input>;
  /** zone is the name of the Zone this endpoint exists in. */
  zone?: InputMaybe<Scalars['String']['input']>;
};

/** ForZone provides information about which zones should consume this endpoint. */
export type Io_K8s_Api_Discovery_V1_ForZone = {
  /** name represents the name of the zone. */
  name: Scalars['String']['output'];
};

/** ForZone provides information about which zones should consume this endpoint. */
export type Io_K8s_Api_Discovery_V1_ForZone_Input = {
  /** name represents the name of the zone. */
  name: Scalars['String']['input'];
};

/** Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data. */
export type Io_K8s_Api_Events_V1_Event = {
  /** action is what action was taken/failed regarding to the regarding object. It is machine-readable. This field cannot be empty for new Events and it can have at most 128 characters. */
  action?: Maybe<Scalars['String']['output']>;
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** deprecatedCount is the deprecated field assuring backward compatibility with core.v1 Event type. */
  deprecatedCount?: Maybe<Scalars['Int']['output']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  deprecatedFirstTimestamp?: Maybe<Scalars['DateTime']['output']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  deprecatedLastTimestamp?: Maybe<Scalars['DateTime']['output']>;
  deprecatedSource?: Maybe<Io_K8s_Api_Core_V1_EventSource>;
  /** MicroTime is version of Time with microsecond level precision. */
  eventTime: Scalars['DateTime']['output'];
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  /** note is a human-readable description of the status of this operation. Maximal length of the note is 1kB, but libraries should be prepared to handle values up to 64kB. */
  note?: Maybe<Scalars['String']['output']>;
  /** reason is why the action was taken. It is human-readable. This field cannot be empty for new Events and it can have at most 128 characters. */
  reason?: Maybe<Scalars['String']['output']>;
  regarding?: Maybe<Io_K8s_Api_Core_V1_ObjectReference>;
  related?: Maybe<Io_K8s_Api_Core_V1_ObjectReference>;
  /** reportingController is the name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`. This field cannot be empty for new Events. */
  reportingController?: Maybe<Scalars['String']['output']>;
  /** reportingInstance is the ID of the controller instance, e.g. `kubelet-xyzf`. This field cannot be empty for new Events and it can have at most 128 characters. */
  reportingInstance?: Maybe<Scalars['String']['output']>;
  series?: Maybe<Io_K8s_Api_Events_V1_EventSeries>;
  /** type is the type of this event (Normal, Warning), new types could be added in the future. It is machine-readable. This field cannot be empty for new Events. */
  type?: Maybe<Scalars['String']['output']>;
};

/** EventList is a list of Event objects. */
export type Io_K8s_Api_Events_V1_EventList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** items is a list of schema objects. */
  items: Array<Maybe<Io_K8s_Api_Events_V1_Event>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time. How often to update the EventSeries is up to the event reporters. The default event reporter in "k8s.io/client-go/tools/events/event_broadcaster.go" shows how this struct is updated on heartbeats and can guide customized reporter implementations. */
export type Io_K8s_Api_Events_V1_EventSeries = {
  /** count is the number of occurrences in this series up to the last heartbeat time. */
  count: Scalars['Int']['output'];
  /** MicroTime is version of Time with microsecond level precision. */
  lastObservedTime: Scalars['DateTime']['output'];
};

/** EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time. How often to update the EventSeries is up to the event reporters. The default event reporter in "k8s.io/client-go/tools/events/event_broadcaster.go" shows how this struct is updated on heartbeats and can guide customized reporter implementations. */
export type Io_K8s_Api_Events_V1_EventSeries_Input = {
  /** count is the number of occurrences in this series up to the last heartbeat time. */
  count: Scalars['Int']['input'];
  /** MicroTime is version of Time with microsecond level precision. */
  lastObservedTime: Scalars['DateTime']['input'];
};

/** Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data. */
export type Io_K8s_Api_Events_V1_Event_Input = {
  /** action is what action was taken/failed regarding to the regarding object. It is machine-readable. This field cannot be empty for new Events and it can have at most 128 characters. */
  action?: InputMaybe<Scalars['String']['input']>;
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** deprecatedCount is the deprecated field assuring backward compatibility with core.v1 Event type. */
  deprecatedCount?: InputMaybe<Scalars['Int']['input']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  deprecatedFirstTimestamp?: InputMaybe<Scalars['DateTime']['input']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  deprecatedLastTimestamp?: InputMaybe<Scalars['DateTime']['input']>;
  deprecatedSource?: InputMaybe<Io_K8s_Api_Core_V1_EventSource_Input>;
  /** MicroTime is version of Time with microsecond level precision. */
  eventTime: Scalars['DateTime']['input'];
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  /** note is a human-readable description of the status of this operation. Maximal length of the note is 1kB, but libraries should be prepared to handle values up to 64kB. */
  note?: InputMaybe<Scalars['String']['input']>;
  /** reason is why the action was taken. It is human-readable. This field cannot be empty for new Events and it can have at most 128 characters. */
  reason?: InputMaybe<Scalars['String']['input']>;
  regarding?: InputMaybe<Io_K8s_Api_Core_V1_ObjectReference_Input>;
  related?: InputMaybe<Io_K8s_Api_Core_V1_ObjectReference_Input>;
  /** reportingController is the name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`. This field cannot be empty for new Events. */
  reportingController?: InputMaybe<Scalars['String']['input']>;
  /** reportingInstance is the ID of the controller instance, e.g. `kubelet-xyzf`. This field cannot be empty for new Events and it can have at most 128 characters. */
  reportingInstance?: InputMaybe<Scalars['String']['input']>;
  series?: InputMaybe<Io_K8s_Api_Events_V1_EventSeries_Input>;
  /** type is the type of this event (Normal, Warning), new types could be added in the future. It is machine-readable. This field cannot be empty for new Events. */
  type?: InputMaybe<Scalars['String']['input']>;
};

/** ExemptPriorityLevelConfiguration describes the configurable aspects of the handling of exempt requests. In the mandatory exempt configuration object the values in the fields here can be modified by authorized users, unlike the rest of the `spec`. */
export type Io_K8s_Api_Flowcontrol_V1_ExemptPriorityLevelConfiguration = {
  /**
   * `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels.  This value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
   *
   * LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
   */
  lendablePercent?: Maybe<Scalars['Int']['output']>;
  /**
   * `nominalConcurrencyShares` (NCS) contributes to the computation of the NominalConcurrencyLimit (NominalCL) of this level. This is the number of execution seats nominally reserved for this priority level. This DOES NOT limit the dispatching from this priority level but affects the other priority levels through the borrowing mechanism. The server's concurrency limit (ServerCL) is divided among all the priority levels in proportion to their NCS values:
   *
   * NominalCL(i)  = ceil( ServerCL * NCS(i) / sum_ncs ) sum_ncs = sum[priority level k] NCS(k)
   *
   * Bigger numbers mean a larger nominal concurrency limit, at the expense of every other priority level. This field has a default value of zero.
   */
  nominalConcurrencyShares?: Maybe<Scalars['Int']['output']>;
};

/** ExemptPriorityLevelConfiguration describes the configurable aspects of the handling of exempt requests. In the mandatory exempt configuration object the values in the fields here can be modified by authorized users, unlike the rest of the `spec`. */
export type Io_K8s_Api_Flowcontrol_V1_ExemptPriorityLevelConfiguration_Input = {
  /**
   * `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels.  This value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
   *
   * LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
   */
  lendablePercent?: InputMaybe<Scalars['Int']['input']>;
  /**
   * `nominalConcurrencyShares` (NCS) contributes to the computation of the NominalConcurrencyLimit (NominalCL) of this level. This is the number of execution seats nominally reserved for this priority level. This DOES NOT limit the dispatching from this priority level but affects the other priority levels through the borrowing mechanism. The server's concurrency limit (ServerCL) is divided among all the priority levels in proportion to their NCS values:
   *
   * NominalCL(i)  = ceil( ServerCL * NCS(i) / sum_ncs ) sum_ncs = sum[priority level k] NCS(k)
   *
   * Bigger numbers mean a larger nominal concurrency limit, at the expense of every other priority level. This field has a default value of zero.
   */
  nominalConcurrencyShares?: InputMaybe<Scalars['Int']['input']>;
};

/** FlowDistinguisherMethod specifies the method of a flow distinguisher. */
export type Io_K8s_Api_Flowcontrol_V1_FlowDistinguisherMethod = {
  /** `type` is the type of flow distinguisher method The supported types are "ByUser" and "ByNamespace". Required. */
  type: Scalars['String']['output'];
};

/** FlowDistinguisherMethod specifies the method of a flow distinguisher. */
export type Io_K8s_Api_Flowcontrol_V1_FlowDistinguisherMethod_Input = {
  /** `type` is the type of flow distinguisher method The supported types are "ByUser" and "ByNamespace". Required. */
  type: Scalars['String']['input'];
};

/** FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a "flow distinguisher". */
export type Io_K8s_Api_Flowcontrol_V1_FlowSchema = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Io_K8s_Api_Flowcontrol_V1_FlowSchemaSpec>;
  status?: Maybe<Io_K8s_Api_Flowcontrol_V1_FlowSchemaStatus>;
};

/** FlowSchemaCondition describes conditions for a FlowSchema. */
export type Io_K8s_Api_Flowcontrol_V1_FlowSchemaCondition = {
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  lastTransitionTime?: Maybe<Scalars['DateTime']['output']>;
  /** `message` is a human-readable message indicating details about last transition. */
  message?: Maybe<Scalars['String']['output']>;
  /** `reason` is a unique, one-word, CamelCase reason for the condition's last transition. */
  reason?: Maybe<Scalars['String']['output']>;
  /** `status` is the status of the condition. Can be True, False, Unknown. Required. */
  status?: Maybe<Scalars['String']['output']>;
  /** `type` is the type of the condition. Required. */
  type?: Maybe<Scalars['String']['output']>;
};

/** FlowSchemaCondition describes conditions for a FlowSchema. */
export type Io_K8s_Api_Flowcontrol_V1_FlowSchemaCondition_Input = {
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  lastTransitionTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** `message` is a human-readable message indicating details about last transition. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** `reason` is a unique, one-word, CamelCase reason for the condition's last transition. */
  reason?: InputMaybe<Scalars['String']['input']>;
  /** `status` is the status of the condition. Can be True, False, Unknown. Required. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** `type` is the type of the condition. Required. */
  type?: InputMaybe<Scalars['String']['input']>;
};

/** FlowSchemaList is a list of FlowSchema objects. */
export type Io_K8s_Api_Flowcontrol_V1_FlowSchemaList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** `items` is a list of FlowSchemas. */
  items: Array<Maybe<Io_K8s_Api_Flowcontrol_V1_FlowSchema>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** FlowSchemaSpec describes how the FlowSchema's specification looks like. */
export type Io_K8s_Api_Flowcontrol_V1_FlowSchemaSpec = {
  distinguisherMethod?: Maybe<Io_K8s_Api_Flowcontrol_V1_FlowDistinguisherMethod>;
  /** `matchingPrecedence` is used to choose among the FlowSchemas that match a given request. The chosen FlowSchema is among those with the numerically lowest (which we take to be logically highest) MatchingPrecedence.  Each MatchingPrecedence value must be ranged in [1,10000]. Note that if the precedence is not specified, it will be set to 1000 as default. */
  matchingPrecedence?: Maybe<Scalars['Int']['output']>;
  priorityLevelConfiguration: Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationReference;
  /** `rules` describes which requests will match this flow schema. This FlowSchema matches a request if and only if at least one member of rules matches the request. if it is an empty slice, there will be no requests matching the FlowSchema. */
  rules?: Maybe<Array<Maybe<Io_K8s_Api_Flowcontrol_V1_PolicyRulesWithSubjects>>>;
};

/** FlowSchemaSpec describes how the FlowSchema's specification looks like. */
export type Io_K8s_Api_Flowcontrol_V1_FlowSchemaSpec_Input = {
  distinguisherMethod?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_FlowDistinguisherMethod_Input>;
  /** `matchingPrecedence` is used to choose among the FlowSchemas that match a given request. The chosen FlowSchema is among those with the numerically lowest (which we take to be logically highest) MatchingPrecedence.  Each MatchingPrecedence value must be ranged in [1,10000]. Note that if the precedence is not specified, it will be set to 1000 as default. */
  matchingPrecedence?: InputMaybe<Scalars['Int']['input']>;
  priorityLevelConfiguration: Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationReference_Input;
  /** `rules` describes which requests will match this flow schema. This FlowSchema matches a request if and only if at least one member of rules matches the request. if it is an empty slice, there will be no requests matching the FlowSchema. */
  rules?: InputMaybe<Array<InputMaybe<Io_K8s_Api_Flowcontrol_V1_PolicyRulesWithSubjects_Input>>>;
};

/** FlowSchemaStatus represents the current state of a FlowSchema. */
export type Io_K8s_Api_Flowcontrol_V1_FlowSchemaStatus = {
  /** `conditions` is a list of the current states of FlowSchema. */
  conditions?: Maybe<Array<Maybe<Io_K8s_Api_Flowcontrol_V1_FlowSchemaCondition>>>;
};

/** FlowSchemaStatus represents the current state of a FlowSchema. */
export type Io_K8s_Api_Flowcontrol_V1_FlowSchemaStatus_Input = {
  /** `conditions` is a list of the current states of FlowSchema. */
  conditions?: InputMaybe<Array<InputMaybe<Io_K8s_Api_Flowcontrol_V1_FlowSchemaCondition_Input>>>;
};

/** FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a "flow distinguisher". */
export type Io_K8s_Api_Flowcontrol_V1_FlowSchema_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_FlowSchemaSpec_Input>;
  status?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_FlowSchemaStatus_Input>;
};

/** GroupSubject holds detailed information for group-kind subject. */
export type Io_K8s_Api_Flowcontrol_V1_GroupSubject = {
  /** name is the user group that matches, or "*" to match all user groups. See https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go for some well-known group names. Required. */
  name: Scalars['String']['output'];
};

/** GroupSubject holds detailed information for group-kind subject. */
export type Io_K8s_Api_Flowcontrol_V1_GroupSubject_Input = {
  /** name is the user group that matches, or "*" to match all user groups. See https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go for some well-known group names. Required. */
  name: Scalars['String']['input'];
};

/** LimitResponse defines how to handle requests that can not be executed right now. */
export type Io_K8s_Api_Flowcontrol_V1_LimitResponse = {
  queuing?: Maybe<Io_K8s_Api_Flowcontrol_V1_QueuingConfiguration>;
  /** `type` is "Queue" or "Reject". "Queue" means that requests that can not be executed upon arrival are held in a queue until they can be executed or a queuing limit is reached. "Reject" means that requests that can not be executed upon arrival are rejected. Required. */
  type: Scalars['String']['output'];
};

/** LimitResponse defines how to handle requests that can not be executed right now. */
export type Io_K8s_Api_Flowcontrol_V1_LimitResponse_Input = {
  queuing?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_QueuingConfiguration_Input>;
  /** `type` is "Queue" or "Reject". "Queue" means that requests that can not be executed upon arrival are held in a queue until they can be executed or a queuing limit is reached. "Reject" means that requests that can not be executed upon arrival are rejected. Required. */
  type: Scalars['String']['input'];
};

/**
 * LimitedPriorityLevelConfiguration specifies how to handle requests that are subject to limits. It addresses two issues:
 *   - How are requests for this priority level limited?
 *   - What should be done with requests that exceed the limit?
 */
export type Io_K8s_Api_Flowcontrol_V1_LimitedPriorityLevelConfiguration = {
  /**
   * `borrowingLimitPercent`, if present, configures a limit on how many seats this priority level can borrow from other priority levels. The limit is known as this level's BorrowingConcurrencyLimit (BorrowingCL) and is a limit on the total number of seats that this level may borrow at any one time. This field holds the ratio of that limit to the level's nominal concurrency limit. When this field is non-nil, it must hold a non-negative integer and the limit is calculated as follows.
   *
   * BorrowingCL(i) = round( NominalCL(i) * borrowingLimitPercent(i)/100.0 )
   *
   * The value of this field can be more than 100, implying that this priority level can borrow a number of seats that is greater than its own nominal concurrency limit (NominalCL). When this field is left `nil`, the limit is effectively infinite.
   */
  borrowingLimitPercent?: Maybe<Scalars['Int']['output']>;
  /**
   * `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels. The value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
   *
   * LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
   */
  lendablePercent?: Maybe<Scalars['Int']['output']>;
  limitResponse?: Maybe<Io_K8s_Api_Flowcontrol_V1_LimitResponse>;
  /**
   * `nominalConcurrencyShares` (NCS) contributes to the computation of the NominalConcurrencyLimit (NominalCL) of this level. This is the number of execution seats available at this priority level. This is used both for requests dispatched from this priority level as well as requests dispatched from other priority levels borrowing seats from this level. The server's concurrency limit (ServerCL) is divided among the Limited priority levels in proportion to their NCS values:
   *
   * NominalCL(i)  = ceil( ServerCL * NCS(i) / sum_ncs ) sum_ncs = sum[priority level k] NCS(k)
   *
   * Bigger numbers mean a larger nominal concurrency limit, at the expense of every other priority level.
   *
   * If not specified, this field defaults to a value of 30.
   *
   * Setting this field to zero supports the construction of a "jail" for this priority level that is used to hold some request(s)
   */
  nominalConcurrencyShares?: Maybe<Scalars['Int']['output']>;
};

/**
 * LimitedPriorityLevelConfiguration specifies how to handle requests that are subject to limits. It addresses two issues:
 *   - How are requests for this priority level limited?
 *   - What should be done with requests that exceed the limit?
 */
export type Io_K8s_Api_Flowcontrol_V1_LimitedPriorityLevelConfiguration_Input = {
  /**
   * `borrowingLimitPercent`, if present, configures a limit on how many seats this priority level can borrow from other priority levels. The limit is known as this level's BorrowingConcurrencyLimit (BorrowingCL) and is a limit on the total number of seats that this level may borrow at any one time. This field holds the ratio of that limit to the level's nominal concurrency limit. When this field is non-nil, it must hold a non-negative integer and the limit is calculated as follows.
   *
   * BorrowingCL(i) = round( NominalCL(i) * borrowingLimitPercent(i)/100.0 )
   *
   * The value of this field can be more than 100, implying that this priority level can borrow a number of seats that is greater than its own nominal concurrency limit (NominalCL). When this field is left `nil`, the limit is effectively infinite.
   */
  borrowingLimitPercent?: InputMaybe<Scalars['Int']['input']>;
  /**
   * `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels. The value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
   *
   * LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
   */
  lendablePercent?: InputMaybe<Scalars['Int']['input']>;
  limitResponse?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_LimitResponse_Input>;
  /**
   * `nominalConcurrencyShares` (NCS) contributes to the computation of the NominalConcurrencyLimit (NominalCL) of this level. This is the number of execution seats available at this priority level. This is used both for requests dispatched from this priority level as well as requests dispatched from other priority levels borrowing seats from this level. The server's concurrency limit (ServerCL) is divided among the Limited priority levels in proportion to their NCS values:
   *
   * NominalCL(i)  = ceil( ServerCL * NCS(i) / sum_ncs ) sum_ncs = sum[priority level k] NCS(k)
   *
   * Bigger numbers mean a larger nominal concurrency limit, at the expense of every other priority level.
   *
   * If not specified, this field defaults to a value of 30.
   *
   * Setting this field to zero supports the construction of a "jail" for this priority level that is used to hold some request(s)
   */
  nominalConcurrencyShares?: InputMaybe<Scalars['Int']['input']>;
};

/** NonResourcePolicyRule is a predicate that matches non-resource requests according to their verb and the target non-resource URL. A NonResourcePolicyRule matches a request if and only if both (a) at least one member of verbs matches the request and (b) at least one member of nonResourceURLs matches the request. */
export type Io_K8s_Api_Flowcontrol_V1_NonResourcePolicyRule = {
  /**
   * `nonResourceURLs` is a set of url prefixes that a user should have access to and may not be empty. For example:
   *   - "/healthz" is legal
   *   - "/hea*" is illegal
   *   - "/hea" is legal but matches nothing
   *   - "/hea/*" also matches nothing
   *   - "/healthz/*" matches all per-component health checks.
   * "*" matches all non-resource urls. if it is present, it must be the only entry. Required.
   */
  nonResourceURLs: Array<Maybe<Scalars['String']['output']>>;
  /** `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs. If it is present, it must be the only entry. Required. */
  verbs: Array<Maybe<Scalars['String']['output']>>;
};

/** NonResourcePolicyRule is a predicate that matches non-resource requests according to their verb and the target non-resource URL. A NonResourcePolicyRule matches a request if and only if both (a) at least one member of verbs matches the request and (b) at least one member of nonResourceURLs matches the request. */
export type Io_K8s_Api_Flowcontrol_V1_NonResourcePolicyRule_Input = {
  /**
   * `nonResourceURLs` is a set of url prefixes that a user should have access to and may not be empty. For example:
   *   - "/healthz" is legal
   *   - "/hea*" is illegal
   *   - "/hea" is legal but matches nothing
   *   - "/hea/*" also matches nothing
   *   - "/healthz/*" matches all per-component health checks.
   * "*" matches all non-resource urls. if it is present, it must be the only entry. Required.
   */
  nonResourceURLs: Array<InputMaybe<Scalars['String']['input']>>;
  /** `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs. If it is present, it must be the only entry. Required. */
  verbs: Array<InputMaybe<Scalars['String']['input']>>;
};

/** PolicyRulesWithSubjects prescribes a test that applies to a request to an apiserver. The test considers the subject making the request, the verb being requested, and the resource to be acted upon. This PolicyRulesWithSubjects matches a request if and only if both (a) at least one member of subjects matches the request and (b) at least one member of resourceRules or nonResourceRules matches the request. */
export type Io_K8s_Api_Flowcontrol_V1_PolicyRulesWithSubjects = {
  /** `nonResourceRules` is a list of NonResourcePolicyRules that identify matching requests according to their verb and the target non-resource URL. */
  nonResourceRules?: Maybe<Array<Maybe<Io_K8s_Api_Flowcontrol_V1_NonResourcePolicyRule>>>;
  /** `resourceRules` is a slice of ResourcePolicyRules that identify matching requests according to their verb and the target resource. At least one of `resourceRules` and `nonResourceRules` has to be non-empty. */
  resourceRules?: Maybe<Array<Maybe<Io_K8s_Api_Flowcontrol_V1_ResourcePolicyRule>>>;
  /** subjects is the list of normal user, serviceaccount, or group that this rule cares about. There must be at least one member in this slice. A slice that includes both the system:authenticated and system:unauthenticated user groups matches every request. Required. */
  subjects: Array<Maybe<Io_K8s_Api_Flowcontrol_V1_Subject>>;
};

/** PolicyRulesWithSubjects prescribes a test that applies to a request to an apiserver. The test considers the subject making the request, the verb being requested, and the resource to be acted upon. This PolicyRulesWithSubjects matches a request if and only if both (a) at least one member of subjects matches the request and (b) at least one member of resourceRules or nonResourceRules matches the request. */
export type Io_K8s_Api_Flowcontrol_V1_PolicyRulesWithSubjects_Input = {
  /** `nonResourceRules` is a list of NonResourcePolicyRules that identify matching requests according to their verb and the target non-resource URL. */
  nonResourceRules?: InputMaybe<
    Array<InputMaybe<Io_K8s_Api_Flowcontrol_V1_NonResourcePolicyRule_Input>>
  >;
  /** `resourceRules` is a slice of ResourcePolicyRules that identify matching requests according to their verb and the target resource. At least one of `resourceRules` and `nonResourceRules` has to be non-empty. */
  resourceRules?: InputMaybe<Array<InputMaybe<Io_K8s_Api_Flowcontrol_V1_ResourcePolicyRule_Input>>>;
  /** subjects is the list of normal user, serviceaccount, or group that this rule cares about. There must be at least one member in this slice. A slice that includes both the system:authenticated and system:unauthenticated user groups matches every request. Required. */
  subjects: Array<InputMaybe<Io_K8s_Api_Flowcontrol_V1_Subject_Input>>;
};

/** PriorityLevelConfiguration represents the configuration of a priority level. */
export type Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfiguration = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationSpec>;
  status?: Maybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationStatus>;
};

/** PriorityLevelConfigurationCondition defines the condition of priority level. */
export type Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationCondition = {
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  lastTransitionTime?: Maybe<Scalars['DateTime']['output']>;
  /** `message` is a human-readable message indicating details about last transition. */
  message?: Maybe<Scalars['String']['output']>;
  /** `reason` is a unique, one-word, CamelCase reason for the condition's last transition. */
  reason?: Maybe<Scalars['String']['output']>;
  /** `status` is the status of the condition. Can be True, False, Unknown. Required. */
  status?: Maybe<Scalars['String']['output']>;
  /** `type` is the type of the condition. Required. */
  type?: Maybe<Scalars['String']['output']>;
};

/** PriorityLevelConfigurationCondition defines the condition of priority level. */
export type Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationCondition_Input = {
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  lastTransitionTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** `message` is a human-readable message indicating details about last transition. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** `reason` is a unique, one-word, CamelCase reason for the condition's last transition. */
  reason?: InputMaybe<Scalars['String']['input']>;
  /** `status` is the status of the condition. Can be True, False, Unknown. Required. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** `type` is the type of the condition. Required. */
  type?: InputMaybe<Scalars['String']['input']>;
};

/** PriorityLevelConfigurationList is a list of PriorityLevelConfiguration objects. */
export type Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** `items` is a list of request-priorities. */
  items: Array<Maybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfiguration>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** PriorityLevelConfigurationReference contains information that points to the "request-priority" being used. */
export type Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationReference = {
  /** `name` is the name of the priority level configuration being referenced Required. */
  name: Scalars['String']['output'];
};

/** PriorityLevelConfigurationReference contains information that points to the "request-priority" being used. */
export type Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationReference_Input = {
  /** `name` is the name of the priority level configuration being referenced Required. */
  name: Scalars['String']['input'];
};

/** PriorityLevelConfigurationSpec specifies the configuration of a priority level. */
export type Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationSpec = {
  exempt?: Maybe<Io_K8s_Api_Flowcontrol_V1_ExemptPriorityLevelConfiguration>;
  limited?: Maybe<Io_K8s_Api_Flowcontrol_V1_LimitedPriorityLevelConfiguration>;
  /** `type` indicates whether this priority level is subject to limitation on request execution.  A value of `"Exempt"` means that requests of this priority level are not subject to a limit (and thus are never queued) and do not detract from the capacity made available to other priority levels.  A value of `"Limited"` means that (a) requests of this priority level _are_ subject to limits and (b) some of the server's limited capacity is made available exclusively to this priority level. Required. */
  type: Scalars['String']['output'];
};

/** PriorityLevelConfigurationSpec specifies the configuration of a priority level. */
export type Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationSpec_Input = {
  exempt?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_ExemptPriorityLevelConfiguration_Input>;
  limited?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_LimitedPriorityLevelConfiguration_Input>;
  /** `type` indicates whether this priority level is subject to limitation on request execution.  A value of `"Exempt"` means that requests of this priority level are not subject to a limit (and thus are never queued) and do not detract from the capacity made available to other priority levels.  A value of `"Limited"` means that (a) requests of this priority level _are_ subject to limits and (b) some of the server's limited capacity is made available exclusively to this priority level. Required. */
  type: Scalars['String']['input'];
};

/** PriorityLevelConfigurationStatus represents the current state of a "request-priority". */
export type Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationStatus = {
  /** `conditions` is the current state of "request-priority". */
  conditions?: Maybe<Array<Maybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationCondition>>>;
};

/** PriorityLevelConfigurationStatus represents the current state of a "request-priority". */
export type Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationStatus_Input = {
  /** `conditions` is the current state of "request-priority". */
  conditions?: InputMaybe<
    Array<InputMaybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationCondition_Input>>
  >;
};

/** PriorityLevelConfiguration represents the configuration of a priority level. */
export type Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfiguration_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationSpec_Input>;
  status?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_PriorityLevelConfigurationStatus_Input>;
};

/** QueuingConfiguration holds the configuration parameters for queuing */
export type Io_K8s_Api_Flowcontrol_V1_QueuingConfiguration = {
  /** `handSize` is a small positive number that configures the shuffle sharding of requests into queues.  When enqueuing a request at this priority level the request's flow identifier (a string pair) is hashed and the hash value is used to shuffle the list of queues and deal a hand of the size specified here.  The request is put into one of the shortest queues in that hand. `handSize` must be no larger than `queues`, and should be significantly smaller (so that a few heavy flows do not saturate most of the queues).  See the user-facing documentation for more extensive guidance on setting this field.  This field has a default value of 8. */
  handSize?: Maybe<Scalars['Int']['output']>;
  /** `queueLengthLimit` is the maximum number of requests allowed to be waiting in a given queue of this priority level at a time; excess requests are rejected.  This value must be positive.  If not specified, it will be defaulted to 50. */
  queueLengthLimit?: Maybe<Scalars['Int']['output']>;
  /** `queues` is the number of queues for this priority level. The queues exist independently at each apiserver. The value must be positive.  Setting it to 1 effectively precludes shufflesharding and thus makes the distinguisher method of associated flow schemas irrelevant.  This field has a default value of 64. */
  queues?: Maybe<Scalars['Int']['output']>;
};

/** QueuingConfiguration holds the configuration parameters for queuing */
export type Io_K8s_Api_Flowcontrol_V1_QueuingConfiguration_Input = {
  /** `handSize` is a small positive number that configures the shuffle sharding of requests into queues.  When enqueuing a request at this priority level the request's flow identifier (a string pair) is hashed and the hash value is used to shuffle the list of queues and deal a hand of the size specified here.  The request is put into one of the shortest queues in that hand. `handSize` must be no larger than `queues`, and should be significantly smaller (so that a few heavy flows do not saturate most of the queues).  See the user-facing documentation for more extensive guidance on setting this field.  This field has a default value of 8. */
  handSize?: InputMaybe<Scalars['Int']['input']>;
  /** `queueLengthLimit` is the maximum number of requests allowed to be waiting in a given queue of this priority level at a time; excess requests are rejected.  This value must be positive.  If not specified, it will be defaulted to 50. */
  queueLengthLimit?: InputMaybe<Scalars['Int']['input']>;
  /** `queues` is the number of queues for this priority level. The queues exist independently at each apiserver. The value must be positive.  Setting it to 1 effectively precludes shufflesharding and thus makes the distinguisher method of associated flow schemas irrelevant.  This field has a default value of 64. */
  queues?: InputMaybe<Scalars['Int']['input']>;
};

/** ResourcePolicyRule is a predicate that matches some resource requests, testing the request's verb and the target resource. A ResourcePolicyRule matches a resource request if and only if: (a) at least one member of verbs matches the request, (b) at least one member of apiGroups matches the request, (c) at least one member of resources matches the request, and (d) either (d1) the request does not specify a namespace (i.e., `Namespace==""`) and clusterScope is true or (d2) the request specifies a namespace and least one member of namespaces matches the request's namespace. */
export type Io_K8s_Api_Flowcontrol_V1_ResourcePolicyRule = {
  /** `apiGroups` is a list of matching API groups and may not be empty. "*" matches all API groups and, if present, must be the only entry. Required. */
  apiGroups: Array<Maybe<Scalars['String']['output']>>;
  /** `clusterScope` indicates whether to match requests that do not specify a namespace (which happens either because the resource is not namespaced or the request targets all namespaces). If this field is omitted or false then the `namespaces` field must contain a non-empty list. */
  clusterScope?: Maybe<Scalars['Boolean']['output']>;
  /** `namespaces` is a list of target namespaces that restricts matches.  A request that specifies a target namespace matches only if either (a) this list contains that target namespace or (b) this list contains "*".  Note that "*" matches any specified namespace but does not match a request that _does not specify_ a namespace (see the `clusterScope` field for that). This list may be empty, but only if `clusterScope` is true. */
  namespaces?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** `resources` is a list of matching resources (i.e., lowercase and plural) with, if desired, subresource.  For example, [ "services", "nodes/status" ].  This list may not be empty. "*" matches all resources and, if present, must be the only entry. Required. */
  resources: Array<Maybe<Scalars['String']['output']>>;
  /** `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs and, if present, must be the only entry. Required. */
  verbs: Array<Maybe<Scalars['String']['output']>>;
};

/** ResourcePolicyRule is a predicate that matches some resource requests, testing the request's verb and the target resource. A ResourcePolicyRule matches a resource request if and only if: (a) at least one member of verbs matches the request, (b) at least one member of apiGroups matches the request, (c) at least one member of resources matches the request, and (d) either (d1) the request does not specify a namespace (i.e., `Namespace==""`) and clusterScope is true or (d2) the request specifies a namespace and least one member of namespaces matches the request's namespace. */
export type Io_K8s_Api_Flowcontrol_V1_ResourcePolicyRule_Input = {
  /** `apiGroups` is a list of matching API groups and may not be empty. "*" matches all API groups and, if present, must be the only entry. Required. */
  apiGroups: Array<InputMaybe<Scalars['String']['input']>>;
  /** `clusterScope` indicates whether to match requests that do not specify a namespace (which happens either because the resource is not namespaced or the request targets all namespaces). If this field is omitted or false then the `namespaces` field must contain a non-empty list. */
  clusterScope?: InputMaybe<Scalars['Boolean']['input']>;
  /** `namespaces` is a list of target namespaces that restricts matches.  A request that specifies a target namespace matches only if either (a) this list contains that target namespace or (b) this list contains "*".  Note that "*" matches any specified namespace but does not match a request that _does not specify_ a namespace (see the `clusterScope` field for that). This list may be empty, but only if `clusterScope` is true. */
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** `resources` is a list of matching resources (i.e., lowercase and plural) with, if desired, subresource.  For example, [ "services", "nodes/status" ].  This list may not be empty. "*" matches all resources and, if present, must be the only entry. Required. */
  resources: Array<InputMaybe<Scalars['String']['input']>>;
  /** `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs and, if present, must be the only entry. Required. */
  verbs: Array<InputMaybe<Scalars['String']['input']>>;
};

/** ServiceAccountSubject holds detailed information for service-account-kind subject. */
export type Io_K8s_Api_Flowcontrol_V1_ServiceAccountSubject = {
  /** `name` is the name of matching ServiceAccount objects, or "*" to match regardless of name. Required. */
  name: Scalars['String']['output'];
  /** `namespace` is the namespace of matching ServiceAccount objects. Required. */
  namespace: Scalars['String']['output'];
};

/** ServiceAccountSubject holds detailed information for service-account-kind subject. */
export type Io_K8s_Api_Flowcontrol_V1_ServiceAccountSubject_Input = {
  /** `name` is the name of matching ServiceAccount objects, or "*" to match regardless of name. Required. */
  name: Scalars['String']['input'];
  /** `namespace` is the namespace of matching ServiceAccount objects. Required. */
  namespace: Scalars['String']['input'];
};

/** Subject matches the originator of a request, as identified by the request authentication system. There are three ways of matching an originator; by user, group, or service account. */
export type Io_K8s_Api_Flowcontrol_V1_Subject = {
  group?: Maybe<Io_K8s_Api_Flowcontrol_V1_GroupSubject>;
  /** `kind` indicates which one of the other fields is non-empty. Required */
  kind: Scalars['String']['output'];
  serviceAccount?: Maybe<Io_K8s_Api_Flowcontrol_V1_ServiceAccountSubject>;
  user?: Maybe<Io_K8s_Api_Flowcontrol_V1_UserSubject>;
};

/** Subject matches the originator of a request, as identified by the request authentication system. There are three ways of matching an originator; by user, group, or service account. */
export type Io_K8s_Api_Flowcontrol_V1_Subject_Input = {
  group?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_GroupSubject_Input>;
  /** `kind` indicates which one of the other fields is non-empty. Required */
  kind: Scalars['String']['input'];
  serviceAccount?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_ServiceAccountSubject_Input>;
  user?: InputMaybe<Io_K8s_Api_Flowcontrol_V1_UserSubject_Input>;
};

/** UserSubject holds detailed information for user-kind subject. */
export type Io_K8s_Api_Flowcontrol_V1_UserSubject = {
  /** `name` is the username that matches, or "*" to match all usernames. Required. */
  name: Scalars['String']['output'];
};

/** UserSubject holds detailed information for user-kind subject. */
export type Io_K8s_Api_Flowcontrol_V1_UserSubject_Input = {
  /** `name` is the username that matches, or "*" to match all usernames. Required. */
  name: Scalars['String']['input'];
};

/** AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole */
export type Io_K8s_Api_Rbac_V1_AggregationRule = {
  /** ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles and create the rules. If any of the selectors match, then the ClusterRole's permissions will be added */
  clusterRoleSelectors?: Maybe<Array<Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector>>>;
};

/** AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole */
export type Io_K8s_Api_Rbac_V1_AggregationRule_Input = {
  /** ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles and create the rules. If any of the selectors match, then the ClusterRole's permissions will be added */
  clusterRoleSelectors?: InputMaybe<
    Array<InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector_Input>>
  >;
};

/** ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. */
export type Io_K8s_Api_Rbac_V1_ClusterRole = {
  aggregationRule?: Maybe<Io_K8s_Api_Rbac_V1_AggregationRule>;
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  /** Rules holds all the PolicyRules for this ClusterRole */
  rules?: Maybe<Array<Maybe<Io_K8s_Api_Rbac_V1_PolicyRule>>>;
};

/** ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject. */
export type Io_K8s_Api_Rbac_V1_ClusterRoleBinding = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  roleRef: Io_K8s_Api_Rbac_V1_RoleRef;
  /** Subjects holds references to the objects the role applies to. */
  subjects?: Maybe<Array<Maybe<Io_K8s_Api_Rbac_V1_Subject>>>;
};

/** ClusterRoleBindingList is a collection of ClusterRoleBindings */
export type Io_K8s_Api_Rbac_V1_ClusterRoleBindingList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Items is a list of ClusterRoleBindings */
  items: Array<Maybe<Io_K8s_Api_Rbac_V1_ClusterRoleBinding>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject. */
export type Io_K8s_Api_Rbac_V1_ClusterRoleBinding_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  roleRef: Io_K8s_Api_Rbac_V1_RoleRef_Input;
  /** Subjects holds references to the objects the role applies to. */
  subjects?: InputMaybe<Array<InputMaybe<Io_K8s_Api_Rbac_V1_Subject_Input>>>;
};

/** ClusterRoleList is a collection of ClusterRoles */
export type Io_K8s_Api_Rbac_V1_ClusterRoleList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Items is a list of ClusterRoles */
  items: Array<Maybe<Io_K8s_Api_Rbac_V1_ClusterRole>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. */
export type Io_K8s_Api_Rbac_V1_ClusterRole_Input = {
  aggregationRule?: InputMaybe<Io_K8s_Api_Rbac_V1_AggregationRule_Input>;
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  /** Rules holds all the PolicyRules for this ClusterRole */
  rules?: InputMaybe<Array<InputMaybe<Io_K8s_Api_Rbac_V1_PolicyRule_Input>>>;
};

/** PolicyRule holds information that describes a policy rule, but does not contain information about who the rule applies to or which namespace the rule applies to. */
export type Io_K8s_Api_Rbac_V1_PolicyRule = {
  /** APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed. "" represents the core API group and "*" represents all API groups. */
  apiGroups?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding. Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both. */
  nonResourceURLs?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed. */
  resourceNames?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Resources is a list of resources this rule applies to. '*' represents all resources. */
  resources?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs. */
  verbs: Array<Maybe<Scalars['String']['output']>>;
};

/** PolicyRule holds information that describes a policy rule, but does not contain information about who the rule applies to or which namespace the rule applies to. */
export type Io_K8s_Api_Rbac_V1_PolicyRule_Input = {
  /** APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed. "" represents the core API group and "*" represents all API groups. */
  apiGroups?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding. Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both. */
  nonResourceURLs?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed. */
  resourceNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Resources is a list of resources this rule applies to. '*' represents all resources. */
  resources?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs. */
  verbs: Array<InputMaybe<Scalars['String']['input']>>;
};

/** Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. */
export type Io_K8s_Api_Rbac_V1_Role = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  /** Rules holds all the PolicyRules for this Role */
  rules?: Maybe<Array<Maybe<Io_K8s_Api_Rbac_V1_PolicyRule>>>;
};

/** RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace. */
export type Io_K8s_Api_Rbac_V1_RoleBinding = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  roleRef: Io_K8s_Api_Rbac_V1_RoleRef;
  /** Subjects holds references to the objects the role applies to. */
  subjects?: Maybe<Array<Maybe<Io_K8s_Api_Rbac_V1_Subject>>>;
};

/** RoleBindingList is a collection of RoleBindings */
export type Io_K8s_Api_Rbac_V1_RoleBindingList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Items is a list of RoleBindings */
  items: Array<Maybe<Io_K8s_Api_Rbac_V1_RoleBinding>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace. */
export type Io_K8s_Api_Rbac_V1_RoleBinding_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  roleRef: Io_K8s_Api_Rbac_V1_RoleRef_Input;
  /** Subjects holds references to the objects the role applies to. */
  subjects?: InputMaybe<Array<InputMaybe<Io_K8s_Api_Rbac_V1_Subject_Input>>>;
};

/** RoleList is a collection of Roles */
export type Io_K8s_Api_Rbac_V1_RoleList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Items is a list of Roles */
  items: Array<Maybe<Io_K8s_Api_Rbac_V1_Role>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** RoleRef contains information that points to the role being used */
export type Io_K8s_Api_Rbac_V1_RoleRef = {
  /** APIGroup is the group for the resource being referenced */
  apiGroup: Scalars['String']['output'];
  /** Kind is the type of resource being referenced */
  kind: Scalars['String']['output'];
  /** Name is the name of resource being referenced */
  name: Scalars['String']['output'];
};

/** RoleRef contains information that points to the role being used */
export type Io_K8s_Api_Rbac_V1_RoleRef_Input = {
  /** APIGroup is the group for the resource being referenced */
  apiGroup: Scalars['String']['input'];
  /** Kind is the type of resource being referenced */
  kind: Scalars['String']['input'];
  /** Name is the name of resource being referenced */
  name: Scalars['String']['input'];
};

/** Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. */
export type Io_K8s_Api_Rbac_V1_Role_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  /** Rules holds all the PolicyRules for this Role */
  rules?: InputMaybe<Array<InputMaybe<Io_K8s_Api_Rbac_V1_PolicyRule_Input>>>;
};

/** Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names. */
export type Io_K8s_Api_Rbac_V1_Subject = {
  /** APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects. */
  apiGroup?: Maybe<Scalars['String']['output']>;
  /** Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer should report an error. */
  kind: Scalars['String']['output'];
  /** Name of the object being referenced. */
  name: Scalars['String']['output'];
  /** Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty the Authorizer should report an error. */
  namespace?: Maybe<Scalars['String']['output']>;
};

/** Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names. */
export type Io_K8s_Api_Rbac_V1_Subject_Input = {
  /** APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects. */
  apiGroup?: InputMaybe<Scalars['String']['input']>;
  /** Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer should report an error. */
  kind: Scalars['String']['input'];
  /** Name of the object being referenced. */
  name: Scalars['String']['input'];
  /** Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty the Authorizer should report an error. */
  namespace?: InputMaybe<Scalars['String']['input']>;
};

/** CustomResourceColumnDefinition specifies a column for server side printing. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceColumnDefinition =
  {
    /** description is a human readable description of this column. */
    description?: Maybe<Scalars['String']['output']>;
    /** format is an optional OpenAPI type definition for this column. The 'name' format is applied to the primary identifier column to assist in clients identifying column is the resource name. See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details. */
    format?: Maybe<Scalars['String']['output']>;
    /** jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against each custom resource to produce the value for this column. */
    jsonPath: Scalars['String']['output'];
    /** name is a human readable name for the column. */
    name: Scalars['String']['output'];
    /** priority is an integer defining the relative importance of this column compared to others. Lower numbers are considered higher priority. Columns that may be omitted in limited space scenarios should be given a priority greater than 0. */
    priority?: Maybe<Scalars['Int']['output']>;
    /** type is an OpenAPI type definition for this column. See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details. */
    type: Scalars['String']['output'];
  };

/** CustomResourceColumnDefinition specifies a column for server side printing. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceColumnDefinition_Input =
  {
    /** description is a human readable description of this column. */
    description?: InputMaybe<Scalars['String']['input']>;
    /** format is an optional OpenAPI type definition for this column. The 'name' format is applied to the primary identifier column to assist in clients identifying column is the resource name. See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details. */
    format?: InputMaybe<Scalars['String']['input']>;
    /** jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against each custom resource to produce the value for this column. */
    jsonPath: Scalars['String']['input'];
    /** name is a human readable name for the column. */
    name: Scalars['String']['input'];
    /** priority is an integer defining the relative importance of this column compared to others. Lower numbers are considered higher priority. Columns that may be omitted in limited space scenarios should be given a priority greater than 0. */
    priority?: InputMaybe<Scalars['Int']['input']>;
    /** type is an OpenAPI type definition for this column. See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details. */
    type: Scalars['String']['input'];
  };

/** CustomResourceConversion describes how to convert different versions of a CR. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceConversion = {
  /**
   * strategy specifies how custom resources are converted between versions. Allowed values are: - `"None"`: The converter only change the apiVersion and would not touch any other field in the custom resource. - `"Webhook"`: API Server will call to an external webhook to do the conversion. Additional information
   *   is needed for this option. This requires spec.preserveUnknownFields to be false, and spec.conversion.webhook to be set.
   */
  strategy: Scalars['String']['output'];
  webhook?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_WebhookConversion>;
};

/** CustomResourceConversion describes how to convert different versions of a CR. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceConversion_Input =
  {
    /**
     * strategy specifies how custom resources are converted between versions. Allowed values are: - `"None"`: The converter only change the apiVersion and would not touch any other field in the custom resource. - `"Webhook"`: API Server will call to an external webhook to do the conversion. Additional information
     *   is needed for this option. This requires spec.preserveUnknownFields to be false, and spec.conversion.webhook to be set.
     */
    strategy: Scalars['String']['input'];
    webhook?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_WebhookConversion_Input>;
  };

/** CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinition = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionSpec;
  status?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionStatus>;
};

/** CustomResourceDefinitionCondition contains details for the current condition of this pod. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionCondition =
  {
    /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
    lastTransitionTime?: Maybe<Scalars['DateTime']['output']>;
    /** message is a human-readable message indicating details about last transition. */
    message?: Maybe<Scalars['String']['output']>;
    /** reason is a unique, one-word, CamelCase reason for the condition's last transition. */
    reason?: Maybe<Scalars['String']['output']>;
    /** status is the status of the condition. Can be True, False, Unknown. */
    status: Scalars['String']['output'];
    /** type is the type of the condition. Types include Established, NamesAccepted and Terminating. */
    type: Scalars['String']['output'];
  };

/** CustomResourceDefinitionCondition contains details for the current condition of this pod. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionCondition_Input =
  {
    /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
    lastTransitionTime?: InputMaybe<Scalars['DateTime']['input']>;
    /** message is a human-readable message indicating details about last transition. */
    message?: InputMaybe<Scalars['String']['input']>;
    /** reason is a unique, one-word, CamelCase reason for the condition's last transition. */
    reason?: InputMaybe<Scalars['String']['input']>;
    /** status is the status of the condition. Can be True, False, Unknown. */
    status: Scalars['String']['input'];
    /** type is the type of the condition. Types include Established, NamesAccepted and Terminating. */
    type: Scalars['String']['input'];
  };

/** CustomResourceDefinitionList is a list of CustomResourceDefinition objects. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionList =
  {
    /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
    apiVersion?: Maybe<Scalars['String']['output']>;
    /** items list individual CustomResourceDefinition objects */
    items: Array<
      Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinition>
    >;
    /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
    kind?: Maybe<Scalars['String']['output']>;
    metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
  };

/** CustomResourceDefinitionNames indicates the names to serve this CustomResourceDefinition */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionNames =
  {
    /** categories is a list of grouped resources this custom resource belongs to (e.g. 'all'). This is published in API discovery documents, and used by clients to support invocations like `kubectl get all`. */
    categories?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /** kind is the serialized kind of the resource. It is normally CamelCase and singular. Custom resource instances will use this value as the `kind` attribute in API calls. */
    kind: Scalars['String']['output'];
    /** listKind is the serialized kind of the list for this resource. Defaults to "`kind`List". */
    listKind?: Maybe<Scalars['String']['output']>;
    /** plural is the plural name of the resource to serve. The custom resources are served under `/apis/<group>/<version>/.../<plural>`. Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`). Must be all lowercase. */
    plural: Scalars['String']['output'];
    /** shortNames are short names for the resource, exposed in API discovery documents, and used by clients to support invocations like `kubectl get <shortname>`. It must be all lowercase. */
    shortNames?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /** singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`. */
    singular?: Maybe<Scalars['String']['output']>;
  };

/** CustomResourceDefinitionNames indicates the names to serve this CustomResourceDefinition */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionNames_Input =
  {
    /** categories is a list of grouped resources this custom resource belongs to (e.g. 'all'). This is published in API discovery documents, and used by clients to support invocations like `kubectl get all`. */
    categories?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /** kind is the serialized kind of the resource. It is normally CamelCase and singular. Custom resource instances will use this value as the `kind` attribute in API calls. */
    kind: Scalars['String']['input'];
    /** listKind is the serialized kind of the list for this resource. Defaults to "`kind`List". */
    listKind?: InputMaybe<Scalars['String']['input']>;
    /** plural is the plural name of the resource to serve. The custom resources are served under `/apis/<group>/<version>/.../<plural>`. Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`). Must be all lowercase. */
    plural: Scalars['String']['input'];
    /** shortNames are short names for the resource, exposed in API discovery documents, and used by clients to support invocations like `kubectl get <shortname>`. It must be all lowercase. */
    shortNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /** singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`. */
    singular?: InputMaybe<Scalars['String']['input']>;
  };

/** CustomResourceDefinitionSpec describes how a user wants their resource to appear */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionSpec =
  {
    conversion?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceConversion>;
    /** group is the API group of the defined custom resource. The custom resources are served under `/apis/<group>/...`. Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`). */
    group: Scalars['String']['output'];
    names: Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionNames;
    /** preserveUnknownFields indicates that object fields which are not specified in the OpenAPI schema should be preserved when persisting to storage. apiVersion, kind, metadata and known fields inside metadata are always preserved. This field is deprecated in favor of setting `x-preserve-unknown-fields` to true in `spec.versions[*].schema.openAPIV3Schema`. See https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#field-pruning for details. */
    preserveUnknownFields?: Maybe<Scalars['Boolean']['output']>;
    /** scope indicates whether the defined custom resource is cluster- or namespace-scoped. Allowed values are `Cluster` and `Namespaced`. */
    scope: Scalars['String']['output'];
    /** versions is the list of all API versions of the defined custom resource. Version names are used to compute the order in which served versions are listed in API discovery. If the version string is "kube-like", it will sort above non "kube-like" version strings, which are ordered lexicographically. "Kube-like" versions start with a "v", then are followed by a number (the major version), then optionally the string "alpha" or "beta" and another number (the minor version). These are sorted first by GA > beta > alpha (where GA is a version with no suffix such as beta or alpha), and then by comparing major version, then minor version. An example sorted list of versions: v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10. */
    versions: Array<
      Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionVersion>
    >;
  };

/** CustomResourceDefinitionSpec describes how a user wants their resource to appear */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionSpec_Input =
  {
    conversion?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceConversion_Input>;
    /** group is the API group of the defined custom resource. The custom resources are served under `/apis/<group>/...`. Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`). */
    group: Scalars['String']['input'];
    names: Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionNames_Input;
    /** preserveUnknownFields indicates that object fields which are not specified in the OpenAPI schema should be preserved when persisting to storage. apiVersion, kind, metadata and known fields inside metadata are always preserved. This field is deprecated in favor of setting `x-preserve-unknown-fields` to true in `spec.versions[*].schema.openAPIV3Schema`. See https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#field-pruning for details. */
    preserveUnknownFields?: InputMaybe<Scalars['Boolean']['input']>;
    /** scope indicates whether the defined custom resource is cluster- or namespace-scoped. Allowed values are `Cluster` and `Namespaced`. */
    scope: Scalars['String']['input'];
    /** versions is the list of all API versions of the defined custom resource. Version names are used to compute the order in which served versions are listed in API discovery. If the version string is "kube-like", it will sort above non "kube-like" version strings, which are ordered lexicographically. "Kube-like" versions start with a "v", then are followed by a number (the major version), then optionally the string "alpha" or "beta" and another number (the minor version). These are sorted first by GA > beta > alpha (where GA is a version with no suffix such as beta or alpha), and then by comparing major version, then minor version. An example sorted list of versions: v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10. */
    versions: Array<
      InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionVersion_Input>
    >;
  };

/** CustomResourceDefinitionStatus indicates the state of the CustomResourceDefinition */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionStatus =
  {
    acceptedNames?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionNames>;
    /** conditions indicate state for particular aspects of a CustomResourceDefinition */
    conditions?: Maybe<
      Array<
        Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionCondition>
      >
    >;
    /** storedVersions lists all versions of CustomResources that were ever persisted. Tracking these versions allows a migration path for stored versions in etcd. The field is mutable so a migration controller can finish a migration to another version (ensuring no old objects are left in storage), and then remove the rest of the versions from this list. Versions may not be removed from `spec.versions` while they exist in this list. */
    storedVersions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  };

/** CustomResourceDefinitionStatus indicates the state of the CustomResourceDefinition */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionStatus_Input =
  {
    acceptedNames?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionNames_Input>;
    /** conditions indicate state for particular aspects of a CustomResourceDefinition */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionCondition_Input>
      >
    >;
    /** storedVersions lists all versions of CustomResources that were ever persisted. Tracking these versions allows a migration path for stored versions in etcd. The field is mutable so a migration controller can finish a migration to another version (ensuring no old objects are left in storage), and then remove the rest of the versions from this list. Versions may not be removed from `spec.versions` while they exist in this list. */
    storedVersions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  };

/** CustomResourceDefinitionVersion describes a version for CRD. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionVersion =
  {
    /** additionalPrinterColumns specifies additional columns returned in Table output. See https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables for details. If no columns are specified, a single column displaying the age of the custom resource is used. */
    additionalPrinterColumns?: Maybe<
      Array<
        Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceColumnDefinition>
      >
    >;
    /** deprecated indicates this version of the custom resource API is deprecated. When set to true, API requests to this version receive a warning header in the server response. Defaults to false. */
    deprecated?: Maybe<Scalars['Boolean']['output']>;
    /** deprecationWarning overrides the default warning returned to API clients. May only be set when `deprecated` is true. The default warning indicates this version is deprecated and recommends use of the newest served version of equal or greater stability, if one exists. */
    deprecationWarning?: Maybe<Scalars['String']['output']>;
    /** name is the version name, e.g. v1, v2beta1, etc. The custom resources are served under this version at `/apis/<group>/<version>/...` if `served` is true. */
    name: Scalars['String']['output'];
    schema?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceValidation>;
    /** selectableFields specifies paths to fields that may be used as field selectors. A maximum of 8 selectable fields are allowed. See https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors */
    selectableFields?: Maybe<
      Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_SelectableField>>
    >;
    /** served is a flag enabling/disabling this version from being served via REST APIs */
    served: Scalars['Boolean']['output'];
    /** storage indicates this version should be used when persisting custom resources to storage. There must be exactly one version with storage=true. */
    storage: Scalars['Boolean']['output'];
    subresources?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceSubresources>;
  };

/** CustomResourceDefinitionVersion describes a version for CRD. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionVersion_Input =
  {
    /** additionalPrinterColumns specifies additional columns returned in Table output. See https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables for details. If no columns are specified, a single column displaying the age of the custom resource is used. */
    additionalPrinterColumns?: InputMaybe<
      Array<
        InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceColumnDefinition_Input>
      >
    >;
    /** deprecated indicates this version of the custom resource API is deprecated. When set to true, API requests to this version receive a warning header in the server response. Defaults to false. */
    deprecated?: InputMaybe<Scalars['Boolean']['input']>;
    /** deprecationWarning overrides the default warning returned to API clients. May only be set when `deprecated` is true. The default warning indicates this version is deprecated and recommends use of the newest served version of equal or greater stability, if one exists. */
    deprecationWarning?: InputMaybe<Scalars['String']['input']>;
    /** name is the version name, e.g. v1, v2beta1, etc. The custom resources are served under this version at `/apis/<group>/<version>/...` if `served` is true. */
    name: Scalars['String']['input'];
    schema?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceValidation_Input>;
    /** selectableFields specifies paths to fields that may be used as field selectors. A maximum of 8 selectable fields are allowed. See https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors */
    selectableFields?: InputMaybe<
      Array<
        InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_SelectableField_Input>
      >
    >;
    /** served is a flag enabling/disabling this version from being served via REST APIs */
    served: Scalars['Boolean']['input'];
    /** storage indicates this version should be used when persisting custom resources to storage. There must be exactly one version with storage=true. */
    storage: Scalars['Boolean']['input'];
    subresources?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceSubresources_Input>;
  };

/** CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinition_Input =
  {
    /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
    apiVersion?: InputMaybe<Scalars['String']['input']>;
    /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
    kind?: InputMaybe<Scalars['String']['input']>;
    metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
    spec: Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionSpec_Input;
    status?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceDefinitionStatus_Input>;
  };

/** CustomResourceSubresourceScale defines how to serve the scale subresource for CustomResources. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceSubresourceScale =
  {
    /** labelSelectorPath defines the JSON path inside of a custom resource that corresponds to Scale `status.selector`. Only JSON paths without the array notation are allowed. Must be a JSON Path under `.status` or `.spec`. Must be set to work with HorizontalPodAutoscaler. The field pointed by this JSON path must be a string field (not a complex selector struct) which contains a serialized label selector in string form. More info: https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions#scale-subresource If there is no value under the given path in the custom resource, the `status.selector` value in the `/scale` subresource will default to the empty string. */
    labelSelectorPath?: Maybe<Scalars['String']['output']>;
    /** specReplicasPath defines the JSON path inside of a custom resource that corresponds to Scale `spec.replicas`. Only JSON paths without the array notation are allowed. Must be a JSON Path under `.spec`. If there is no value under the given path in the custom resource, the `/scale` subresource will return an error on GET. */
    specReplicasPath: Scalars['String']['output'];
    /** statusReplicasPath defines the JSON path inside of a custom resource that corresponds to Scale `status.replicas`. Only JSON paths without the array notation are allowed. Must be a JSON Path under `.status`. If there is no value under the given path in the custom resource, the `status.replicas` value in the `/scale` subresource will default to 0. */
    statusReplicasPath: Scalars['String']['output'];
  };

/** CustomResourceSubresourceScale defines how to serve the scale subresource for CustomResources. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceSubresourceScale_Input =
  {
    /** labelSelectorPath defines the JSON path inside of a custom resource that corresponds to Scale `status.selector`. Only JSON paths without the array notation are allowed. Must be a JSON Path under `.status` or `.spec`. Must be set to work with HorizontalPodAutoscaler. The field pointed by this JSON path must be a string field (not a complex selector struct) which contains a serialized label selector in string form. More info: https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions#scale-subresource If there is no value under the given path in the custom resource, the `status.selector` value in the `/scale` subresource will default to the empty string. */
    labelSelectorPath?: InputMaybe<Scalars['String']['input']>;
    /** specReplicasPath defines the JSON path inside of a custom resource that corresponds to Scale `spec.replicas`. Only JSON paths without the array notation are allowed. Must be a JSON Path under `.spec`. If there is no value under the given path in the custom resource, the `/scale` subresource will return an error on GET. */
    specReplicasPath: Scalars['String']['input'];
    /** statusReplicasPath defines the JSON path inside of a custom resource that corresponds to Scale `status.replicas`. Only JSON paths without the array notation are allowed. Must be a JSON Path under `.status`. If there is no value under the given path in the custom resource, the `status.replicas` value in the `/scale` subresource will default to 0. */
    statusReplicasPath: Scalars['String']['input'];
  };

/** CustomResourceSubresources defines the status and scale subresources for CustomResources. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceSubresources = {
  scale?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceSubresourceScale>;
  status?: Maybe<Scalars['JSON']['output']>;
};

/** CustomResourceSubresources defines the status and scale subresources for CustomResources. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceSubresources_Input =
  {
    scale?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceSubresourceScale_Input>;
    status?: InputMaybe<Scalars['JSON']['input']>;
  };

/** CustomResourceValidation is a list of validation methods for CustomResources. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceValidation = {
  openAPIV3Schema?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>;
};

/** CustomResourceValidation is a list of validation methods for CustomResources. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_CustomResourceValidation_Input =
  {
    openAPIV3Schema?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps_Input>;
  };

/** ExternalDocumentation allows referencing an external resource for extended documentation. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ExternalDocumentation = {
  description?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

/** ExternalDocumentation allows referencing an external resource for extended documentation. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ExternalDocumentation_Input = {
  description?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/). */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps = {
  _DOLLAR_ref?: Maybe<Scalars['String']['output']>;
  _DOLLAR_schema?: Maybe<Scalars['String']['output']>;
  /** JSONSchemaPropsOrBool represents JSONSchemaProps or a boolean value. Defaults to true for the boolean property. */
  additionalItems?: Maybe<Scalars['JSON']['output']>;
  allOf?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>>
  >;
  anyOf?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>>
  >;
  /** JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil. */
  default?: Maybe<Scalars['JSON']['output']>;
  definitions?: Maybe<Query_ListApiextensionsV1CustomResourceDefinition_OneOf_0_Items_Items_Spec_Versions_Items_Schema_OpenApiv3Schema_AllOf_Items_AnyOf_Items_Definitions>;
  dependencies?: Maybe<Scalars['JSON']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  enum?: Maybe<Array<Maybe<Scalars['JSON']['output']>>>;
  /** JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil. */
  example?: Maybe<Scalars['JSON']['output']>;
  exclusiveMaximum?: Maybe<Scalars['Boolean']['output']>;
  exclusiveMinimum?: Maybe<Scalars['Boolean']['output']>;
  externalDocs?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ExternalDocumentation>;
  /**
   * format is an OpenAPI v3 format string. Unknown formats are ignored. The following formats are validated:
   *
   * - bsonobjectid: a bson object ID, i.e. a 24 characters hex string - uri: an URI as parsed by Golang net/url.ParseRequestURI - email: an email address as parsed by Golang net/mail.ParseAddress - hostname: a valid representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034]. - ipv4: an IPv4 IP as parsed by Golang net.ParseIP - ipv6: an IPv6 IP as parsed by Golang net.ParseIP - cidr: a CIDR as parsed by Golang net.ParseCIDR - mac: a MAC address as parsed by Golang net.ParseMAC - uuid: an UUID that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid3: an UUID3 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid4: an UUID4 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - uuid5: an UUID5 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - isbn: an ISBN10 or ISBN13 number string like "0321751043" or "978-0321751041" - isbn10: an ISBN10 number string like "0321751043" - isbn13: an ISBN13 number string like "978-0321751041" - creditcard: a credit card number defined by the regex ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$ with any non digit characters mixed in - ssn: a U.S. social security number following the regex ^\\d{3}[- ]?\\d{2}[- ]?\\d{4}$ - hexcolor: an hexadecimal color code like "#FFFFFF: following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$ - rgbcolor: an RGB color code like rgb like "rgb(255,255,2559" - byte: base64 encoded binary data - password: any kind of string - date: a date string like "2006-01-02" as defined by full-date in RFC3339 - duration: a duration string like "22 ns" as parsed by Golang time.ParseDuration or compatible with Scala duration format - datetime: a date time string like "2014-12-15T19:30:20.000Z" as defined by date-time in RFC3339.
   */
  format?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  /** JSONSchemaPropsOrArray represents a value that can either be a JSONSchemaProps or an array of JSONSchemaProps. Mainly here for serialization purposes. */
  items?: Maybe<Scalars['JSON']['output']>;
  maxItems?: Maybe<Scalars['BigInt']['output']>;
  maxLength?: Maybe<Scalars['BigInt']['output']>;
  maxProperties?: Maybe<Scalars['BigInt']['output']>;
  maximum?: Maybe<Scalars['Float']['output']>;
  minItems?: Maybe<Scalars['BigInt']['output']>;
  minLength?: Maybe<Scalars['BigInt']['output']>;
  minProperties?: Maybe<Scalars['BigInt']['output']>;
  minimum?: Maybe<Scalars['Float']['output']>;
  multipleOf?: Maybe<Scalars['Float']['output']>;
  /** JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/). */
  not?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>;
  nullable?: Maybe<Scalars['Boolean']['output']>;
  oneOf?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>>
  >;
  pattern?: Maybe<Scalars['String']['output']>;
  patternProperties?: Maybe<AdditionalProperties_Not_OneOf_Items_PatternProperties>;
  properties?: Maybe<AdditionalProperties_Not_OneOf_Items_PatternProperties_AdditionalProperties>;
  required?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  title?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  uniqueItems?: Maybe<Scalars['Boolean']['output']>;
  /** x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to further restrict the embedded object. kind, apiVersion and metadata are validated automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not have to be if the object is fully specified (up to kind, apiVersion, metadata). */
  x_kubernetes_embedded_resource?: Maybe<Scalars['Boolean']['output']>;
  /**
   * x-kubernetes-int-or-string specifies that this value is either an integer or a string. If this is true, an empty type is allowed and type as child of anyOf is permitted if following one of the following patterns:
   *
   * 1) anyOf:
   *    - type: integer
   *    - type: string
   * 2) allOf:
   *    - anyOf:
   *      - type: integer
   *      - type: string
   *    - ... zero or more
   */
  x_kubernetes_int_or_string?: Maybe<Scalars['Boolean']['output']>;
  /**
   * x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by specifying the keys used as the index of the map.
   *
   * This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set to "map". Also, the values specified for this attribute must be a scalar typed field of the child structure (no nesting is supported).
   *
   * The properties specified must either be required or have a default value, to ensure those properties are present for all list items.
   */
  x_kubernetes_list_map_keys?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * x-kubernetes-list-type annotates an array to further describe its topology. This extension must only be used on lists and may have 3 possible values:
   *
   * 1) `atomic`: the list is treated as a single entity, like a scalar.
   *      Atomic lists will be entirely replaced when updated. This extension
   *      may be used on any type of list (struct, scalar, ...).
   * 2) `set`:
   *      Sets are lists that must not have multiple items with the same value. Each
   *      value must be a scalar, an object with x-kubernetes-map-type `atomic` or an
   *      array with x-kubernetes-list-type `atomic`.
   * 3) `map`:
   *      These lists are like maps in that their elements have a non-index key
   *      used to identify them. Order is preserved upon merge. The map tag
   *      must only be used on a list with elements of type object.
   * Defaults to atomic for arrays.
   */
  x_kubernetes_list_type?: Maybe<Scalars['String']['output']>;
  /**
   * x-kubernetes-map-type annotates an object to further describe its topology. This extension must only be used when type is object and may have 2 possible values:
   *
   * 1) `granular`:
   *      These maps are actual maps (key-value pairs) and each fields are independent
   *      from each other (they can each be manipulated by separate actors). This is
   *      the default behaviour for all maps.
   * 2) `atomic`: the list is treated as a single entity, like a scalar.
   *      Atomic maps will be entirely replaced when updated.
   */
  x_kubernetes_map_type?: Maybe<Scalars['String']['output']>;
  /** x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning fields which are not specified in the validation schema. This affects fields recursively, but switches back to normal pruning behaviour if nested properties or additionalProperties are specified in the schema. This can either be true or undefined. False is forbidden. */
  x_kubernetes_preserve_unknown_fields?: Maybe<Scalars['Boolean']['output']>;
  /** x-kubernetes-validations describes a list of validation rules written in the CEL expression language. */
  x_kubernetes_validations?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ValidationRule>>
  >;
};

/** JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/). */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps2 = {
  _DOLLAR_ref?: Maybe<Scalars['String']['output']>;
  _DOLLAR_schema?: Maybe<Scalars['String']['output']>;
  /** JSONSchemaPropsOrBool represents JSONSchemaProps or a boolean value. Defaults to true for the boolean property. */
  additionalItems?: Maybe<Scalars['JSON']['output']>;
  allOf?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>>
  >;
  anyOf?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>>
  >;
  /** JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil. */
  default?: Maybe<Scalars['JSON']['output']>;
  definitions?: Maybe<Query_ListApiextensionsV1CustomResourceDefinition_OneOf_0_Items_Items_Spec_Versions_Items_Schema_OpenApiv3Schema_AllOf_Items_AnyOf_Items_Definitions>;
  dependencies?: Maybe<Scalars['JSON']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  enum?: Maybe<Array<Maybe<Scalars['JSON']['output']>>>;
  /** JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil. */
  example?: Maybe<Scalars['JSON']['output']>;
  exclusiveMaximum?: Maybe<Scalars['Boolean']['output']>;
  exclusiveMinimum?: Maybe<Scalars['Boolean']['output']>;
  externalDocs?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ExternalDocumentation>;
  /**
   * format is an OpenAPI v3 format string. Unknown formats are ignored. The following formats are validated:
   *
   * - bsonobjectid: a bson object ID, i.e. a 24 characters hex string - uri: an URI as parsed by Golang net/url.ParseRequestURI - email: an email address as parsed by Golang net/mail.ParseAddress - hostname: a valid representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034]. - ipv4: an IPv4 IP as parsed by Golang net.ParseIP - ipv6: an IPv6 IP as parsed by Golang net.ParseIP - cidr: a CIDR as parsed by Golang net.ParseCIDR - mac: a MAC address as parsed by Golang net.ParseMAC - uuid: an UUID that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid3: an UUID3 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid4: an UUID4 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - uuid5: an UUID5 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - isbn: an ISBN10 or ISBN13 number string like "0321751043" or "978-0321751041" - isbn10: an ISBN10 number string like "0321751043" - isbn13: an ISBN13 number string like "978-0321751041" - creditcard: a credit card number defined by the regex ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$ with any non digit characters mixed in - ssn: a U.S. social security number following the regex ^\\d{3}[- ]?\\d{2}[- ]?\\d{4}$ - hexcolor: an hexadecimal color code like "#FFFFFF: following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$ - rgbcolor: an RGB color code like rgb like "rgb(255,255,2559" - byte: base64 encoded binary data - password: any kind of string - date: a date string like "2006-01-02" as defined by full-date in RFC3339 - duration: a duration string like "22 ns" as parsed by Golang time.ParseDuration or compatible with Scala duration format - datetime: a date time string like "2014-12-15T19:30:20.000Z" as defined by date-time in RFC3339.
   */
  format?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  /** JSONSchemaPropsOrArray represents a value that can either be a JSONSchemaProps or an array of JSONSchemaProps. Mainly here for serialization purposes. */
  items?: Maybe<Scalars['JSON']['output']>;
  maxItems?: Maybe<Scalars['BigInt']['output']>;
  maxLength?: Maybe<Scalars['BigInt']['output']>;
  maxProperties?: Maybe<Scalars['BigInt']['output']>;
  maximum?: Maybe<Scalars['Float']['output']>;
  minItems?: Maybe<Scalars['BigInt']['output']>;
  minLength?: Maybe<Scalars['BigInt']['output']>;
  minProperties?: Maybe<Scalars['BigInt']['output']>;
  minimum?: Maybe<Scalars['Float']['output']>;
  multipleOf?: Maybe<Scalars['Float']['output']>;
  /** JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/). */
  not?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>;
  nullable?: Maybe<Scalars['Boolean']['output']>;
  oneOf?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>>
  >;
  pattern?: Maybe<Scalars['String']['output']>;
  patternProperties?: Maybe<AdditionalProperties_Not_OneOf_Items_PatternProperties>;
  properties?: Maybe<AdditionalProperties_Not_OneOf_Items_PatternProperties_AdditionalProperties>;
  required?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  title?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  uniqueItems?: Maybe<Scalars['Boolean']['output']>;
  /** x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to further restrict the embedded object. kind, apiVersion and metadata are validated automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not have to be if the object is fully specified (up to kind, apiVersion, metadata). */
  x_kubernetes_embedded_resource?: Maybe<Scalars['Boolean']['output']>;
  /**
   * x-kubernetes-int-or-string specifies that this value is either an integer or a string. If this is true, an empty type is allowed and type as child of anyOf is permitted if following one of the following patterns:
   *
   * 1) anyOf:
   *    - type: integer
   *    - type: string
   * 2) allOf:
   *    - anyOf:
   *      - type: integer
   *      - type: string
   *    - ... zero or more
   */
  x_kubernetes_int_or_string?: Maybe<Scalars['Boolean']['output']>;
  /**
   * x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by specifying the keys used as the index of the map.
   *
   * This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set to "map". Also, the values specified for this attribute must be a scalar typed field of the child structure (no nesting is supported).
   *
   * The properties specified must either be required or have a default value, to ensure those properties are present for all list items.
   */
  x_kubernetes_list_map_keys?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * x-kubernetes-list-type annotates an array to further describe its topology. This extension must only be used on lists and may have 3 possible values:
   *
   * 1) `atomic`: the list is treated as a single entity, like a scalar.
   *      Atomic lists will be entirely replaced when updated. This extension
   *      may be used on any type of list (struct, scalar, ...).
   * 2) `set`:
   *      Sets are lists that must not have multiple items with the same value. Each
   *      value must be a scalar, an object with x-kubernetes-map-type `atomic` or an
   *      array with x-kubernetes-list-type `atomic`.
   * 3) `map`:
   *      These lists are like maps in that their elements have a non-index key
   *      used to identify them. Order is preserved upon merge. The map tag
   *      must only be used on a list with elements of type object.
   * Defaults to atomic for arrays.
   */
  x_kubernetes_list_type?: Maybe<Scalars['String']['output']>;
  /**
   * x-kubernetes-map-type annotates an object to further describe its topology. This extension must only be used when type is object and may have 2 possible values:
   *
   * 1) `granular`:
   *      These maps are actual maps (key-value pairs) and each fields are independent
   *      from each other (they can each be manipulated by separate actors). This is
   *      the default behaviour for all maps.
   * 2) `atomic`: the list is treated as a single entity, like a scalar.
   *      Atomic maps will be entirely replaced when updated.
   */
  x_kubernetes_map_type?: Maybe<Scalars['String']['output']>;
  /** x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning fields which are not specified in the validation schema. This affects fields recursively, but switches back to normal pruning behaviour if nested properties or additionalProperties are specified in the schema. This can either be true or undefined. False is forbidden. */
  x_kubernetes_preserve_unknown_fields?: Maybe<Scalars['Boolean']['output']>;
  /** x-kubernetes-validations describes a list of validation rules written in the CEL expression language. */
  x_kubernetes_validations?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ValidationRule>>
  >;
};

export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps2_Entry = {
  key: Scalars['ID']['output'];
  value?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps2>;
};

/** JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/). */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps3 = {
  _DOLLAR_ref?: Maybe<Scalars['String']['output']>;
  _DOLLAR_schema?: Maybe<Scalars['String']['output']>;
  /** JSONSchemaPropsOrBool represents JSONSchemaProps or a boolean value. Defaults to true for the boolean property. */
  additionalItems?: Maybe<Scalars['JSON']['output']>;
  allOf?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>>
  >;
  anyOf?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>>
  >;
  /** JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil. */
  default?: Maybe<Scalars['JSON']['output']>;
  definitions?: Maybe<Query_ListApiextensionsV1CustomResourceDefinition_OneOf_0_Items_Items_Spec_Versions_Items_Schema_OpenApiv3Schema_AllOf_Items_AnyOf_Items_Definitions>;
  dependencies?: Maybe<Scalars['JSON']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  enum?: Maybe<Array<Maybe<Scalars['JSON']['output']>>>;
  /** JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil. */
  example?: Maybe<Scalars['JSON']['output']>;
  exclusiveMaximum?: Maybe<Scalars['Boolean']['output']>;
  exclusiveMinimum?: Maybe<Scalars['Boolean']['output']>;
  externalDocs?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ExternalDocumentation>;
  /**
   * format is an OpenAPI v3 format string. Unknown formats are ignored. The following formats are validated:
   *
   * - bsonobjectid: a bson object ID, i.e. a 24 characters hex string - uri: an URI as parsed by Golang net/url.ParseRequestURI - email: an email address as parsed by Golang net/mail.ParseAddress - hostname: a valid representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034]. - ipv4: an IPv4 IP as parsed by Golang net.ParseIP - ipv6: an IPv6 IP as parsed by Golang net.ParseIP - cidr: a CIDR as parsed by Golang net.ParseCIDR - mac: a MAC address as parsed by Golang net.ParseMAC - uuid: an UUID that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid3: an UUID3 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid4: an UUID4 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - uuid5: an UUID5 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - isbn: an ISBN10 or ISBN13 number string like "0321751043" or "978-0321751041" - isbn10: an ISBN10 number string like "0321751043" - isbn13: an ISBN13 number string like "978-0321751041" - creditcard: a credit card number defined by the regex ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$ with any non digit characters mixed in - ssn: a U.S. social security number following the regex ^\\d{3}[- ]?\\d{2}[- ]?\\d{4}$ - hexcolor: an hexadecimal color code like "#FFFFFF: following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$ - rgbcolor: an RGB color code like rgb like "rgb(255,255,2559" - byte: base64 encoded binary data - password: any kind of string - date: a date string like "2006-01-02" as defined by full-date in RFC3339 - duration: a duration string like "22 ns" as parsed by Golang time.ParseDuration or compatible with Scala duration format - datetime: a date time string like "2014-12-15T19:30:20.000Z" as defined by date-time in RFC3339.
   */
  format?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  /** JSONSchemaPropsOrArray represents a value that can either be a JSONSchemaProps or an array of JSONSchemaProps. Mainly here for serialization purposes. */
  items?: Maybe<Scalars['JSON']['output']>;
  maxItems?: Maybe<Scalars['BigInt']['output']>;
  maxLength?: Maybe<Scalars['BigInt']['output']>;
  maxProperties?: Maybe<Scalars['BigInt']['output']>;
  maximum?: Maybe<Scalars['Float']['output']>;
  minItems?: Maybe<Scalars['BigInt']['output']>;
  minLength?: Maybe<Scalars['BigInt']['output']>;
  minProperties?: Maybe<Scalars['BigInt']['output']>;
  minimum?: Maybe<Scalars['Float']['output']>;
  multipleOf?: Maybe<Scalars['Float']['output']>;
  /** JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/). */
  not?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>;
  nullable?: Maybe<Scalars['Boolean']['output']>;
  oneOf?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>>
  >;
  pattern?: Maybe<Scalars['String']['output']>;
  patternProperties?: Maybe<AdditionalProperties_Not_OneOf_Items_PatternProperties>;
  properties?: Maybe<AdditionalProperties_Not_OneOf_Items_PatternProperties_AdditionalProperties>;
  required?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  title?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  uniqueItems?: Maybe<Scalars['Boolean']['output']>;
  /** x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to further restrict the embedded object. kind, apiVersion and metadata are validated automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not have to be if the object is fully specified (up to kind, apiVersion, metadata). */
  x_kubernetes_embedded_resource?: Maybe<Scalars['Boolean']['output']>;
  /**
   * x-kubernetes-int-or-string specifies that this value is either an integer or a string. If this is true, an empty type is allowed and type as child of anyOf is permitted if following one of the following patterns:
   *
   * 1) anyOf:
   *    - type: integer
   *    - type: string
   * 2) allOf:
   *    - anyOf:
   *      - type: integer
   *      - type: string
   *    - ... zero or more
   */
  x_kubernetes_int_or_string?: Maybe<Scalars['Boolean']['output']>;
  /**
   * x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by specifying the keys used as the index of the map.
   *
   * This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set to "map". Also, the values specified for this attribute must be a scalar typed field of the child structure (no nesting is supported).
   *
   * The properties specified must either be required or have a default value, to ensure those properties are present for all list items.
   */
  x_kubernetes_list_map_keys?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * x-kubernetes-list-type annotates an array to further describe its topology. This extension must only be used on lists and may have 3 possible values:
   *
   * 1) `atomic`: the list is treated as a single entity, like a scalar.
   *      Atomic lists will be entirely replaced when updated. This extension
   *      may be used on any type of list (struct, scalar, ...).
   * 2) `set`:
   *      Sets are lists that must not have multiple items with the same value. Each
   *      value must be a scalar, an object with x-kubernetes-map-type `atomic` or an
   *      array with x-kubernetes-list-type `atomic`.
   * 3) `map`:
   *      These lists are like maps in that their elements have a non-index key
   *      used to identify them. Order is preserved upon merge. The map tag
   *      must only be used on a list with elements of type object.
   * Defaults to atomic for arrays.
   */
  x_kubernetes_list_type?: Maybe<Scalars['String']['output']>;
  /**
   * x-kubernetes-map-type annotates an object to further describe its topology. This extension must only be used when type is object and may have 2 possible values:
   *
   * 1) `granular`:
   *      These maps are actual maps (key-value pairs) and each fields are independent
   *      from each other (they can each be manipulated by separate actors). This is
   *      the default behaviour for all maps.
   * 2) `atomic`: the list is treated as a single entity, like a scalar.
   *      Atomic maps will be entirely replaced when updated.
   */
  x_kubernetes_map_type?: Maybe<Scalars['String']['output']>;
  /** x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning fields which are not specified in the validation schema. This affects fields recursively, but switches back to normal pruning behaviour if nested properties or additionalProperties are specified in the schema. This can either be true or undefined. False is forbidden. */
  x_kubernetes_preserve_unknown_fields?: Maybe<Scalars['Boolean']['output']>;
  /** x-kubernetes-validations describes a list of validation rules written in the CEL expression language. */
  x_kubernetes_validations?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ValidationRule>>
  >;
};

export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps3_Entry = {
  key: Scalars['ID']['output'];
  value?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps3>;
};

/** JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/). */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps4 = {
  _DOLLAR_ref?: Maybe<Scalars['String']['output']>;
  _DOLLAR_schema?: Maybe<Scalars['String']['output']>;
  /** JSONSchemaPropsOrBool represents JSONSchemaProps or a boolean value. Defaults to true for the boolean property. */
  additionalItems?: Maybe<Scalars['JSON']['output']>;
  allOf?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>>
  >;
  anyOf?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>>
  >;
  /** JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil. */
  default?: Maybe<Scalars['JSON']['output']>;
  definitions?: Maybe<Query_ListApiextensionsV1CustomResourceDefinition_OneOf_0_Items_Items_Spec_Versions_Items_Schema_OpenApiv3Schema_AllOf_Items_AnyOf_Items_Definitions>;
  dependencies?: Maybe<Scalars['JSON']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  enum?: Maybe<Array<Maybe<Scalars['JSON']['output']>>>;
  /** JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil. */
  example?: Maybe<Scalars['JSON']['output']>;
  exclusiveMaximum?: Maybe<Scalars['Boolean']['output']>;
  exclusiveMinimum?: Maybe<Scalars['Boolean']['output']>;
  externalDocs?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ExternalDocumentation>;
  /**
   * format is an OpenAPI v3 format string. Unknown formats are ignored. The following formats are validated:
   *
   * - bsonobjectid: a bson object ID, i.e. a 24 characters hex string - uri: an URI as parsed by Golang net/url.ParseRequestURI - email: an email address as parsed by Golang net/mail.ParseAddress - hostname: a valid representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034]. - ipv4: an IPv4 IP as parsed by Golang net.ParseIP - ipv6: an IPv6 IP as parsed by Golang net.ParseIP - cidr: a CIDR as parsed by Golang net.ParseCIDR - mac: a MAC address as parsed by Golang net.ParseMAC - uuid: an UUID that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid3: an UUID3 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid4: an UUID4 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - uuid5: an UUID5 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - isbn: an ISBN10 or ISBN13 number string like "0321751043" or "978-0321751041" - isbn10: an ISBN10 number string like "0321751043" - isbn13: an ISBN13 number string like "978-0321751041" - creditcard: a credit card number defined by the regex ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$ with any non digit characters mixed in - ssn: a U.S. social security number following the regex ^\\d{3}[- ]?\\d{2}[- ]?\\d{4}$ - hexcolor: an hexadecimal color code like "#FFFFFF: following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$ - rgbcolor: an RGB color code like rgb like "rgb(255,255,2559" - byte: base64 encoded binary data - password: any kind of string - date: a date string like "2006-01-02" as defined by full-date in RFC3339 - duration: a duration string like "22 ns" as parsed by Golang time.ParseDuration or compatible with Scala duration format - datetime: a date time string like "2014-12-15T19:30:20.000Z" as defined by date-time in RFC3339.
   */
  format?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  /** JSONSchemaPropsOrArray represents a value that can either be a JSONSchemaProps or an array of JSONSchemaProps. Mainly here for serialization purposes. */
  items?: Maybe<Scalars['JSON']['output']>;
  maxItems?: Maybe<Scalars['BigInt']['output']>;
  maxLength?: Maybe<Scalars['BigInt']['output']>;
  maxProperties?: Maybe<Scalars['BigInt']['output']>;
  maximum?: Maybe<Scalars['Float']['output']>;
  minItems?: Maybe<Scalars['BigInt']['output']>;
  minLength?: Maybe<Scalars['BigInt']['output']>;
  minProperties?: Maybe<Scalars['BigInt']['output']>;
  minimum?: Maybe<Scalars['Float']['output']>;
  multipleOf?: Maybe<Scalars['Float']['output']>;
  /** JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/). */
  not?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>;
  nullable?: Maybe<Scalars['Boolean']['output']>;
  oneOf?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps>>
  >;
  pattern?: Maybe<Scalars['String']['output']>;
  patternProperties?: Maybe<AdditionalProperties_Not_OneOf_Items_PatternProperties>;
  properties?: Maybe<AdditionalProperties_Not_OneOf_Items_PatternProperties_AdditionalProperties>;
  required?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  title?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  uniqueItems?: Maybe<Scalars['Boolean']['output']>;
  /** x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to further restrict the embedded object. kind, apiVersion and metadata are validated automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not have to be if the object is fully specified (up to kind, apiVersion, metadata). */
  x_kubernetes_embedded_resource?: Maybe<Scalars['Boolean']['output']>;
  /**
   * x-kubernetes-int-or-string specifies that this value is either an integer or a string. If this is true, an empty type is allowed and type as child of anyOf is permitted if following one of the following patterns:
   *
   * 1) anyOf:
   *    - type: integer
   *    - type: string
   * 2) allOf:
   *    - anyOf:
   *      - type: integer
   *      - type: string
   *    - ... zero or more
   */
  x_kubernetes_int_or_string?: Maybe<Scalars['Boolean']['output']>;
  /**
   * x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by specifying the keys used as the index of the map.
   *
   * This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set to "map". Also, the values specified for this attribute must be a scalar typed field of the child structure (no nesting is supported).
   *
   * The properties specified must either be required or have a default value, to ensure those properties are present for all list items.
   */
  x_kubernetes_list_map_keys?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * x-kubernetes-list-type annotates an array to further describe its topology. This extension must only be used on lists and may have 3 possible values:
   *
   * 1) `atomic`: the list is treated as a single entity, like a scalar.
   *      Atomic lists will be entirely replaced when updated. This extension
   *      may be used on any type of list (struct, scalar, ...).
   * 2) `set`:
   *      Sets are lists that must not have multiple items with the same value. Each
   *      value must be a scalar, an object with x-kubernetes-map-type `atomic` or an
   *      array with x-kubernetes-list-type `atomic`.
   * 3) `map`:
   *      These lists are like maps in that their elements have a non-index key
   *      used to identify them. Order is preserved upon merge. The map tag
   *      must only be used on a list with elements of type object.
   * Defaults to atomic for arrays.
   */
  x_kubernetes_list_type?: Maybe<Scalars['String']['output']>;
  /**
   * x-kubernetes-map-type annotates an object to further describe its topology. This extension must only be used when type is object and may have 2 possible values:
   *
   * 1) `granular`:
   *      These maps are actual maps (key-value pairs) and each fields are independent
   *      from each other (they can each be manipulated by separate actors). This is
   *      the default behaviour for all maps.
   * 2) `atomic`: the list is treated as a single entity, like a scalar.
   *      Atomic maps will be entirely replaced when updated.
   */
  x_kubernetes_map_type?: Maybe<Scalars['String']['output']>;
  /** x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning fields which are not specified in the validation schema. This affects fields recursively, but switches back to normal pruning behaviour if nested properties or additionalProperties are specified in the schema. This can either be true or undefined. False is forbidden. */
  x_kubernetes_preserve_unknown_fields?: Maybe<Scalars['Boolean']['output']>;
  /** x-kubernetes-validations describes a list of validation rules written in the CEL expression language. */
  x_kubernetes_validations?: Maybe<
    Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ValidationRule>>
  >;
};

export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps4_Entry = {
  key: Scalars['ID']['output'];
  value?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps4>;
};

/** JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/). */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps_Input = {
  _DOLLAR_ref?: InputMaybe<Scalars['String']['input']>;
  _DOLLAR_schema?: InputMaybe<Scalars['String']['input']>;
  /** JSONSchemaPropsOrBool represents JSONSchemaProps or a boolean value. Defaults to true for the boolean property. */
  additionalItems?: InputMaybe<Scalars['JSON']['input']>;
  allOf?: InputMaybe<
    Array<
      InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps_Input>
    >
  >;
  anyOf?: InputMaybe<
    Array<
      InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps_Input>
    >
  >;
  /** JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil. */
  default?: InputMaybe<Scalars['JSON']['input']>;
  definitions?: InputMaybe<Scalars['JSON']['input']>;
  dependencies?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  enum?: InputMaybe<Array<InputMaybe<Scalars['JSON']['input']>>>;
  /** JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil. */
  example?: InputMaybe<Scalars['JSON']['input']>;
  exclusiveMaximum?: InputMaybe<Scalars['Boolean']['input']>;
  exclusiveMinimum?: InputMaybe<Scalars['Boolean']['input']>;
  externalDocs?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ExternalDocumentation_Input>;
  /**
   * format is an OpenAPI v3 format string. Unknown formats are ignored. The following formats are validated:
   *
   * - bsonobjectid: a bson object ID, i.e. a 24 characters hex string - uri: an URI as parsed by Golang net/url.ParseRequestURI - email: an email address as parsed by Golang net/mail.ParseAddress - hostname: a valid representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034]. - ipv4: an IPv4 IP as parsed by Golang net.ParseIP - ipv6: an IPv6 IP as parsed by Golang net.ParseIP - cidr: a CIDR as parsed by Golang net.ParseCIDR - mac: a MAC address as parsed by Golang net.ParseMAC - uuid: an UUID that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid3: an UUID3 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid4: an UUID4 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - uuid5: an UUID5 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - isbn: an ISBN10 or ISBN13 number string like "0321751043" or "978-0321751041" - isbn10: an ISBN10 number string like "0321751043" - isbn13: an ISBN13 number string like "978-0321751041" - creditcard: a credit card number defined by the regex ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$ with any non digit characters mixed in - ssn: a U.S. social security number following the regex ^\\d{3}[- ]?\\d{2}[- ]?\\d{4}$ - hexcolor: an hexadecimal color code like "#FFFFFF: following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$ - rgbcolor: an RGB color code like rgb like "rgb(255,255,2559" - byte: base64 encoded binary data - password: any kind of string - date: a date string like "2006-01-02" as defined by full-date in RFC3339 - duration: a duration string like "22 ns" as parsed by Golang time.ParseDuration or compatible with Scala duration format - datetime: a date time string like "2014-12-15T19:30:20.000Z" as defined by date-time in RFC3339.
   */
  format?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  /** JSONSchemaPropsOrArray represents a value that can either be a JSONSchemaProps or an array of JSONSchemaProps. Mainly here for serialization purposes. */
  items?: InputMaybe<Scalars['JSON']['input']>;
  maxItems?: InputMaybe<Scalars['BigInt']['input']>;
  maxLength?: InputMaybe<Scalars['BigInt']['input']>;
  maxProperties?: InputMaybe<Scalars['BigInt']['input']>;
  maximum?: InputMaybe<Scalars['Float']['input']>;
  minItems?: InputMaybe<Scalars['BigInt']['input']>;
  minLength?: InputMaybe<Scalars['BigInt']['input']>;
  minProperties?: InputMaybe<Scalars['BigInt']['input']>;
  minimum?: InputMaybe<Scalars['Float']['input']>;
  multipleOf?: InputMaybe<Scalars['Float']['input']>;
  /** JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/). */
  not?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps_Input>;
  nullable?: InputMaybe<Scalars['Boolean']['input']>;
  oneOf?: InputMaybe<
    Array<
      InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps_Input>
    >
  >;
  pattern?: InputMaybe<Scalars['String']['input']>;
  patternProperties?: InputMaybe<Scalars['JSON']['input']>;
  properties?: InputMaybe<Scalars['JSON']['input']>;
  required?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  title?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  uniqueItems?: InputMaybe<Scalars['Boolean']['input']>;
  /** x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to further restrict the embedded object. kind, apiVersion and metadata are validated automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not have to be if the object is fully specified (up to kind, apiVersion, metadata). */
  x_kubernetes_embedded_resource?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * x-kubernetes-int-or-string specifies that this value is either an integer or a string. If this is true, an empty type is allowed and type as child of anyOf is permitted if following one of the following patterns:
   *
   * 1) anyOf:
   *    - type: integer
   *    - type: string
   * 2) allOf:
   *    - anyOf:
   *      - type: integer
   *      - type: string
   *    - ... zero or more
   */
  x_kubernetes_int_or_string?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by specifying the keys used as the index of the map.
   *
   * This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set to "map". Also, the values specified for this attribute must be a scalar typed field of the child structure (no nesting is supported).
   *
   * The properties specified must either be required or have a default value, to ensure those properties are present for all list items.
   */
  x_kubernetes_list_map_keys?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * x-kubernetes-list-type annotates an array to further describe its topology. This extension must only be used on lists and may have 3 possible values:
   *
   * 1) `atomic`: the list is treated as a single entity, like a scalar.
   *      Atomic lists will be entirely replaced when updated. This extension
   *      may be used on any type of list (struct, scalar, ...).
   * 2) `set`:
   *      Sets are lists that must not have multiple items with the same value. Each
   *      value must be a scalar, an object with x-kubernetes-map-type `atomic` or an
   *      array with x-kubernetes-list-type `atomic`.
   * 3) `map`:
   *      These lists are like maps in that their elements have a non-index key
   *      used to identify them. Order is preserved upon merge. The map tag
   *      must only be used on a list with elements of type object.
   * Defaults to atomic for arrays.
   */
  x_kubernetes_list_type?: InputMaybe<Scalars['String']['input']>;
  /**
   * x-kubernetes-map-type annotates an object to further describe its topology. This extension must only be used when type is object and may have 2 possible values:
   *
   * 1) `granular`:
   *      These maps are actual maps (key-value pairs) and each fields are independent
   *      from each other (they can each be manipulated by separate actors). This is
   *      the default behaviour for all maps.
   * 2) `atomic`: the list is treated as a single entity, like a scalar.
   *      Atomic maps will be entirely replaced when updated.
   */
  x_kubernetes_map_type?: InputMaybe<Scalars['String']['input']>;
  /** x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning fields which are not specified in the validation schema. This affects fields recursively, but switches back to normal pruning behaviour if nested properties or additionalProperties are specified in the schema. This can either be true or undefined. False is forbidden. */
  x_kubernetes_preserve_unknown_fields?: InputMaybe<Scalars['Boolean']['input']>;
  /** x-kubernetes-validations describes a list of validation rules written in the CEL expression language. */
  x_kubernetes_validations?: InputMaybe<
    Array<InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ValidationRule_Input>>
  >;
};

/** SelectableField specifies the JSON path of a field that may be used with field selectors. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_SelectableField = {
  /** jsonPath is a simple JSON path which is evaluated against each custom resource to produce a field selector value. Only JSON paths without the array notation are allowed. Must point to a field of type string, boolean or integer. Types with enum values and strings with formats are allowed. If jsonPath refers to absent field in a resource, the jsonPath evaluates to an empty string. Must not point to metdata fields. Required. */
  jsonPath: Scalars['String']['output'];
};

/** SelectableField specifies the JSON path of a field that may be used with field selectors. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_SelectableField_Input = {
  /** jsonPath is a simple JSON path which is evaluated against each custom resource to produce a field selector value. Only JSON paths without the array notation are allowed. Must point to a field of type string, boolean or integer. Types with enum values and strings with formats are allowed. If jsonPath refers to absent field in a resource, the jsonPath evaluates to an empty string. Must not point to metdata fields. Required. */
  jsonPath: Scalars['String']['input'];
};

/** ServiceReference holds a reference to Service.legacy.k8s.io */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ServiceReference = {
  /** name is the name of the service. Required */
  name: Scalars['String']['output'];
  /** namespace is the namespace of the service. Required */
  namespace: Scalars['String']['output'];
  /** path is an optional URL path at which the webhook will be contacted. */
  path?: Maybe<Scalars['String']['output']>;
  /** port is an optional service port at which the webhook will be contacted. `port` should be a valid port number (1-65535, inclusive). Defaults to 443 for backward compatibility. */
  port?: Maybe<Scalars['Int']['output']>;
};

/** ServiceReference holds a reference to Service.legacy.k8s.io */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ServiceReference_Input = {
  /** name is the name of the service. Required */
  name: Scalars['String']['input'];
  /** namespace is the namespace of the service. Required */
  namespace: Scalars['String']['input'];
  /** path is an optional URL path at which the webhook will be contacted. */
  path?: InputMaybe<Scalars['String']['input']>;
  /** port is an optional service port at which the webhook will be contacted. `port` should be a valid port number (1-65535, inclusive). Defaults to 443 for backward compatibility. */
  port?: InputMaybe<Scalars['Int']['input']>;
};

/** ValidationRule describes a validation rule written in the CEL expression language. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ValidationRule = {
  /** fieldPath represents the field path returned when the validation fails. It must be a relative JSON path (i.e. with array notation) scoped to the location of this x-kubernetes-validations extension in the schema and refer to an existing field. e.g. when validation checks if a specific attribute `foo` under a map `testMap`, the fieldPath could be set to `.testMap.foo` If the validation checks two lists must have unique attributes, the fieldPath could be set to either of the list: e.g. `.testList` It does not support list numeric index. It supports child operation to refer to an existing field currently. Refer to [JSONPath support in Kubernetes](https://kubernetes.io/docs/reference/kubectl/jsonpath/) for more info. Numeric index of array is not supported. For field name which contains special characters, use `['specialName']` to refer the field name. e.g. for attribute `foo.34$` appears in a list `testList`, the fieldPath could be set to `.testList['foo.34$']` */
  fieldPath?: Maybe<Scalars['String']['output']>;
  /** Message represents the message displayed when validation fails. The message is required if the Rule contains line breaks. The message must not contain line breaks. If unset, the message is "failed rule: {Rule}". e.g. "must be a URL with the host matching spec.host" */
  message?: Maybe<Scalars['String']['output']>;
  /** MessageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails. Since messageExpression is used as a failure message, it must evaluate to a string. If both message and messageExpression are present on a rule, then messageExpression will be used if validation fails. If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged. messageExpression has access to all the same variables as the rule; the only difference is the return type. Example: "x must be less than max ("+string(self.max)+")" */
  messageExpression?: Maybe<Scalars['String']['output']>;
  /**
   * optionalOldSelf is used to opt a transition rule into evaluation even when the object is first created, or if the old object is missing the value.
   *
   * When enabled `oldSelf` will be a CEL optional whose value will be `None` if there is no old value, or when the object is initially created.
   *
   * You may check for presence of oldSelf using `oldSelf.hasValue()` and unwrap it after checking using `oldSelf.value()`. Check the CEL documentation for Optional types for more information: https://pkg.go.dev/github.com/google/cel-go/cel#OptionalTypes
   *
   * May not be set unless `oldSelf` is used in `rule`.
   */
  optionalOldSelf?: Maybe<Scalars['Boolean']['output']>;
  reason?: Maybe<AdditionalProperties_Not_OneOf_Items_PatternProperties_AdditionalProperties_AdditionalProperties_X_Kubernetes_Validations_Items_Reason>;
  /**
   * Rule represents the expression which will be evaluated by CEL. ref: https://github.com/google/cel-spec The Rule is scoped to the location of the x-kubernetes-validations extension in the schema. The `self` variable in the CEL expression is bound to the scoped value. Example: - Rule scoped to the root of a resource with a status subresource: {"rule": "self.status.actual <= self.spec.maxDesired"}
   *
   * If the Rule is scoped to an object with properties, the accessible properties of the object are field selectable via `self.field` and field presence can be checked via `has(self.field)`. Null valued fields are treated as absent fields in CEL expressions. If the Rule is scoped to an object with additionalProperties (i.e. a map) the value of the map are accessible via `self[mapKey]`, map containment can be checked via `mapKey in self` and all entries of the map are accessible via CEL macros and functions such as `self.all(...)`. If the Rule is scoped to an array, the elements of the array are accessible via `self[i]` and also by macros and functions. If the Rule is scoped to a scalar, `self` is bound to the scalar value. Examples: - Rule scoped to a map of objects: {"rule": "self.components['Widget'].priority < 10"} - Rule scoped to a list of integers: {"rule": "self.values.all(value, value >= 0 && value < 100)"} - Rule scoped to a string value: {"rule": "self.startsWith('kube')"}
   *
   * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the object and from any x-kubernetes-embedded-resource annotated objects. No other metadata properties are accessible.
   *
   * Unknown data preserved in custom resources via x-kubernetes-preserve-unknown-fields is not accessible in CEL expressions. This includes: - Unknown field values that are preserved by object schemas with x-kubernetes-preserve-unknown-fields. - Object properties where the property schema is of an "unknown type". An "unknown type" is recursively defined as:
   *   - A schema with no type and x-kubernetes-preserve-unknown-fields set to true
   *   - An array where the items schema is of an "unknown type"
   *   - An object where the additionalProperties schema is of an "unknown type"
   *
   * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible. Accessible property names are escaped according to the following rules when accessed in the expression: - '__' escapes to '__underscores__' - '.' escapes to '__dot__' - '-' escapes to '__dash__' - '/' escapes to '__slash__' - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
   * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
   * 	  "import", "let", "loop", "package", "namespace", "return".
   * Examples:
   *   - Rule accessing a property named "namespace": {"rule": "self.__namespace__ > 0"}
   *   - Rule accessing a property named "x-prop": {"rule": "self.x__dash__prop > 0"}
   *   - Rule accessing a property named "redact__d": {"rule": "self.redact__underscores__d > 0"}
   *
   * Equality on arrays with x-kubernetes-list-type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1]. Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
   *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
   *     non-intersecting elements in `Y` are appended, retaining their partial order.
   *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
   *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
   *     non-intersecting keys are appended, retaining their partial order.
   *
   * If `rule` makes use of the `oldSelf` variable it is implicitly a `transition rule`.
   *
   * By default, the `oldSelf` variable is the same type as `self`. When `optionalOldSelf` is true, the `oldSelf` variable is a CEL optional
   *  variable whose value() is the same type as `self`.
   * See the documentation for the `optionalOldSelf` field for details.
   *
   * Transition rules by default are applied only on UPDATE requests and are skipped if an old value could not be found. You can opt a transition rule into unconditional evaluation by setting `optionalOldSelf` to true.
   */
  rule: Scalars['String']['output'];
};

/** ValidationRule describes a validation rule written in the CEL expression language. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ValidationRule_Input = {
  /** fieldPath represents the field path returned when the validation fails. It must be a relative JSON path (i.e. with array notation) scoped to the location of this x-kubernetes-validations extension in the schema and refer to an existing field. e.g. when validation checks if a specific attribute `foo` under a map `testMap`, the fieldPath could be set to `.testMap.foo` If the validation checks two lists must have unique attributes, the fieldPath could be set to either of the list: e.g. `.testList` It does not support list numeric index. It supports child operation to refer to an existing field currently. Refer to [JSONPath support in Kubernetes](https://kubernetes.io/docs/reference/kubectl/jsonpath/) for more info. Numeric index of array is not supported. For field name which contains special characters, use `['specialName']` to refer the field name. e.g. for attribute `foo.34$` appears in a list `testList`, the fieldPath could be set to `.testList['foo.34$']` */
  fieldPath?: InputMaybe<Scalars['String']['input']>;
  /** Message represents the message displayed when validation fails. The message is required if the Rule contains line breaks. The message must not contain line breaks. If unset, the message is "failed rule: {Rule}". e.g. "must be a URL with the host matching spec.host" */
  message?: InputMaybe<Scalars['String']['input']>;
  /** MessageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails. Since messageExpression is used as a failure message, it must evaluate to a string. If both message and messageExpression are present on a rule, then messageExpression will be used if validation fails. If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged. messageExpression has access to all the same variables as the rule; the only difference is the return type. Example: "x must be less than max ("+string(self.max)+")" */
  messageExpression?: InputMaybe<Scalars['String']['input']>;
  /**
   * optionalOldSelf is used to opt a transition rule into evaluation even when the object is first created, or if the old object is missing the value.
   *
   * When enabled `oldSelf` will be a CEL optional whose value will be `None` if there is no old value, or when the object is initially created.
   *
   * You may check for presence of oldSelf using `oldSelf.hasValue()` and unwrap it after checking using `oldSelf.value()`. Check the CEL documentation for Optional types for more information: https://pkg.go.dev/github.com/google/cel-go/cel#OptionalTypes
   *
   * May not be set unless `oldSelf` is used in `rule`.
   */
  optionalOldSelf?: InputMaybe<Scalars['Boolean']['input']>;
  reason?: InputMaybe<AdditionalProperties_Not_OneOf_Items_PatternProperties_AdditionalProperties_AdditionalProperties_X_Kubernetes_Validations_Items_Reason>;
  /**
   * Rule represents the expression which will be evaluated by CEL. ref: https://github.com/google/cel-spec The Rule is scoped to the location of the x-kubernetes-validations extension in the schema. The `self` variable in the CEL expression is bound to the scoped value. Example: - Rule scoped to the root of a resource with a status subresource: {"rule": "self.status.actual <= self.spec.maxDesired"}
   *
   * If the Rule is scoped to an object with properties, the accessible properties of the object are field selectable via `self.field` and field presence can be checked via `has(self.field)`. Null valued fields are treated as absent fields in CEL expressions. If the Rule is scoped to an object with additionalProperties (i.e. a map) the value of the map are accessible via `self[mapKey]`, map containment can be checked via `mapKey in self` and all entries of the map are accessible via CEL macros and functions such as `self.all(...)`. If the Rule is scoped to an array, the elements of the array are accessible via `self[i]` and also by macros and functions. If the Rule is scoped to a scalar, `self` is bound to the scalar value. Examples: - Rule scoped to a map of objects: {"rule": "self.components['Widget'].priority < 10"} - Rule scoped to a list of integers: {"rule": "self.values.all(value, value >= 0 && value < 100)"} - Rule scoped to a string value: {"rule": "self.startsWith('kube')"}
   *
   * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the object and from any x-kubernetes-embedded-resource annotated objects. No other metadata properties are accessible.
   *
   * Unknown data preserved in custom resources via x-kubernetes-preserve-unknown-fields is not accessible in CEL expressions. This includes: - Unknown field values that are preserved by object schemas with x-kubernetes-preserve-unknown-fields. - Object properties where the property schema is of an "unknown type". An "unknown type" is recursively defined as:
   *   - A schema with no type and x-kubernetes-preserve-unknown-fields set to true
   *   - An array where the items schema is of an "unknown type"
   *   - An object where the additionalProperties schema is of an "unknown type"
   *
   * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible. Accessible property names are escaped according to the following rules when accessed in the expression: - '__' escapes to '__underscores__' - '.' escapes to '__dot__' - '-' escapes to '__dash__' - '/' escapes to '__slash__' - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
   * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
   * 	  "import", "let", "loop", "package", "namespace", "return".
   * Examples:
   *   - Rule accessing a property named "namespace": {"rule": "self.__namespace__ > 0"}
   *   - Rule accessing a property named "x-prop": {"rule": "self.x__dash__prop > 0"}
   *   - Rule accessing a property named "redact__d": {"rule": "self.redact__underscores__d > 0"}
   *
   * Equality on arrays with x-kubernetes-list-type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1]. Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
   *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
   *     non-intersecting elements in `Y` are appended, retaining their partial order.
   *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
   *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
   *     non-intersecting keys are appended, retaining their partial order.
   *
   * If `rule` makes use of the `oldSelf` variable it is implicitly a `transition rule`.
   *
   * By default, the `oldSelf` variable is the same type as `self`. When `optionalOldSelf` is true, the `oldSelf` variable is a CEL optional
   *  variable whose value() is the same type as `self`.
   * See the documentation for the `optionalOldSelf` field for details.
   *
   * Transition rules by default are applied only on UPDATE requests and are skipped if an old value could not be found. You can opt a transition rule into unconditional evaluation by setting `optionalOldSelf` to true.
   */
  rule: Scalars['String']['input'];
};

/** WebhookClientConfig contains the information to make a TLS connection with the webhook. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_WebhookClientConfig = {
  /** caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server certificate. If unspecified, system trust roots on the apiserver are used. */
  caBundle?: Maybe<Scalars['Byte']['output']>;
  service?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ServiceReference>;
  /**
   * url gives the location of the webhook, in standard URL form (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.
   *
   * The `host` should not refer to a service running in the cluster; use the `service` field instead. The host might be resolved via external DNS in some apiservers (e.g., `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation). `host` may also be an IP address.
   *
   * Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take great care to run this webhook on all hosts which run an apiserver which might need to make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn up in a new cluster.
   *
   * The scheme must be "https"; the URL must begin with "https://".
   *
   * A path is optional, and if present may be any string permissible in a URL. You may use the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
   *
   * Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments ("#...") and query parameters ("?...") are not allowed, either.
   */
  url?: Maybe<Scalars['String']['output']>;
};

/** WebhookClientConfig contains the information to make a TLS connection with the webhook. */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_WebhookClientConfig_Input = {
  /** caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server certificate. If unspecified, system trust roots on the apiserver are used. */
  caBundle?: InputMaybe<Scalars['Byte']['input']>;
  service?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_ServiceReference_Input>;
  /**
   * url gives the location of the webhook, in standard URL form (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.
   *
   * The `host` should not refer to a service running in the cluster; use the `service` field instead. The host might be resolved via external DNS in some apiservers (e.g., `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation). `host` may also be an IP address.
   *
   * Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take great care to run this webhook on all hosts which run an apiserver which might need to make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn up in a new cluster.
   *
   * The scheme must be "https"; the URL must begin with "https://".
   *
   * A path is optional, and if present may be any string permissible in a URL. You may use the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
   *
   * Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments ("#...") and query parameters ("?...") are not allowed, either.
   */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** WebhookConversion describes how to call a conversion webhook */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_WebhookConversion = {
  clientConfig?: Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_WebhookClientConfig>;
  /** conversionReviewVersions is an ordered list of preferred `ConversionReview` versions the Webhook expects. The API server will use the first version in the list which it supports. If none of the versions specified in this list are supported by API server, conversion will fail for the custom resource. If a persisted Webhook configuration specifies allowed versions and does not include any versions known to the API Server, calls to the webhook will fail. */
  conversionReviewVersions: Array<Maybe<Scalars['String']['output']>>;
};

/** WebhookConversion describes how to call a conversion webhook */
export type Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_WebhookConversion_Input = {
  clientConfig?: InputMaybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_WebhookClientConfig_Input>;
  /** conversionReviewVersions is an ordered list of preferred `ConversionReview` versions the Webhook expects. The API server will use the first version in the list which it supports. If none of the versions specified in this list are supported by API server, conversion will fail for the custom resource. If a persisted Webhook configuration specifies allowed versions and does not include any versions known to the API Server, calls to the webhook will fail. */
  conversionReviewVersions: Array<InputMaybe<Scalars['String']['input']>>;
};

/** APIGroup contains the name, the supported versions, and the preferred version of a group. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiGroup = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  /** name is the name of the group. */
  name: Scalars['String']['output'];
  preferredVersion?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionForDiscovery>;
  /** a map of client CIDR to server address that is serving this group. This is to help clients reach servers in the most network-efficient way possible. Clients can use the appropriate server address as per the CIDR that they match. In case of multiple matches, clients should use the longest matching CIDR. The server returns only those CIDRs that it thinks that the client can match. For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP. Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP. */
  serverAddressByClientCIDRs?: Maybe<
    Array<Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ServerAddressByClientCidr>>
  >;
  /** versions are the versions supported in this group. */
  versions: Array<Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionForDiscovery>>;
};

/** APIResource specifies the name of a resource and whether it is namespaced. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResource = {
  /** categories is a list of the grouped resources this resource belongs to (e.g. 'all') */
  categories?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** group is the preferred group of the resource.  Empty implies the group of the containing resource list. For subresources, this may have a different value, for example: Scale". */
  group?: Maybe<Scalars['String']['output']>;
  /** kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo') */
  kind: Scalars['String']['output'];
  /** name is the plural name of the resource. */
  name: Scalars['String']['output'];
  /** namespaced indicates if a resource is namespaced or not. */
  namespaced: Scalars['Boolean']['output'];
  /** shortNames is a list of suggested short names of the resource. */
  shortNames?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely. The singularName is more correct for reporting status on a single item and both singular and plural are allowed from the kubectl CLI interface. */
  singularName: Scalars['String']['output'];
  /** The hash value of the storage version, the version this resource is converted to when written to the data store. Value must be treated as opaque by clients. Only equality comparison on the value is valid. This is an alpha feature and may change or be removed in the future. The field is populated by the apiserver only if the StorageVersionHash feature gate is enabled. This field will remain optional even if it graduates. */
  storageVersionHash?: Maybe<Scalars['String']['output']>;
  /** verbs is a list of supported kube verbs (this includes get, list, watch, create, update, patch, delete, deletecollection, and proxy) */
  verbs: Array<Maybe<Scalars['String']['output']>>;
  /** version is the preferred version of the resource.  Empty implies the version of the containing resource list For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)". */
  version?: Maybe<Scalars['String']['output']>;
};

/** APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResourceList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** groupVersion is the group and version this APIResourceList is for. */
  groupVersion: Scalars['String']['output'];
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  /** resources contains the name of the resources and if they are namespaced. */
  resources: Array<Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiResource>>;
};

/** APIVersions lists the versions that are available, to allow clients to discover the API at /api, which is the root path of the legacy v1 API. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ApiVersions = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  /** a map of client CIDR to server address that is serving this group. This is to help clients reach servers in the most network-efficient way possible. Clients can use the appropriate server address as per the CIDR that they match. In case of multiple matches, clients should use the longest matching CIDR. The server returns only those CIDRs that it thinks that the client can match. For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP. Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP. */
  serverAddressByClientCIDRs: Array<
    Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ServerAddressByClientCidr>
  >;
  /** versions are the api versions that are available. */
  versions: Array<Maybe<Scalars['String']['output']>>;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Condition = {
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  lastTransitionTime: Scalars['DateTime']['output'];
  /** message is a human readable message indicating details about the transition. This may be an empty string. */
  message: Scalars['String']['output'];
  /** observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance. */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
  /** reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty. */
  reason: Scalars['String']['output'];
  /** status of the condition, one of True, False, Unknown. */
  status: Scalars['String']['output'];
  /** type of condition in CamelCase or in foo.example.com/CamelCase. */
  type: Scalars['String']['output'];
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Condition_Input = {
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  lastTransitionTime: Scalars['DateTime']['input'];
  /** message is a human readable message indicating details about the transition. This may be an empty string. */
  message: Scalars['String']['input'];
  /** observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance. */
  observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
  /** reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty. */
  reason: Scalars['String']['input'];
  /** status of the condition, one of True, False, Unknown. */
  status: Scalars['String']['input'];
  /** type of condition in CamelCase or in foo.example.com/CamelCase. */
  type: Scalars['String']['input'];
};

/** DeleteOptions may be provided when deleting an API object. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed */
  dryRun?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. */
  gracePeriodSeconds?: InputMaybe<Scalars['BigInt']['input']>;
  /** if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it */
  ignoreStoreReadErrorWithClusterBreakingPotential?: InputMaybe<Scalars['Boolean']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  /** Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. */
  orphanDependents?: InputMaybe<Scalars['Boolean']['input']>;
  preconditions?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Preconditions_Input>;
  /** Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. */
  propagationPolicy?: InputMaybe<Scalars['String']['input']>;
};

/** FieldSelectorRequirement is a selector that contains values, a key, and an operator that relates the key and values. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_FieldSelectorRequirement = {
  /** key is the field selector key that the requirement applies to. */
  key: Scalars['String']['output'];
  /** operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. The list of operators may grow in the future. */
  operator: Scalars['String']['output'];
  /** values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. */
  values?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** FieldSelectorRequirement is a selector that contains values, a key, and an operator that relates the key and values. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_FieldSelectorRequirement_Input = {
  /** key is the field selector key that the requirement applies to. */
  key: Scalars['String']['input'];
  /** operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. The list of operators may grow in the future. */
  operator: Scalars['String']['input'];
  /** values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. */
  values?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** GroupVersion contains the "group/version" and "version" string of a version. It is made a struct to keep extensibility. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionForDiscovery = {
  /** groupVersion specifies the API group and version in the form "group/version" */
  groupVersion: Scalars['String']['output'];
  /** version specifies the version in the form of "version". This is to save the clients the trouble of splitting the GroupVersion. */
  version: Scalars['String']['output'];
};

/** A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector = {
  /** matchExpressions is a list of label selector requirements. The requirements are ANDed. */
  matchExpressions?: Maybe<
    Array<Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelectorRequirement>>
  >;
  /** matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed. */
  matchLabels?: Maybe<Scalars['JSON']['output']>;
};

/** A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelectorRequirement = {
  /** key is the label key that the selector applies to. */
  key: Scalars['String']['output'];
  /** operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist. */
  operator: Scalars['String']['output'];
  /** values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. */
  values?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelectorRequirement_Input = {
  /** key is the label key that the selector applies to. */
  key: Scalars['String']['input'];
  /** operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist. */
  operator: Scalars['String']['input'];
  /** values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. */
  values?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector_Input = {
  /** matchExpressions is a list of label selector requirements. The requirements are ANDed. */
  matchExpressions?: InputMaybe<
    Array<InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_LabelSelectorRequirement_Input>>
  >;
  /** matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed. */
  matchLabels?: InputMaybe<Scalars['JSON']['input']>;
};

/** ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta = {
  /** continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message. */
  continue?: Maybe<Scalars['String']['output']>;
  /** remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact. */
  remainingItemCount?: Maybe<Scalars['BigInt']['output']>;
  /** String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency */
  resourceVersion?: Maybe<Scalars['String']['output']>;
  /** Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. */
  selfLink?: Maybe<Scalars['String']['output']>;
};

/** ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ManagedFieldsEntry = {
  /** APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted. */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1" */
  fieldsType?: Maybe<Scalars['String']['output']>;
  fieldsV1?: Maybe<Scalars['JSON']['output']>;
  /** Manager is an identifier of the workflow managing these fields. */
  manager?: Maybe<Scalars['String']['output']>;
  /** Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'. */
  operation?: Maybe<Scalars['String']['output']>;
  /** Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource. */
  subresource?: Maybe<Scalars['String']['output']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  time?: Maybe<Scalars['DateTime']['output']>;
};

/** ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ManagedFieldsEntry_Input = {
  /** APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted. */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1" */
  fieldsType?: InputMaybe<Scalars['String']['input']>;
  fieldsV1?: InputMaybe<Scalars['JSON']['input']>;
  /** Manager is an identifier of the workflow managing these fields. */
  manager?: InputMaybe<Scalars['String']['input']>;
  /** Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'. */
  operation?: InputMaybe<Scalars['String']['input']>;
  /** Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource. */
  subresource?: InputMaybe<Scalars['String']['input']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  time?: InputMaybe<Scalars['DateTime']['input']>;
};

/** ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta = {
  /** Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations */
  annotations?: Maybe<Scalars['JSON']['output']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  creationTimestamp?: Maybe<Scalars['DateTime']['output']>;
  /** Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only. */
  deletionGracePeriodSeconds?: Maybe<Scalars['BigInt']['output']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  deletionTimestamp?: Maybe<Scalars['DateTime']['output']>;
  /** Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. */
  finalizers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
   *
   * If this field is specified and the generated name exists, the server will return a 409.
   *
   * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
   */
  generateName?: Maybe<Scalars['String']['output']>;
  /** A sequence number representing a specific generation of the desired state. Populated by the system. Read-only. */
  generation?: Maybe<Scalars['BigInt']['output']>;
  /** Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels */
  labels?: Maybe<Scalars['JSON']['output']>;
  /** ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object. */
  managedFields?: Maybe<Array<Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ManagedFieldsEntry>>>;
  /** Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
   *
   * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
   */
  namespace?: Maybe<Scalars['String']['output']>;
  /** List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. */
  ownerReferences?: Maybe<Array<Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_OwnerReference>>>;
  /**
   * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
   *
   * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   */
  resourceVersion?: Maybe<Scalars['String']['output']>;
  /** Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. */
  selfLink?: Maybe<Scalars['String']['output']>;
  /**
   * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
   *
   * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
   */
  uid?: Maybe<Scalars['String']['output']>;
};

/** ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input = {
  /** Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations */
  annotations?: InputMaybe<Scalars['JSON']['input']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  creationTimestamp?: InputMaybe<Scalars['DateTime']['input']>;
  /** Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only. */
  deletionGracePeriodSeconds?: InputMaybe<Scalars['BigInt']['input']>;
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  deletionTimestamp?: InputMaybe<Scalars['DateTime']['input']>;
  /** Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. */
  finalizers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
   *
   * If this field is specified and the generated name exists, the server will return a 409.
   *
   * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
   */
  generateName?: InputMaybe<Scalars['String']['input']>;
  /** A sequence number representing a specific generation of the desired state. Populated by the system. Read-only. */
  generation?: InputMaybe<Scalars['BigInt']['input']>;
  /** Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels */
  labels?: InputMaybe<Scalars['JSON']['input']>;
  /** ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object. */
  managedFields?: InputMaybe<
    Array<InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ManagedFieldsEntry_Input>>
  >;
  /** Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names */
  name?: InputMaybe<Scalars['String']['input']>;
  /**
   * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
   *
   * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
   */
  namespace?: InputMaybe<Scalars['String']['input']>;
  /** List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. */
  ownerReferences?: InputMaybe<
    Array<InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_OwnerReference_Input>>
  >;
  /**
   * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
   *
   * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   */
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  /** Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. */
  selfLink?: InputMaybe<Scalars['String']['input']>;
  /**
   * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
   *
   * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
   */
  uid?: InputMaybe<Scalars['String']['input']>;
};

/** OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_OwnerReference = {
  /** API version of the referent. */
  apiVersion: Scalars['String']['output'];
  /** If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. */
  blockOwnerDeletion?: Maybe<Scalars['Boolean']['output']>;
  /** If true, this reference points to the managing controller. */
  controller?: Maybe<Scalars['Boolean']['output']>;
  /** Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind: Scalars['String']['output'];
  /** Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names */
  name: Scalars['String']['output'];
  /** UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
  uid: Scalars['String']['output'];
};

/** OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_OwnerReference_Input = {
  /** API version of the referent. */
  apiVersion: Scalars['String']['input'];
  /** If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. */
  blockOwnerDeletion?: InputMaybe<Scalars['Boolean']['input']>;
  /** If true, this reference points to the managing controller. */
  controller?: InputMaybe<Scalars['Boolean']['input']>;
  /** Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind: Scalars['String']['input'];
  /** Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names */
  name: Scalars['String']['input'];
  /** UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
  uid: Scalars['String']['input'];
};

/** Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Preconditions_Input = {
  /** Specifies the target ResourceVersion */
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  /** Specifies the target UID. */
  uid?: InputMaybe<Scalars['String']['input']>;
};

/** ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ServerAddressByClientCidr = {
  /** The CIDR with which clients can match their IP to figure out the server address that they should use. */
  clientCIDR: Scalars['String']['output'];
  /** Address of this server, suitable for a client that matches the above CIDR. This can be a hostname, hostname:port, IP or IP:port. */
  serverAddress: Scalars['String']['output'];
};

/** Status is a return value for calls that don't return other objects. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_Status = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Suggested HTTP return code for this status, 0 if not set. */
  code?: Maybe<Scalars['Int']['output']>;
  details?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_StatusDetails>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  /** A human-readable description of the status of this operation. */
  message?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
  /** A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it. */
  reason?: Maybe<Scalars['String']['output']>;
  /** Status of the operation. One of: "Success" or "Failure". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status */
  status?: Maybe<Scalars['String']['output']>;
};

/** StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_StatusCause = {
  /**
   * The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.
   *
   * Examples:
   *   "name" - the field "name" on the current resource
   *   "items[0].name" - the field "name" on the first array entry in "items"
   */
  field?: Maybe<Scalars['String']['output']>;
  /** A human-readable description of the cause of the error.  This field may be presented as-is to a reader. */
  message?: Maybe<Scalars['String']['output']>;
  /** A machine-readable description of the cause of the error. If this value is empty there is no information available. */
  reason?: Maybe<Scalars['String']['output']>;
};

/** StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_StatusDetails = {
  /** The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes. */
  causes?: Maybe<Array<Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_StatusCause>>>;
  /** The group attribute of the resource associated with the status StatusReason. */
  group?: Maybe<Scalars['String']['output']>;
  /** The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  /** The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described). */
  name?: Maybe<Scalars['String']['output']>;
  /** If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action. */
  retryAfterSeconds?: Maybe<Scalars['Int']['output']>;
  /** UID of the resource. (when there is a single resource which can be described). More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
  uid?: Maybe<Scalars['String']['output']>;
};

/** Event represents a single event to a watched resource. */
export type Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent = {
  object: Scalars['JSON']['output'];
  type: Scalars['String']['output'];
};

/** Event captures all the information that can be included in an API audit log. */
export type Io_K8s_Apiserver_Pkg_Apis_Audit_V1_Event = {
  /** Annotations is an unstructured key value map stored with an audit event that may be set by plugins invoked in the request serving chain, including authentication, authorization and admission plugins. Note that these annotations are for the audit event, and do not correspond to the metadata.annotations of the submitted object. Keys should uniquely identify the informing component to avoid name collisions (e.g. podsecuritypolicy.admission.k8s.io/policy). Values should be short. Annotations are included in the Metadata level. */
  annotations?: Maybe<Scalars['JSON']['output']>;
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Unique audit ID, generated for each request. */
  auditID: Scalars['String']['output'];
  impersonatedUser?: Maybe<Io_K8s_Api_Authentication_V1_UserInfo>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  /** AuditLevel at which event was generated */
  level: Scalars['String']['output'];
  objectRef?: Maybe<Io_K8s_Apiserver_Pkg_Apis_Audit_V1_ObjectReference>;
  requestObject?: Maybe<Unknown_Runtime_Pkg_Apimachinery_K8s_Io>;
  /** MicroTime is version of Time with microsecond level precision. */
  requestReceivedTimestamp?: Maybe<Scalars['DateTime']['output']>;
  /** RequestURI is the request URI as sent by the client to a server. */
  requestURI: Scalars['String']['output'];
  responseObject?: Maybe<Unknown_Runtime_Pkg_Apimachinery_K8s_Io>;
  responseStatus?: Maybe<Status_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io>;
  /**
   * Source IPs, from where the request originated and intermediate proxies. The source IPs are listed from (in order): 1. X-Forwarded-For request header IPs 2. X-Real-Ip header, if not present in the X-Forwarded-For list 3. The remote address for the connection, if it doesn't match the last
   *    IP in the list up to here (X-Forwarded-For or X-Real-Ip).
   * Note: All but the last IP can be arbitrarily set by the client.
   */
  sourceIPs?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Stage of the request handling when this event instance was generated. */
  stage: Scalars['String']['output'];
  /** MicroTime is version of Time with microsecond level precision. */
  stageTimestamp?: Maybe<Scalars['DateTime']['output']>;
  user: Io_K8s_Api_Authentication_V1_UserInfo;
  /** UserAgent records the user agent string reported by the client. Note that the UserAgent is provided by the client, and must not be trusted. */
  userAgent?: Maybe<Scalars['String']['output']>;
  /** Verb is the kubernetes verb associated with the request. For non-resource requests, this is the lower-cased HTTP method. */
  verb: Scalars['String']['output'];
};

/** Event captures all the information that can be included in an API audit log. */
export type Io_K8s_Apiserver_Pkg_Apis_Audit_V1_Event_Input = {
  /** Annotations is an unstructured key value map stored with an audit event that may be set by plugins invoked in the request serving chain, including authentication, authorization and admission plugins. Note that these annotations are for the audit event, and do not correspond to the metadata.annotations of the submitted object. Keys should uniquely identify the informing component to avoid name collisions (e.g. podsecuritypolicy.admission.k8s.io/policy). Values should be short. Annotations are included in the Metadata level. */
  annotations?: InputMaybe<Scalars['JSON']['input']>;
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Unique audit ID, generated for each request. */
  auditID: Scalars['String']['input'];
  impersonatedUser?: InputMaybe<Io_K8s_Api_Authentication_V1_UserInfo_Input>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  /** AuditLevel at which event was generated */
  level: Scalars['String']['input'];
  objectRef?: InputMaybe<Io_K8s_Apiserver_Pkg_Apis_Audit_V1_ObjectReference_Input>;
  requestObject?: InputMaybe<Unknown_Runtime_Pkg_Apimachinery_K8s_Io_Input>;
  /** MicroTime is version of Time with microsecond level precision. */
  requestReceivedTimestamp?: InputMaybe<Scalars['DateTime']['input']>;
  /** RequestURI is the request URI as sent by the client to a server. */
  requestURI: Scalars['String']['input'];
  responseObject?: InputMaybe<Unknown_Runtime_Pkg_Apimachinery_K8s_Io_Input>;
  responseStatus?: InputMaybe<Status_V1_Meta_Apis_Pkg_Apimachinery_K8s_Io_Input>;
  /**
   * Source IPs, from where the request originated and intermediate proxies. The source IPs are listed from (in order): 1. X-Forwarded-For request header IPs 2. X-Real-Ip header, if not present in the X-Forwarded-For list 3. The remote address for the connection, if it doesn't match the last
   *    IP in the list up to here (X-Forwarded-For or X-Real-Ip).
   * Note: All but the last IP can be arbitrarily set by the client.
   */
  sourceIPs?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Stage of the request handling when this event instance was generated. */
  stage: Scalars['String']['input'];
  /** MicroTime is version of Time with microsecond level precision. */
  stageTimestamp?: InputMaybe<Scalars['DateTime']['input']>;
  user: Io_K8s_Api_Authentication_V1_UserInfo_Input;
  /** UserAgent records the user agent string reported by the client. Note that the UserAgent is provided by the client, and must not be trusted. */
  userAgent?: InputMaybe<Scalars['String']['input']>;
  /** Verb is the kubernetes verb associated with the request. For non-resource requests, this is the lower-cased HTTP method. */
  verb: Scalars['String']['input'];
};

/** ObjectReference contains enough information to let you inspect or modify the referred object. */
export type Io_K8s_Apiserver_Pkg_Apis_Audit_V1_ObjectReference = {
  /** APIGroup is the name of the API group that contains the referred object. The empty string represents the core API group. */
  apiGroup?: Maybe<Scalars['String']['output']>;
  /** APIVersion is the version of the API group that contains the referred object. */
  apiVersion?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  namespace?: Maybe<Scalars['String']['output']>;
  resource?: Maybe<Scalars['String']['output']>;
  resourceVersion?: Maybe<Scalars['String']['output']>;
  subresource?: Maybe<Scalars['String']['output']>;
  uid?: Maybe<Scalars['String']['output']>;
};

/** ObjectReference contains enough information to let you inspect or modify the referred object. */
export type Io_K8s_Apiserver_Pkg_Apis_Audit_V1_ObjectReference_Input = {
  /** APIGroup is the name of the API group that contains the referred object. The empty string represents the core API group. */
  apiGroup?: InputMaybe<Scalars['String']['input']>;
  /** APIVersion is the version of the API group that contains the referred object. */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  resource?: InputMaybe<Scalars['String']['input']>;
  resourceVersion?: InputMaybe<Scalars['String']['input']>;
  subresource?: InputMaybe<Scalars['String']['input']>;
  uid?: InputMaybe<Scalars['String']['input']>;
};

/** APIService represents a server for a particular GroupVersion. Name must be "version.group". */
export type Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiService = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec?: Maybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiServiceSpec>;
  status?: Maybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiServiceStatus>;
};

/** APIServiceCondition describes the state of an APIService at a particular point */
export type Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiServiceCondition = {
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  lastTransitionTime?: Maybe<Scalars['DateTime']['output']>;
  /** Human-readable message indicating details about last transition. */
  message?: Maybe<Scalars['String']['output']>;
  /** Unique, one-word, CamelCase reason for the condition's last transition. */
  reason?: Maybe<Scalars['String']['output']>;
  /** Status is the status of the condition. Can be True, False, Unknown. */
  status: Scalars['String']['output'];
  /** Type is the type of the condition. */
  type: Scalars['String']['output'];
};

/** APIServiceCondition describes the state of an APIService at a particular point */
export type Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiServiceCondition_Input = {
  /** Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
  lastTransitionTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** Human-readable message indicating details about last transition. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Unique, one-word, CamelCase reason for the condition's last transition. */
  reason?: InputMaybe<Scalars['String']['input']>;
  /** Status is the status of the condition. Can be True, False, Unknown. */
  status: Scalars['String']['input'];
  /** Type is the type of the condition. */
  type: Scalars['String']['input'];
};

/** APIServiceList is a list of APIService objects. */
export type Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiServiceList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Items is the list of APIService */
  items: Array<Maybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiService>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/** APIServiceSpec contains information for locating and communicating with a server. Only https is supported, though you are able to disable certificate verification. */
export type Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiServiceSpec = {
  /** CABundle is a PEM encoded CA bundle which will be used to validate an API server's serving certificate. If unspecified, system trust roots on the apiserver are used. */
  caBundle?: Maybe<Scalars['Byte']['output']>;
  /** Group is the API group name this server hosts */
  group?: Maybe<Scalars['String']['output']>;
  /** GroupPriorityMinimum is the priority this group should have at least. Higher priority means that the group is preferred by clients over lower priority ones. Note that other versions of this group might specify even higher GroupPriorityMinimum values such that the whole group gets a higher priority. The primary sort is based on GroupPriorityMinimum, ordered highest number to lowest (20 before 10). The secondary sort is based on the alphabetical comparison of the name of the object.  (v1.bar before v1.foo) We'd recommend something like: *.k8s.io (except extensions) at 18000 and PaaSes (OpenShift, Deis) are recommended to be in the 2000s */
  groupPriorityMinimum: Scalars['Int']['output'];
  /** InsecureSkipTLSVerify disables TLS certificate verification when communicating with this server. This is strongly discouraged.  You should use the CABundle instead. */
  insecureSkipTLSVerify?: Maybe<Scalars['Boolean']['output']>;
  service?: Maybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ServiceReference>;
  /** Version is the API version this server hosts.  For example, "v1" */
  version?: Maybe<Scalars['String']['output']>;
  /** VersionPriority controls the ordering of this API version inside of its group.  Must be greater than zero. The primary sort is based on VersionPriority, ordered highest to lowest (20 before 10). Since it's inside of a group, the number can be small, probably in the 10s. In case of equal version priorities, the version string will be used to compute the order inside a group. If the version string is "kube-like", it will sort above non "kube-like" version strings, which are ordered lexicographically. "Kube-like" versions start with a "v", then are followed by a number (the major version), then optionally the string "alpha" or "beta" and another number (the minor version). These are sorted first by GA > beta > alpha (where GA is a version with no suffix such as beta or alpha), and then by comparing major version, then minor version. An example sorted list of versions: v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10. */
  versionPriority: Scalars['Int']['output'];
};

/** APIServiceSpec contains information for locating and communicating with a server. Only https is supported, though you are able to disable certificate verification. */
export type Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiServiceSpec_Input = {
  /** CABundle is a PEM encoded CA bundle which will be used to validate an API server's serving certificate. If unspecified, system trust roots on the apiserver are used. */
  caBundle?: InputMaybe<Scalars['Byte']['input']>;
  /** Group is the API group name this server hosts */
  group?: InputMaybe<Scalars['String']['input']>;
  /** GroupPriorityMinimum is the priority this group should have at least. Higher priority means that the group is preferred by clients over lower priority ones. Note that other versions of this group might specify even higher GroupPriorityMinimum values such that the whole group gets a higher priority. The primary sort is based on GroupPriorityMinimum, ordered highest number to lowest (20 before 10). The secondary sort is based on the alphabetical comparison of the name of the object.  (v1.bar before v1.foo) We'd recommend something like: *.k8s.io (except extensions) at 18000 and PaaSes (OpenShift, Deis) are recommended to be in the 2000s */
  groupPriorityMinimum: Scalars['Int']['input'];
  /** InsecureSkipTLSVerify disables TLS certificate verification when communicating with this server. This is strongly discouraged.  You should use the CABundle instead. */
  insecureSkipTLSVerify?: InputMaybe<Scalars['Boolean']['input']>;
  service?: InputMaybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ServiceReference_Input>;
  /** Version is the API version this server hosts.  For example, "v1" */
  version?: InputMaybe<Scalars['String']['input']>;
  /** VersionPriority controls the ordering of this API version inside of its group.  Must be greater than zero. The primary sort is based on VersionPriority, ordered highest to lowest (20 before 10). Since it's inside of a group, the number can be small, probably in the 10s. In case of equal version priorities, the version string will be used to compute the order inside a group. If the version string is "kube-like", it will sort above non "kube-like" version strings, which are ordered lexicographically. "Kube-like" versions start with a "v", then are followed by a number (the major version), then optionally the string "alpha" or "beta" and another number (the minor version). These are sorted first by GA > beta > alpha (where GA is a version with no suffix such as beta or alpha), and then by comparing major version, then minor version. An example sorted list of versions: v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10. */
  versionPriority: Scalars['Int']['input'];
};

/** APIServiceStatus contains derived information about an API server */
export type Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiServiceStatus = {
  /** Current service state of apiService. */
  conditions?: Maybe<
    Array<Maybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiServiceCondition>>
  >;
};

/** APIServiceStatus contains derived information about an API server */
export type Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiServiceStatus_Input = {
  /** Current service state of apiService. */
  conditions?: InputMaybe<
    Array<InputMaybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiServiceCondition_Input>>
  >;
};

/** APIService represents a server for a particular GroupVersion. Name must be "version.group". */
export type Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiService_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec?: InputMaybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiServiceSpec_Input>;
  status?: InputMaybe<Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ApiServiceStatus_Input>;
};

/** ServiceReference holds a reference to Service.legacy.k8s.io */
export type Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ServiceReference = {
  /** Name is the name of the service */
  name?: Maybe<Scalars['String']['output']>;
  /** Namespace is the namespace of the service */
  namespace?: Maybe<Scalars['String']['output']>;
  /** If specified, the port on the service that hosting webhook. Default to 443 for backward compatibility. `port` should be a valid port number (1-65535, inclusive). */
  port?: Maybe<Scalars['Int']['output']>;
};

/** ServiceReference holds a reference to Service.legacy.k8s.io */
export type Io_K8s_Kube_Aggregator_Pkg_Apis_Apiregistration_V1_ServiceReference_Input = {
  /** Name is the name of the service */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Namespace is the namespace of the service */
  namespace?: InputMaybe<Scalars['String']['input']>;
  /** If specified, the port on the service that hosting webhook. Default to 443 for backward compatibility. `port` should be a valid port number (1-65535, inclusive). */
  port?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * BackendTLSPolicy provides a way to configure how a Gateway
 * connects to a Backend via TLS.
 */
export type Io_K8s_Networking_Gateway_V1_BackendTlsPolicy = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status>;
};

/** BackendTLSPolicyList is a list of BackendTLSPolicy */
export type Io_K8s_Networking_Gateway_V1_BackendTlsPolicyList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of backendtlspolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Io_K8s_Networking_Gateway_V1_BackendTlsPolicy>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * BackendTLSPolicy provides a way to configure how a Gateway
 * connects to a Backend via TLS.
 */
export type Io_K8s_Networking_Gateway_V1_BackendTlsPolicy_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * Gateway represents an instance of a service-traffic handling infrastructure
 * by binding Listeners to a set of IP addresses.
 */
export type Io_K8s_Networking_Gateway_V1_Gateway = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status>;
};

/**
 * GatewayClass describes a class of Gateways available to the user for creating
 * Gateway resources.
 *
 * It is recommended that this resource be used as a template for Gateways. This
 * means that a Gateway is based on the state of the GatewayClass at the time it
 * was created and changes to the GatewayClass or associated parameters are not
 * propagated down to existing Gateways. This recommendation is intended to
 * limit the blast radius of changes to GatewayClass or associated parameters.
 * If implementations choose to propagate GatewayClass changes to existing
 * Gateways, that MUST be clearly documented by the implementation.
 *
 * Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
 * add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
 * associated GatewayClass. This ensures that a GatewayClass associated with a
 * Gateway is not deleted while in use.
 *
 * GatewayClass is a Cluster level resource.
 */
export type Io_K8s_Networking_Gateway_V1_GatewayClass = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Spec;
  status?: Maybe<Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Status>;
};

/** GatewayClassList is a list of GatewayClass */
export type Io_K8s_Networking_Gateway_V1_GatewayClassList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of gatewayclasses. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Io_K8s_Networking_Gateway_V1_GatewayClass>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * GatewayClass describes a class of Gateways available to the user for creating
 * Gateway resources.
 *
 * It is recommended that this resource be used as a template for Gateways. This
 * means that a Gateway is based on the state of the GatewayClass at the time it
 * was created and changes to the GatewayClass or associated parameters are not
 * propagated down to existing Gateways. This recommendation is intended to
 * limit the blast radius of changes to GatewayClass or associated parameters.
 * If implementations choose to propagate GatewayClass changes to existing
 * Gateways, that MUST be clearly documented by the implementation.
 *
 * Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
 * add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
 * associated GatewayClass. This ensures that a GatewayClass associated with a
 * Gateway is not deleted while in use.
 *
 * GatewayClass is a Cluster level resource.
 */
export type Io_K8s_Networking_Gateway_V1_GatewayClass_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Status_Input>;
};

/** GatewayList is a list of Gateway */
export type Io_K8s_Networking_Gateway_V1_GatewayList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of gateways. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Io_K8s_Networking_Gateway_V1_Gateway>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * Gateway represents an instance of a service-traffic handling infrastructure
 * by binding Listeners to a set of IP addresses.
 */
export type Io_K8s_Networking_Gateway_V1_Gateway_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * HTTPRoute provides a way to route HTTP requests. This includes the capability
 * to match requests by hostname, path, header, or query param. Filters can be
 * used to specify additional processing steps. Backends specify where matching
 * requests should be routed.
 */
export type Io_K8s_Networking_Gateway_V1_HttpRoute = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status>;
};

/** HTTPRouteList is a list of HTTPRoute */
export type Io_K8s_Networking_Gateway_V1_HttpRouteList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of httproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Io_K8s_Networking_Gateway_V1_HttpRoute>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * HTTPRoute provides a way to route HTTP requests. This includes the capability
 * to match requests by hostname, path, header, or query param. Filters can be
 * used to specify additional processing steps. Backends specify where matching
 * requests should be routed.
 */
export type Io_K8s_Networking_Gateway_V1_HttpRoute_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * BackendTLSPolicy provides a way to configure how a Gateway
 * connects to a Backend via TLS.
 */
export type Io_K8s_Networking_Gateway_V1alpha3_BackendTlsPolicy = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status>;
};

/** BackendTLSPolicyList is a list of BackendTLSPolicy */
export type Io_K8s_Networking_Gateway_V1alpha3_BackendTlsPolicyList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of backendtlspolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Io_K8s_Networking_Gateway_V1alpha3_BackendTlsPolicy>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * BackendTLSPolicy provides a way to configure how a Gateway
 * connects to a Backend via TLS.
 */
export type Io_K8s_Networking_Gateway_V1alpha3_BackendTlsPolicy_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * Gateway represents an instance of a service-traffic handling infrastructure
 * by binding Listeners to a set of IP addresses.
 */
export type Io_K8s_Networking_Gateway_V1beta1_Gateway = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status>;
};

/**
 * GatewayClass describes a class of Gateways available to the user for creating
 * Gateway resources.
 *
 * It is recommended that this resource be used as a template for Gateways. This
 * means that a Gateway is based on the state of the GatewayClass at the time it
 * was created and changes to the GatewayClass or associated parameters are not
 * propagated down to existing Gateways. This recommendation is intended to
 * limit the blast radius of changes to GatewayClass or associated parameters.
 * If implementations choose to propagate GatewayClass changes to existing
 * Gateways, that MUST be clearly documented by the implementation.
 *
 * Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
 * add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
 * associated GatewayClass. This ensures that a GatewayClass associated with a
 * Gateway is not deleted while in use.
 *
 * GatewayClass is a Cluster level resource.
 */
export type Io_K8s_Networking_Gateway_V1beta1_GatewayClass = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Spec;
  status?: Maybe<Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Status>;
};

/** GatewayClassList is a list of GatewayClass */
export type Io_K8s_Networking_Gateway_V1beta1_GatewayClassList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of gatewayclasses. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Io_K8s_Networking_Gateway_V1beta1_GatewayClass>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * GatewayClass describes a class of Gateways available to the user for creating
 * Gateway resources.
 *
 * It is recommended that this resource be used as a template for Gateways. This
 * means that a Gateway is based on the state of the GatewayClass at the time it
 * was created and changes to the GatewayClass or associated parameters are not
 * propagated down to existing Gateways. This recommendation is intended to
 * limit the blast radius of changes to GatewayClass or associated parameters.
 * If implementations choose to propagate GatewayClass changes to existing
 * Gateways, that MUST be clearly documented by the implementation.
 *
 * Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
 * add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
 * associated GatewayClass. This ensures that a GatewayClass associated with a
 * Gateway is not deleted while in use.
 *
 * GatewayClass is a Cluster level resource.
 */
export type Io_K8s_Networking_Gateway_V1beta1_GatewayClass_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Status_Input>;
};

/** GatewayList is a list of Gateway */
export type Io_K8s_Networking_Gateway_V1beta1_GatewayList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of gateways. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Io_K8s_Networking_Gateway_V1beta1_Gateway>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * Gateway represents an instance of a service-traffic handling infrastructure
 * by binding Listeners to a set of IP addresses.
 */
export type Io_K8s_Networking_Gateway_V1beta1_Gateway_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * HTTPRoute provides a way to route HTTP requests. This includes the capability
 * to match requests by hostname, path, header, or query param. Filters can be
 * used to specify additional processing steps. Backends specify where matching
 * requests should be routed.
 */
export type Io_K8s_Networking_Gateway_V1beta1_HttpRoute = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta>;
  spec: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec;
  status?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status>;
};

/** HTTPRouteList is a list of HTTPRoute */
export type Io_K8s_Networking_Gateway_V1beta1_HttpRouteList = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** List of httproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md */
  items: Array<Maybe<Io_K8s_Networking_Gateway_V1beta1_HttpRoute>>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ListMeta>;
};

/**
 * HTTPRoute provides a way to route HTTP requests. This includes the capability
 * to match requests by hostname, path, header, or query param. Filters can be
 * used to specify additional processing steps. Backends specify where matching
 * requests should be routed.
 */
export type Io_K8s_Networking_Gateway_V1beta1_HttpRoute_Input = {
  /** APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
  kind?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Io_K8s_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta_Input>;
  spec: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Input;
  status?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Input>;
};

/**
 * FailurePolicy defines how unrecognized errors from the admission endpoint are handled - allowed values are Ignore or Fail. Defaults to Fail.
 *
 * Possible enum values:
 *  - `"Fail"` means that an error calling the webhook causes the admission to fail.
 *  - `"Ignore"` means that an error calling the webhook is ignored.
 */
export type Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_FailurePolicy =
  'Fail' | 'Ignore';

/**
 * matchPolicy defines how the "rules" list is used to match incoming requests. Allowed values are "Exact" or "Equivalent".
 *
 * - Exact: match a request only if it exactly matches a specified rule. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
 *
 * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
 *
 * Defaults to "Equivalent"
 *
 * Possible enum values:
 *  - `"Equivalent"` means requests should be sent to the webhook if they modify a resource listed in rules via another API group or version.
 *  - `"Exact"` means requests should only be sent to the webhook if they exactly match a given rule.
 */
export type Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_MatchPolicy =
  'Equivalent' | 'Exact';

/**
 * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation. Allowed values are "Never" and "IfNeeded".
 *
 * Never: the webhook will not be called more than once in a single admission evaluation.
 *
 * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation if the object being admitted is modified by other admission plugins after the initial webhook call. Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted. Note: * the number of additional invocations is not guaranteed to be exactly one. * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again. * webhooks that use this option may be reordered to minimize the number of additional invocations. * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
 *
 * Defaults to "Never".
 *
 * Possible enum values:
 *  - `"IfNeeded"` indicates that the mutation may be called at least one additional time as part of the admission evaluation if the object being admitted is modified by other admission plugins after the initial mutation call.
 *  - `"Never"` indicates that the mutation must not be called more than once in a single admission evaluation.
 */
export type Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_ReinvocationPolicy =
  'IfNeeded' | 'Never';

export type Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_Rules_Items_Operations_Items =
  'CONNECT' | 'CREATE' | 'DELETE' | 'UPDATE' | '_STAR_';

/**
 * SideEffects states whether this webhook has side effects. Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks with side effects MUST implement a reconciliation system, since a request may be rejected by a future step in the admission chain and the side effects therefore need to be undone. Requests with the dryRun attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or Some.
 *
 * Possible enum values:
 *  - `"None"` means that calling the webhook will have no side effects.
 *  - `"NoneOnDryRun"` means that calling the webhook will possibly have side effects, but if the request being reviewed has the dry-run attribute, the side effects will be suppressed.
 *  - `"Some"` means that calling the webhook will possibly have side effects. If a request with the dry-run attribute would trigger a call to this webhook, the request will instead fail.
 *  - `"Unknown"` means that no information is known about the side effects of calling the webhook. If a request with the dry-run attribute would trigger a call to this webhook, the request will instead fail.
 */
export type Query_ListAdmissionregistrationV1MutatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_SideEffects =
  'None' | 'NoneOnDryRun' | 'Some' | 'Unknown';

export type Query_ListAdmissionregistrationV1ValidatingAdmissionPolicyBinding_OneOf_0_Items_Items_Spec_ValidationActions_Items =
  'Audit' | 'Deny' | 'Warn';

/**
 * failurePolicy defines how to handle failures for the admission policy. Failures can occur from CEL expression parse errors, type check errors, runtime errors and invalid or mis-configured policy definitions or bindings.
 *
 * A policy is invalid if spec.paramKind refers to a non-existent Kind. A binding is invalid if spec.paramRef.name refers to a non-existent resource.
 *
 * failurePolicy does not define how validations that evaluate to false are handled.
 *
 * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions define how failures are enforced.
 *
 * Allowed values are Ignore or Fail. Defaults to Fail.
 *
 * Possible enum values:
 *  - `"Fail"` means that an error calling the webhook causes the admission to fail.
 *  - `"Ignore"` means that an error calling the webhook is ignored.
 */
export type Query_ListAdmissionregistrationV1ValidatingAdmissionPolicy_OneOf_0_Items_Items_Spec_FailurePolicy =
  'Fail' | 'Ignore';

export type Query_ListAdmissionregistrationV1ValidatingAdmissionPolicy_OneOf_0_Items_Items_Spec_MatchConstraints_ExcludeResourceRules_Items_Operations_Items =
  'CONNECT' | 'CREATE' | 'DELETE' | 'UPDATE' | '_STAR_';

/**
 * matchPolicy defines how the "MatchResources" list is used to match incoming requests. Allowed values are "Exact" or "Equivalent".
 *
 * - Exact: match a request only if it exactly matches a specified rule. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
 *
 * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
 *
 * Defaults to "Equivalent"
 *
 * Possible enum values:
 *  - `"Equivalent"` means requests should be sent to the webhook if they modify a resource listed in rules via another API group or version.
 *  - `"Exact"` means requests should only be sent to the webhook if they exactly match a given rule.
 */
export type Query_ListAdmissionregistrationV1ValidatingAdmissionPolicy_OneOf_0_Items_Items_Spec_MatchConstraints_MatchPolicy =
  'Equivalent' | 'Exact';

/**
 * FailurePolicy defines how unrecognized errors from the admission endpoint are handled - allowed values are Ignore or Fail. Defaults to Fail.
 *
 * Possible enum values:
 *  - `"Fail"` means that an error calling the webhook causes the admission to fail.
 *  - `"Ignore"` means that an error calling the webhook is ignored.
 */
export type Query_ListAdmissionregistrationV1ValidatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_FailurePolicy =
  'Fail' | 'Ignore';

/**
 * matchPolicy defines how the "rules" list is used to match incoming requests. Allowed values are "Exact" or "Equivalent".
 *
 * - Exact: match a request only if it exactly matches a specified rule. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
 *
 * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
 *
 * Defaults to "Equivalent"
 *
 * Possible enum values:
 *  - `"Equivalent"` means requests should be sent to the webhook if they modify a resource listed in rules via another API group or version.
 *  - `"Exact"` means requests should only be sent to the webhook if they exactly match a given rule.
 */
export type Query_ListAdmissionregistrationV1ValidatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_MatchPolicy =
  'Equivalent' | 'Exact';

/**
 * SideEffects states whether this webhook has side effects. Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks with side effects MUST implement a reconciliation system, since a request may be rejected by a future step in the admission chain and the side effects therefore need to be undone. Requests with the dryRun attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or Some.
 *
 * Possible enum values:
 *  - `"None"` means that calling the webhook will have no side effects.
 *  - `"NoneOnDryRun"` means that calling the webhook will possibly have side effects, but if the request being reviewed has the dry-run attribute, the side effects will be suppressed.
 *  - `"Some"` means that calling the webhook will possibly have side effects. If a request with the dry-run attribute would trigger a call to this webhook, the request will instead fail.
 *  - `"Unknown"` means that no information is known about the side effects of calling the webhook. If a request with the dry-run attribute would trigger a call to this webhook, the request will instead fail.
 */
export type Query_ListAdmissionregistrationV1ValidatingWebhookConfiguration_OneOf_0_Items_Items_Webhooks_Items_SideEffects =
  'None' | 'NoneOnDryRun' | 'Some' | 'Unknown';

/** DocumentAcceptanceSpec defines the desired state of DocumentAcceptance. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec =
  {
    acceptanceContext: Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_AcceptanceContext;
    accepterRef: Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_AccepterRef;
    documentRevisionRef: Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_DocumentRevisionRef;
    signature: Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_Signature;
    subjectRef: Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_SubjectRef;
  };

/** DocumentAcceptanceSpec defines the desired state of DocumentAcceptance. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_Input =
  {
    acceptanceContext: Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_AcceptanceContext_Input;
    accepterRef: Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_AccepterRef_Input;
    documentRevisionRef: Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_DocumentRevisionRef_Input;
    signature: Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_Signature_Input;
    subjectRef: Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_SubjectRef_Input;
  };

/** AcceptanceContext is the context of the document acceptance. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_AcceptanceContext =
  {
    /** AcceptanceLanguage is the language of the document acceptance. */
    acceptanceLanguage?: Maybe<Scalars['String']['output']>;
    /** IPAddress is the IP address of the accepter. */
    ipAddress?: Maybe<Scalars['String']['output']>;
    method: Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_AcceptanceContext_Method;
    /** UserAgent is the user agent of the accepter. */
    userAgent?: Maybe<Scalars['String']['output']>;
  };

/** AcceptanceContext is the context of the document acceptance. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_AcceptanceContext_Input =
  {
    /** AcceptanceLanguage is the language of the document acceptance. */
    acceptanceLanguage?: InputMaybe<Scalars['String']['input']>;
    /** IPAddress is the IP address of the accepter. */
    ipAddress?: InputMaybe<Scalars['String']['input']>;
    method: Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_AcceptanceContext_Method;
    /** UserAgent is the user agent of the accepter. */
    userAgent?: InputMaybe<Scalars['String']['input']>;
  };

/** Method is the method of the document acceptance. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_AcceptanceContext_Method =
  'cli' | 'email' | 'web';

/** AccepterRef is a reference to the accepter that this document acceptance applies to. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_AccepterRef =
  {
    /** APIGroup is the group for the resource being referenced. */
    apiGroup: Scalars['String']['output'];
    /** Kind is the type of resource being referenced. */
    kind: Scalars['String']['output'];
    /** Name is the name of the Resource being referenced. */
    name: Scalars['String']['output'];
    /** Namespace is the namespace of the Resource being referenced. */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/** AccepterRef is a reference to the accepter that this document acceptance applies to. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_AccepterRef_Input =
  {
    /** APIGroup is the group for the resource being referenced. */
    apiGroup: Scalars['String']['input'];
    /** Kind is the type of resource being referenced. */
    kind: Scalars['String']['input'];
    /** Name is the name of the Resource being referenced. */
    name: Scalars['String']['input'];
    /** Namespace is the namespace of the Resource being referenced. */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/** DocumentRevisionRef is a reference to the document revision that is being accepted. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_DocumentRevisionRef =
  {
    /** Name is the name of the DocumentRevision being referenced. */
    name: Scalars['String']['output'];
    /** Namespace of the referenced document revision. */
    namespace: Scalars['String']['output'];
    version: Scalars['query_listAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_items_items_spec_documentRevisionRef_version']['output'];
  };

/** DocumentRevisionRef is a reference to the document revision that is being accepted. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_DocumentRevisionRef_Input =
  {
    /** Name is the name of the DocumentRevision being referenced. */
    name: Scalars['String']['input'];
    /** Namespace of the referenced document revision. */
    namespace: Scalars['String']['input'];
    version: Scalars['query_listAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_items_items_spec_documentRevisionRef_version']['input'];
  };

/** Signature is the signature of the document acceptance. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_Signature =
  {
    /** Timestamp is the timestamp of the document acceptance. */
    timestamp: Scalars['DateTime']['output'];
    type: Checkbox_Const;
  };

/** Signature is the signature of the document acceptance. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_Signature_Input =
  {
    /** Timestamp is the timestamp of the document acceptance. */
    timestamp: Scalars['DateTime']['input'];
    type: Checkbox_Const;
  };

/** SubjectRef is a reference to the subject that this document acceptance applies to. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_SubjectRef =
  {
    /** APIGroup is the group for the resource being referenced. */
    apiGroup: Scalars['String']['output'];
    /** Kind is the type of resource being referenced. */
    kind: Scalars['String']['output'];
    /** Name is the name of the Resource being referenced. */
    name: Scalars['String']['output'];
    /** Namespace is the namespace of the Resource being referenced. */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/** SubjectRef is a reference to the subject that this document acceptance applies to. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Spec_SubjectRef_Input =
  {
    /** APIGroup is the group for the resource being referenced. */
    apiGroup: Scalars['String']['input'];
    /** Kind is the type of resource being referenced. */
    kind: Scalars['String']['input'];
    /** Name is the name of the Resource being referenced. */
    name: Scalars['String']['input'];
    /** Namespace is the namespace of the Resource being referenced. */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/** DocumentAcceptanceStatus defines the observed state of DocumentAcceptance. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Status =
  {
    /** Conditions represent the latest available observations of an object's current state. */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Status_Conditions_Items>
      >
    >;
  };

/** DocumentAcceptanceStatus defines the observed state of DocumentAcceptance. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Status_Input =
  {
    /** Conditions represent the latest available observations of an object's current state. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListAgreementMiloapisComV1alpha1DocumentAcceptanceForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

export type Query_ListApiextensionsV1CustomResourceDefinition_OneOf_0_Items_Items_Spec_Versions_Items_Schema_OpenApiv3Schema_AllOf_Items_AnyOf_Items_Definitions =
  {
    additionalProperties?: Maybe<
      Array<Maybe<Io_K8s_Apiextensions_Apiserver_Pkg_Apis_Apiextensions_V1_JsonSchemaProps2_Entry>>
    >;
  };

/** Spec defines the desired state of an Instance. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec = {
  controller?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Controller>;
  location?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Location>;
  /** Network interface configuration. */
  networkInterfaces: Array<
    Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items>
  >;
  runtime: Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime;
  /**
   * Volumes that must be available to attach to an instance's containers or
   * Virtual Machine.
   */
  volumes?: Maybe<
    Array<
      Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items>
    >
  >;
};

/** Spec defines the desired state of an Instance. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Input = {
  controller?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Controller_Input>;
  location?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Location_Input>;
  /** Network interface configuration. */
  networkInterfaces: Array<
    InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_Input>
  >;
  runtime: Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Input;
  /**
   * Volumes that must be available to attach to an instance's containers or
   * Virtual Machine.
   */
  volumes?: InputMaybe<
    Array<
      InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Input>
    >
  >;
};

/** Controller contains settings driven by the controller managing the instance. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Controller =
  {
    /**
     * SchedulingGates is a list of gates that must be satisfied before the
     * instance can be scheduled.
     */
    schedulingGates?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Controller_SchedulingGates_Items>
      >
    >;
    /** TemplateHash is the hash of the instance template applied for this instance. */
    templateHash: Scalars['String']['output'];
  };

/** Controller contains settings driven by the controller managing the instance. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Controller_Input =
  {
    /**
     * SchedulingGates is a list of gates that must be satisfied before the
     * instance can be scheduled.
     */
    schedulingGates?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Controller_SchedulingGates_Items_Input>
      >
    >;
    /** TemplateHash is the hash of the instance template applied for this instance. */
    templateHash: Scalars['String']['input'];
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Controller_SchedulingGates_Items =
  {
    /** The name of the gate. */
    name: Scalars['String']['output'];
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Controller_SchedulingGates_Items_Input =
  {
    /** The name of the gate. */
    name: Scalars['String']['input'];
  };

/** The location which the instance has been scheduled to */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Location =
  {
    /** Name of a datum location */
    name: Scalars['String']['output'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['output'];
  };

/** The location which the instance has been scheduled to */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Location_Input =
  {
    /** Name of a datum location */
    name: Scalars['String']['input'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['input'];
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items =
  {
    network: Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_Network;
    networkPolicy?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy>;
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_Input =
  {
    network: Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_Network_Input;
    networkPolicy?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Input>;
  };

/** The network to attach the network interface to. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_Network =
  {
    /** The network name */
    name: Scalars['String']['output'];
    /**
     * The network namespace.
     *
     * Defaults to the namespace for the type the reference is embedded in.
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/**
 * Interface specific network policy.
 *
 * If provided, this will result in a platform managed network policy being
 * created that targets the specfiic instance interface. This network policy
 * will be of the lowest priority, and can effectively be prohibited from
 * influencing network connectivity.
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy =
  {
    ingress?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items>
      >
    >;
  };

/**
 * Interface specific network policy.
 *
 * If provided, this will result in a platform managed network policy being
 * created that targets the specfiic instance interface. This network policy
 * will be of the lowest priority, and can effectively be prohibited from
 * influencing network connectivity.
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Input =
  {
    ingress?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Input>
      >
    >;
  };

/** See k8s network policy types for inspiration here */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items =
  {
    /**
     * from is a list of sources which should be able to access the instances selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all sources (traffic not restricted by
     * source). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the from list.
     */
    from?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items>
      >
    >;
    /**
     * ports is a list of ports which should be made accessible on the instances selected for
     * this rule. Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     */
    ports?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items>
      >
    >;
  };

/** See k8s network policy types for inspiration here */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Input =
  {
    /**
     * from is a list of sources which should be able to access the instances selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all sources (traffic not restricted by
     * source). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the from list.
     */
    from?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_Input>
      >
    >;
    /**
     * ports is a list of ports which should be made accessible on the instances selected for
     * this rule. Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     */
    ports?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items_Input>
      >
    >;
  };

/**
 * NetworkPolicyPeer describes a peer to allow traffic to/from. Only certain combinations of
 * fields are allowed
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items =
  {
    ipBlock?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_IpBlock>;
  };

/**
 * NetworkPolicyPeer describes a peer to allow traffic to/from. Only certain combinations of
 * fields are allowed
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_Input =
  {
    ipBlock?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_IpBlock_Input>;
  };

/**
 * ipBlock defines policy on a particular IPBlock. If this field is set then
 * neither of the other fields can be.
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_IpBlock =
  {
    /**
     * cidr is a string representing the IPBlock
     * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
     */
    cidr: Scalars['String']['output'];
    /**
     * except is a slice of CIDRs that should not be included within an IPBlock
     * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
     * Except values will be rejected if they are outside the cidr range
     */
    except?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  };

/**
 * ipBlock defines policy on a particular IPBlock. If this field is set then
 * neither of the other fields can be.
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_IpBlock_Input =
  {
    /**
     * cidr is a string representing the IPBlock
     * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
     */
    cidr: Scalars['String']['input'];
    /**
     * except is a slice of CIDRs that should not be included within an IPBlock
     * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
     * Except values will be rejected if they are outside the cidr range
     */
    except?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  };

/** NetworkPolicyPort describes a port to allow traffic on */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items =
  {
    /**
     * endPort indicates that the range of ports from port to endPort if set, inclusive,
     * should be allowed by the policy. This field cannot be defined if the port field
     * is not defined or if the port field is defined as a named (string) port.
     * The endPort must be equal or greater than port.
     */
    endPort?: Maybe<Scalars['Int']['output']>;
    /**
     * port represents the port on the given protocol. This can either be a numerical or named
     * port on an instance. If this field is not provided, this matches all port names and
     * numbers.
     * If present, only traffic on the specified protocol AND port will be matched.
     */
    port?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items_Port>;
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: Maybe<Scalars['String']['output']>;
  };

/** NetworkPolicyPort describes a port to allow traffic on */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items_Input =
  {
    /**
     * endPort indicates that the range of ports from port to endPort if set, inclusive,
     * should be allowed by the policy. This field cannot be defined if the port field
     * is not defined or if the port field is defined as a named (string) port.
     * The endPort must be equal or greater than port.
     */
    endPort?: InputMaybe<Scalars['Int']['input']>;
    /**
     * port represents the port on the given protocol. This can either be a numerical or named
     * port on an instance. If this field is not provided, this matches all port names and
     * numbers.
     * If present, only traffic on the specified protocol AND port will be matched.
     */
    port?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * port represents the port on the given protocol. This can either be a numerical or named
 * port on an instance. If this field is not provided, this matches all port names and
 * numbers.
 * If present, only traffic on the specified protocol AND port will be matched.
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items_Port =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
  };

/** The network to attach the network interface to. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_NetworkInterfaces_Items_Network_Input =
  {
    /** The network name */
    name: Scalars['String']['input'];
    /**
     * The network namespace.
     *
     * Defaults to the namespace for the type the reference is embedded in.
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/** The runtime type of the instance, such as a container sandbox or a VM. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime =
  {
    resources: Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Resources;
    sandbox?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox>;
    virtualMachine?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_VirtualMachine>;
  };

/** The runtime type of the instance, such as a container sandbox or a VM. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Input =
  {
    resources: Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Resources_Input;
    sandbox?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Input>;
    virtualMachine?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_VirtualMachine_Input>;
  };

/**
 * Resources each instance must be allocated.
 *
 * A sandbox runtime's containers may specify resource requests and
 * limits. When limits are defined on all containers, they MUST consume
 * the entire amount of resources defined here. Some resources, such
 * as a GPU, MUST have at least one container request them so that the
 * device can be presented appropriately.
 *
 * A virtual machine runtime will be provided all requested resources.
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Resources =
  {
    /**
     * Full or partial URL of the instance type resource to use for this instance.
     *
     * For example: `datumcloud/d1-standard-2`
     *
     * May be combined with `resources` to allow for custom instance types for
     * instance families that support customization. Instance types which support
     * customization will appear in the form `<project>/<instanceFamily>-custom`.
     */
    instanceType: Scalars['String']['output'];
    /** Describes adjustments to the resources defined by the instance type. */
    requests?: Maybe<Scalars['JSON']['output']>;
  };

/**
 * Resources each instance must be allocated.
 *
 * A sandbox runtime's containers may specify resource requests and
 * limits. When limits are defined on all containers, they MUST consume
 * the entire amount of resources defined here. Some resources, such
 * as a GPU, MUST have at least one container request them so that the
 * device can be presented appropriately.
 *
 * A virtual machine runtime will be provided all requested resources.
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Resources_Input =
  {
    /**
     * Full or partial URL of the instance type resource to use for this instance.
     *
     * For example: `datumcloud/d1-standard-2`
     *
     * May be combined with `resources` to allow for custom instance types for
     * instance families that support customization. Instance types which support
     * customization will appear in the form `<project>/<instanceFamily>-custom`.
     */
    instanceType: Scalars['String']['input'];
    /** Describes adjustments to the resources defined by the instance type. */
    requests?: InputMaybe<Scalars['JSON']['input']>;
  };

/** A sandbox is a managed isolated environment capable of running containers. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox =
  {
    /** A list of containers to run within the sandbox. */
    containers: Array<
      Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items>
    >;
    /**
     * An optional list of secrets in the same namespace to use for pulling images
     * used by the instance.
     */
    imagePullSecrets?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_ImagePullSecrets_Items>
      >
    >;
  };

/** A sandbox is a managed isolated environment capable of running containers. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Input =
  {
    /** A list of containers to run within the sandbox. */
    containers: Array<
      InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Input>
    >;
    /**
     * An optional list of secrets in the same namespace to use for pulling images
     * used by the instance.
     */
    imagePullSecrets?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_ImagePullSecrets_Items_Input>
      >
    >;
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items =
  {
    /**
     * List of environment variables to set in the container.
     *
     * so replicate the structure here too.
     */
    env?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items>
      >
    >;
    /** The fully qualified container image name. */
    image: Scalars['String']['output'];
    /** The name of the container. */
    name: Scalars['String']['output'];
    /** A list of named ports for the container. */
    ports?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Ports_Items>
      >
    >;
    resources?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Resources>;
    /** A list of volumes to attach to the container. */
    volumeAttachments?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_VolumeAttachments_Items>
      >
    >;
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Input =
  {
    /**
     * List of environment variables to set in the container.
     *
     * so replicate the structure here too.
     */
    env?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_Input>
      >
    >;
    /** The fully qualified container image name. */
    image: Scalars['String']['input'];
    /** The name of the container. */
    name: Scalars['String']['input'];
    /** A list of named ports for the container. */
    ports?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Ports_Items_Input>
      >
    >;
    resources?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Resources_Input>;
    /** A list of volumes to attach to the container. */
    volumeAttachments?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_VolumeAttachments_Items_Input>
      >
    >;
  };

/** EnvVar represents an environment variable present in a Container. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items =
  {
    /** Name of the environment variable. Must be a C_IDENTIFIER. */
    name: Scalars['String']['output'];
    /**
     * Variable references $(VAR_NAME) are expanded
     * using the previously defined environment variables in the container and
     * any service environment variables. If a variable cannot be resolved,
     * the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
     * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
     * Escaped references will never be expanded, regardless of whether the variable
     * exists or not.
     * Defaults to "".
     */
    value?: Maybe<Scalars['String']['output']>;
    valueFrom?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom>;
  };

/** EnvVar represents an environment variable present in a Container. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_Input =
  {
    /** Name of the environment variable. Must be a C_IDENTIFIER. */
    name: Scalars['String']['input'];
    /**
     * Variable references $(VAR_NAME) are expanded
     * using the previously defined environment variables in the container and
     * any service environment variables. If a variable cannot be resolved,
     * the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
     * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
     * Escaped references will never be expanded, regardless of whether the variable
     * exists or not.
     * Defaults to "".
     */
    value?: InputMaybe<Scalars['String']['input']>;
    valueFrom?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_Input>;
  };

/** Source for the environment variable's value. Cannot be used if value is not empty. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom =
  {
    configMapKeyRef?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ConfigMapKeyRef>;
    fieldRef?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_FieldRef>;
    resourceFieldRef?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ResourceFieldRef>;
    secretKeyRef?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_SecretKeyRef>;
  };

/** Source for the environment variable's value. Cannot be used if value is not empty. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_Input =
  {
    configMapKeyRef?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ConfigMapKeyRef_Input>;
    fieldRef?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_FieldRef_Input>;
    resourceFieldRef?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ResourceFieldRef_Input>;
    secretKeyRef?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_SecretKeyRef_Input>;
  };

/** Selects a key of a ConfigMap. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ConfigMapKeyRef =
  {
    /** The key to select. */
    key: Scalars['String']['output'];
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: Maybe<Scalars['String']['output']>;
    /** Specify whether the ConfigMap or its key must be defined */
    optional?: Maybe<Scalars['Boolean']['output']>;
  };

/** Selects a key of a ConfigMap. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ConfigMapKeyRef_Input =
  {
    /** The key to select. */
    key: Scalars['String']['input'];
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: InputMaybe<Scalars['String']['input']>;
    /** Specify whether the ConfigMap or its key must be defined */
    optional?: InputMaybe<Scalars['Boolean']['input']>;
  };

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_FieldRef =
  {
    /** Version of the schema the FieldPath is written in terms of, defaults to "v1". */
    apiVersion?: Maybe<Scalars['String']['output']>;
    /** Path of the field to select in the specified API version. */
    fieldPath: Scalars['String']['output'];
  };

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_FieldRef_Input =
  {
    /** Version of the schema the FieldPath is written in terms of, defaults to "v1". */
    apiVersion?: InputMaybe<Scalars['String']['input']>;
    /** Path of the field to select in the specified API version. */
    fieldPath: Scalars['String']['input'];
  };

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ResourceFieldRef =
  {
    /** Container name: required for volumes, optional for env vars */
    containerName?: Maybe<Scalars['String']['output']>;
    divisor?: Maybe<
      Scalars['query_listComputeDatumapisComV1alphaInstanceForAllNamespaces_items_items_spec_runtime_sandbox_containers_items_env_items_valueFrom_resourceFieldRef_divisor']['output']
    >;
    /** Required: resource to select */
    resource: Scalars['String']['output'];
  };

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ResourceFieldRef_Input =
  {
    /** Container name: required for volumes, optional for env vars */
    containerName?: InputMaybe<Scalars['String']['input']>;
    divisor?: InputMaybe<
      Scalars['query_listComputeDatumapisComV1alphaInstanceForAllNamespaces_items_items_spec_runtime_sandbox_containers_items_env_items_valueFrom_resourceFieldRef_divisor']['input']
    >;
    /** Required: resource to select */
    resource: Scalars['String']['input'];
  };

/** Selects a key of a secret in the pod's namespace */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_SecretKeyRef =
  {
    /** The key of the secret to select from.  Must be a valid secret key. */
    key: Scalars['String']['output'];
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: Maybe<Scalars['String']['output']>;
    /** Specify whether the Secret or its key must be defined */
    optional?: Maybe<Scalars['Boolean']['output']>;
  };

/** Selects a key of a secret in the pod's namespace */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_SecretKeyRef_Input =
  {
    /** The key of the secret to select from.  Must be a valid secret key. */
    key: Scalars['String']['input'];
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: InputMaybe<Scalars['String']['input']>;
    /** Specify whether the Secret or its key must be defined */
    optional?: InputMaybe<Scalars['Boolean']['input']>;
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Ports_Items =
  {
    /** The name of the port that can be referenced by other platform features. */
    name: Scalars['String']['output'];
    /** The port number, which can be a value between 1 and 65535. */
    port: Scalars['Int']['output'];
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Ports_Items_Input =
  {
    /** The name of the port that can be referenced by other platform features. */
    name: Scalars['String']['input'];
    /** The port number, which can be a value between 1 and 65535. */
    port: Scalars['Int']['input'];
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: InputMaybe<Scalars['String']['input']>;
  };

/** The resource requirements for the container, such as CPU, memory, and GPUs. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Resources =
  {
    /** Limits describes the maximum amount of compute resources allowed. */
    limits?: Maybe<Scalars['JSON']['output']>;
    /** Requests describes the minimum amount of compute resources required. */
    requests?: Maybe<Scalars['JSON']['output']>;
  };

/** The resource requirements for the container, such as CPU, memory, and GPUs. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_Resources_Input =
  {
    /** Limits describes the maximum amount of compute resources allowed. */
    limits?: InputMaybe<Scalars['JSON']['input']>;
    /** Requests describes the minimum amount of compute resources required. */
    requests?: InputMaybe<Scalars['JSON']['input']>;
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_VolumeAttachments_Items =
  {
    /**
     * The path to mount the volume inside the guest OS.
     *
     * The referenced volume must be populated with a filesystem to use this
     * feature.
     *
     * For VM based instances, this functionality requires certain capabilities
     * to be annotated on the boot image, such as cloud-init.
     */
    mountPath?: Maybe<Scalars['String']['output']>;
    /** The name of the volume to attach as defined in InstanceSpec.Volumes. */
    name: Scalars['String']['output'];
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_Containers_Items_VolumeAttachments_Items_Input =
  {
    /**
     * The path to mount the volume inside the guest OS.
     *
     * The referenced volume must be populated with a filesystem to use this
     * feature.
     *
     * For VM based instances, this functionality requires certain capabilities
     * to be annotated on the boot image, such as cloud-init.
     */
    mountPath?: InputMaybe<Scalars['String']['input']>;
    /** The name of the volume to attach as defined in InstanceSpec.Volumes. */
    name: Scalars['String']['input'];
  };

/**
 * References a secret in the same namespace as the entity defining the
 * reference.
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_ImagePullSecrets_Items =
  {
    /** The name of the secret */
    name: Scalars['String']['output'];
  };

/**
 * References a secret in the same namespace as the entity defining the
 * reference.
 */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_Sandbox_ImagePullSecrets_Items_Input =
  {
    /** The name of the secret */
    name: Scalars['String']['input'];
  };

/** A virtual machine is a classical VM environment, booting a full OS provided by the user via an image. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_VirtualMachine =
  {
    /** A list of named ports for the virtual machine. */
    ports?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_VirtualMachine_Ports_Items>
      >
    >;
    /** A list of volumes to attach to the VM. */
    volumeAttachments: Array<
      Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_VirtualMachine_VolumeAttachments_Items>
    >;
  };

/** A virtual machine is a classical VM environment, booting a full OS provided by the user via an image. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_VirtualMachine_Input =
  {
    /** A list of named ports for the virtual machine. */
    ports?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_VirtualMachine_Ports_Items_Input>
      >
    >;
    /** A list of volumes to attach to the VM. */
    volumeAttachments: Array<
      InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_VirtualMachine_VolumeAttachments_Items_Input>
    >;
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_VirtualMachine_Ports_Items =
  {
    /** The name of the port that can be referenced by other platform features. */
    name: Scalars['String']['output'];
    /** The port number, which can be a value between 1 and 65535. */
    port: Scalars['Int']['output'];
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_VirtualMachine_Ports_Items_Input =
  {
    /** The name of the port that can be referenced by other platform features. */
    name: Scalars['String']['input'];
    /** The port number, which can be a value between 1 and 65535. */
    port: Scalars['Int']['input'];
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: InputMaybe<Scalars['String']['input']>;
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_VirtualMachine_VolumeAttachments_Items =
  {
    /**
     * The path to mount the volume inside the guest OS.
     *
     * The referenced volume must be populated with a filesystem to use this
     * feature.
     *
     * For VM based instances, this functionality requires certain capabilities
     * to be annotated on the boot image, such as cloud-init.
     */
    mountPath?: Maybe<Scalars['String']['output']>;
    /** The name of the volume to attach as defined in InstanceSpec.Volumes. */
    name: Scalars['String']['output'];
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Runtime_VirtualMachine_VolumeAttachments_Items_Input =
  {
    /**
     * The path to mount the volume inside the guest OS.
     *
     * The referenced volume must be populated with a filesystem to use this
     * feature.
     *
     * For VM based instances, this functionality requires certain capabilities
     * to be annotated on the boot image, such as cloud-init.
     */
    mountPath?: InputMaybe<Scalars['String']['input']>;
    /** The name of the volume to attach as defined in InstanceSpec.Volumes. */
    name: Scalars['String']['input'];
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items =
  {
    configMap?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_ConfigMap>;
    disk?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk>;
    /**
     * Name is used to reference the volume in `volumeAttachments` for
     * containers and VMs, and will be used to derive the platform resource
     * name when required by prefixing this name with the instance name upon
     * creation.
     */
    name: Scalars['String']['output'];
    secret?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Secret>;
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Input =
  {
    configMap?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_ConfigMap_Input>;
    disk?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Input>;
    /**
     * Name is used to reference the volume in `volumeAttachments` for
     * containers and VMs, and will be used to derive the platform resource
     * name when required by prefixing this name with the instance name upon
     * creation.
     */
    name: Scalars['String']['input'];
    secret?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Secret_Input>;
  };

/** A configMap that should populate this volume */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_ConfigMap =
  {
    /**
     * defaultMode is optional: mode bits used to set permissions on created files by default.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * Defaults to 0644.
     * Directories within the path are not affected by this setting.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    defaultMode?: Maybe<Scalars['Int']['output']>;
    /**
     * items if unspecified, each key-value pair in the Data field of the referenced
     * ConfigMap will be projected into the volume as a file whose name is the
     * key and content is the value. If specified, the listed keys will be
     * projected into the specified paths, and unlisted keys will not be
     * present. If a key is specified which is not present in the ConfigMap,
     * the volume setup will error unless it is marked optional. Paths must be
     * relative and may not contain the '..' path or start with '..'.
     */
    items?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_ConfigMap_Items_Items>
      >
    >;
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: Maybe<Scalars['String']['output']>;
    /** optional specify whether the ConfigMap or its keys must be defined */
    optional?: Maybe<Scalars['Boolean']['output']>;
  };

/** A configMap that should populate this volume */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_ConfigMap_Input =
  {
    /**
     * defaultMode is optional: mode bits used to set permissions on created files by default.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * Defaults to 0644.
     * Directories within the path are not affected by this setting.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    defaultMode?: InputMaybe<Scalars['Int']['input']>;
    /**
     * items if unspecified, each key-value pair in the Data field of the referenced
     * ConfigMap will be projected into the volume as a file whose name is the
     * key and content is the value. If specified, the listed keys will be
     * projected into the specified paths, and unlisted keys will not be
     * present. If a key is specified which is not present in the ConfigMap,
     * the volume setup will error unless it is marked optional. Paths must be
     * relative and may not contain the '..' path or start with '..'.
     */
    items?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_ConfigMap_Items_Items_Input>
      >
    >;
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: InputMaybe<Scalars['String']['input']>;
    /** optional specify whether the ConfigMap or its keys must be defined */
    optional?: InputMaybe<Scalars['Boolean']['input']>;
  };

/** Maps a string key to a path within a volume. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_ConfigMap_Items_Items =
  {
    /** key is the key to project. */
    key: Scalars['String']['output'];
    /**
     * mode is Optional: mode bits used to set permissions on this file.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * If not specified, the volume defaultMode will be used.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    mode?: Maybe<Scalars['Int']['output']>;
    /**
     * path is the relative path of the file to map the key to.
     * May not be an absolute path.
     * May not contain the path element '..'.
     * May not start with the string '..'.
     */
    path: Scalars['String']['output'];
  };

/** Maps a string key to a path within a volume. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_ConfigMap_Items_Items_Input =
  {
    /** key is the key to project. */
    key: Scalars['String']['input'];
    /**
     * mode is Optional: mode bits used to set permissions on this file.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * If not specified, the volume defaultMode will be used.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    mode?: InputMaybe<Scalars['Int']['input']>;
    /**
     * path is the relative path of the file to map the key to.
     * May not be an absolute path.
     * May not contain the path element '..'.
     * May not start with the string '..'.
     */
    path: Scalars['String']['input'];
  };

/** A persistent disk backed volume. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk =
  {
    /**
     * Specifies a unique device name that is reflected into the
     * `/dev/disk/by-id/datumcloud-*` tree of a Linux operating system
     * running within the instance. This name can be used to reference
     * the device for mounting, resizing, and so on, from within the
     * instance.
     *
     * If not specified, the server chooses a default device name to
     * apply to this disk, in the form persistent-disk-x, where x is a
     * number assigned by Datum Cloud.
     */
    deviceName?: Maybe<Scalars['String']['output']>;
    template: Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template;
  };

/** A persistent disk backed volume. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Input =
  {
    /**
     * Specifies a unique device name that is reflected into the
     * `/dev/disk/by-id/datumcloud-*` tree of a Linux operating system
     * running within the instance. This name can be used to reference
     * the device for mounting, resizing, and so on, from within the
     * instance.
     *
     * If not specified, the server chooses a default device name to
     * apply to this disk, in the form persistent-disk-x, where x is a
     * number assigned by Datum Cloud.
     */
    deviceName?: InputMaybe<Scalars['String']['input']>;
    template: Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Input;
  };

/** Settings to create a new disk for an attached disk */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template =
  {
    metadata?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Metadata>;
    spec: Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec;
  };

/** Settings to create a new disk for an attached disk */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Input =
  {
    metadata?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Metadata_Input>;
    spec: Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Input;
  };

/** Metadata of the disks created from this template */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Metadata =
  {
    annotations?: Maybe<Scalars['JSON']['output']>;
    finalizers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    labels?: Maybe<Scalars['JSON']['output']>;
    name?: Maybe<Scalars['String']['output']>;
    namespace?: Maybe<Scalars['String']['output']>;
  };

/** Metadata of the disks created from this template */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Metadata_Input =
  {
    annotations?: InputMaybe<Scalars['JSON']['input']>;
    finalizers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    labels?: InputMaybe<Scalars['JSON']['input']>;
    name?: InputMaybe<Scalars['String']['input']>;
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/** Describes the desired configuration of a disk */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec =
  {
    populator?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Populator>;
    resources?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Resources>;
    /** The type the disk, such as `pd-standard`. */
    type?: Maybe<Scalars['String']['output']>;
  };

/** Describes the desired configuration of a disk */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Input =
  {
    populator?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Populator_Input>;
    resources?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Resources_Input>;
    /** The type the disk, such as `pd-standard`. */
    type?: InputMaybe<Scalars['String']['input']>;
  };

/** Populator to use while initializing the disk. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Populator =
  {
    filesystem?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Populator_Filesystem>;
    image?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Populator_Image>;
  };

/** Populator to use while initializing the disk. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Populator_Input =
  {
    filesystem?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Populator_Filesystem_Input>;
    image?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Populator_Image_Input>;
  };

/** Populate the disk with a filesystem */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Populator_Filesystem =
  {
    type: Ext4_Const;
  };

/** Populate the disk with a filesystem */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Populator_Filesystem_Input =
  {
    type: Ext4_Const;
  };

/** Populate the disk from an image */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Populator_Image =
  {
    /**
     * The name of the image to populate the disk with.
     *
     * 	in `populator.image.imageRef.name` though.
     */
    name: Scalars['String']['output'];
  };

/** Populate the disk from an image */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Populator_Image_Input =
  {
    /**
     * The name of the image to populate the disk with.
     *
     * 	in `populator.image.imageRef.name` though.
     */
    name: Scalars['String']['input'];
  };

/** The resource requirements for the disk. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Resources =
  {
    /** Requests describes the minimum amount of storage resources required. */
    requests?: Maybe<Scalars['JSON']['output']>;
  };

/** The resource requirements for the disk. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Disk_Template_Spec_Resources_Input =
  {
    /** Requests describes the minimum amount of storage resources required. */
    requests?: InputMaybe<Scalars['JSON']['input']>;
  };

/** A secret that should populate this volume */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Secret =
  {
    /**
     * defaultMode is Optional: mode bits used to set permissions on created files by default.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values
     * for mode bits. Defaults to 0644.
     * Directories within the path are not affected by this setting.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    defaultMode?: Maybe<Scalars['Int']['output']>;
    /**
     * items If unspecified, each key-value pair in the Data field of the referenced
     * Secret will be projected into the volume as a file whose name is the
     * key and content is the value. If specified, the listed keys will be
     * projected into the specified paths, and unlisted keys will not be
     * present. If a key is specified which is not present in the Secret,
     * the volume setup will error unless it is marked optional. Paths must be
     * relative and may not contain the '..' path or start with '..'.
     */
    items?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Secret_Items_Items>
      >
    >;
    /** optional field specify whether the Secret or its keys must be defined */
    optional?: Maybe<Scalars['Boolean']['output']>;
    /**
     * secretName is the name of the secret in the pod's namespace to use.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
     */
    secretName?: Maybe<Scalars['String']['output']>;
  };

/** A secret that should populate this volume */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Secret_Input =
  {
    /**
     * defaultMode is Optional: mode bits used to set permissions on created files by default.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values
     * for mode bits. Defaults to 0644.
     * Directories within the path are not affected by this setting.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    defaultMode?: InputMaybe<Scalars['Int']['input']>;
    /**
     * items If unspecified, each key-value pair in the Data field of the referenced
     * Secret will be projected into the volume as a file whose name is the
     * key and content is the value. If specified, the listed keys will be
     * projected into the specified paths, and unlisted keys will not be
     * present. If a key is specified which is not present in the Secret,
     * the volume setup will error unless it is marked optional. Paths must be
     * relative and may not contain the '..' path or start with '..'.
     */
    items?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Secret_Items_Items_Input>
      >
    >;
    /** optional field specify whether the Secret or its keys must be defined */
    optional?: InputMaybe<Scalars['Boolean']['input']>;
    /**
     * secretName is the name of the secret in the pod's namespace to use.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
     */
    secretName?: InputMaybe<Scalars['String']['input']>;
  };

/** Maps a string key to a path within a volume. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Secret_Items_Items =
  {
    /** key is the key to project. */
    key: Scalars['String']['output'];
    /**
     * mode is Optional: mode bits used to set permissions on this file.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * If not specified, the volume defaultMode will be used.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    mode?: Maybe<Scalars['Int']['output']>;
    /**
     * path is the relative path of the file to map the key to.
     * May not be an absolute path.
     * May not contain the path element '..'.
     * May not start with the string '..'.
     */
    path: Scalars['String']['output'];
  };

/** Maps a string key to a path within a volume. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Spec_Volumes_Items_Secret_Items_Items_Input =
  {
    /** key is the key to project. */
    key: Scalars['String']['input'];
    /**
     * mode is Optional: mode bits used to set permissions on this file.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * If not specified, the volume defaultMode will be used.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    mode?: InputMaybe<Scalars['Int']['input']>;
    /**
     * path is the relative path of the file to map the key to.
     * May not be an absolute path.
     * May not contain the path element '..'.
     * May not start with the string '..'.
     */
    path: Scalars['String']['input'];
  };

/** Status defines the current state of an Instance. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status = {
  /**
   * Represents the observations of an instance's current state.
   * Known condition types are: "Available", "Progressing"
   */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
  controller?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_Controller>;
  /** Network interface information */
  networkInterfaces?: Maybe<
    Array<
      Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_NetworkInterfaces_Items>
    >
  >;
};

/** Status defines the current state of an Instance. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * Represents the observations of an instance's current state.
     * Known condition types are: "Available", "Progressing"
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    controller?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_Controller_Input>;
    /** Network interface information */
    networkInterfaces?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_NetworkInterfaces_Items_Input>
      >
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listComputeDatumapisComV1alphaInstanceForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listComputeDatumapisComV1alphaInstanceForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listComputeDatumapisComV1alphaInstanceForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listComputeDatumapisComV1alphaInstanceForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listComputeDatumapisComV1alphaInstanceForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listComputeDatumapisComV1alphaInstanceForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** Controller contains status information about the controller managing the instance. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_Controller =
  {
    /** ObservedTemplateHash is the hash of the instance template applied for this instance. */
    observedTemplateHash: Scalars['String']['output'];
  };

/** Controller contains status information about the controller managing the instance. */
export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_Controller_Input =
  {
    /** ObservedTemplateHash is the hash of the instance template applied for this instance. */
    observedTemplateHash: Scalars['String']['input'];
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_NetworkInterfaces_Items =
  {
    assignments?: Maybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_NetworkInterfaces_Items_Assignments>;
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_NetworkInterfaces_Items_Input =
  {
    assignments?: InputMaybe<Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_NetworkInterfaces_Items_Assignments_Input>;
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_NetworkInterfaces_Items_Assignments =
  {
    /**
     * The external IP address used for the interface. A one to one NAT will be
     * performed for this address with the interface's network IP.
     */
    externalIP?: Maybe<Scalars['String']['output']>;
    /** The IP address assigned as the primary IP from the attached network. */
    networkIP?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListComputeDatumapisComV1alphaInstanceForAllNamespaces_Items_Items_Status_NetworkInterfaces_Items_Assignments_Input =
  {
    /**
     * The external IP address used for the interface. A one to one NAT will be
     * performed for this address with the interface's network IP.
     */
    externalIP?: InputMaybe<Scalars['String']['input']>;
    /** The IP address assigned as the primary IP from the attached network. */
    networkIP?: InputMaybe<Scalars['String']['input']>;
  };

/** WorkloadDeploymentSpec defines the desired state of WorkloadDeployment */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec = {
  /** deployments can be scheduled in ways other than just a city code. */
  cityCode: Scalars['String']['output'];
  /** The placement in the workload which is driving a deployment */
  placementName: Scalars['String']['output'];
  scaleSettings: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings;
  template: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template;
  workloadRef: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_WorkloadRef;
};

/** WorkloadDeploymentSpec defines the desired state of WorkloadDeployment */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Input =
  {
    /** deployments can be scheduled in ways other than just a city code. */
    cityCode: Scalars['String']['input'];
    /** The placement in the workload which is driving a deployment */
    placementName: Scalars['String']['input'];
    scaleSettings: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings_Input;
    template: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Input;
    workloadRef: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_WorkloadRef_Input;
  };

/** Scale settings such as minimum and maximum replica counts. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings =
  {
    /**
     * Controls how instances are managed during scale up and down, as well as
     * during maintenance events.
     */
    instanceManagementPolicy: Scalars['String']['output'];
    /** The maximum number of replicas. */
    maxReplicas?: Maybe<Scalars['Int']['output']>;
    /** A list of metrics that determine scaling behavior, such as external metrics. */
    metrics?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings_Metrics_Items>
      >
    >;
    /** The minimum number of replicas. */
    minReplicas: Scalars['Int']['output'];
  };

/** Scale settings such as minimum and maximum replica counts. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings_Input =
  {
    /**
     * Controls how instances are managed during scale up and down, as well as
     * during maintenance events.
     */
    instanceManagementPolicy?: Scalars['String']['input'];
    /** The maximum number of replicas. */
    maxReplicas?: InputMaybe<Scalars['Int']['input']>;
    /** A list of metrics that determine scaling behavior, such as external metrics. */
    metrics?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings_Metrics_Items_Input>
      >
    >;
    /** The minimum number of replicas. */
    minReplicas: Scalars['Int']['input'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings_Metrics_Items =
  {
    resource?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings_Metrics_Items_Resource>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings_Metrics_Items_Input =
  {
    resource?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings_Metrics_Items_Resource_Input>;
  };

/** Resource metrics known to Datum. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings_Metrics_Items_Resource =
  {
    /** The name of the resource in question. */
    name: Scalars['String']['output'];
    target: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings_Metrics_Items_Resource_Target;
  };

/** Resource metrics known to Datum. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings_Metrics_Items_Resource_Input =
  {
    /** The name of the resource in question. */
    name: Scalars['String']['input'];
    target: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings_Metrics_Items_Resource_Target_Input;
  };

/** The target value for the given metric */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings_Metrics_Items_Resource_Target =
  {
    /**
     * The target value of the average of the
     * resource metric across all relevant instances, represented as a percentage of
     * the requested value of the resource for the instances.
     */
    averageUtilization?: Maybe<Scalars['Int']['output']>;
    averageValue?: Maybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_spec_scaleSettings_metrics_items_resource_target_averageValue']['output']
    >;
    value?: Maybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_spec_scaleSettings_metrics_items_resource_target_value']['output']
    >;
  };

/** The target value for the given metric */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_ScaleSettings_Metrics_Items_Resource_Target_Input =
  {
    /**
     * The target value of the average of the
     * resource metric across all relevant instances, represented as a percentage of
     * the requested value of the resource for the instances.
     */
    averageUtilization?: InputMaybe<Scalars['Int']['input']>;
    averageValue?: InputMaybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_spec_scaleSettings_metrics_items_resource_target_averageValue']['input']
    >;
    value?: InputMaybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_spec_scaleSettings_metrics_items_resource_target_value']['input']
    >;
  };

/** Defines settings for each instance. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template =
  {
    metadata?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Metadata>;
    spec: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec;
  };

/** Defines settings for each instance. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Input =
  {
    metadata?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Metadata_Input>;
    spec: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Input;
  };

/** Metadata of the instances created from this template */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Metadata =
  {
    annotations?: Maybe<Scalars['JSON']['output']>;
    finalizers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    labels?: Maybe<Scalars['JSON']['output']>;
    name?: Maybe<Scalars['String']['output']>;
    namespace?: Maybe<Scalars['String']['output']>;
  };

/** Metadata of the instances created from this template */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Metadata_Input =
  {
    annotations?: InputMaybe<Scalars['JSON']['input']>;
    finalizers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    labels?: InputMaybe<Scalars['JSON']['input']>;
    name?: InputMaybe<Scalars['String']['input']>;
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/** Describes the desired configuration of an instance */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec =
  {
    controller?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Controller>;
    location?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Location>;
    /** Network interface configuration. */
    networkInterfaces: Array<
      Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items>
    >;
    runtime: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime;
    /**
     * Volumes that must be available to attach to an instance's containers or
     * Virtual Machine.
     */
    volumes?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items>
      >
    >;
  };

/** Describes the desired configuration of an instance */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Input =
  {
    controller?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Controller_Input>;
    location?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Location_Input>;
    /** Network interface configuration. */
    networkInterfaces: Array<
      InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_Input>
    >;
    runtime: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Input;
    /**
     * Volumes that must be available to attach to an instance's containers or
     * Virtual Machine.
     */
    volumes?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Input>
      >
    >;
  };

/** Controller contains settings driven by the controller managing the instance. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Controller =
  {
    /**
     * SchedulingGates is a list of gates that must be satisfied before the
     * instance can be scheduled.
     */
    schedulingGates?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Controller_SchedulingGates_Items>
      >
    >;
    /** TemplateHash is the hash of the instance template applied for this instance. */
    templateHash: Scalars['String']['output'];
  };

/** Controller contains settings driven by the controller managing the instance. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Controller_Input =
  {
    /**
     * SchedulingGates is a list of gates that must be satisfied before the
     * instance can be scheduled.
     */
    schedulingGates?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Controller_SchedulingGates_Items_Input>
      >
    >;
    /** TemplateHash is the hash of the instance template applied for this instance. */
    templateHash: Scalars['String']['input'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Controller_SchedulingGates_Items =
  {
    /** The name of the gate. */
    name: Scalars['String']['output'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Controller_SchedulingGates_Items_Input =
  {
    /** The name of the gate. */
    name: Scalars['String']['input'];
  };

/** The location which the instance has been scheduled to */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Location =
  {
    /** Name of a datum location */
    name: Scalars['String']['output'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['output'];
  };

/** The location which the instance has been scheduled to */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Location_Input =
  {
    /** Name of a datum location */
    name: Scalars['String']['input'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['input'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items =
  {
    network: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_Network;
    networkPolicy?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_Input =
  {
    network: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_Network_Input;
    networkPolicy?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Input>;
  };

/** The network to attach the network interface to. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_Network =
  {
    /** The network name */
    name: Scalars['String']['output'];
    /**
     * The network namespace.
     *
     * Defaults to the namespace for the type the reference is embedded in.
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/**
 * Interface specific network policy.
 *
 * If provided, this will result in a platform managed network policy being
 * created that targets the specfiic instance interface. This network policy
 * will be of the lowest priority, and can effectively be prohibited from
 * influencing network connectivity.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy =
  {
    ingress?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items>
      >
    >;
  };

/**
 * Interface specific network policy.
 *
 * If provided, this will result in a platform managed network policy being
 * created that targets the specfiic instance interface. This network policy
 * will be of the lowest priority, and can effectively be prohibited from
 * influencing network connectivity.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Input =
  {
    ingress?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Input>
      >
    >;
  };

/** See k8s network policy types for inspiration here */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items =
  {
    /**
     * from is a list of sources which should be able to access the instances selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all sources (traffic not restricted by
     * source). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the from list.
     */
    from?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items>
      >
    >;
    /**
     * ports is a list of ports which should be made accessible on the instances selected for
     * this rule. Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     */
    ports?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items>
      >
    >;
  };

/** See k8s network policy types for inspiration here */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Input =
  {
    /**
     * from is a list of sources which should be able to access the instances selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all sources (traffic not restricted by
     * source). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the from list.
     */
    from?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_Input>
      >
    >;
    /**
     * ports is a list of ports which should be made accessible on the instances selected for
     * this rule. Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     */
    ports?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items_Input>
      >
    >;
  };

/**
 * NetworkPolicyPeer describes a peer to allow traffic to/from. Only certain combinations of
 * fields are allowed
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items =
  {
    ipBlock?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_IpBlock>;
  };

/**
 * NetworkPolicyPeer describes a peer to allow traffic to/from. Only certain combinations of
 * fields are allowed
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_Input =
  {
    ipBlock?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_IpBlock_Input>;
  };

/**
 * ipBlock defines policy on a particular IPBlock. If this field is set then
 * neither of the other fields can be.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_IpBlock =
  {
    /**
     * cidr is a string representing the IPBlock
     * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
     */
    cidr: Scalars['String']['output'];
    /**
     * except is a slice of CIDRs that should not be included within an IPBlock
     * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
     * Except values will be rejected if they are outside the cidr range
     */
    except?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  };

/**
 * ipBlock defines policy on a particular IPBlock. If this field is set then
 * neither of the other fields can be.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_IpBlock_Input =
  {
    /**
     * cidr is a string representing the IPBlock
     * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
     */
    cidr: Scalars['String']['input'];
    /**
     * except is a slice of CIDRs that should not be included within an IPBlock
     * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
     * Except values will be rejected if they are outside the cidr range
     */
    except?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  };

/** NetworkPolicyPort describes a port to allow traffic on */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items =
  {
    /**
     * endPort indicates that the range of ports from port to endPort if set, inclusive,
     * should be allowed by the policy. This field cannot be defined if the port field
     * is not defined or if the port field is defined as a named (string) port.
     * The endPort must be equal or greater than port.
     */
    endPort?: Maybe<Scalars['Int']['output']>;
    /**
     * port represents the port on the given protocol. This can either be a numerical or named
     * port on an instance. If this field is not provided, this matches all port names and
     * numbers.
     * If present, only traffic on the specified protocol AND port will be matched.
     */
    port?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items_Port>;
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: Maybe<Scalars['String']['output']>;
  };

/** NetworkPolicyPort describes a port to allow traffic on */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items_Input =
  {
    /**
     * endPort indicates that the range of ports from port to endPort if set, inclusive,
     * should be allowed by the policy. This field cannot be defined if the port field
     * is not defined or if the port field is defined as a named (string) port.
     * The endPort must be equal or greater than port.
     */
    endPort?: InputMaybe<Scalars['Int']['input']>;
    /**
     * port represents the port on the given protocol. This can either be a numerical or named
     * port on an instance. If this field is not provided, this matches all port names and
     * numbers.
     * If present, only traffic on the specified protocol AND port will be matched.
     */
    port?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * port represents the port on the given protocol. This can either be a numerical or named
 * port on an instance. If this field is not provided, this matches all port names and
 * numbers.
 * If present, only traffic on the specified protocol AND port will be matched.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items_Port =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
  };

/** The network to attach the network interface to. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_Network_Input =
  {
    /** The network name */
    name: Scalars['String']['input'];
    /**
     * The network namespace.
     *
     * Defaults to the namespace for the type the reference is embedded in.
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/** The runtime type of the instance, such as a container sandbox or a VM. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime =
  {
    resources: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Resources;
    sandbox?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox>;
    virtualMachine?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine>;
  };

/** The runtime type of the instance, such as a container sandbox or a VM. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Input =
  {
    resources: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Resources_Input;
    sandbox?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Input>;
    virtualMachine?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_Input>;
  };

/**
 * Resources each instance must be allocated.
 *
 * A sandbox runtime's containers may specify resource requests and
 * limits. When limits are defined on all containers, they MUST consume
 * the entire amount of resources defined here. Some resources, such
 * as a GPU, MUST have at least one container request them so that the
 * device can be presented appropriately.
 *
 * A virtual machine runtime will be provided all requested resources.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Resources =
  {
    /**
     * Full or partial URL of the instance type resource to use for this instance.
     *
     * For example: `datumcloud/d1-standard-2`
     *
     * May be combined with `resources` to allow for custom instance types for
     * instance families that support customization. Instance types which support
     * customization will appear in the form `<project>/<instanceFamily>-custom`.
     */
    instanceType: Scalars['String']['output'];
    /** Describes adjustments to the resources defined by the instance type. */
    requests?: Maybe<Scalars['JSON']['output']>;
  };

/**
 * Resources each instance must be allocated.
 *
 * A sandbox runtime's containers may specify resource requests and
 * limits. When limits are defined on all containers, they MUST consume
 * the entire amount of resources defined here. Some resources, such
 * as a GPU, MUST have at least one container request them so that the
 * device can be presented appropriately.
 *
 * A virtual machine runtime will be provided all requested resources.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Resources_Input =
  {
    /**
     * Full or partial URL of the instance type resource to use for this instance.
     *
     * For example: `datumcloud/d1-standard-2`
     *
     * May be combined with `resources` to allow for custom instance types for
     * instance families that support customization. Instance types which support
     * customization will appear in the form `<project>/<instanceFamily>-custom`.
     */
    instanceType: Scalars['String']['input'];
    /** Describes adjustments to the resources defined by the instance type. */
    requests?: InputMaybe<Scalars['JSON']['input']>;
  };

/** A sandbox is a managed isolated environment capable of running containers. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox =
  {
    /** A list of containers to run within the sandbox. */
    containers: Array<
      Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items>
    >;
    /**
     * An optional list of secrets in the same namespace to use for pulling images
     * used by the instance.
     */
    imagePullSecrets?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_ImagePullSecrets_Items>
      >
    >;
  };

/** A sandbox is a managed isolated environment capable of running containers. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Input =
  {
    /** A list of containers to run within the sandbox. */
    containers: Array<
      InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Input>
    >;
    /**
     * An optional list of secrets in the same namespace to use for pulling images
     * used by the instance.
     */
    imagePullSecrets?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_ImagePullSecrets_Items_Input>
      >
    >;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items =
  {
    /**
     * List of environment variables to set in the container.
     *
     * so replicate the structure here too.
     */
    env?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items>
      >
    >;
    /** The fully qualified container image name. */
    image: Scalars['String']['output'];
    /** The name of the container. */
    name: Scalars['String']['output'];
    /** A list of named ports for the container. */
    ports?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Ports_Items>
      >
    >;
    resources?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Resources>;
    /** A list of volumes to attach to the container. */
    volumeAttachments?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_VolumeAttachments_Items>
      >
    >;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Input =
  {
    /**
     * List of environment variables to set in the container.
     *
     * so replicate the structure here too.
     */
    env?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_Input>
      >
    >;
    /** The fully qualified container image name. */
    image: Scalars['String']['input'];
    /** The name of the container. */
    name: Scalars['String']['input'];
    /** A list of named ports for the container. */
    ports?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Ports_Items_Input>
      >
    >;
    resources?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Resources_Input>;
    /** A list of volumes to attach to the container. */
    volumeAttachments?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_VolumeAttachments_Items_Input>
      >
    >;
  };

/** EnvVar represents an environment variable present in a Container. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items =
  {
    /** Name of the environment variable. Must be a C_IDENTIFIER. */
    name: Scalars['String']['output'];
    /**
     * Variable references $(VAR_NAME) are expanded
     * using the previously defined environment variables in the container and
     * any service environment variables. If a variable cannot be resolved,
     * the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
     * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
     * Escaped references will never be expanded, regardless of whether the variable
     * exists or not.
     * Defaults to "".
     */
    value?: Maybe<Scalars['String']['output']>;
    valueFrom?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom>;
  };

/** EnvVar represents an environment variable present in a Container. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_Input =
  {
    /** Name of the environment variable. Must be a C_IDENTIFIER. */
    name: Scalars['String']['input'];
    /**
     * Variable references $(VAR_NAME) are expanded
     * using the previously defined environment variables in the container and
     * any service environment variables. If a variable cannot be resolved,
     * the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
     * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
     * Escaped references will never be expanded, regardless of whether the variable
     * exists or not.
     * Defaults to "".
     */
    value?: InputMaybe<Scalars['String']['input']>;
    valueFrom?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_Input>;
  };

/** Source for the environment variable's value. Cannot be used if value is not empty. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom =
  {
    configMapKeyRef?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ConfigMapKeyRef>;
    fieldRef?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_FieldRef>;
    resourceFieldRef?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ResourceFieldRef>;
    secretKeyRef?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_SecretKeyRef>;
  };

/** Source for the environment variable's value. Cannot be used if value is not empty. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_Input =
  {
    configMapKeyRef?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ConfigMapKeyRef_Input>;
    fieldRef?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_FieldRef_Input>;
    resourceFieldRef?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ResourceFieldRef_Input>;
    secretKeyRef?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_SecretKeyRef_Input>;
  };

/** Selects a key of a ConfigMap. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ConfigMapKeyRef =
  {
    /** The key to select. */
    key: Scalars['String']['output'];
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: Maybe<Scalars['String']['output']>;
    /** Specify whether the ConfigMap or its key must be defined */
    optional?: Maybe<Scalars['Boolean']['output']>;
  };

/** Selects a key of a ConfigMap. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ConfigMapKeyRef_Input =
  {
    /** The key to select. */
    key: Scalars['String']['input'];
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: InputMaybe<Scalars['String']['input']>;
    /** Specify whether the ConfigMap or its key must be defined */
    optional?: InputMaybe<Scalars['Boolean']['input']>;
  };

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_FieldRef =
  {
    /** Version of the schema the FieldPath is written in terms of, defaults to "v1". */
    apiVersion?: Maybe<Scalars['String']['output']>;
    /** Path of the field to select in the specified API version. */
    fieldPath: Scalars['String']['output'];
  };

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_FieldRef_Input =
  {
    /** Version of the schema the FieldPath is written in terms of, defaults to "v1". */
    apiVersion?: InputMaybe<Scalars['String']['input']>;
    /** Path of the field to select in the specified API version. */
    fieldPath: Scalars['String']['input'];
  };

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ResourceFieldRef =
  {
    /** Container name: required for volumes, optional for env vars */
    containerName?: Maybe<Scalars['String']['output']>;
    divisor?: Maybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_spec_template_spec_runtime_sandbox_containers_items_env_items_valueFrom_resourceFieldRef_divisor']['output']
    >;
    /** Required: resource to select */
    resource: Scalars['String']['output'];
  };

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ResourceFieldRef_Input =
  {
    /** Container name: required for volumes, optional for env vars */
    containerName?: InputMaybe<Scalars['String']['input']>;
    divisor?: InputMaybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_spec_template_spec_runtime_sandbox_containers_items_env_items_valueFrom_resourceFieldRef_divisor']['input']
    >;
    /** Required: resource to select */
    resource: Scalars['String']['input'];
  };

/** Selects a key of a secret in the pod's namespace */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_SecretKeyRef =
  {
    /** The key of the secret to select from.  Must be a valid secret key. */
    key: Scalars['String']['output'];
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: Maybe<Scalars['String']['output']>;
    /** Specify whether the Secret or its key must be defined */
    optional?: Maybe<Scalars['Boolean']['output']>;
  };

/** Selects a key of a secret in the pod's namespace */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_SecretKeyRef_Input =
  {
    /** The key of the secret to select from.  Must be a valid secret key. */
    key: Scalars['String']['input'];
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: InputMaybe<Scalars['String']['input']>;
    /** Specify whether the Secret or its key must be defined */
    optional?: InputMaybe<Scalars['Boolean']['input']>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Ports_Items =
  {
    /** The name of the port that can be referenced by other platform features. */
    name: Scalars['String']['output'];
    /** The port number, which can be a value between 1 and 65535. */
    port: Scalars['Int']['output'];
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Ports_Items_Input =
  {
    /** The name of the port that can be referenced by other platform features. */
    name: Scalars['String']['input'];
    /** The port number, which can be a value between 1 and 65535. */
    port: Scalars['Int']['input'];
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: InputMaybe<Scalars['String']['input']>;
  };

/** The resource requirements for the container, such as CPU, memory, and GPUs. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Resources =
  {
    /** Limits describes the maximum amount of compute resources allowed. */
    limits?: Maybe<Scalars['JSON']['output']>;
    /** Requests describes the minimum amount of compute resources required. */
    requests?: Maybe<Scalars['JSON']['output']>;
  };

/** The resource requirements for the container, such as CPU, memory, and GPUs. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Resources_Input =
  {
    /** Limits describes the maximum amount of compute resources allowed. */
    limits?: InputMaybe<Scalars['JSON']['input']>;
    /** Requests describes the minimum amount of compute resources required. */
    requests?: InputMaybe<Scalars['JSON']['input']>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_VolumeAttachments_Items =
  {
    /**
     * The path to mount the volume inside the guest OS.
     *
     * The referenced volume must be populated with a filesystem to use this
     * feature.
     *
     * For VM based instances, this functionality requires certain capabilities
     * to be annotated on the boot image, such as cloud-init.
     */
    mountPath?: Maybe<Scalars['String']['output']>;
    /** The name of the volume to attach as defined in InstanceSpec.Volumes. */
    name: Scalars['String']['output'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_VolumeAttachments_Items_Input =
  {
    /**
     * The path to mount the volume inside the guest OS.
     *
     * The referenced volume must be populated with a filesystem to use this
     * feature.
     *
     * For VM based instances, this functionality requires certain capabilities
     * to be annotated on the boot image, such as cloud-init.
     */
    mountPath?: InputMaybe<Scalars['String']['input']>;
    /** The name of the volume to attach as defined in InstanceSpec.Volumes. */
    name: Scalars['String']['input'];
  };

/**
 * References a secret in the same namespace as the entity defining the
 * reference.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_ImagePullSecrets_Items =
  {
    /** The name of the secret */
    name: Scalars['String']['output'];
  };

/**
 * References a secret in the same namespace as the entity defining the
 * reference.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_Sandbox_ImagePullSecrets_Items_Input =
  {
    /** The name of the secret */
    name: Scalars['String']['input'];
  };

/** A virtual machine is a classical VM environment, booting a full OS provided by the user via an image. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine =
  {
    /** A list of named ports for the virtual machine. */
    ports?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_Ports_Items>
      >
    >;
    /** A list of volumes to attach to the VM. */
    volumeAttachments: Array<
      Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_VolumeAttachments_Items>
    >;
  };

/** A virtual machine is a classical VM environment, booting a full OS provided by the user via an image. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_Input =
  {
    /** A list of named ports for the virtual machine. */
    ports?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_Ports_Items_Input>
      >
    >;
    /** A list of volumes to attach to the VM. */
    volumeAttachments: Array<
      InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_VolumeAttachments_Items_Input>
    >;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_Ports_Items =
  {
    /** The name of the port that can be referenced by other platform features. */
    name: Scalars['String']['output'];
    /** The port number, which can be a value between 1 and 65535. */
    port: Scalars['Int']['output'];
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_Ports_Items_Input =
  {
    /** The name of the port that can be referenced by other platform features. */
    name: Scalars['String']['input'];
    /** The port number, which can be a value between 1 and 65535. */
    port: Scalars['Int']['input'];
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: InputMaybe<Scalars['String']['input']>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_VolumeAttachments_Items =
  {
    /**
     * The path to mount the volume inside the guest OS.
     *
     * The referenced volume must be populated with a filesystem to use this
     * feature.
     *
     * For VM based instances, this functionality requires certain capabilities
     * to be annotated on the boot image, such as cloud-init.
     */
    mountPath?: Maybe<Scalars['String']['output']>;
    /** The name of the volume to attach as defined in InstanceSpec.Volumes. */
    name: Scalars['String']['output'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_VolumeAttachments_Items_Input =
  {
    /**
     * The path to mount the volume inside the guest OS.
     *
     * The referenced volume must be populated with a filesystem to use this
     * feature.
     *
     * For VM based instances, this functionality requires certain capabilities
     * to be annotated on the boot image, such as cloud-init.
     */
    mountPath?: InputMaybe<Scalars['String']['input']>;
    /** The name of the volume to attach as defined in InstanceSpec.Volumes. */
    name: Scalars['String']['input'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items =
  {
    configMap?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap>;
    disk?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk>;
    /**
     * Name is used to reference the volume in `volumeAttachments` for
     * containers and VMs, and will be used to derive the platform resource
     * name when required by prefixing this name with the instance name upon
     * creation.
     */
    name: Scalars['String']['output'];
    secret?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Secret>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Input =
  {
    configMap?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap_Input>;
    disk?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Input>;
    /**
     * Name is used to reference the volume in `volumeAttachments` for
     * containers and VMs, and will be used to derive the platform resource
     * name when required by prefixing this name with the instance name upon
     * creation.
     */
    name: Scalars['String']['input'];
    secret?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Secret_Input>;
  };

/** A configMap that should populate this volume */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap =
  {
    /**
     * defaultMode is optional: mode bits used to set permissions on created files by default.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * Defaults to 0644.
     * Directories within the path are not affected by this setting.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    defaultMode?: Maybe<Scalars['Int']['output']>;
    /**
     * items if unspecified, each key-value pair in the Data field of the referenced
     * ConfigMap will be projected into the volume as a file whose name is the
     * key and content is the value. If specified, the listed keys will be
     * projected into the specified paths, and unlisted keys will not be
     * present. If a key is specified which is not present in the ConfigMap,
     * the volume setup will error unless it is marked optional. Paths must be
     * relative and may not contain the '..' path or start with '..'.
     */
    items?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap_Items_Items>
      >
    >;
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: Maybe<Scalars['String']['output']>;
    /** optional specify whether the ConfigMap or its keys must be defined */
    optional?: Maybe<Scalars['Boolean']['output']>;
  };

/** A configMap that should populate this volume */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap_Input =
  {
    /**
     * defaultMode is optional: mode bits used to set permissions on created files by default.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * Defaults to 0644.
     * Directories within the path are not affected by this setting.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    defaultMode?: InputMaybe<Scalars['Int']['input']>;
    /**
     * items if unspecified, each key-value pair in the Data field of the referenced
     * ConfigMap will be projected into the volume as a file whose name is the
     * key and content is the value. If specified, the listed keys will be
     * projected into the specified paths, and unlisted keys will not be
     * present. If a key is specified which is not present in the ConfigMap,
     * the volume setup will error unless it is marked optional. Paths must be
     * relative and may not contain the '..' path or start with '..'.
     */
    items?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap_Items_Items_Input>
      >
    >;
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: InputMaybe<Scalars['String']['input']>;
    /** optional specify whether the ConfigMap or its keys must be defined */
    optional?: InputMaybe<Scalars['Boolean']['input']>;
  };

/** Maps a string key to a path within a volume. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap_Items_Items =
  {
    /** key is the key to project. */
    key: Scalars['String']['output'];
    /**
     * mode is Optional: mode bits used to set permissions on this file.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * If not specified, the volume defaultMode will be used.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    mode?: Maybe<Scalars['Int']['output']>;
    /**
     * path is the relative path of the file to map the key to.
     * May not be an absolute path.
     * May not contain the path element '..'.
     * May not start with the string '..'.
     */
    path: Scalars['String']['output'];
  };

/** Maps a string key to a path within a volume. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap_Items_Items_Input =
  {
    /** key is the key to project. */
    key: Scalars['String']['input'];
    /**
     * mode is Optional: mode bits used to set permissions on this file.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * If not specified, the volume defaultMode will be used.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    mode?: InputMaybe<Scalars['Int']['input']>;
    /**
     * path is the relative path of the file to map the key to.
     * May not be an absolute path.
     * May not contain the path element '..'.
     * May not start with the string '..'.
     */
    path: Scalars['String']['input'];
  };

/** A persistent disk backed volume. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk =
  {
    /**
     * Specifies a unique device name that is reflected into the
     * `/dev/disk/by-id/datumcloud-*` tree of a Linux operating system
     * running within the instance. This name can be used to reference
     * the device for mounting, resizing, and so on, from within the
     * instance.
     *
     * If not specified, the server chooses a default device name to
     * apply to this disk, in the form persistent-disk-x, where x is a
     * number assigned by Datum Cloud.
     */
    deviceName?: Maybe<Scalars['String']['output']>;
    template: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template;
  };

/** A persistent disk backed volume. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Input =
  {
    /**
     * Specifies a unique device name that is reflected into the
     * `/dev/disk/by-id/datumcloud-*` tree of a Linux operating system
     * running within the instance. This name can be used to reference
     * the device for mounting, resizing, and so on, from within the
     * instance.
     *
     * If not specified, the server chooses a default device name to
     * apply to this disk, in the form persistent-disk-x, where x is a
     * number assigned by Datum Cloud.
     */
    deviceName?: InputMaybe<Scalars['String']['input']>;
    template: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Input;
  };

/** Settings to create a new disk for an attached disk */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template =
  {
    metadata?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Metadata>;
    spec: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec;
  };

/** Settings to create a new disk for an attached disk */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Input =
  {
    metadata?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Metadata_Input>;
    spec: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Input;
  };

/** Metadata of the disks created from this template */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Metadata =
  {
    annotations?: Maybe<Scalars['JSON']['output']>;
    finalizers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    labels?: Maybe<Scalars['JSON']['output']>;
    name?: Maybe<Scalars['String']['output']>;
    namespace?: Maybe<Scalars['String']['output']>;
  };

/** Metadata of the disks created from this template */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Metadata_Input =
  {
    annotations?: InputMaybe<Scalars['JSON']['input']>;
    finalizers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    labels?: InputMaybe<Scalars['JSON']['input']>;
    name?: InputMaybe<Scalars['String']['input']>;
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/** Describes the desired configuration of a disk */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec =
  {
    populator?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator>;
    resources?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Resources>;
    /** The type the disk, such as `pd-standard`. */
    type?: Maybe<Scalars['String']['output']>;
  };

/** Describes the desired configuration of a disk */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Input =
  {
    populator?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Input>;
    resources?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Resources_Input>;
    /** The type the disk, such as `pd-standard`. */
    type?: InputMaybe<Scalars['String']['input']>;
  };

/** Populator to use while initializing the disk. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator =
  {
    filesystem?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Filesystem>;
    image?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Image>;
  };

/** Populator to use while initializing the disk. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Input =
  {
    filesystem?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Filesystem_Input>;
    image?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Image_Input>;
  };

/** Populate the disk with a filesystem */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Filesystem =
  {
    type: Ext4_Const;
  };

/** Populate the disk with a filesystem */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Filesystem_Input =
  {
    type: Ext4_Const;
  };

/** Populate the disk from an image */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Image =
  {
    /**
     * The name of the image to populate the disk with.
     *
     * 	in `populator.image.imageRef.name` though.
     */
    name: Scalars['String']['output'];
  };

/** Populate the disk from an image */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Image_Input =
  {
    /**
     * The name of the image to populate the disk with.
     *
     * 	in `populator.image.imageRef.name` though.
     */
    name: Scalars['String']['input'];
  };

/** The resource requirements for the disk. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Resources =
  {
    /** Requests describes the minimum amount of storage resources required. */
    requests?: Maybe<Scalars['JSON']['output']>;
  };

/** The resource requirements for the disk. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Resources_Input =
  {
    /** Requests describes the minimum amount of storage resources required. */
    requests?: InputMaybe<Scalars['JSON']['input']>;
  };

/** A secret that should populate this volume */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Secret =
  {
    /**
     * defaultMode is Optional: mode bits used to set permissions on created files by default.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values
     * for mode bits. Defaults to 0644.
     * Directories within the path are not affected by this setting.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    defaultMode?: Maybe<Scalars['Int']['output']>;
    /**
     * items If unspecified, each key-value pair in the Data field of the referenced
     * Secret will be projected into the volume as a file whose name is the
     * key and content is the value. If specified, the listed keys will be
     * projected into the specified paths, and unlisted keys will not be
     * present. If a key is specified which is not present in the Secret,
     * the volume setup will error unless it is marked optional. Paths must be
     * relative and may not contain the '..' path or start with '..'.
     */
    items?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Secret_Items_Items>
      >
    >;
    /** optional field specify whether the Secret or its keys must be defined */
    optional?: Maybe<Scalars['Boolean']['output']>;
    /**
     * secretName is the name of the secret in the pod's namespace to use.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
     */
    secretName?: Maybe<Scalars['String']['output']>;
  };

/** A secret that should populate this volume */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Secret_Input =
  {
    /**
     * defaultMode is Optional: mode bits used to set permissions on created files by default.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values
     * for mode bits. Defaults to 0644.
     * Directories within the path are not affected by this setting.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    defaultMode?: InputMaybe<Scalars['Int']['input']>;
    /**
     * items If unspecified, each key-value pair in the Data field of the referenced
     * Secret will be projected into the volume as a file whose name is the
     * key and content is the value. If specified, the listed keys will be
     * projected into the specified paths, and unlisted keys will not be
     * present. If a key is specified which is not present in the Secret,
     * the volume setup will error unless it is marked optional. Paths must be
     * relative and may not contain the '..' path or start with '..'.
     */
    items?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Secret_Items_Items_Input>
      >
    >;
    /** optional field specify whether the Secret or its keys must be defined */
    optional?: InputMaybe<Scalars['Boolean']['input']>;
    /**
     * secretName is the name of the secret in the pod's namespace to use.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
     */
    secretName?: InputMaybe<Scalars['String']['input']>;
  };

/** Maps a string key to a path within a volume. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Secret_Items_Items =
  {
    /** key is the key to project. */
    key: Scalars['String']['output'];
    /**
     * mode is Optional: mode bits used to set permissions on this file.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * If not specified, the volume defaultMode will be used.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    mode?: Maybe<Scalars['Int']['output']>;
    /**
     * path is the relative path of the file to map the key to.
     * May not be an absolute path.
     * May not contain the path element '..'.
     * May not start with the string '..'.
     */
    path: Scalars['String']['output'];
  };

/** Maps a string key to a path within a volume. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_Template_Spec_Volumes_Items_Secret_Items_Items_Input =
  {
    /** key is the key to project. */
    key: Scalars['String']['input'];
    /**
     * mode is Optional: mode bits used to set permissions on this file.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * If not specified, the volume defaultMode will be used.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    mode?: InputMaybe<Scalars['Int']['input']>;
    /**
     * path is the relative path of the file to map the key to.
     * May not be an absolute path.
     * May not contain the path element '..'.
     * May not start with the string '..'.
     */
    path: Scalars['String']['input'];
  };

/** The workload that a deployment belongs to */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_WorkloadRef =
  {
    /** The name of the workload */
    name: Scalars['String']['output'];
    /** UID of the Workload */
    uid: Scalars['String']['output'];
  };

/** The workload that a deployment belongs to */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Spec_WorkloadRef_Input =
  {
    /** The name of the workload */
    name: Scalars['String']['input'];
    /** UID of the Workload */
    uid: Scalars['String']['input'];
  };

/** WorkloadDeploymentStatus defines the observed state of WorkloadDeployment */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status = {
  /**
   * Represents the observations of a deployment's current state.
   * Known condition types are: "Available", "Progressing"
   */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status_Conditions_Items>
    >
  >;
  /** The number of instances which have the latest workload settings applied. */
  currentReplicas: Scalars['Int']['output'];
  /** The desired number of instances */
  desiredReplicas: Scalars['Int']['output'];
  location?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status_Location>;
  /** The number of instances which are ready. */
  readyReplicas: Scalars['Int']['output'];
  /** The number of instances created */
  replicas: Scalars['Int']['output'];
};

/** WorkloadDeploymentStatus defines the observed state of WorkloadDeployment */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status_Input =
  {
    /**
     * Represents the observations of a deployment's current state.
     * Known condition types are: "Available", "Progressing"
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /** The number of instances which have the latest workload settings applied. */
    currentReplicas: Scalars['Int']['input'];
    /** The desired number of instances */
    desiredReplicas: Scalars['Int']['input'];
    location?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status_Location_Input>;
    /** The number of instances which are ready. */
    readyReplicas: Scalars['Int']['input'];
    /** The number of instances created */
    replicas: Scalars['Int']['input'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_status_conditions_items_reason']['output'];
    status: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_status_conditions_items_reason']['input'];
    status: Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkloadDeployment_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** The location which the deployment has been scheduled to */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status_Location =
  {
    /** Name of a datum location */
    name: Scalars['String']['output'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['output'];
  };

/** The location which the deployment has been scheduled to */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkloadDeployment_Items_Items_Status_Location_Input =
  {
    /** Name of a datum location */
    name: Scalars['String']['input'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['input'];
  };

/** WorkloadSpec defines the desired state of Workload */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec = {
  /**
   * Defines where instances should be deployed, and at what scope a deployment
   * will live in, such as in a city, or region.
   */
  placements: Array<
    Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items>
  >;
  template: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template;
};

/** WorkloadSpec defines the desired state of Workload */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Input = {
  /**
   * Defines where instances should be deployed, and at what scope a deployment
   * will live in, such as in a city, or region.
   */
  placements: Array<
    InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_Input>
  >;
  template: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Input;
};

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items =
  {
    /** A list of city codes that define where the instances should be deployed. */
    cityCodes: Array<Maybe<Scalars['String']['output']>>;
    /** The name of the placement */
    name: Scalars['String']['output'];
    scaleSettings: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_Input =
  {
    /** A list of city codes that define where the instances should be deployed. */
    cityCodes: Array<InputMaybe<Scalars['String']['input']>>;
    /** The name of the placement */
    name: Scalars['String']['input'];
    scaleSettings: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings_Input;
  };

/** Scale settings such as minimum and maximum replica counts. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings =
  {
    /**
     * Controls how instances are managed during scale up and down, as well as
     * during maintenance events.
     */
    instanceManagementPolicy: Scalars['String']['output'];
    /** The maximum number of replicas. */
    maxReplicas?: Maybe<Scalars['Int']['output']>;
    /** A list of metrics that determine scaling behavior, such as external metrics. */
    metrics?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings_Metrics_Items>
      >
    >;
    /** The minimum number of replicas. */
    minReplicas: Scalars['Int']['output'];
  };

/** Scale settings such as minimum and maximum replica counts. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings_Input =
  {
    /**
     * Controls how instances are managed during scale up and down, as well as
     * during maintenance events.
     */
    instanceManagementPolicy?: Scalars['String']['input'];
    /** The maximum number of replicas. */
    maxReplicas?: InputMaybe<Scalars['Int']['input']>;
    /** A list of metrics that determine scaling behavior, such as external metrics. */
    metrics?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings_Metrics_Items_Input>
      >
    >;
    /** The minimum number of replicas. */
    minReplicas: Scalars['Int']['input'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings_Metrics_Items =
  {
    resource?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings_Metrics_Items_Resource>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings_Metrics_Items_Input =
  {
    resource?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings_Metrics_Items_Resource_Input>;
  };

/** Resource metrics known to Datum. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings_Metrics_Items_Resource =
  {
    /** The name of the resource in question. */
    name: Scalars['String']['output'];
    target: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings_Metrics_Items_Resource_Target;
  };

/** Resource metrics known to Datum. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings_Metrics_Items_Resource_Input =
  {
    /** The name of the resource in question. */
    name: Scalars['String']['input'];
    target: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings_Metrics_Items_Resource_Target_Input;
  };

/** The target value for the given metric */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings_Metrics_Items_Resource_Target =
  {
    /**
     * The target value of the average of the
     * resource metric across all relevant instances, represented as a percentage of
     * the requested value of the resource for the instances.
     */
    averageUtilization?: Maybe<Scalars['Int']['output']>;
    averageValue?: Maybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_spec_placements_items_scaleSettings_metrics_items_resource_target_averageValue']['output']
    >;
    value?: Maybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_spec_placements_items_scaleSettings_metrics_items_resource_target_value']['output']
    >;
  };

/** The target value for the given metric */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Placements_Items_ScaleSettings_Metrics_Items_Resource_Target_Input =
  {
    /**
     * The target value of the average of the
     * resource metric across all relevant instances, represented as a percentage of
     * the requested value of the resource for the instances.
     */
    averageUtilization?: InputMaybe<Scalars['Int']['input']>;
    averageValue?: InputMaybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_spec_placements_items_scaleSettings_metrics_items_resource_target_averageValue']['input']
    >;
    value?: InputMaybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_spec_placements_items_scaleSettings_metrics_items_resource_target_value']['input']
    >;
  };

/** Defines settings for each instance. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template = {
  metadata?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Metadata>;
  spec: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec;
};

/** Defines settings for each instance. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Input =
  {
    metadata?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Metadata_Input>;
    spec: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Input;
  };

/** Metadata of the instances created from this template */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Metadata =
  {
    annotations?: Maybe<Scalars['JSON']['output']>;
    finalizers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    labels?: Maybe<Scalars['JSON']['output']>;
    name?: Maybe<Scalars['String']['output']>;
    namespace?: Maybe<Scalars['String']['output']>;
  };

/** Metadata of the instances created from this template */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Metadata_Input =
  {
    annotations?: InputMaybe<Scalars['JSON']['input']>;
    finalizers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    labels?: InputMaybe<Scalars['JSON']['input']>;
    name?: InputMaybe<Scalars['String']['input']>;
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/** Describes the desired configuration of an instance */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec =
  {
    controller?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Controller>;
    location?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Location>;
    /** Network interface configuration. */
    networkInterfaces: Array<
      Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items>
    >;
    runtime: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime;
    /**
     * Volumes that must be available to attach to an instance's containers or
     * Virtual Machine.
     */
    volumes?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items>
      >
    >;
  };

/** Describes the desired configuration of an instance */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Input =
  {
    controller?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Controller_Input>;
    location?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Location_Input>;
    /** Network interface configuration. */
    networkInterfaces: Array<
      InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_Input>
    >;
    runtime: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Input;
    /**
     * Volumes that must be available to attach to an instance's containers or
     * Virtual Machine.
     */
    volumes?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Input>
      >
    >;
  };

/** Controller contains settings driven by the controller managing the instance. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Controller =
  {
    /**
     * SchedulingGates is a list of gates that must be satisfied before the
     * instance can be scheduled.
     */
    schedulingGates?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Controller_SchedulingGates_Items>
      >
    >;
    /** TemplateHash is the hash of the instance template applied for this instance. */
    templateHash: Scalars['String']['output'];
  };

/** Controller contains settings driven by the controller managing the instance. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Controller_Input =
  {
    /**
     * SchedulingGates is a list of gates that must be satisfied before the
     * instance can be scheduled.
     */
    schedulingGates?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Controller_SchedulingGates_Items_Input>
      >
    >;
    /** TemplateHash is the hash of the instance template applied for this instance. */
    templateHash: Scalars['String']['input'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Controller_SchedulingGates_Items =
  {
    /** The name of the gate. */
    name: Scalars['String']['output'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Controller_SchedulingGates_Items_Input =
  {
    /** The name of the gate. */
    name: Scalars['String']['input'];
  };

/** The location which the instance has been scheduled to */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Location =
  {
    /** Name of a datum location */
    name: Scalars['String']['output'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['output'];
  };

/** The location which the instance has been scheduled to */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Location_Input =
  {
    /** Name of a datum location */
    name: Scalars['String']['input'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['input'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items =
  {
    network: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_Network;
    networkPolicy?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_Input =
  {
    network: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_Network_Input;
    networkPolicy?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Input>;
  };

/** The network to attach the network interface to. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_Network =
  {
    /** The network name */
    name: Scalars['String']['output'];
    /**
     * The network namespace.
     *
     * Defaults to the namespace for the type the reference is embedded in.
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/**
 * Interface specific network policy.
 *
 * If provided, this will result in a platform managed network policy being
 * created that targets the specfiic instance interface. This network policy
 * will be of the lowest priority, and can effectively be prohibited from
 * influencing network connectivity.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy =
  {
    ingress?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items>
      >
    >;
  };

/**
 * Interface specific network policy.
 *
 * If provided, this will result in a platform managed network policy being
 * created that targets the specfiic instance interface. This network policy
 * will be of the lowest priority, and can effectively be prohibited from
 * influencing network connectivity.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Input =
  {
    ingress?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Input>
      >
    >;
  };

/** See k8s network policy types for inspiration here */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items =
  {
    /**
     * from is a list of sources which should be able to access the instances selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all sources (traffic not restricted by
     * source). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the from list.
     */
    from?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items>
      >
    >;
    /**
     * ports is a list of ports which should be made accessible on the instances selected for
     * this rule. Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     */
    ports?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items>
      >
    >;
  };

/** See k8s network policy types for inspiration here */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Input =
  {
    /**
     * from is a list of sources which should be able to access the instances selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all sources (traffic not restricted by
     * source). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the from list.
     */
    from?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_Input>
      >
    >;
    /**
     * ports is a list of ports which should be made accessible on the instances selected for
     * this rule. Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     */
    ports?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items_Input>
      >
    >;
  };

/**
 * NetworkPolicyPeer describes a peer to allow traffic to/from. Only certain combinations of
 * fields are allowed
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items =
  {
    ipBlock?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_IpBlock>;
  };

/**
 * NetworkPolicyPeer describes a peer to allow traffic to/from. Only certain combinations of
 * fields are allowed
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_Input =
  {
    ipBlock?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_IpBlock_Input>;
  };

/**
 * ipBlock defines policy on a particular IPBlock. If this field is set then
 * neither of the other fields can be.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_IpBlock =
  {
    /**
     * cidr is a string representing the IPBlock
     * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
     */
    cidr: Scalars['String']['output'];
    /**
     * except is a slice of CIDRs that should not be included within an IPBlock
     * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
     * Except values will be rejected if they are outside the cidr range
     */
    except?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  };

/**
 * ipBlock defines policy on a particular IPBlock. If this field is set then
 * neither of the other fields can be.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_From_Items_IpBlock_Input =
  {
    /**
     * cidr is a string representing the IPBlock
     * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
     */
    cidr: Scalars['String']['input'];
    /**
     * except is a slice of CIDRs that should not be included within an IPBlock
     * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
     * Except values will be rejected if they are outside the cidr range
     */
    except?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  };

/** NetworkPolicyPort describes a port to allow traffic on */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items =
  {
    /**
     * endPort indicates that the range of ports from port to endPort if set, inclusive,
     * should be allowed by the policy. This field cannot be defined if the port field
     * is not defined or if the port field is defined as a named (string) port.
     * The endPort must be equal or greater than port.
     */
    endPort?: Maybe<Scalars['Int']['output']>;
    /**
     * port represents the port on the given protocol. This can either be a numerical or named
     * port on an instance. If this field is not provided, this matches all port names and
     * numbers.
     * If present, only traffic on the specified protocol AND port will be matched.
     */
    port?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items_Port>;
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: Maybe<Scalars['String']['output']>;
  };

/** NetworkPolicyPort describes a port to allow traffic on */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items_Input =
  {
    /**
     * endPort indicates that the range of ports from port to endPort if set, inclusive,
     * should be allowed by the policy. This field cannot be defined if the port field
     * is not defined or if the port field is defined as a named (string) port.
     * The endPort must be equal or greater than port.
     */
    endPort?: InputMaybe<Scalars['Int']['input']>;
    /**
     * port represents the port on the given protocol. This can either be a numerical or named
     * port on an instance. If this field is not provided, this matches all port names and
     * numbers.
     * If present, only traffic on the specified protocol AND port will be matched.
     */
    port?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * port represents the port on the given protocol. This can either be a numerical or named
 * port on an instance. If this field is not provided, this matches all port names and
 * numbers.
 * If present, only traffic on the specified protocol AND port will be matched.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_NetworkPolicy_Ingress_Items_Ports_Items_Port =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
  };

/** The network to attach the network interface to. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_NetworkInterfaces_Items_Network_Input =
  {
    /** The network name */
    name: Scalars['String']['input'];
    /**
     * The network namespace.
     *
     * Defaults to the namespace for the type the reference is embedded in.
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/** The runtime type of the instance, such as a container sandbox or a VM. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime =
  {
    resources: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Resources;
    sandbox?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox>;
    virtualMachine?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine>;
  };

/** The runtime type of the instance, such as a container sandbox or a VM. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Input =
  {
    resources: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Resources_Input;
    sandbox?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Input>;
    virtualMachine?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_Input>;
  };

/**
 * Resources each instance must be allocated.
 *
 * A sandbox runtime's containers may specify resource requests and
 * limits. When limits are defined on all containers, they MUST consume
 * the entire amount of resources defined here. Some resources, such
 * as a GPU, MUST have at least one container request them so that the
 * device can be presented appropriately.
 *
 * A virtual machine runtime will be provided all requested resources.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Resources =
  {
    /**
     * Full or partial URL of the instance type resource to use for this instance.
     *
     * For example: `datumcloud/d1-standard-2`
     *
     * May be combined with `resources` to allow for custom instance types for
     * instance families that support customization. Instance types which support
     * customization will appear in the form `<project>/<instanceFamily>-custom`.
     */
    instanceType: Scalars['String']['output'];
    /** Describes adjustments to the resources defined by the instance type. */
    requests?: Maybe<Scalars['JSON']['output']>;
  };

/**
 * Resources each instance must be allocated.
 *
 * A sandbox runtime's containers may specify resource requests and
 * limits. When limits are defined on all containers, they MUST consume
 * the entire amount of resources defined here. Some resources, such
 * as a GPU, MUST have at least one container request them so that the
 * device can be presented appropriately.
 *
 * A virtual machine runtime will be provided all requested resources.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Resources_Input =
  {
    /**
     * Full or partial URL of the instance type resource to use for this instance.
     *
     * For example: `datumcloud/d1-standard-2`
     *
     * May be combined with `resources` to allow for custom instance types for
     * instance families that support customization. Instance types which support
     * customization will appear in the form `<project>/<instanceFamily>-custom`.
     */
    instanceType: Scalars['String']['input'];
    /** Describes adjustments to the resources defined by the instance type. */
    requests?: InputMaybe<Scalars['JSON']['input']>;
  };

/** A sandbox is a managed isolated environment capable of running containers. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox =
  {
    /** A list of containers to run within the sandbox. */
    containers: Array<
      Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items>
    >;
    /**
     * An optional list of secrets in the same namespace to use for pulling images
     * used by the instance.
     */
    imagePullSecrets?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_ImagePullSecrets_Items>
      >
    >;
  };

/** A sandbox is a managed isolated environment capable of running containers. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Input =
  {
    /** A list of containers to run within the sandbox. */
    containers: Array<
      InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Input>
    >;
    /**
     * An optional list of secrets in the same namespace to use for pulling images
     * used by the instance.
     */
    imagePullSecrets?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_ImagePullSecrets_Items_Input>
      >
    >;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items =
  {
    /**
     * List of environment variables to set in the container.
     *
     * so replicate the structure here too.
     */
    env?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items>
      >
    >;
    /** The fully qualified container image name. */
    image: Scalars['String']['output'];
    /** The name of the container. */
    name: Scalars['String']['output'];
    /** A list of named ports for the container. */
    ports?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Ports_Items>
      >
    >;
    resources?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Resources>;
    /** A list of volumes to attach to the container. */
    volumeAttachments?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_VolumeAttachments_Items>
      >
    >;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Input =
  {
    /**
     * List of environment variables to set in the container.
     *
     * so replicate the structure here too.
     */
    env?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_Input>
      >
    >;
    /** The fully qualified container image name. */
    image: Scalars['String']['input'];
    /** The name of the container. */
    name: Scalars['String']['input'];
    /** A list of named ports for the container. */
    ports?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Ports_Items_Input>
      >
    >;
    resources?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Resources_Input>;
    /** A list of volumes to attach to the container. */
    volumeAttachments?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_VolumeAttachments_Items_Input>
      >
    >;
  };

/** EnvVar represents an environment variable present in a Container. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items =
  {
    /** Name of the environment variable. Must be a C_IDENTIFIER. */
    name: Scalars['String']['output'];
    /**
     * Variable references $(VAR_NAME) are expanded
     * using the previously defined environment variables in the container and
     * any service environment variables. If a variable cannot be resolved,
     * the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
     * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
     * Escaped references will never be expanded, regardless of whether the variable
     * exists or not.
     * Defaults to "".
     */
    value?: Maybe<Scalars['String']['output']>;
    valueFrom?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom>;
  };

/** EnvVar represents an environment variable present in a Container. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_Input =
  {
    /** Name of the environment variable. Must be a C_IDENTIFIER. */
    name: Scalars['String']['input'];
    /**
     * Variable references $(VAR_NAME) are expanded
     * using the previously defined environment variables in the container and
     * any service environment variables. If a variable cannot be resolved,
     * the reference in the input string will be unchanged. Double $$ are reduced
     * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
     * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
     * Escaped references will never be expanded, regardless of whether the variable
     * exists or not.
     * Defaults to "".
     */
    value?: InputMaybe<Scalars['String']['input']>;
    valueFrom?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_Input>;
  };

/** Source for the environment variable's value. Cannot be used if value is not empty. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom =
  {
    configMapKeyRef?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ConfigMapKeyRef>;
    fieldRef?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_FieldRef>;
    resourceFieldRef?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ResourceFieldRef>;
    secretKeyRef?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_SecretKeyRef>;
  };

/** Source for the environment variable's value. Cannot be used if value is not empty. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_Input =
  {
    configMapKeyRef?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ConfigMapKeyRef_Input>;
    fieldRef?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_FieldRef_Input>;
    resourceFieldRef?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ResourceFieldRef_Input>;
    secretKeyRef?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_SecretKeyRef_Input>;
  };

/** Selects a key of a ConfigMap. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ConfigMapKeyRef =
  {
    /** The key to select. */
    key: Scalars['String']['output'];
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: Maybe<Scalars['String']['output']>;
    /** Specify whether the ConfigMap or its key must be defined */
    optional?: Maybe<Scalars['Boolean']['output']>;
  };

/** Selects a key of a ConfigMap. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ConfigMapKeyRef_Input =
  {
    /** The key to select. */
    key: Scalars['String']['input'];
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: InputMaybe<Scalars['String']['input']>;
    /** Specify whether the ConfigMap or its key must be defined */
    optional?: InputMaybe<Scalars['Boolean']['input']>;
  };

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_FieldRef =
  {
    /** Version of the schema the FieldPath is written in terms of, defaults to "v1". */
    apiVersion?: Maybe<Scalars['String']['output']>;
    /** Path of the field to select in the specified API version. */
    fieldPath: Scalars['String']['output'];
  };

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_FieldRef_Input =
  {
    /** Version of the schema the FieldPath is written in terms of, defaults to "v1". */
    apiVersion?: InputMaybe<Scalars['String']['input']>;
    /** Path of the field to select in the specified API version. */
    fieldPath: Scalars['String']['input'];
  };

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ResourceFieldRef =
  {
    /** Container name: required for volumes, optional for env vars */
    containerName?: Maybe<Scalars['String']['output']>;
    divisor?: Maybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_spec_template_spec_runtime_sandbox_containers_items_env_items_valueFrom_resourceFieldRef_divisor']['output']
    >;
    /** Required: resource to select */
    resource: Scalars['String']['output'];
  };

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_ResourceFieldRef_Input =
  {
    /** Container name: required for volumes, optional for env vars */
    containerName?: InputMaybe<Scalars['String']['input']>;
    divisor?: InputMaybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_spec_template_spec_runtime_sandbox_containers_items_env_items_valueFrom_resourceFieldRef_divisor']['input']
    >;
    /** Required: resource to select */
    resource: Scalars['String']['input'];
  };

/** Selects a key of a secret in the pod's namespace */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_SecretKeyRef =
  {
    /** The key of the secret to select from.  Must be a valid secret key. */
    key: Scalars['String']['output'];
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: Maybe<Scalars['String']['output']>;
    /** Specify whether the Secret or its key must be defined */
    optional?: Maybe<Scalars['Boolean']['output']>;
  };

/** Selects a key of a secret in the pod's namespace */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Env_Items_ValueFrom_SecretKeyRef_Input =
  {
    /** The key of the secret to select from.  Must be a valid secret key. */
    key: Scalars['String']['input'];
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: InputMaybe<Scalars['String']['input']>;
    /** Specify whether the Secret or its key must be defined */
    optional?: InputMaybe<Scalars['Boolean']['input']>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Ports_Items =
  {
    /** The name of the port that can be referenced by other platform features. */
    name: Scalars['String']['output'];
    /** The port number, which can be a value between 1 and 65535. */
    port: Scalars['Int']['output'];
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Ports_Items_Input =
  {
    /** The name of the port that can be referenced by other platform features. */
    name: Scalars['String']['input'];
    /** The port number, which can be a value between 1 and 65535. */
    port: Scalars['Int']['input'];
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: InputMaybe<Scalars['String']['input']>;
  };

/** The resource requirements for the container, such as CPU, memory, and GPUs. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Resources =
  {
    /** Limits describes the maximum amount of compute resources allowed. */
    limits?: Maybe<Scalars['JSON']['output']>;
    /** Requests describes the minimum amount of compute resources required. */
    requests?: Maybe<Scalars['JSON']['output']>;
  };

/** The resource requirements for the container, such as CPU, memory, and GPUs. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_Resources_Input =
  {
    /** Limits describes the maximum amount of compute resources allowed. */
    limits?: InputMaybe<Scalars['JSON']['input']>;
    /** Requests describes the minimum amount of compute resources required. */
    requests?: InputMaybe<Scalars['JSON']['input']>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_VolumeAttachments_Items =
  {
    /**
     * The path to mount the volume inside the guest OS.
     *
     * The referenced volume must be populated with a filesystem to use this
     * feature.
     *
     * For VM based instances, this functionality requires certain capabilities
     * to be annotated on the boot image, such as cloud-init.
     */
    mountPath?: Maybe<Scalars['String']['output']>;
    /** The name of the volume to attach as defined in InstanceSpec.Volumes. */
    name: Scalars['String']['output'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_Containers_Items_VolumeAttachments_Items_Input =
  {
    /**
     * The path to mount the volume inside the guest OS.
     *
     * The referenced volume must be populated with a filesystem to use this
     * feature.
     *
     * For VM based instances, this functionality requires certain capabilities
     * to be annotated on the boot image, such as cloud-init.
     */
    mountPath?: InputMaybe<Scalars['String']['input']>;
    /** The name of the volume to attach as defined in InstanceSpec.Volumes. */
    name: Scalars['String']['input'];
  };

/**
 * References a secret in the same namespace as the entity defining the
 * reference.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_ImagePullSecrets_Items =
  {
    /** The name of the secret */
    name: Scalars['String']['output'];
  };

/**
 * References a secret in the same namespace as the entity defining the
 * reference.
 */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_Sandbox_ImagePullSecrets_Items_Input =
  {
    /** The name of the secret */
    name: Scalars['String']['input'];
  };

/** A virtual machine is a classical VM environment, booting a full OS provided by the user via an image. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine =
  {
    /** A list of named ports for the virtual machine. */
    ports?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_Ports_Items>
      >
    >;
    /** A list of volumes to attach to the VM. */
    volumeAttachments: Array<
      Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_VolumeAttachments_Items>
    >;
  };

/** A virtual machine is a classical VM environment, booting a full OS provided by the user via an image. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_Input =
  {
    /** A list of named ports for the virtual machine. */
    ports?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_Ports_Items_Input>
      >
    >;
    /** A list of volumes to attach to the VM. */
    volumeAttachments: Array<
      InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_VolumeAttachments_Items_Input>
    >;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_Ports_Items =
  {
    /** The name of the port that can be referenced by other platform features. */
    name: Scalars['String']['output'];
    /** The port number, which can be a value between 1 and 65535. */
    port: Scalars['Int']['output'];
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_Ports_Items_Input =
  {
    /** The name of the port that can be referenced by other platform features. */
    name: Scalars['String']['input'];
    /** The port number, which can be a value between 1 and 65535. */
    port: Scalars['Int']['input'];
    /**
     * protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     */
    protocol?: InputMaybe<Scalars['String']['input']>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_VolumeAttachments_Items =
  {
    /**
     * The path to mount the volume inside the guest OS.
     *
     * The referenced volume must be populated with a filesystem to use this
     * feature.
     *
     * For VM based instances, this functionality requires certain capabilities
     * to be annotated on the boot image, such as cloud-init.
     */
    mountPath?: Maybe<Scalars['String']['output']>;
    /** The name of the volume to attach as defined in InstanceSpec.Volumes. */
    name: Scalars['String']['output'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Runtime_VirtualMachine_VolumeAttachments_Items_Input =
  {
    /**
     * The path to mount the volume inside the guest OS.
     *
     * The referenced volume must be populated with a filesystem to use this
     * feature.
     *
     * For VM based instances, this functionality requires certain capabilities
     * to be annotated on the boot image, such as cloud-init.
     */
    mountPath?: InputMaybe<Scalars['String']['input']>;
    /** The name of the volume to attach as defined in InstanceSpec.Volumes. */
    name: Scalars['String']['input'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items =
  {
    configMap?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap>;
    disk?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk>;
    /**
     * Name is used to reference the volume in `volumeAttachments` for
     * containers and VMs, and will be used to derive the platform resource
     * name when required by prefixing this name with the instance name upon
     * creation.
     */
    name: Scalars['String']['output'];
    secret?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Secret>;
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Input =
  {
    configMap?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap_Input>;
    disk?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Input>;
    /**
     * Name is used to reference the volume in `volumeAttachments` for
     * containers and VMs, and will be used to derive the platform resource
     * name when required by prefixing this name with the instance name upon
     * creation.
     */
    name: Scalars['String']['input'];
    secret?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Secret_Input>;
  };

/** A configMap that should populate this volume */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap =
  {
    /**
     * defaultMode is optional: mode bits used to set permissions on created files by default.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * Defaults to 0644.
     * Directories within the path are not affected by this setting.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    defaultMode?: Maybe<Scalars['Int']['output']>;
    /**
     * items if unspecified, each key-value pair in the Data field of the referenced
     * ConfigMap will be projected into the volume as a file whose name is the
     * key and content is the value. If specified, the listed keys will be
     * projected into the specified paths, and unlisted keys will not be
     * present. If a key is specified which is not present in the ConfigMap,
     * the volume setup will error unless it is marked optional. Paths must be
     * relative and may not contain the '..' path or start with '..'.
     */
    items?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap_Items_Items>
      >
    >;
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: Maybe<Scalars['String']['output']>;
    /** optional specify whether the ConfigMap or its keys must be defined */
    optional?: Maybe<Scalars['Boolean']['output']>;
  };

/** A configMap that should populate this volume */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap_Input =
  {
    /**
     * defaultMode is optional: mode bits used to set permissions on created files by default.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * Defaults to 0644.
     * Directories within the path are not affected by this setting.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    defaultMode?: InputMaybe<Scalars['Int']['input']>;
    /**
     * items if unspecified, each key-value pair in the Data field of the referenced
     * ConfigMap will be projected into the volume as a file whose name is the
     * key and content is the value. If specified, the listed keys will be
     * projected into the specified paths, and unlisted keys will not be
     * present. If a key is specified which is not present in the ConfigMap,
     * the volume setup will error unless it is marked optional. Paths must be
     * relative and may not contain the '..' path or start with '..'.
     */
    items?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap_Items_Items_Input>
      >
    >;
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: InputMaybe<Scalars['String']['input']>;
    /** optional specify whether the ConfigMap or its keys must be defined */
    optional?: InputMaybe<Scalars['Boolean']['input']>;
  };

/** Maps a string key to a path within a volume. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap_Items_Items =
  {
    /** key is the key to project. */
    key: Scalars['String']['output'];
    /**
     * mode is Optional: mode bits used to set permissions on this file.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * If not specified, the volume defaultMode will be used.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    mode?: Maybe<Scalars['Int']['output']>;
    /**
     * path is the relative path of the file to map the key to.
     * May not be an absolute path.
     * May not contain the path element '..'.
     * May not start with the string '..'.
     */
    path: Scalars['String']['output'];
  };

/** Maps a string key to a path within a volume. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_ConfigMap_Items_Items_Input =
  {
    /** key is the key to project. */
    key: Scalars['String']['input'];
    /**
     * mode is Optional: mode bits used to set permissions on this file.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * If not specified, the volume defaultMode will be used.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    mode?: InputMaybe<Scalars['Int']['input']>;
    /**
     * path is the relative path of the file to map the key to.
     * May not be an absolute path.
     * May not contain the path element '..'.
     * May not start with the string '..'.
     */
    path: Scalars['String']['input'];
  };

/** A persistent disk backed volume. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk =
  {
    /**
     * Specifies a unique device name that is reflected into the
     * `/dev/disk/by-id/datumcloud-*` tree of a Linux operating system
     * running within the instance. This name can be used to reference
     * the device for mounting, resizing, and so on, from within the
     * instance.
     *
     * If not specified, the server chooses a default device name to
     * apply to this disk, in the form persistent-disk-x, where x is a
     * number assigned by Datum Cloud.
     */
    deviceName?: Maybe<Scalars['String']['output']>;
    template: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template;
  };

/** A persistent disk backed volume. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Input =
  {
    /**
     * Specifies a unique device name that is reflected into the
     * `/dev/disk/by-id/datumcloud-*` tree of a Linux operating system
     * running within the instance. This name can be used to reference
     * the device for mounting, resizing, and so on, from within the
     * instance.
     *
     * If not specified, the server chooses a default device name to
     * apply to this disk, in the form persistent-disk-x, where x is a
     * number assigned by Datum Cloud.
     */
    deviceName?: InputMaybe<Scalars['String']['input']>;
    template: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Input;
  };

/** Settings to create a new disk for an attached disk */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template =
  {
    metadata?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Metadata>;
    spec: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec;
  };

/** Settings to create a new disk for an attached disk */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Input =
  {
    metadata?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Metadata_Input>;
    spec: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Input;
  };

/** Metadata of the disks created from this template */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Metadata =
  {
    annotations?: Maybe<Scalars['JSON']['output']>;
    finalizers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    labels?: Maybe<Scalars['JSON']['output']>;
    name?: Maybe<Scalars['String']['output']>;
    namespace?: Maybe<Scalars['String']['output']>;
  };

/** Metadata of the disks created from this template */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Metadata_Input =
  {
    annotations?: InputMaybe<Scalars['JSON']['input']>;
    finalizers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    labels?: InputMaybe<Scalars['JSON']['input']>;
    name?: InputMaybe<Scalars['String']['input']>;
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/** Describes the desired configuration of a disk */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec =
  {
    populator?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator>;
    resources?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Resources>;
    /** The type the disk, such as `pd-standard`. */
    type?: Maybe<Scalars['String']['output']>;
  };

/** Describes the desired configuration of a disk */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Input =
  {
    populator?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Input>;
    resources?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Resources_Input>;
    /** The type the disk, such as `pd-standard`. */
    type?: InputMaybe<Scalars['String']['input']>;
  };

/** Populator to use while initializing the disk. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator =
  {
    filesystem?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Filesystem>;
    image?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Image>;
  };

/** Populator to use while initializing the disk. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Input =
  {
    filesystem?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Filesystem_Input>;
    image?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Image_Input>;
  };

/** Populate the disk with a filesystem */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Filesystem =
  {
    type: Ext4_Const;
  };

/** Populate the disk with a filesystem */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Filesystem_Input =
  {
    type: Ext4_Const;
  };

/** Populate the disk from an image */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Image =
  {
    /**
     * The name of the image to populate the disk with.
     *
     * 	in `populator.image.imageRef.name` though.
     */
    name: Scalars['String']['output'];
  };

/** Populate the disk from an image */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Populator_Image_Input =
  {
    /**
     * The name of the image to populate the disk with.
     *
     * 	in `populator.image.imageRef.name` though.
     */
    name: Scalars['String']['input'];
  };

/** The resource requirements for the disk. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Resources =
  {
    /** Requests describes the minimum amount of storage resources required. */
    requests?: Maybe<Scalars['JSON']['output']>;
  };

/** The resource requirements for the disk. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Disk_Template_Spec_Resources_Input =
  {
    /** Requests describes the minimum amount of storage resources required. */
    requests?: InputMaybe<Scalars['JSON']['input']>;
  };

/** A secret that should populate this volume */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Secret =
  {
    /**
     * defaultMode is Optional: mode bits used to set permissions on created files by default.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values
     * for mode bits. Defaults to 0644.
     * Directories within the path are not affected by this setting.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    defaultMode?: Maybe<Scalars['Int']['output']>;
    /**
     * items If unspecified, each key-value pair in the Data field of the referenced
     * Secret will be projected into the volume as a file whose name is the
     * key and content is the value. If specified, the listed keys will be
     * projected into the specified paths, and unlisted keys will not be
     * present. If a key is specified which is not present in the Secret,
     * the volume setup will error unless it is marked optional. Paths must be
     * relative and may not contain the '..' path or start with '..'.
     */
    items?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Secret_Items_Items>
      >
    >;
    /** optional field specify whether the Secret or its keys must be defined */
    optional?: Maybe<Scalars['Boolean']['output']>;
    /**
     * secretName is the name of the secret in the pod's namespace to use.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
     */
    secretName?: Maybe<Scalars['String']['output']>;
  };

/** A secret that should populate this volume */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Secret_Input =
  {
    /**
     * defaultMode is Optional: mode bits used to set permissions on created files by default.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values
     * for mode bits. Defaults to 0644.
     * Directories within the path are not affected by this setting.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    defaultMode?: InputMaybe<Scalars['Int']['input']>;
    /**
     * items If unspecified, each key-value pair in the Data field of the referenced
     * Secret will be projected into the volume as a file whose name is the
     * key and content is the value. If specified, the listed keys will be
     * projected into the specified paths, and unlisted keys will not be
     * present. If a key is specified which is not present in the Secret,
     * the volume setup will error unless it is marked optional. Paths must be
     * relative and may not contain the '..' path or start with '..'.
     */
    items?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Secret_Items_Items_Input>
      >
    >;
    /** optional field specify whether the Secret or its keys must be defined */
    optional?: InputMaybe<Scalars['Boolean']['input']>;
    /**
     * secretName is the name of the secret in the pod's namespace to use.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
     */
    secretName?: InputMaybe<Scalars['String']['input']>;
  };

/** Maps a string key to a path within a volume. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Secret_Items_Items =
  {
    /** key is the key to project. */
    key: Scalars['String']['output'];
    /**
     * mode is Optional: mode bits used to set permissions on this file.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * If not specified, the volume defaultMode will be used.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    mode?: Maybe<Scalars['Int']['output']>;
    /**
     * path is the relative path of the file to map the key to.
     * May not be an absolute path.
     * May not contain the path element '..'.
     * May not start with the string '..'.
     */
    path: Scalars['String']['output'];
  };

/** Maps a string key to a path within a volume. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Spec_Template_Spec_Volumes_Items_Secret_Items_Items_Input =
  {
    /** key is the key to project. */
    key: Scalars['String']['input'];
    /**
     * mode is Optional: mode bits used to set permissions on this file.
     * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
     * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
     * If not specified, the volume defaultMode will be used.
     * This might be in conflict with other options that affect the file
     * mode, like fsGroup, and the result can be other mode bits set.
     */
    mode?: InputMaybe<Scalars['Int']['input']>;
    /**
     * path is the relative path of the file to map the key to.
     * May not be an absolute path.
     * May not contain the path element '..'.
     * May not start with the string '..'.
     */
    path: Scalars['String']['input'];
  };

/** WorkloadStatus defines the observed state of Workload */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status = {
  /**
   * Represents the observations of a workload's current state.
   * Known condition types are: "Available", "Progressing"
   */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Conditions_Items>
    >
  >;
  /** The number of instances which have the latest workload settings applied. */
  currentReplicas: Scalars['Int']['output'];
  /** The number of deployments that currently exist */
  deployments: Scalars['Int']['output'];
  /** The desired number of instances */
  desiredReplicas: Scalars['Int']['output'];
  gateway?: Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway>;
  /** The current status of placemetns in a workload. */
  placements?: Maybe<
    Array<
      Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Placements_Items>
    >
  >;
  /** The number of instances which are ready. */
  readyReplicas: Scalars['Int']['output'];
  /** The number of instances that currently exist */
  replicas: Scalars['Int']['output'];
};

/** WorkloadStatus defines the observed state of Workload */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Input = {
  /**
   * Represents the observations of a workload's current state.
   * Known condition types are: "Available", "Progressing"
   */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /** The number of instances which have the latest workload settings applied. */
  currentReplicas: Scalars['Int']['input'];
  /** The number of deployments that currently exist */
  deployments: Scalars['Int']['input'];
  /** The desired number of instances */
  desiredReplicas: Scalars['Int']['input'];
  gateway?: InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Input>;
  /** The current status of placemetns in a workload. */
  placements?: InputMaybe<
    Array<
      InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Placements_Items_Input>
    >
  >;
  /** The number of instances which are ready. */
  readyReplicas: Scalars['Int']['input'];
  /** The number of instances that currently exist */
  replicas: Scalars['Int']['input'];
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_conditions_items_reason']['output'];
    status: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_conditions_items_reason']['input'];
    status: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** The status of the workload gateway if configured. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway = {
  /**
   * Addresses lists the network addresses that have been bound to the
   * Gateway.
   *
   * This list may differ from the addresses provided in the spec under some
   * conditions:
   *
   *   * no addresses are specified, all addresses are dynamically assigned
   *   * a combination of specified and dynamic addresses are assigned
   *   * a specified address was unusable (e.g. already in use)
   *
   * <gateway:validateIPAddress>
   */
  addresses?: Maybe<
    Array<
      Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Addresses_Items>
    >
  >;
  /**
   * Conditions describe the current conditions of the Gateway.
   *
   * Implementations should prefer to express Gateway conditions
   * using the `GatewayConditionType` and `GatewayConditionReason`
   * constants so that operators and tools can converge on a common
   * vocabulary to describe Gateway state.
   *
   * Known condition types are:
   *
   * * "Accepted"
   * * "Programmed"
   * * "Ready"
   */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Conditions_Items>
    >
  >;
  /** Listeners provide status for each unique listener port defined in the Spec. */
  listeners?: Maybe<
    Array<
      Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items>
    >
  >;
};

/** The status of the workload gateway if configured. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Input =
  {
    /**
     * Addresses lists the network addresses that have been bound to the
     * Gateway.
     *
     * This list may differ from the addresses provided in the spec under some
     * conditions:
     *
     *   * no addresses are specified, all addresses are dynamically assigned
     *   * a combination of specified and dynamic addresses are assigned
     *   * a specified address was unusable (e.g. already in use)
     *
     * <gateway:validateIPAddress>
     */
    addresses?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Addresses_Items_Input>
      >
    >;
    /**
     * Conditions describe the current conditions of the Gateway.
     *
     * Implementations should prefer to express Gateway conditions
     * using the `GatewayConditionType` and `GatewayConditionReason`
     * constants so that operators and tools can converge on a common
     * vocabulary to describe Gateway state.
     *
     * Known condition types are:
     *
     * * "Accepted"
     * * "Programmed"
     * * "Ready"
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Conditions_Items_Input>
      >
    >;
    /** Listeners provide status for each unique listener port defined in the Spec. */
    listeners?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items_Input>
      >
    >;
  };

/** GatewayStatusAddress describes a network address that is bound to a Gateway. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Addresses_Items =
  {
    type?: Maybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_addresses_items_type']['output']
    >;
    /**
     * Value of the address. The validity of the values will depend
     * on the type and support by the controller.
     *
     * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
     */
    value: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_addresses_items_value']['output'];
  };

/** GatewayStatusAddress describes a network address that is bound to a Gateway. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Addresses_Items_Input =
  {
    type?: InputMaybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_addresses_items_type']['input']
    >;
    /**
     * Value of the address. The validity of the values will depend
     * on the type and support by the controller.
     *
     * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
     */
    value: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_addresses_items_value']['input'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_conditions_items_reason']['output'];
    status: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Conditions_Items_Status;
    type: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_conditions_items_reason']['input'];
    status: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Conditions_Items_Status;
    type: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** ListenerStatus is the status associated with a Listener. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items =
  {
    /**
     * AttachedRoutes represents the total number of Routes that have been
     * successfully attached to this Listener.
     *
     * Successful attachment of a Route to a Listener is based solely on the
     * combination of the AllowedRoutes field on the corresponding Listener
     * and the Route's ParentRefs field. A Route is successfully attached to
     * a Listener when it is selected by the Listener's AllowedRoutes field
     * AND the Route has a valid ParentRef selecting the whole Gateway
     * resource or a specific Listener as a parent resource (more detail on
     * attachment semantics can be found in the documentation on the various
     * Route kinds ParentRefs fields). Listener or Route status does not impact
     * successful attachment, i.e. the AttachedRoutes field count MUST be set
     * for Listeners with condition Accepted: false and MUST count successfully
     * attached Routes that may themselves have Accepted: false conditions.
     *
     * Uses for this field include troubleshooting Route attachment and
     * measuring blast radius/impact of changes to a Listener.
     */
    attachedRoutes: Scalars['Int']['output'];
    /** Conditions describe the current condition of this listener. */
    conditions: Array<
      Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items_Conditions_Items>
    >;
    name: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_name']['output'];
    /**
     * SupportedKinds is the list indicating the Kinds supported by this
     * listener. This MUST represent the kinds an implementation supports for
     * that Listener configuration.
     *
     * If kinds are specified in Spec that are not supported, they MUST NOT
     * appear in this list and an implementation MUST set the "ResolvedRefs"
     * condition to "False" with the "InvalidRouteKinds" reason. If both valid
     * and invalid Route kinds are specified, the implementation MUST
     * reference the valid Route kinds that have been specified.
     */
    supportedKinds: Array<
      Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items_SupportedKinds_Items>
    >;
  };

/** ListenerStatus is the status associated with a Listener. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items_Input =
  {
    /**
     * AttachedRoutes represents the total number of Routes that have been
     * successfully attached to this Listener.
     *
     * Successful attachment of a Route to a Listener is based solely on the
     * combination of the AllowedRoutes field on the corresponding Listener
     * and the Route's ParentRefs field. A Route is successfully attached to
     * a Listener when it is selected by the Listener's AllowedRoutes field
     * AND the Route has a valid ParentRef selecting the whole Gateway
     * resource or a specific Listener as a parent resource (more detail on
     * attachment semantics can be found in the documentation on the various
     * Route kinds ParentRefs fields). Listener or Route status does not impact
     * successful attachment, i.e. the AttachedRoutes field count MUST be set
     * for Listeners with condition Accepted: false and MUST count successfully
     * attached Routes that may themselves have Accepted: false conditions.
     *
     * Uses for this field include troubleshooting Route attachment and
     * measuring blast radius/impact of changes to a Listener.
     */
    attachedRoutes: Scalars['Int']['input'];
    /** Conditions describe the current condition of this listener. */
    conditions: Array<
      InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items_Conditions_Items_Input>
    >;
    name: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_name']['input'];
    /**
     * SupportedKinds is the list indicating the Kinds supported by this
     * listener. This MUST represent the kinds an implementation supports for
     * that Listener configuration.
     *
     * If kinds are specified in Spec that are not supported, they MUST NOT
     * appear in this list and an implementation MUST set the "ResolvedRefs"
     * condition to "False" with the "InvalidRouteKinds" reason. If both valid
     * and invalid Route kinds are specified, the implementation MUST
     * reference the valid Route kinds that have been specified.
     */
    supportedKinds: Array<
      InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items_SupportedKinds_Items_Input>
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_conditions_items_reason']['output'];
    status: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items_Conditions_Items_Status;
    type: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_conditions_items_reason']['input'];
    status: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items_Conditions_Items_Status;
    type: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** RouteGroupKind indicates the group and kind of a Route resource. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items_SupportedKinds_Items =
  {
    group?: Maybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_supportedKinds_items_group']['output']
    >;
    kind: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_supportedKinds_items_kind']['output'];
  };

/** RouteGroupKind indicates the group and kind of a Route resource. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Gateway_Listeners_Items_SupportedKinds_Items_Input =
  {
    group?: InputMaybe<
      Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_supportedKinds_items_group']['input']
    >;
    kind: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_gateway_listeners_items_supportedKinds_items_kind']['input'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Placements_Items =
  {
    /**
     * Represents the observations of a placement's current state.
     * Known condition types are: "Available", "Progressing"
     */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Placements_Items_Conditions_Items>
      >
    >;
    /** The number of instances which have the latest workload settings applied. */
    currentReplicas: Scalars['Int']['output'];
    /** The desired number of instances */
    desiredReplicas: Scalars['Int']['output'];
    /** The name of the placement */
    name: Scalars['String']['output'];
    /** The number of instances which are ready. */
    readyReplicas: Scalars['Int']['output'];
    /** The number of instances that currently exist */
    replicas: Scalars['Int']['output'];
  };

export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Placements_Items_Input =
  {
    /**
     * Represents the observations of a placement's current state.
     * Known condition types are: "Available", "Progressing"
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Placements_Items_Conditions_Items_Input>
      >
    >;
    /** The number of instances which have the latest workload settings applied. */
    currentReplicas: Scalars['Int']['input'];
    /** The desired number of instances */
    desiredReplicas: Scalars['Int']['input'];
    /** The name of the placement */
    name: Scalars['String']['input'];
    /** The number of instances which are ready. */
    readyReplicas: Scalars['Int']['input'];
    /** The number of instances that currently exist */
    replicas: Scalars['Int']['input'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Placements_Items_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_placements_items_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_placements_items_conditions_items_reason']['output'];
    status: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Placements_Items_Conditions_Items_Status;
    type: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_placements_items_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Placements_Items_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_placements_items_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_placements_items_conditions_items_reason']['input'];
    status: Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Placements_Items_Conditions_Items_Status;
    type: Scalars['query_listComputeDatumapisComV1alphaNamespacedWorkload_items_items_status_placements_items_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListComputeDatumapisComV1alphaNamespacedWorkload_Items_Items_Status_Placements_Items_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * Phase is the current lifecycle phase of the namespace. More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
 *
 * Possible enum values:
 *  - `"Active"` means the namespace is available for use in the system
 *  - `"Terminating"` means the namespace is undergoing graceful termination
 */
export type Query_ListCoreV1Namespace_OneOf_0_Items_Items_Status_Phase = 'Active' | 'Terminating';

/** NoteSpec defines the desired state of Note. */
export type Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec = {
  /** Content is the text content of the note. */
  content: Scalars['query_listCrmMiloapisComV1alpha1Note_items_items_spec_content']['output'];
  creatorRef?: Maybe<Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_CreatorRef>;
  /**
   * FollowUp indicates whether this note requires follow-up.
   * When true, the note is being actively tracked for further action.
   */
  followUp?: Maybe<Scalars['Boolean']['output']>;
  /** InteractionTime is the timestamp of the interaction with the subject. */
  interactionTime?: Maybe<Scalars['DateTime']['output']>;
  /** NextAction is an optional follow-up action. */
  nextAction?: Maybe<Scalars['String']['output']>;
  /** NextActionTime is the timestamp for the follow-up action. */
  nextActionTime?: Maybe<Scalars['DateTime']['output']>;
  subjectRef: Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_SubjectRef;
};

/** NoteSpec defines the desired state of Note. */
export type Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_Input = {
  /** Content is the text content of the note. */
  content: Scalars['query_listCrmMiloapisComV1alpha1Note_items_items_spec_content']['input'];
  creatorRef?: InputMaybe<Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_CreatorRef_Input>;
  /**
   * FollowUp indicates whether this note requires follow-up.
   * When true, the note is being actively tracked for further action.
   */
  followUp?: InputMaybe<Scalars['Boolean']['input']>;
  /** InteractionTime is the timestamp of the interaction with the subject. */
  interactionTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** NextAction is an optional follow-up action. */
  nextAction?: InputMaybe<Scalars['String']['input']>;
  /** NextActionTime is the timestamp for the follow-up action. */
  nextActionTime?: InputMaybe<Scalars['DateTime']['input']>;
  subjectRef: Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_SubjectRef_Input;
};

/**
 * CreatorRef is a reference to the user that created the note.
 * Defaults to the user that created the note.
 */
export type Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_CreatorRef = {
  /** Name is the name of the User being referenced. */
  name: Scalars['String']['output'];
};

/**
 * CreatorRef is a reference to the user that created the note.
 * Defaults to the user that created the note.
 */
export type Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_CreatorRef_Input = {
  /** Name is the name of the User being referenced. */
  name: Scalars['String']['input'];
};

/** Subject is a reference to the subject of the note. */
export type Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_SubjectRef = {
  apiGroup: Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_SubjectRef_ApiGroup;
  kind: Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_SubjectRef_Kind;
  /** Name is the name of resource being referenced. */
  name: Scalars['String']['output'];
  /**
   * Namespace is the namespace of resource being referenced.
   * Required for namespace-scoped resources. Omitted for cluster-scoped resources.
   */
  namespace?: Maybe<Scalars['String']['output']>;
};

/** Subject is a reference to the subject of the note. */
export type Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_SubjectRef_Input = {
  apiGroup: Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_SubjectRef_ApiGroup;
  kind: Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_SubjectRef_Kind;
  /** Name is the name of resource being referenced. */
  name: Scalars['String']['input'];
  /**
   * Namespace is the namespace of resource being referenced.
   * Required for namespace-scoped resources. Omitted for cluster-scoped resources.
   */
  namespace?: InputMaybe<Scalars['String']['input']>;
};

/** APIGroup is the group for the resource being referenced. */
export type Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_SubjectRef_ApiGroup =
  | 'iam_miloapis_com'
  | 'notification_miloapis_com';

/** Kind is the type of resource being referenced. */
export type Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Spec_SubjectRef_Kind =
  | 'Contact'
  | 'User';

/** NoteStatus defines the observed state of Note */
export type Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Status = {
  /** Conditions provide conditions that represent the current status of the Note. */
  conditions?: Maybe<
    Array<Maybe<Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Status_Conditions_Items>>
  >;
  /** CreatedBy is the email of the user that created the note. */
  createdBy?: Maybe<Scalars['String']['output']>;
};

/** NoteStatus defines the observed state of Note */
export type Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Status_Input = {
  /** Conditions provide conditions that represent the current status of the Note. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /** CreatedBy is the email of the user that created the note. */
  createdBy?: InputMaybe<Scalars['String']['input']>;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Status_Conditions_Items = {
  /**
   * lastTransitionTime is the last time the condition transitioned from one status to another.
   * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
   */
  lastTransitionTime: Scalars['DateTime']['output'];
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  message: Scalars['query_listCrmMiloapisComV1alpha1Note_items_items_status_conditions_items_message']['output'];
  /**
   * observedGeneration represents the .metadata.generation that the condition was set based upon.
   * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
   * with respect to the current state of the instance.
   */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
  reason: Scalars['query_listCrmMiloapisComV1alpha1Note_items_items_status_conditions_items_reason']['output'];
  status: Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Status_Conditions_Items_Status;
  type: Scalars['query_listCrmMiloapisComV1alpha1Note_items_items_status_conditions_items_type']['output'];
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Status_Conditions_Items_Input = {
  /**
   * lastTransitionTime is the last time the condition transitioned from one status to another.
   * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
   */
  lastTransitionTime: Scalars['DateTime']['input'];
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  message: Scalars['query_listCrmMiloapisComV1alpha1Note_items_items_status_conditions_items_message']['input'];
  /**
   * observedGeneration represents the .metadata.generation that the condition was set based upon.
   * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
   * with respect to the current state of the instance.
   */
  observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
  reason: Scalars['query_listCrmMiloapisComV1alpha1Note_items_items_status_conditions_items_reason']['input'];
  status: Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Status_Conditions_Items_Status;
  type: Scalars['query_listCrmMiloapisComV1alpha1Note_items_items_status_conditions_items_type']['input'];
};

/** status of the condition, one of True, False, Unknown. */
export type Query_ListCrmMiloapisComV1alpha1Note_Items_Items_Status_Conditions_Items_Status =
  | 'False'
  | 'True'
  | 'Unknown';

/**
 * addressType specifies the type of address carried by this EndpointSlice. All addresses in this slice must be the same type. This field is immutable after creation. The following address types are currently supported: * IPv4: Represents an IPv4 Address. * IPv6: Represents an IPv6 Address. * FQDN: Represents a Fully Qualified Domain Name.
 *
 * Possible enum values:
 *  - `"FQDN"` represents a FQDN.
 *  - `"IPv4"` represents an IPv4 Address.
 *  - `"IPv6"` represents an IPv6 Address.
 */
export type Query_ListDiscoveryV1EndpointSliceForAllNamespaces_OneOf_0_Items_Items_AddressType =
  | 'FQDN'
  | 'IPv4'
  | 'IPv6';

/**
 * protocol represents the IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.
 *
 * Possible enum values:
 *  - `"SCTP"` is the SCTP protocol.
 *  - `"TCP"` is the TCP protocol.
 *  - `"UDP"` is the UDP protocol.
 */
export type Query_ListDiscoveryV1EndpointSliceForAllNamespaces_OneOf_0_Items_Items_Ports_Items_Protocol =
  'SCTP' | 'TCP' | 'UDP';

/** spec defines the desired state of DNSRecordSet */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec =
  {
    dnsZoneRef: Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_DnsZoneRef;
    recordType: Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_RecordType;
    /** Records contains one or more owner names with values appropriate for the RecordType. */
    records: Array<
      Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items>
    >;
  };

/** spec defines the desired state of DNSRecordSet */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Input =
  {
    dnsZoneRef: Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_DnsZoneRef_Input;
    recordType: Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_RecordType;
    /** Records contains one or more owner names with values appropriate for the RecordType. */
    records: Array<
      InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Input>
    >;
  };

/** DNSZoneRef references the DNSZone (same namespace) this recordset belongs to. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_DnsZoneRef =
  {
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: Maybe<Scalars['String']['output']>;
  };

/** DNSZoneRef references the DNSZone (same namespace) this recordset belongs to. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_DnsZoneRef_Input =
  {
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: InputMaybe<Scalars['String']['input']>;
  };

/** RecordType is the DNS RR type for this recordset. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_RecordType =

    | 'A'
    | 'AAAA'
    | 'ALIAS'
    | 'CAA'
    | 'CNAME'
    | 'HTTPS'
    | 'MX'
    | 'NS'
    | 'PTR'
    | 'SOA'
    | 'SRV'
    | 'SVCB'
    | 'TLSA'
    | 'TXT';

/** RecordEntry represents one owner name and its values. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items =
  {
    a?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_A>;
    aaaa?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Aaaa>;
    alias?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Alias>;
    caa?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Caa>;
    cname?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Cname>;
    https?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Https>;
    mx?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Mx>;
    name: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_name']['output'];
    ns?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Ns>;
    ptr?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Ptr>;
    soa?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Soa>;
    srv?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Srv>;
    svcb?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Svcb>;
    tlsa?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Tlsa>;
    /** TTL optionally overrides TTL for this owner/RRset. */
    ttl?: Maybe<Scalars['BigInt']['output']>;
    txt?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Txt>;
  };

/** RecordEntry represents one owner name and its values. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Input =
  {
    a?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_A_Input>;
    aaaa?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Aaaa_Input>;
    alias?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Alias_Input>;
    caa?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Caa_Input>;
    cname?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Cname_Input>;
    https?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Https_Input>;
    mx?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Mx_Input>;
    name: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_name']['input'];
    ns?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Ns_Input>;
    ptr?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Ptr_Input>;
    soa?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Soa_Input>;
    srv?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Srv_Input>;
    svcb?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Svcb_Input>;
    tlsa?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Tlsa_Input>;
    /** TTL optionally overrides TTL for this owner/RRset. */
    ttl?: InputMaybe<Scalars['BigInt']['input']>;
    txt?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Txt_Input>;
  };

/** Exactly one of the following type-specific fields should be set matching RecordType. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_A =
  {
    content: Scalars['IPv4']['output'];
  };

/** Exactly one of the following type-specific fields should be set matching RecordType. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_A_Input =
  {
    content: Scalars['IPv4']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Aaaa =
  {
    content: Scalars['IPv6']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Aaaa_Input =
  {
    content: Scalars['IPv6']['input'];
  };

/**
 * ALIASRecordSpec is like CNAME but intended for providers that implement an ALIAS/ANAME-style record.
 * The content is a hostname (FQDN or relative) with an optional trailing dot.
 */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Alias =
  {
    content: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_alias_content']['output'];
  };

/**
 * ALIASRecordSpec is like CNAME but intended for providers that implement an ALIAS/ANAME-style record.
 * The content is a hostname (FQDN or relative) with an optional trailing dot.
 */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Alias_Input =
  {
    content: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_alias_content']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Caa =
  {
    /** 0255 flag */
    flag: Scalars['NonNegativeInt']['output'];
    tag: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_caa_tag']['output'];
    value: Scalars['NonEmptyString']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Caa_Input =
  {
    /** 0255 flag */
    flag: Scalars['NonNegativeInt']['input'];
    tag: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_caa_tag']['input'];
    value: Scalars['NonEmptyString']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Cname =
  {
    content: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_cname_content']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Cname_Input =
  {
    content: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_cname_content']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Https =
  {
    params?: Maybe<Scalars['JSON']['output']>;
    priority: Scalars['NonNegativeInt']['output'];
    target: Scalars['String']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Https_Input =
  {
    params?: InputMaybe<Scalars['JSON']['input']>;
    priority: Scalars['NonNegativeInt']['input'];
    target: Scalars['String']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Mx =
  {
    exchange: Scalars['NonEmptyString']['output'];
    preference: Scalars['NonNegativeInt']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Mx_Input =
  {
    exchange: Scalars['NonEmptyString']['input'];
    preference: Scalars['NonNegativeInt']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Ns =
  {
    content: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_ns_content']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Ns_Input =
  {
    content: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_spec_records_items_ns_content']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Ptr =
  {
    content: Scalars['String']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Ptr_Input =
  {
    content: Scalars['String']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Soa =
  {
    expire?: Maybe<Scalars['Int']['output']>;
    mname: Scalars['NonEmptyString']['output'];
    refresh?: Maybe<Scalars['Int']['output']>;
    retry?: Maybe<Scalars['Int']['output']>;
    rname: Scalars['NonEmptyString']['output'];
    serial?: Maybe<Scalars['Int']['output']>;
    ttl?: Maybe<Scalars['Int']['output']>;
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Soa_Input =
  {
    expire?: InputMaybe<Scalars['Int']['input']>;
    mname: Scalars['NonEmptyString']['input'];
    refresh?: InputMaybe<Scalars['Int']['input']>;
    retry?: InputMaybe<Scalars['Int']['input']>;
    rname: Scalars['NonEmptyString']['input'];
    serial?: InputMaybe<Scalars['Int']['input']>;
    ttl?: InputMaybe<Scalars['Int']['input']>;
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Srv =
  {
    port: Scalars['NonNegativeInt']['output'];
    priority: Scalars['NonNegativeInt']['output'];
    target: Scalars['NonEmptyString']['output'];
    weight: Scalars['NonNegativeInt']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Srv_Input =
  {
    port: Scalars['NonNegativeInt']['input'];
    priority: Scalars['NonNegativeInt']['input'];
    target: Scalars['NonEmptyString']['input'];
    weight: Scalars['NonNegativeInt']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Svcb =
  {
    params?: Maybe<Scalars['JSON']['output']>;
    priority: Scalars['NonNegativeInt']['output'];
    target: Scalars['String']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Svcb_Input =
  {
    params?: InputMaybe<Scalars['JSON']['input']>;
    priority: Scalars['NonNegativeInt']['input'];
    target: Scalars['String']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Tlsa =
  {
    certData: Scalars['String']['output'];
    matchingType: Scalars['Int']['output'];
    selector: Scalars['Int']['output'];
    usage: Scalars['Int']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Tlsa_Input =
  {
    certData: Scalars['String']['input'];
    matchingType: Scalars['Int']['input'];
    selector: Scalars['Int']['input'];
    usage: Scalars['Int']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Txt =
  {
    content: Scalars['String']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Spec_Records_Items_Txt_Input =
  {
    content: Scalars['String']['input'];
  };

/** status defines the observed state of DNSRecordSet */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status =
  {
    /** Conditions includes Accepted and Programmed readiness. */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_Conditions_Items>
      >
    >;
    /** RecordSets captures per-owner (per name) status and conditions. */
    recordSets?: Maybe<
      Array<
        Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_RecordSets_Items>
      >
    >;
  };

/** status defines the observed state of DNSRecordSet */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_Input =
  {
    /** Conditions includes Accepted and Programmed readiness. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /** RecordSets captures per-owner (per name) status and conditions. */
    recordSets?: InputMaybe<
      Array<
        InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_RecordSets_Items_Input>
      >
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_RecordSets_Items =
  {
    /** Conditions captures per-name readiness information such as RecordProgrammed. */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_RecordSets_Items_Conditions_Items>
      >
    >;
    /** Name is the owner name this status pertains to. */
    name: Scalars['String']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_RecordSets_Items_Input =
  {
    /** Conditions captures per-name readiness information such as RecordProgrammed. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_RecordSets_Items_Conditions_Items_Input>
      >
    >;
    /** Name is the owner name this status pertains to. */
    name: Scalars['String']['input'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_RecordSets_Items_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_recordSets_items_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_recordSets_items_conditions_items_reason']['output'];
    status: Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_RecordSets_Items_Conditions_Items_Status;
    type: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_recordSets_items_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_RecordSets_Items_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_recordSets_items_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_recordSets_items_conditions_items_reason']['input'];
    status: Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_RecordSets_Items_Conditions_Items_Status;
    type: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSRecordSetForAllNamespaces_items_items_status_recordSets_items_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsRecordSetForAllNamespaces_Items_Items_Status_RecordSets_Items_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** spec defines the desired state of DNSZoneClass */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec = {
  /** ControllerName identifies the downstream controller/backend implementation (e.g., "powerdns", "hickory"). */
  controllerName: Scalars['String']['output'];
  defaults?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec_Defaults>;
  nameServerPolicy?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec_NameServerPolicy>;
};

/** spec defines the desired state of DNSZoneClass */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec_Input = {
  /** ControllerName identifies the downstream controller/backend implementation (e.g., "powerdns", "hickory"). */
  controllerName: Scalars['String']['input'];
  defaults?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec_Defaults_Input>;
  nameServerPolicy?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec_NameServerPolicy_Input>;
};

/** Defaults provides optional default values applied to managed zones. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec_Defaults = {
  /** DefaultTTL is the default TTL applied to records when not otherwise specified. */
  defaultTTL?: Maybe<Scalars['BigInt']['output']>;
};

/** Defaults provides optional default values applied to managed zones. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec_Defaults_Input =
  {
    /** DefaultTTL is the default TTL applied to records when not otherwise specified. */
    defaultTTL?: InputMaybe<Scalars['BigInt']['input']>;
  };

/** NameServerPolicy defines how nameservers are assigned for zones using this class. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec_NameServerPolicy =
  {
    mode: Static_Const;
    static?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec_NameServerPolicy_Static>;
  };

/** NameServerPolicy defines how nameservers are assigned for zones using this class. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec_NameServerPolicy_Input =
  {
    mode: Static_Const;
    static?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec_NameServerPolicy_Static_Input>;
  };

/** Static contains a static list of authoritative nameservers when Mode == "Static". */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec_NameServerPolicy_Static =
  {
    servers: Array<Maybe<Scalars['String']['output']>>;
  };

/** Static contains a static list of authoritative nameservers when Mode == "Static". */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Spec_NameServerPolicy_Static_Input =
  {
    servers: Array<InputMaybe<Scalars['String']['input']>>;
  };

/** status defines the observed state of DNSZoneClass */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Status = {
  /**
   * Conditions represent the current state of the resource. Common types include
   * "Accepted" and "Programmed" to standardize readiness reporting across controllers.
   */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Status_Conditions_Items>
    >
  >;
};

/** status defines the observed state of DNSZoneClass */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Status_Input = {
  /**
   * Conditions represent the current state of the resource. Common types include
   * "Accepted" and "Programmed" to standardize readiness reporting across controllers.
   */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Status_Conditions_Items_Input>
    >
  >;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneClass_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneClass_items_items_status_conditions_items_reason']['output'];
    status: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneClass_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneClass_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneClass_items_items_status_conditions_items_reason']['input'];
    status: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneClass_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneClass_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** spec defines the desired target for discovery. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Spec =
  {
    dnsZoneRef: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Spec_DnsZoneRef;
  };

/** spec defines the desired target for discovery. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Spec_Input =
  {
    dnsZoneRef: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Spec_DnsZoneRef_Input;
  };

/** DNSZoneRef references the DNSZone (same namespace) this discovery targets. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Spec_DnsZoneRef =
  {
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: Maybe<Scalars['String']['output']>;
  };

/** DNSZoneRef references the DNSZone (same namespace) this discovery targets. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Spec_DnsZoneRef_Input =
  {
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: InputMaybe<Scalars['String']['input']>;
  };

/** status contains the discovered data (write-once). */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status =
  {
    /** Conditions includes Accepted and Discovered. */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_Conditions_Items>
      >
    >;
    /** RecordSets is the set of discovered RRsets grouped by RecordType. */
    recordSets?: Maybe<
      Array<
        Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items>
      >
    >;
  };

/** status contains the discovered data (write-once). */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_Input =
  {
    /** Conditions includes Accepted and Discovered. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /** RecordSets is the set of discovered RRsets grouped by RecordType. */
    recordSets?: InputMaybe<
      Array<
        InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Input>
      >
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** DiscoveredRecordSet groups discovered records by type. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items =
  {
    recordType: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_RecordType;
    /**
     * Records contains one or more owner names with values appropriate for the RecordType.
     * The RecordEntry schema is shared with DNSRecordSet for easy translation.
     */
    records: Array<
      Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items>
    >;
  };

/** DiscoveredRecordSet groups discovered records by type. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Input =
  {
    recordType: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_RecordType;
    /**
     * Records contains one or more owner names with values appropriate for the RecordType.
     * The RecordEntry schema is shared with DNSRecordSet for easy translation.
     */
    records: Array<
      InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Input>
    >;
  };

/** RecordType is the DNS RR type for this recordset. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_RecordType =

    | 'A'
    | 'AAAA'
    | 'ALIAS'
    | 'CAA'
    | 'CNAME'
    | 'HTTPS'
    | 'MX'
    | 'NS'
    | 'PTR'
    | 'SOA'
    | 'SRV'
    | 'SVCB'
    | 'TLSA'
    | 'TXT';

/** RecordEntry represents one owner name and its values. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items =
  {
    a?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_A>;
    aaaa?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Aaaa>;
    alias?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Alias>;
    caa?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Caa>;
    cname?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Cname>;
    https?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Https>;
    mx?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Mx>;
    name: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_name']['output'];
    ns?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Ns>;
    ptr?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Ptr>;
    soa?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Soa>;
    srv?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Srv>;
    svcb?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Svcb>;
    tlsa?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Tlsa>;
    /** TTL optionally overrides TTL for this owner/RRset. */
    ttl?: Maybe<Scalars['BigInt']['output']>;
    txt?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Txt>;
  };

/** RecordEntry represents one owner name and its values. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Input =
  {
    a?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_A_Input>;
    aaaa?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Aaaa_Input>;
    alias?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Alias_Input>;
    caa?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Caa_Input>;
    cname?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Cname_Input>;
    https?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Https_Input>;
    mx?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Mx_Input>;
    name: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_name']['input'];
    ns?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Ns_Input>;
    ptr?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Ptr_Input>;
    soa?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Soa_Input>;
    srv?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Srv_Input>;
    svcb?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Svcb_Input>;
    tlsa?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Tlsa_Input>;
    /** TTL optionally overrides TTL for this owner/RRset. */
    ttl?: InputMaybe<Scalars['BigInt']['input']>;
    txt?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Txt_Input>;
  };

/** Exactly one of the following type-specific fields should be set matching RecordType. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_A =
  {
    content: Scalars['IPv4']['output'];
  };

/** Exactly one of the following type-specific fields should be set matching RecordType. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_A_Input =
  {
    content: Scalars['IPv4']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Aaaa =
  {
    content: Scalars['IPv6']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Aaaa_Input =
  {
    content: Scalars['IPv6']['input'];
  };

/**
 * ALIASRecordSpec is like CNAME but intended for providers that implement an ALIAS/ANAME-style record.
 * The content is a hostname (FQDN or relative) with an optional trailing dot.
 */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Alias =
  {
    content: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_alias_content']['output'];
  };

/**
 * ALIASRecordSpec is like CNAME but intended for providers that implement an ALIAS/ANAME-style record.
 * The content is a hostname (FQDN or relative) with an optional trailing dot.
 */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Alias_Input =
  {
    content: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_alias_content']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Caa =
  {
    /** 0255 flag */
    flag: Scalars['NonNegativeInt']['output'];
    tag: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_caa_tag']['output'];
    value: Scalars['NonEmptyString']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Caa_Input =
  {
    /** 0255 flag */
    flag: Scalars['NonNegativeInt']['input'];
    tag: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_caa_tag']['input'];
    value: Scalars['NonEmptyString']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Cname =
  {
    content: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_cname_content']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Cname_Input =
  {
    content: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_cname_content']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Https =
  {
    params?: Maybe<Scalars['JSON']['output']>;
    priority: Scalars['NonNegativeInt']['output'];
    target: Scalars['String']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Https_Input =
  {
    params?: InputMaybe<Scalars['JSON']['input']>;
    priority: Scalars['NonNegativeInt']['input'];
    target: Scalars['String']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Mx =
  {
    exchange: Scalars['NonEmptyString']['output'];
    preference: Scalars['NonNegativeInt']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Mx_Input =
  {
    exchange: Scalars['NonEmptyString']['input'];
    preference: Scalars['NonNegativeInt']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Ns =
  {
    content: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_ns_content']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Ns_Input =
  {
    content: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneDiscoveryForAllNamespaces_items_items_status_recordSets_items_records_items_ns_content']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Ptr =
  {
    content: Scalars['String']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Ptr_Input =
  {
    content: Scalars['String']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Soa =
  {
    expire?: Maybe<Scalars['Int']['output']>;
    mname: Scalars['NonEmptyString']['output'];
    refresh?: Maybe<Scalars['Int']['output']>;
    retry?: Maybe<Scalars['Int']['output']>;
    rname: Scalars['NonEmptyString']['output'];
    serial?: Maybe<Scalars['Int']['output']>;
    ttl?: Maybe<Scalars['Int']['output']>;
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Soa_Input =
  {
    expire?: InputMaybe<Scalars['Int']['input']>;
    mname: Scalars['NonEmptyString']['input'];
    refresh?: InputMaybe<Scalars['Int']['input']>;
    retry?: InputMaybe<Scalars['Int']['input']>;
    rname: Scalars['NonEmptyString']['input'];
    serial?: InputMaybe<Scalars['Int']['input']>;
    ttl?: InputMaybe<Scalars['Int']['input']>;
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Srv =
  {
    port: Scalars['NonNegativeInt']['output'];
    priority: Scalars['NonNegativeInt']['output'];
    target: Scalars['NonEmptyString']['output'];
    weight: Scalars['NonNegativeInt']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Srv_Input =
  {
    port: Scalars['NonNegativeInt']['input'];
    priority: Scalars['NonNegativeInt']['input'];
    target: Scalars['NonEmptyString']['input'];
    weight: Scalars['NonNegativeInt']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Svcb =
  {
    params?: Maybe<Scalars['JSON']['output']>;
    priority: Scalars['NonNegativeInt']['output'];
    target: Scalars['String']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Svcb_Input =
  {
    params?: InputMaybe<Scalars['JSON']['input']>;
    priority: Scalars['NonNegativeInt']['input'];
    target: Scalars['String']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Tlsa =
  {
    certData: Scalars['String']['output'];
    matchingType: Scalars['Int']['output'];
    selector: Scalars['Int']['output'];
    usage: Scalars['Int']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Tlsa_Input =
  {
    certData: Scalars['String']['input'];
    matchingType: Scalars['Int']['input'];
    selector: Scalars['Int']['input'];
    usage: Scalars['Int']['input'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Txt =
  {
    content: Scalars['String']['output'];
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneDiscoveryForAllNamespaces_Items_Items_Status_RecordSets_Items_Records_Items_Txt_Input =
  {
    content: Scalars['String']['input'];
  };

/** spec defines the desired state of DNSZone */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Spec = {
  /** DNSZoneClassName references the DNSZoneClass used to provision this zone. */
  dnsZoneClassName: Scalars['String']['output'];
  domainName: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneForAllNamespaces_items_items_spec_domainName']['output'];
};

/** spec defines the desired state of DNSZone */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Spec_Input =
  {
    /** DNSZoneClassName references the DNSZoneClass used to provision this zone. */
    dnsZoneClassName: Scalars['String']['input'];
    domainName: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneForAllNamespaces_items_items_spec_domainName']['input'];
  };

/** status defines the observed state of DNSZone */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status = {
  /** Conditions tracks state such as Accepted and Programmed readiness. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
  domainRef?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef>;
  /** Nameservers lists the active authoritative nameservers for this zone. */
  nameservers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** RecordCount is the number of DNSRecordSet resources in this namespace that reference this zone. */
  recordCount?: Maybe<Scalars['Int']['output']>;
};

/** status defines the observed state of DNSZone */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_Input =
  {
    /** Conditions tracks state such as Accepted and Programmed readiness. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    domainRef?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef_Input>;
    /** Nameservers lists the active authoritative nameservers for this zone. */
    nameservers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /** RecordCount is the number of DNSRecordSet resources in this namespace that reference this zone. */
    recordCount?: InputMaybe<Scalars['Int']['input']>;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listDnsNetworkingMiloapisComV1alpha1DNSZoneForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** DomainRef references the Domain this zone belongs to. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef =
  {
    name: Scalars['String']['output'];
    status?: Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef_Status>;
  };

/** DomainRef references the Domain this zone belongs to. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef_Input =
  {
    name: Scalars['String']['input'];
    status?: InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef_Status_Input>;
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef_Status =
  {
    nameservers?: Maybe<
      Array<
        Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef_Status_Nameservers_Items>
      >
    >;
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef_Status_Input =
  {
    nameservers?: InputMaybe<
      Array<
        InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef_Status_Nameservers_Items_Input>
      >
    >;
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef_Status_Nameservers_Items =
  {
    hostname: Scalars['String']['output'];
    ips?: Maybe<
      Array<
        Maybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef_Status_Nameservers_Items_Ips_Items>
      >
    >;
  };

export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef_Status_Nameservers_Items_Input =
  {
    hostname: Scalars['String']['input'];
    ips?: InputMaybe<
      Array<
        InputMaybe<Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef_Status_Nameservers_Items_Ips_Items_Input>
      >
    >;
  };

/** NameserverIP captures per-address provenance for a nameserver. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef_Status_Nameservers_Items_Ips_Items =
  {
    address: Scalars['String']['output'];
    registrantName?: Maybe<Scalars['String']['output']>;
  };

/** NameserverIP captures per-address provenance for a nameserver. */
export type Query_ListDnsNetworkingMiloapisComV1alpha1DnsZoneForAllNamespaces_Items_Items_Status_DomainRef_Status_Nameservers_Items_Ips_Items_Input =
  {
    address: Scalars['String']['input'];
    registrantName?: InputMaybe<Scalars['String']['input']>;
  };

/** DocumentMetadata defines the metadata of the Document. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_DocumentMetadata =
  {
    /** Category is the category of the Document. */
    category: Scalars['String']['output'];
    /** Jurisdiction is the jurisdiction of the Document. */
    jurisdiction: Scalars['String']['output'];
  };

/** DocumentMetadata defines the metadata of the Document. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_DocumentMetadata_Input =
  {
    /** Category is the category of the Document. */
    category: Scalars['String']['input'];
    /** Jurisdiction is the jurisdiction of the Document. */
    jurisdiction: Scalars['String']['input'];
  };

/** DocumentSpec defines the desired state of Document. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Spec = {
  /** Description is the description of the Document. */
  description: Scalars['String']['output'];
  /** DocumentType is the type of the document. */
  documentType: Scalars['String']['output'];
  /** Title is the title of the Document. */
  title: Scalars['String']['output'];
};

/** DocumentSpec defines the desired state of Document. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Spec_Input =
  {
    /** Description is the description of the Document. */
    description: Scalars['String']['input'];
    /** DocumentType is the type of the document. */
    documentType: Scalars['String']['input'];
    /** Title is the title of the Document. */
    title: Scalars['String']['input'];
  };

/** DocumentStatus defines the observed state of Document. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status =
  {
    /** Conditions represent the latest available observations of an object's current state. */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status_Conditions_Items>
      >
    >;
    latestRevisionRef?: Maybe<Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status_LatestRevisionRef>;
  };

/** DocumentStatus defines the observed state of Document. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status_Input =
  {
    /** Conditions represent the latest available observations of an object's current state. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    latestRevisionRef?: InputMaybe<Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status_LatestRevisionRef_Input>;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** LatestRevisionRef is a reference to the latest revision of the document. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status_LatestRevisionRef =
  {
    name?: Maybe<Scalars['String']['output']>;
    namespace?: Maybe<Scalars['String']['output']>;
    publishedAt?: Maybe<Scalars['DateTime']['output']>;
    version?: Maybe<
      Scalars['query_listDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_items_items_status_latestRevisionRef_version']['output']
    >;
  };

/** LatestRevisionRef is a reference to the latest revision of the document. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_Items_Items_Status_LatestRevisionRef_Input =
  {
    name?: InputMaybe<Scalars['String']['input']>;
    namespace?: InputMaybe<Scalars['String']['input']>;
    publishedAt?: InputMaybe<Scalars['DateTime']['input']>;
    version?: InputMaybe<
      Scalars['query_listDocumentationMiloapisComV1alpha1DocumentForAllNamespaces_items_items_status_latestRevisionRef_version']['input']
    >;
  };

/** DocumentRevisionSpec defines the desired state of DocumentRevision. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec =
  {
    /** ChangesSummary is the summary of the changes in the document revision. */
    changesSummary: Scalars['String']['output'];
    content: Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_Content;
    documentRef: Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_DocumentRef;
    /** EffectiveDate is the date in which the document revision starts to be effective. */
    effectiveDate: Scalars['DateTime']['output'];
    /** ExpectedAccepterKinds is the resource kinds that are expected to accept this revision. */
    expectedAccepterKinds: Array<
      Maybe<Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_ExpectedAccepterKinds_Items>
    >;
    /** ExpectedSubjectKinds is the resource kinds that this revision affects to. */
    expectedSubjectKinds: Array<
      Maybe<Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_ExpectedSubjectKinds_Items>
    >;
    version: Scalars['query_listDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_items_items_spec_version']['output'];
  };

/** DocumentRevisionSpec defines the desired state of DocumentRevision. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_Input =
  {
    /** ChangesSummary is the summary of the changes in the document revision. */
    changesSummary: Scalars['String']['input'];
    content: Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_Content_Input;
    documentRef: Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_DocumentRef_Input;
    /** EffectiveDate is the date in which the document revision starts to be effective. */
    effectiveDate: Scalars['DateTime']['input'];
    /** ExpectedAccepterKinds is the resource kinds that are expected to accept this revision. */
    expectedAccepterKinds: Array<
      InputMaybe<Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_ExpectedAccepterKinds_Items_Input>
    >;
    /** ExpectedSubjectKinds is the resource kinds that this revision affects to. */
    expectedSubjectKinds: Array<
      InputMaybe<Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_ExpectedSubjectKinds_Items_Input>
    >;
    version: Scalars['query_listDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_items_items_spec_version']['input'];
  };

/** Content is the content of the document revision. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_Content =
  {
    /** Data is the data of the document revision. */
    data: Scalars['String']['output'];
    format: Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_Content_Format;
  };

/** Content is the content of the document revision. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_Content_Input =
  {
    /** Data is the data of the document revision. */
    data: Scalars['String']['input'];
    format: Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_Content_Format;
  };

/** Format is the format of the document revision. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_Content_Format =
  'html' | 'markdown';

/** DocumentRef is a reference to the document that this revision is based on. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_DocumentRef =
  {
    /** Name is the name of the Document being referenced. */
    name: Scalars['String']['output'];
    /** Namespace of the referenced Document. */
    namespace: Scalars['String']['output'];
  };

/** DocumentRef is a reference to the document that this revision is based on. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_DocumentRef_Input =
  {
    /** Name is the name of the Document being referenced. */
    name: Scalars['String']['input'];
    /** Namespace of the referenced Document. */
    namespace: Scalars['String']['input'];
  };

/** DocumentRevisionExpectedAccepterKind is the kind of the resource that is expected to accept this revision. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_ExpectedAccepterKinds_Items =
  {
    /** APIGroup is the group for the resource being referenced. */
    apiGroup: Scalars['String']['output'];
    kind: Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_ExpectedAccepterKinds_Items_Kind;
  };

/** DocumentRevisionExpectedAccepterKind is the kind of the resource that is expected to accept this revision. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_ExpectedAccepterKinds_Items_Input =
  {
    /** APIGroup is the group for the resource being referenced. */
    apiGroup: Scalars['String']['input'];
    kind: Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_ExpectedAccepterKinds_Items_Kind;
  };

/** Kind is the type of resource being referenced. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_ExpectedAccepterKinds_Items_Kind =
  'MachineAccount' | 'User';

/** DocumentRevisionExpectedSubjectKind is the kind of the resource that is expected to reference this revision. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_ExpectedSubjectKinds_Items =
  {
    apiGroup: Resourcemanager_Miloapis_Com_Const;
    kind: Organization_Const;
  };

/** DocumentRevisionExpectedSubjectKind is the kind of the resource that is expected to reference this revision. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Spec_ExpectedSubjectKinds_Items_Input =
  {
    apiGroup: Resourcemanager_Miloapis_Com_Const;
    kind: Organization_Const;
  };

/** DocumentRevisionStatus defines the observed state of DocumentRevision. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Status =
  {
    /** Conditions represent the latest available observations of an object's current state. */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Status_Conditions_Items>
      >
    >;
    /**
     * ContentHash is the hash of the content of the document revision.
     * This is used to detect if the content of the document revision has changed.
     */
    contentHash?: Maybe<Scalars['String']['output']>;
  };

/** DocumentRevisionStatus defines the observed state of DocumentRevision. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Status_Input =
  {
    /** Conditions represent the latest available observations of an object's current state. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /**
     * ContentHash is the hash of the content of the document revision.
     * This is used to detect if the content of the document revision has changed.
     */
    contentHash?: InputMaybe<Scalars['String']['input']>;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListDocumentationMiloapisComV1alpha1DocumentRevisionForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** Spec defines the desired state of Backend. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec = {
  /** AppProtocols defines the application protocols to be supported when connecting to the backend. */
  appProtocols?: Maybe<
    Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_AppProtocols_Items>
    >
  >;
  /** Endpoints defines the endpoints to be used when connecting to the backend. */
  endpoints?: Maybe<
    Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items>
    >
  >;
  /**
   * Fallback indicates whether the backend is designated as a fallback.
   * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
   * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
   * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
   * the health of the active backends falls below 72%.
   */
  fallback?: Maybe<Scalars['Boolean']['output']>;
  tls?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Tls>;
  type?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Type>;
};

/** Spec defines the desired state of Backend. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Input = {
  /** AppProtocols defines the application protocols to be supported when connecting to the backend. */
  appProtocols?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_AppProtocols_Items>
    >
  >;
  /** Endpoints defines the endpoints to be used when connecting to the backend. */
  endpoints?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items_Input>
    >
  >;
  /**
   * Fallback indicates whether the backend is designated as a fallback.
   * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
   * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
   * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
   * the health of the active backends falls below 72%.
   */
  fallback?: InputMaybe<Scalars['Boolean']['input']>;
  tls?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Tls_Input>;
  type?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Type>;
};

/** AppProtocolType defines various backend applications protocols supported by Envoy Gateway */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_AppProtocols_Items =
  'gateway_envoyproxy_io_h2c' | 'gateway_envoyproxy_io_ws' | 'gateway_envoyproxy_io_wss';

/**
 * BackendEndpoint describes a backend endpoint, which can be either a fully-qualified domain name, IP address or unix domain socket
 * corresponding to Envoy's Address: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items =
  {
    fqdn?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items_Fqdn>;
    hostname?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_endpoints_items_hostname']['output']
    >;
    ip?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items_Ip>;
    unix?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items_Unix>;
    /** Zone defines the service zone of the backend endpoint. */
    zone?: Maybe<Scalars['String']['output']>;
  };

/**
 * BackendEndpoint describes a backend endpoint, which can be either a fully-qualified domain name, IP address or unix domain socket
 * corresponding to Envoy's Address: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items_Input =
  {
    fqdn?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items_Fqdn_Input>;
    hostname?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_endpoints_items_hostname']['input']
    >;
    ip?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items_Ip_Input>;
    unix?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items_Unix_Input>;
    /** Zone defines the service zone of the backend endpoint. */
    zone?: InputMaybe<Scalars['String']['input']>;
  };

/** FQDN defines a FQDN endpoint */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items_Fqdn =
  {
    hostname: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_endpoints_items_fqdn_hostname']['output'];
    /** Port defines the port of the backend endpoint. */
    port: Scalars['Int']['output'];
  };

/** FQDN defines a FQDN endpoint */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items_Fqdn_Input =
  {
    hostname: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_endpoints_items_fqdn_hostname']['input'];
    /** Port defines the port of the backend endpoint. */
    port: Scalars['Int']['input'];
  };

/** IP defines an IP endpoint. Supports both IPv4 and IPv6 addresses. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items_Ip =
  {
    address: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_endpoints_items_ip_address']['output'];
    /** Port defines the port of the backend endpoint. */
    port: Scalars['Int']['output'];
  };

/** IP defines an IP endpoint. Supports both IPv4 and IPv6 addresses. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items_Ip_Input =
  {
    address: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_endpoints_items_ip_address']['input'];
    /** Port defines the port of the backend endpoint. */
    port: Scalars['Int']['input'];
  };

/** Unix defines the unix domain socket endpoint */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items_Unix =
  {
    /**
     * Path defines the unix domain socket path of the backend endpoint.
     * The path length must not exceed 108 characters.
     */
    path: Scalars['String']['output'];
  };

/** Unix defines the unix domain socket endpoint */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Endpoints_Items_Unix_Input =
  {
    /**
     * Path defines the unix domain socket path of the backend endpoint.
     * The path length must not exceed 108 characters.
     */
    path: Scalars['String']['input'];
  };

/**
 * TLS defines the TLS settings for the backend.
 * If TLS is specified here and a BackendTLSPolicy is also configured for the backend, the final TLS settings will
 * be a merge of both configurations. In case of overlapping fields, the values defined in the BackendTLSPolicy will
 * take precedence.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Tls = {
  /**
   * CACertificateRefs contains one or more references to Kubernetes objects that
   * contain TLS certificates of the Certificate Authorities that can be used
   * as a trust anchor to validate the certificates presented by the backend.
   *
   * A single reference to a Kubernetes ConfigMap or a Kubernetes Secret,
   * with the CA certificate in a key named `ca.crt` is currently supported.
   *
   * If CACertificateRefs is empty or unspecified, then WellKnownCACertificates must be
   * specified. Only one of CACertificateRefs or WellKnownCACertificates may be specified,
   * not both.
   */
  caCertificateRefs?: Maybe<
    Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Tls_CaCertificateRefs_Items>
    >
  >;
  /**
   * InsecureSkipVerify indicates whether the upstream's certificate verification
   * should be skipped. Defaults to "false".
   */
  insecureSkipVerify?: Maybe<Scalars['Boolean']['output']>;
  wellKnownCACertificates?: Maybe<System_Const>;
};

/**
 * TLS defines the TLS settings for the backend.
 * If TLS is specified here and a BackendTLSPolicy is also configured for the backend, the final TLS settings will
 * be a merge of both configurations. In case of overlapping fields, the values defined in the BackendTLSPolicy will
 * take precedence.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Tls_Input =
  {
    /**
     * CACertificateRefs contains one or more references to Kubernetes objects that
     * contain TLS certificates of the Certificate Authorities that can be used
     * as a trust anchor to validate the certificates presented by the backend.
     *
     * A single reference to a Kubernetes ConfigMap or a Kubernetes Secret,
     * with the CA certificate in a key named `ca.crt` is currently supported.
     *
     * If CACertificateRefs is empty or unspecified, then WellKnownCACertificates must be
     * specified. Only one of CACertificateRefs or WellKnownCACertificates may be specified,
     * not both.
     */
    caCertificateRefs?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Tls_CaCertificateRefs_Items_Input>
      >
    >;
    /**
     * InsecureSkipVerify indicates whether the upstream's certificate verification
     * should be skipped. Defaults to "false".
     */
    insecureSkipVerify?: InputMaybe<Scalars['Boolean']['input']>;
    wellKnownCACertificates?: InputMaybe<System_Const>;
  };

/**
 * LocalObjectReference identifies an API object within the namespace of the
 * referrer.
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Tls_CaCertificateRefs_Items =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_tls_caCertificateRefs_items_group']['output'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_tls_caCertificateRefs_items_kind']['output'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_tls_caCertificateRefs_items_name']['output'];
  };

/**
 * LocalObjectReference identifies an API object within the namespace of the
 * referrer.
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Tls_CaCertificateRefs_Items_Input =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_tls_caCertificateRefs_items_group']['input'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_tls_caCertificateRefs_items_kind']['input'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_spec_tls_caCertificateRefs_items_name']['input'];
  };

/** Type defines the type of the backend. Defaults to "Endpoints" */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Spec_Type =
  | 'DynamicResolver'
  | 'Endpoints';

/** Status defines the current status of Backend. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Status = {
  /** Conditions describe the current conditions of the Backend. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
};

/** Status defines the current status of Backend. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Status_Input =
  {
    /** Conditions describe the current conditions of the Backend. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** spec defines the desired state of BackendTrafficPolicy. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec =
  {
    circuitBreaker?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_CircuitBreaker>;
    /** The compression config for the http streams. */
    compression?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Compression_Items>
      >
    >;
    connection?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Connection>;
    dns?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Dns>;
    faultInjection?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_FaultInjection>;
    healthCheck?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck>;
    http2?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Http2>;
    /**
     * HTTPUpgrade defines the configuration for HTTP protocol upgrades.
     * If not specified, the default upgrade configuration(websocket) will be used.
     */
    httpUpgrade?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HttpUpgrade_Items>
      >
    >;
    loadBalancer?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer>;
    /**
     * MergeType determines how this configuration is merged with existing BackendTrafficPolicy
     * configurations targeting a parent resource. When set, this configuration will be merged
     * into a parent BackendTrafficPolicy (i.e. the one targeting a Gateway or Listener).
     * This field cannot be set when targeting a parent resource (Gateway).
     * If unset, no merging occurs, and only the most specific configuration takes effect.
     */
    mergeType?: Maybe<Scalars['String']['output']>;
    proxyProtocol?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ProxyProtocol>;
    rateLimit?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit>;
    requestBuffer?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RequestBuffer>;
    /**
     * ResponseOverride defines the configuration to override specific responses with a custom one.
     * If multiple configurations are specified, the first one to match wins.
     */
    responseOverride?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items>
      >
    >;
    retry?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry>;
    targetRef?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetRef>;
    /**
     * TargetRefs are the names of the Gateway resources this policy
     * is being attached to.
     */
    targetRefs?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetRefs_Items>
      >
    >;
    /** TargetSelectors allow targeting resources for this policy based on labels */
    targetSelectors?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetSelectors_Items>
      >
    >;
    tcpKeepalive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TcpKeepalive>;
    telemetry?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry>;
    timeout?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Timeout>;
    /**
     * UseClientProtocol configures Envoy to prefer sending requests to backends using
     * the same HTTP protocol that the incoming request used. Defaults to false, which means
     * that Envoy will use the protocol indicated by the attached BackendRef.
     */
    useClientProtocol?: Maybe<Scalars['Boolean']['output']>;
  };

/** spec defines the desired state of BackendTrafficPolicy. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Input =
  {
    circuitBreaker?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_CircuitBreaker_Input>;
    /** The compression config for the http streams. */
    compression?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Compression_Items_Input>
      >
    >;
    connection?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Connection_Input>;
    dns?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Dns_Input>;
    faultInjection?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_FaultInjection_Input>;
    healthCheck?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Input>;
    http2?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Http2_Input>;
    /**
     * HTTPUpgrade defines the configuration for HTTP protocol upgrades.
     * If not specified, the default upgrade configuration(websocket) will be used.
     */
    httpUpgrade?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HttpUpgrade_Items_Input>
      >
    >;
    loadBalancer?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_Input>;
    /**
     * MergeType determines how this configuration is merged with existing BackendTrafficPolicy
     * configurations targeting a parent resource. When set, this configuration will be merged
     * into a parent BackendTrafficPolicy (i.e. the one targeting a Gateway or Listener).
     * This field cannot be set when targeting a parent resource (Gateway).
     * If unset, no merging occurs, and only the most specific configuration takes effect.
     */
    mergeType?: InputMaybe<Scalars['String']['input']>;
    proxyProtocol?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ProxyProtocol_Input>;
    rateLimit?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Input>;
    requestBuffer?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RequestBuffer_Input>;
    /**
     * ResponseOverride defines the configuration to override specific responses with a custom one.
     * If multiple configurations are specified, the first one to match wins.
     */
    responseOverride?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Input>
      >
    >;
    retry?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_Input>;
    targetRef?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetRef_Input>;
    /**
     * TargetRefs are the names of the Gateway resources this policy
     * is being attached to.
     */
    targetRefs?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetRefs_Items_Input>
      >
    >;
    /** TargetSelectors allow targeting resources for this policy based on labels */
    targetSelectors?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetSelectors_Items_Input>
      >
    >;
    tcpKeepalive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TcpKeepalive_Input>;
    telemetry?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Input>;
    timeout?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Timeout_Input>;
    /**
     * UseClientProtocol configures Envoy to prefer sending requests to backends using
     * the same HTTP protocol that the incoming request used. Defaults to false, which means
     * that Envoy will use the protocol indicated by the attached BackendRef.
     */
    useClientProtocol?: InputMaybe<Scalars['Boolean']['input']>;
  };

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_CircuitBreaker =
  {
    /** The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule. */
    maxConnections?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRequests?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRetries?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule. */
    maxPendingRequests?: Maybe<Scalars['BigInt']['output']>;
    /**
     * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
     * Default: unlimited.
     */
    maxRequestsPerConnection?: Maybe<Scalars['BigInt']['output']>;
    perEndpoint?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_CircuitBreaker_PerEndpoint>;
  };

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_CircuitBreaker_Input =
  {
    /** The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule. */
    maxConnections?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRequests?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRetries?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule. */
    maxPendingRequests?: InputMaybe<Scalars['BigInt']['input']>;
    /**
     * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
     * Default: unlimited.
     */
    maxRequestsPerConnection?: InputMaybe<Scalars['BigInt']['input']>;
    perEndpoint?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_CircuitBreaker_PerEndpoint_Input>;
  };

/** PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_CircuitBreaker_PerEndpoint =
  {
    /** MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule. */
    maxConnections?: Maybe<Scalars['BigInt']['output']>;
  };

/** PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_CircuitBreaker_PerEndpoint_Input =
  {
    /** MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule. */
    maxConnections?: InputMaybe<Scalars['BigInt']['input']>;
  };

/**
 * Compression defines the config of enabling compression.
 * This can help reduce the bandwidth at the expense of higher CPU.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Compression_Items =
  {
    brotli?: Maybe<Scalars['JSON']['output']>;
    gzip?: Maybe<Scalars['JSON']['output']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Compression_Items_Type;
  };

/**
 * Compression defines the config of enabling compression.
 * This can help reduce the bandwidth at the expense of higher CPU.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Compression_Items_Input =
  {
    brotli?: InputMaybe<Scalars['JSON']['input']>;
    gzip?: InputMaybe<Scalars['JSON']['input']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Compression_Items_Type;
  };

/** CompressorType defines the compressor type to use for compression. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Compression_Items_Type =
  'Brotli' | 'Gzip';

/** Connection includes backend connection settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Connection =
  {
    /**
     * BufferLimit Soft limit on size of the clusters connections read and write buffers.
     * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
     * If unspecified, an implementation defined default is applied (32768 bytes).
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note: that when the suffix is not provided, the value is interpreted as bytes.
     */
    bufferLimit?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Connection_BufferLimit>;
    /**
     * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
     * to backend.
     * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note that when the suffix is not provided, the value is interpreted as bytes.
     */
    socketBufferLimit?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Connection_SocketBufferLimit>;
  };

/** Connection includes backend connection settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Connection_Input =
  {
    /**
     * BufferLimit Soft limit on size of the clusters connections read and write buffers.
     * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
     * If unspecified, an implementation defined default is applied (32768 bytes).
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note: that when the suffix is not provided, the value is interpreted as bytes.
     */
    bufferLimit?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
     * to backend.
     * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note that when the suffix is not provided, the value is interpreted as bytes.
     */
    socketBufferLimit?: InputMaybe<Scalars['JSON']['input']>;
  };

/**
 * BufferLimit Soft limit on size of the clusters connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Connection_BufferLimit =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_connection_bufferLimit_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_connection_bufferLimit_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_connection_bufferLimit_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_connection_bufferLimit_allOf_1']['output']
    >;
  };

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Connection_SocketBufferLimit =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_connection_socketBufferLimit_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_connection_socketBufferLimit_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_connection_socketBufferLimit_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_connection_socketBufferLimit_allOf_1']['output']
    >;
  };

/** DNS includes dns resolution settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Dns =
  {
    dnsRefreshRate?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_dns_dnsRefreshRate']['output']
    >;
    lookupFamily?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Dns_LookupFamily>;
    /**
     * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
     * If the value is set to true, the DNS refresh rate will be set to the resource records TTL.
     * Defaults to true.
     */
    respectDnsTtl?: Maybe<Scalars['Boolean']['output']>;
  };

/** DNS includes dns resolution settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Dns_Input =
  {
    dnsRefreshRate?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_dns_dnsRefreshRate']['input']
    >;
    lookupFamily?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Dns_LookupFamily>;
    /**
     * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
     * If the value is set to true, the DNS refresh rate will be set to the resource records TTL.
     * Defaults to true.
     */
    respectDnsTtl?: InputMaybe<Scalars['Boolean']['input']>;
  };

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Dns_LookupFamily =
  'IPv4' | 'IPv4AndIPv6' | 'IPv4Preferred' | 'IPv6' | 'IPv6Preferred';

/**
 * FaultInjection defines the fault injection policy to be applied. This configuration can be used to
 * inject delays and abort requests to mimic failure scenarios such as service failures and overloads
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_FaultInjection =
  {
    abort?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_FaultInjection_Abort>;
    delay?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_FaultInjection_Delay>;
  };

/**
 * FaultInjection defines the fault injection policy to be applied. This configuration can be used to
 * inject delays and abort requests to mimic failure scenarios such as service failures and overloads
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_FaultInjection_Input =
  {
    abort?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_FaultInjection_Abort_Input>;
    delay?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_FaultInjection_Delay_Input>;
  };

/** If specified, the request will be aborted if it meets the configuration criteria. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_FaultInjection_Abort =
  {
    /** GrpcStatus specifies the GRPC status code to be returned */
    grpcStatus?: Maybe<Scalars['Int']['output']>;
    /** StatusCode specifies the HTTP status code to be returned */
    httpStatus?: Maybe<Scalars['Int']['output']>;
    /** Percentage specifies the percentage of requests to be aborted. Default 100%, if set 0, no requests will be aborted. Accuracy to 0.0001%. */
    percentage?: Maybe<Scalars['Float']['output']>;
  };

/** If specified, the request will be aborted if it meets the configuration criteria. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_FaultInjection_Abort_Input =
  {
    /** GrpcStatus specifies the GRPC status code to be returned */
    grpcStatus?: InputMaybe<Scalars['Int']['input']>;
    /** StatusCode specifies the HTTP status code to be returned */
    httpStatus?: InputMaybe<Scalars['Int']['input']>;
    /** Percentage specifies the percentage of requests to be aborted. Default 100%, if set 0, no requests will be aborted. Accuracy to 0.0001%. */
    percentage?: InputMaybe<Scalars['Float']['input']>;
  };

/** If specified, a delay will be injected into the request. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_FaultInjection_Delay =
  {
    fixedDelay: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_faultInjection_delay_fixedDelay']['output'];
    /** Percentage specifies the percentage of requests to be delayed. Default 100%, if set 0, no requests will be delayed. Accuracy to 0.0001%. */
    percentage?: Maybe<Scalars['Float']['output']>;
  };

/** If specified, a delay will be injected into the request. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_FaultInjection_Delay_Input =
  {
    fixedDelay: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_faultInjection_delay_fixedDelay']['input'];
    /** Percentage specifies the percentage of requests to be delayed. Default 100%, if set 0, no requests will be delayed. Accuracy to 0.0001%. */
    percentage?: InputMaybe<Scalars['Float']['input']>;
  };

/** HealthCheck allows gateway to perform active health checking on backends. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck =
  {
    active?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active>;
    /**
     * When number of unhealthy endpoints for a backend reaches this threshold
     * Envoy will disregard health status and balance across all endpoints.
     * It's designed to prevent a situation in which host failures cascade throughout the cluster
     * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
     */
    panicThreshold?: Maybe<Scalars['Int']['output']>;
    passive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Passive>;
  };

/** HealthCheck allows gateway to perform active health checking on backends. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Input =
  {
    active?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Input>;
    /**
     * When number of unhealthy endpoints for a backend reaches this threshold
     * Envoy will disregard health status and balance across all endpoints.
     * It's designed to prevent a situation in which host failures cascade throughout the cluster
     * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
     */
    panicThreshold?: InputMaybe<Scalars['Int']['input']>;
    passive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Passive_Input>;
  };

/** Active health check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active =
  {
    grpc?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Grpc>;
    /** HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy. */
    healthyThreshold?: Maybe<Scalars['Int']['output']>;
    http?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Http>;
    initialJitter?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_initialJitter']['output']
    >;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_interval']['output']
    >;
    tcp?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Tcp>;
    timeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_timeout']['output']
    >;
    /** Type defines the type of health checker. */
    type: Scalars['String']['output'];
    /** UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy. */
    unhealthyThreshold?: Maybe<Scalars['Int']['output']>;
  };

/** Active health check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Input =
  {
    grpc?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Grpc_Input>;
    /** HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy. */
    healthyThreshold?: InputMaybe<Scalars['Int']['input']>;
    http?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Http_Input>;
    initialJitter?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_initialJitter']['input']
    >;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_interval']['input']
    >;
    tcp?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Tcp_Input>;
    timeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_timeout']['input']
    >;
    /** Type defines the type of health checker. */
    type: Scalars['String']['input'];
    /** UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy. */
    unhealthyThreshold?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Grpc =
  {
    /**
     * Service to send in the health check request.
     * If this is not specified, then the health check request applies to the entire
     * server and not to a specific service.
     */
    service?: Maybe<Scalars['String']['output']>;
  };

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Grpc_Input =
  {
    /**
     * Service to send in the health check request.
     * If this is not specified, then the health check request applies to the entire
     * server and not to a specific service.
     */
    service?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Http =
  {
    expectedResponse?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Http_ExpectedResponse>;
    /**
     * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
     * Defaults to 200 only
     */
    expectedStatuses?: Maybe<Array<Maybe<Scalars['PositiveInt']['output']>>>;
    hostname?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_http_hostname']['output']
    >;
    /**
     * Method defines the HTTP method used for health checking.
     * Defaults to GET
     */
    method?: Maybe<Scalars['String']['output']>;
    /** Path defines the HTTP path that will be requested during health checking. */
    path: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_http_path']['output'];
  };

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Http_Input =
  {
    expectedResponse?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Http_ExpectedResponse_Input>;
    /**
     * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
     * Defaults to 200 only
     */
    expectedStatuses?: InputMaybe<Array<InputMaybe<Scalars['PositiveInt']['input']>>>;
    hostname?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_http_hostname']['input']
    >;
    /**
     * Method defines the HTTP method used for health checking.
     * Defaults to GET
     */
    method?: InputMaybe<Scalars['String']['input']>;
    /** Path defines the HTTP path that will be requested during health checking. */
    path: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_active_http_path']['input'];
  };

/** ExpectedResponse defines a list of HTTP expected responses to match. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Http_ExpectedResponse =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** ExpectedResponse defines a list of HTTP expected responses to match. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Http_ExpectedResponse_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Tcp =
  {
    receive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Tcp_Receive>;
    send?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Tcp_Send>;
  };

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Tcp_Input =
  {
    receive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Tcp_Receive_Input>;
    send?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Tcp_Send_Input>;
  };

/** Receive defines the expected response payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Tcp_Receive =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** Receive defines the expected response payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Tcp_Receive_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/** Send defines the request payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Tcp_Send =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** Send defines the request payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Active_Tcp_Send_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/** Passive passive check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Passive =
  {
    baseEjectionTime?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_passive_baseEjectionTime']['output']
    >;
    /** Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection. */
    consecutive5XxErrors?: Maybe<Scalars['Int']['output']>;
    /** ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection. */
    consecutiveGatewayErrors?: Maybe<Scalars['Int']['output']>;
    /**
     * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
     * Parameter takes effect only when split_external_local_origin_errors is set to true.
     */
    consecutiveLocalOriginFailures?: Maybe<Scalars['Int']['output']>;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_passive_interval']['output']
    >;
    /** MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected. */
    maxEjectionPercent?: Maybe<Scalars['Int']['output']>;
    /** SplitExternalLocalOriginErrors enables splitting of errors between external and local origin. */
    splitExternalLocalOriginErrors?: Maybe<Scalars['Boolean']['output']>;
  };

/** Passive passive check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HealthCheck_Passive_Input =
  {
    baseEjectionTime?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_passive_baseEjectionTime']['input']
    >;
    /** Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection. */
    consecutive5XxErrors?: InputMaybe<Scalars['Int']['input']>;
    /** ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection. */
    consecutiveGatewayErrors?: InputMaybe<Scalars['Int']['input']>;
    /**
     * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
     * Parameter takes effect only when split_external_local_origin_errors is set to true.
     */
    consecutiveLocalOriginFailures?: InputMaybe<Scalars['Int']['input']>;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_healthCheck_passive_interval']['input']
    >;
    /** MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected. */
    maxEjectionPercent?: InputMaybe<Scalars['Int']['input']>;
    /** SplitExternalLocalOriginErrors enables splitting of errors between external and local origin. */
    splitExternalLocalOriginErrors?: InputMaybe<Scalars['Boolean']['input']>;
  };

/** HTTP2 provides HTTP/2 configuration for backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Http2 =
  {
    /**
     * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
     * If not set, the default value is 1 MiB.
     */
    initialConnectionWindowSize?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Http2_InitialConnectionWindowSize>;
    /**
     * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
     * If not set, the default value is 64 KiB(64*1024).
     */
    initialStreamWindowSize?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Http2_InitialStreamWindowSize>;
    /**
     * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
     * If not set, the default value is 100.
     */
    maxConcurrentStreams?: Maybe<Scalars['Int']['output']>;
    /**
     * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
     * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
     * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
     * Default: TerminateConnection
     */
    onInvalidMessage?: Maybe<Scalars['String']['output']>;
  };

/** HTTP2 provides HTTP/2 configuration for backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Http2_Input =
  {
    /**
     * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
     * If not set, the default value is 1 MiB.
     */
    initialConnectionWindowSize?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
     * If not set, the default value is 64 KiB(64*1024).
     */
    initialStreamWindowSize?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
     * If not set, the default value is 100.
     */
    maxConcurrentStreams?: InputMaybe<Scalars['Int']['input']>;
    /**
     * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
     * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
     * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
     * Default: TerminateConnection
     */
    onInvalidMessage?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Http2_InitialConnectionWindowSize =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_http2_initialConnectionWindowSize_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_http2_initialConnectionWindowSize_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_http2_initialConnectionWindowSize_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_http2_initialConnectionWindowSize_allOf_1']['output']
    >;
  };

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Http2_InitialStreamWindowSize =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_http2_initialStreamWindowSize_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_http2_initialStreamWindowSize_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_http2_initialStreamWindowSize_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_http2_initialStreamWindowSize_allOf_1']['output']
    >;
  };

/** ProtocolUpgradeConfig specifies the configuration for protocol upgrades. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HttpUpgrade_Items =
  {
    connect?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HttpUpgrade_Items_Connect>;
    /**
     * Type is the case-insensitive type of protocol upgrade.
     * e.g. `websocket`, `CONNECT`, `spdy/3.1` etc.
     */
    type: Scalars['String']['output'];
  };

/** ProtocolUpgradeConfig specifies the configuration for protocol upgrades. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HttpUpgrade_Items_Input =
  {
    connect?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HttpUpgrade_Items_Connect_Input>;
    /**
     * Type is the case-insensitive type of protocol upgrade.
     * e.g. `websocket`, `CONNECT`, `spdy/3.1` etc.
     */
    type: Scalars['String']['input'];
  };

/**
 * Connect specifies the configuration for the CONNECT config.
 * This is allowed only when type is CONNECT.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HttpUpgrade_Items_Connect =
  {
    /** Terminate the CONNECT request, and forwards the payload as raw TCP data. */
    terminate?: Maybe<Scalars['Boolean']['output']>;
  };

/**
 * Connect specifies the configuration for the CONNECT config.
 * This is allowed only when type is CONNECT.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_HttpUpgrade_Items_Connect_Input =
  {
    /** Terminate the CONNECT request, and forwards the payload as raw TCP data. */
    terminate?: InputMaybe<Scalars['Boolean']['input']>;
  };

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer =
  {
    consistentHash?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash>;
    endpointOverride?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_EndpointOverride>;
    slowStart?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_SlowStart>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_Type;
    zoneAware?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ZoneAware>;
  };

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_Input =
  {
    consistentHash?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash_Input>;
    endpointOverride?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_EndpointOverride_Input>;
    slowStart?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_SlowStart_Input>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_Type;
    zoneAware?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ZoneAware_Input>;
  };

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash =
  {
    cookie?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash_Cookie>;
    header?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash_Header>;
    /** The table size for consistent hashing, must be prime number limited to 5000011. */
    tableSize?: Maybe<Scalars['BigInt']['output']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash_Type;
  };

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash_Input =
  {
    cookie?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash_Cookie_Input>;
    header?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash_Header_Input>;
    /** The table size for consistent hashing, must be prime number limited to 5000011. */
    tableSize?: InputMaybe<Scalars['BigInt']['input']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash_Type;
  };

/** Cookie configures the cookie hash policy when the consistent hash type is set to Cookie. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash_Cookie =
  {
    /** Additional Attributes to set for the generated cookie. */
    attributes?: Maybe<Scalars['JSON']['output']>;
    /**
     * Name of the cookie to hash.
     * If this cookie does not exist in the request, Envoy will generate a cookie and set
     * the TTL on the response back to the client based on Layer 4
     * attributes of the backend endpoint, to ensure that these future requests
     * go to the same backend endpoint. Make sure to set the TTL field for this case.
     */
    name: Scalars['String']['output'];
    ttl?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_loadBalancer_consistentHash_cookie_ttl']['output']
    >;
  };

/** Cookie configures the cookie hash policy when the consistent hash type is set to Cookie. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash_Cookie_Input =
  {
    /** Additional Attributes to set for the generated cookie. */
    attributes?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * Name of the cookie to hash.
     * If this cookie does not exist in the request, Envoy will generate a cookie and set
     * the TTL on the response back to the client based on Layer 4
     * attributes of the backend endpoint, to ensure that these future requests
     * go to the same backend endpoint. Make sure to set the TTL field for this case.
     */
    name: Scalars['String']['input'];
    ttl?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_loadBalancer_consistentHash_cookie_ttl']['input']
    >;
  };

/** Header configures the header hash policy when the consistent hash type is set to Header. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash_Header =
  {
    /** Name of the header to hash. */
    name: Scalars['String']['output'];
  };

/** Header configures the header hash policy when the consistent hash type is set to Header. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash_Header_Input =
  {
    /** Name of the header to hash. */
    name: Scalars['String']['input'];
  };

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Cookie".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ConsistentHash_Type =
  'Cookie' | 'Header' | 'SourceIP';

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_EndpointOverride =
  {
    /** ExtractFrom defines the sources to extract endpoint override information from. */
    extractFrom: Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_EndpointOverride_ExtractFrom_Items>
    >;
  };

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_EndpointOverride_Input =
  {
    /** ExtractFrom defines the sources to extract endpoint override information from. */
    extractFrom: Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_EndpointOverride_ExtractFrom_Items_Input>
    >;
  };

/** EndpointOverrideExtractFrom defines a source to extract endpoint override information from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_EndpointOverride_ExtractFrom_Items =
  {
    /**
     * Header defines the header to get the override endpoint addresses.
     * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
     * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
     * The IPv6 address is enclosed in square brackets.
     */
    header?: Maybe<Scalars['String']['output']>;
  };

/** EndpointOverrideExtractFrom defines a source to extract endpoint override information from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_EndpointOverride_ExtractFrom_Items_Input =
  {
    /**
     * Header defines the header to get the override endpoint addresses.
     * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
     * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
     * The IPv6 address is enclosed in square brackets.
     */
    header?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_SlowStart =
  {
    window: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_loadBalancer_slowStart_window']['output'];
  };

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_SlowStart_Input =
  {
    window: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_loadBalancer_slowStart_window']['input'];
  };

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_Type =
  'ConsistentHash' | 'LeastRequest' | 'Random' | 'RoundRobin';

/** ZoneAware defines the configuration related to the distribution of requests between locality zones. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ZoneAware =
  {
    preferLocal?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ZoneAware_PreferLocal>;
  };

/** ZoneAware defines the configuration related to the distribution of requests between locality zones. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ZoneAware_Input =
  {
    preferLocal?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ZoneAware_PreferLocal_Input>;
  };

/** PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ZoneAware_PreferLocal =
  {
    force?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ZoneAware_PreferLocal_Force>;
    /** MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing. */
    minEndpointsThreshold?: Maybe<Scalars['BigInt']['output']>;
  };

/** PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ZoneAware_PreferLocal_Input =
  {
    force?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ZoneAware_PreferLocal_Force_Input>;
    /** MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing. */
    minEndpointsThreshold?: InputMaybe<Scalars['BigInt']['input']>;
  };

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ZoneAware_PreferLocal_Force =
  {
    /**
     * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
     * override. This is useful for protecting zones with fewer endpoints.
     */
    minEndpointsInZoneThreshold?: Maybe<Scalars['Int']['output']>;
  };

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_LoadBalancer_ZoneAware_PreferLocal_Force_Input =
  {
    /**
     * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
     * override. This is useful for protecting zones with fewer endpoints.
     */
    minEndpointsInZoneThreshold?: InputMaybe<Scalars['Int']['input']>;
  };

/** ProxyProtocol enables the Proxy Protocol when communicating with the backend. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ProxyProtocol =
  {
    version: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ProxyProtocol_Version;
  };

/** ProxyProtocol enables the Proxy Protocol when communicating with the backend. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ProxyProtocol_Input =
  {
    version: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ProxyProtocol_Version;
  };

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ProxyProtocol_Version =
  'V1' | 'V2';

/**
 * RateLimit allows the user to limit the number of incoming requests
 * to a predefined value based on attributes within the traffic flow.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit =
  {
    global?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global>;
    local?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Type;
  };

/**
 * RateLimit allows the user to limit the number of incoming requests
 * to a predefined value based on attributes within the traffic flow.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Input =
  {
    global?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Input>;
    local?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Input>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Type;
  };

/** Global defines global rate limit configuration. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global =
  {
    /**
     * Rules are a list of RateLimit selectors and limits. Each rule and its
     * associated limit is applied in a mutually exclusive way. If a request
     * matches multiple rules, each of their associated limits get applied, so a
     * single request might increase the rate limit counters for multiple rules
     * if selected. The rate limit service will return a logical OR of the individual
     * rate limit decisions of all matching rules. For example, if a request
     * matches two rules, one rate limited and one not, the final decision will be
     * to rate limit the request.
     */
    rules: Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items>
    >;
  };

/** Global defines global rate limit configuration. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Input =
  {
    /**
     * Rules are a list of RateLimit selectors and limits. Each rule and its
     * associated limit is applied in a mutually exclusive way. If a request
     * matches multiple rules, each of their associated limits get applied, so a
     * single request might increase the rate limit counters for multiple rules
     * if selected. The rate limit service will return a logical OR of the individual
     * rate limit decisions of all matching rules. For example, if a request
     * matches two rules, one rate limited and one not, the final decision will be
     * to rate limit the request.
     */
    rules: Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Input>
    >;
  };

/**
 * RateLimitRule defines the semantics for matching attributes
 * from the incoming requests, and setting limits for them.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items =
  {
    /**
     * ClientSelectors holds the list of select conditions to select
     * specific clients using attributes from the traffic flow.
     * All individual select conditions must hold True for this rule
     * and its limit to be applied.
     *
     * If no client selectors are specified, the rule applies to all traffic of
     * the targeted Route.
     *
     * If the policy targets a Gateway, the rule applies to each Route of the Gateway.
     * Please note that each Route has its own rate limit counters. For example,
     * if a Gateway has two Routes, and the policy has a rule with limit 10rps,
     * each Route will have its own 10rps limit.
     */
    clientSelectors?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items>
      >
    >;
    cost?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost>;
    limit: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Limit;
    /**
     * Shared determines whether this rate limit rule applies across all the policy targets.
     * If set to true, the rule is treated as a common bucket and is shared across all policy targets (xRoutes).
     * Default: false.
     */
    shared?: Maybe<Scalars['Boolean']['output']>;
  };

/**
 * RateLimitRule defines the semantics for matching attributes
 * from the incoming requests, and setting limits for them.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Input =
  {
    /**
     * ClientSelectors holds the list of select conditions to select
     * specific clients using attributes from the traffic flow.
     * All individual select conditions must hold True for this rule
     * and its limit to be applied.
     *
     * If no client selectors are specified, the rule applies to all traffic of
     * the targeted Route.
     *
     * If the policy targets a Gateway, the rule applies to each Route of the Gateway.
     * Please note that each Route has its own rate limit counters. For example,
     * if a Gateway has two Routes, and the policy has a rule with limit 10rps,
     * each Route will have its own 10rps limit.
     */
    clientSelectors?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_Input>
      >
    >;
    cost?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Input>;
    limit: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Limit_Input;
    /**
     * Shared determines whether this rate limit rule applies across all the policy targets.
     * If set to true, the rule is treated as a common bucket and is shared across all policy targets (xRoutes).
     * Default: false.
     */
    shared?: InputMaybe<Scalars['Boolean']['input']>;
  };

/**
 * RateLimitSelectCondition specifies the attributes within the traffic flow that can
 * be used to select a subset of clients to be ratelimited.
 * All the individual conditions must hold True for the overall condition to hold True.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items =
  {
    /**
     * Headers is a list of request headers to match. Multiple header values are ANDed together,
     * meaning, a request MUST match all the specified headers.
     * At least one of headers or sourceCIDR condition must be specified.
     */
    headers?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_Headers_Items>
      >
    >;
    sourceCIDR?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_SourceCidr>;
  };

/**
 * RateLimitSelectCondition specifies the attributes within the traffic flow that can
 * be used to select a subset of clients to be ratelimited.
 * All the individual conditions must hold True for the overall condition to hold True.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_Input =
  {
    /**
     * Headers is a list of request headers to match. Multiple header values are ANDed together,
     * meaning, a request MUST match all the specified headers.
     * At least one of headers or sourceCIDR condition must be specified.
     */
    headers?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_Headers_Items_Input>
      >
    >;
    sourceCIDR?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_SourceCidr_Input>;
  };

/** HeaderMatch defines the match attributes within the HTTP Headers of the request. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_Headers_Items =
  {
    /**
     * Invert specifies whether the value match result will be inverted.
     * Do not set this field when Type="Distinct", implying matching on any/all unique
     * values within the header.
     */
    invert?: Maybe<Scalars['Boolean']['output']>;
    /**
     * Name of the HTTP header.
     * The header name is case-insensitive unless PreserveHeaderCase is set to true.
     * For example, "Foo" and "foo" are considered the same header.
     */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_global_rules_items_clientSelectors_items_headers_items_name']['output'];
    type?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_Headers_Items_Type>;
    /**
     * Value within the HTTP header.
     * Do not set this field when Type="Distinct", implying matching on any/all unique
     * values within the header.
     */
    value?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_global_rules_items_clientSelectors_items_headers_items_value']['output']
    >;
  };

/** HeaderMatch defines the match attributes within the HTTP Headers of the request. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_Headers_Items_Input =
  {
    /**
     * Invert specifies whether the value match result will be inverted.
     * Do not set this field when Type="Distinct", implying matching on any/all unique
     * values within the header.
     */
    invert?: InputMaybe<Scalars['Boolean']['input']>;
    /**
     * Name of the HTTP header.
     * The header name is case-insensitive unless PreserveHeaderCase is set to true.
     * For example, "Foo" and "foo" are considered the same header.
     */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_global_rules_items_clientSelectors_items_headers_items_name']['input'];
    type?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_Headers_Items_Type>;
    /**
     * Value within the HTTP header.
     * Do not set this field when Type="Distinct", implying matching on any/all unique
     * values within the header.
     */
    value?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_global_rules_items_clientSelectors_items_headers_items_value']['input']
    >;
  };

/** Type specifies how to match against the value of the header. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_Headers_Items_Type =
  'Distinct' | 'Exact' | 'RegularExpression';

/**
 * SourceCIDR is the client IP Address range to match on.
 * At least one of headers or sourceCIDR condition must be specified.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_SourceCidr =
  {
    type?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_SourceCidr_Type>;
    /**
     * Value is the IP CIDR that represents the range of Source IP Addresses of the client.
     * These could also be the intermediate addresses through which the request has flown through and is part of the  `X-Forwarded-For` header.
     * For example, `192.168.0.1/32`, `192.168.0.0/24`, `001:db8::/64`.
     */
    value: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_global_rules_items_clientSelectors_items_sourceCIDR_value']['output'];
  };

/**
 * SourceCIDR is the client IP Address range to match on.
 * At least one of headers or sourceCIDR condition must be specified.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_SourceCidr_Input =
  {
    type?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_SourceCidr_Type>;
    /**
     * Value is the IP CIDR that represents the range of Source IP Addresses of the client.
     * These could also be the intermediate addresses through which the request has flown through and is part of the  `X-Forwarded-For` header.
     * For example, `192.168.0.1/32`, `192.168.0.0/24`, `001:db8::/64`.
     */
    value: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_global_rules_items_clientSelectors_items_sourceCIDR_value']['input'];
  };

export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_ClientSelectors_Items_SourceCidr_Type =
  'Distinct' | 'Exact';

/**
 * Cost specifies the cost of requests and responses for the rule.
 *
 * This is optional and if not specified, the default behavior is to reduce the rate limit counters by 1 on
 * the request path and do not reduce the rate limit counters on the response path.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost =
  {
    request?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Request>;
    response?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Response>;
  };

/**
 * Cost specifies the cost of requests and responses for the rule.
 *
 * This is optional and if not specified, the default behavior is to reduce the rate limit counters by 1 on
 * the request path and do not reduce the rate limit counters on the response path.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Input =
  {
    request?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Request_Input>;
    response?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Response_Input>;
  };

/**
 * Request specifies the number to reduce the rate limit counters
 * on the request path. If this is not specified, the default behavior
 * is to reduce the rate limit counters by 1.
 *
 * When Envoy receives a request that matches the rule, it tries to reduce the
 * rate limit counters by the specified number. If the counter doesn't have
 * enough capacity, the request is rate limited.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Request =
  {
    from: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Request_From;
    metadata?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Request_Metadata>;
    /**
     * Number specifies the fixed usage number to reduce the rate limit counters.
     * Using zero can be used to only check the rate limit counters without reducing them.
     */
    number?: Maybe<Scalars['BigInt']['output']>;
  };

/**
 * Request specifies the number to reduce the rate limit counters
 * on the request path. If this is not specified, the default behavior
 * is to reduce the rate limit counters by 1.
 *
 * When Envoy receives a request that matches the rule, it tries to reduce the
 * rate limit counters by the specified number. If the counter doesn't have
 * enough capacity, the request is rate limited.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Request_Input =
  {
    from: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Request_From;
    metadata?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Request_Metadata_Input>;
    /**
     * Number specifies the fixed usage number to reduce the rate limit counters.
     * Using zero can be used to only check the rate limit counters without reducing them.
     */
    number?: InputMaybe<Scalars['BigInt']['input']>;
  };

/** From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Request_From =
  'Metadata' | 'Number';

/** Metadata specifies the per-request metadata to retrieve the usage number from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Request_Metadata =
  {
    /** Key is the key to retrieve the usage number from the filter metadata. */
    key: Scalars['String']['output'];
    /** Namespace is the namespace of the dynamic metadata. */
    namespace: Scalars['String']['output'];
  };

/** Metadata specifies the per-request metadata to retrieve the usage number from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Request_Metadata_Input =
  {
    /** Key is the key to retrieve the usage number from the filter metadata. */
    key: Scalars['String']['input'];
    /** Namespace is the namespace of the dynamic metadata. */
    namespace: Scalars['String']['input'];
  };

/**
 * Response specifies the number to reduce the rate limit counters
 * after the response is sent back to the client or the request stream is closed.
 *
 * The cost is used to reduce the rate limit counters for the matching requests.
 * Since the reduction happens after the request stream is complete, the rate limit
 * won't be enforced for the current request, but for the subsequent matching requests.
 *
 * This is optional and if not specified, the rate limit counters are not reduced
 * on the response path.
 *
 * Currently, this is only supported for HTTP Global Rate Limits.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Response =
  {
    from: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Response_From;
    metadata?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Response_Metadata>;
    /**
     * Number specifies the fixed usage number to reduce the rate limit counters.
     * Using zero can be used to only check the rate limit counters without reducing them.
     */
    number?: Maybe<Scalars['BigInt']['output']>;
  };

/**
 * Response specifies the number to reduce the rate limit counters
 * after the response is sent back to the client or the request stream is closed.
 *
 * The cost is used to reduce the rate limit counters for the matching requests.
 * Since the reduction happens after the request stream is complete, the rate limit
 * won't be enforced for the current request, but for the subsequent matching requests.
 *
 * This is optional and if not specified, the rate limit counters are not reduced
 * on the response path.
 *
 * Currently, this is only supported for HTTP Global Rate Limits.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Response_Input =
  {
    from: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Response_From;
    metadata?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Response_Metadata_Input>;
    /**
     * Number specifies the fixed usage number to reduce the rate limit counters.
     * Using zero can be used to only check the rate limit counters without reducing them.
     */
    number?: InputMaybe<Scalars['BigInt']['input']>;
  };

/** From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Response_From =
  'Metadata' | 'Number';

/** Metadata specifies the per-request metadata to retrieve the usage number from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Response_Metadata =
  {
    /** Key is the key to retrieve the usage number from the filter metadata. */
    key: Scalars['String']['output'];
    /** Namespace is the namespace of the dynamic metadata. */
    namespace: Scalars['String']['output'];
  };

/** Metadata specifies the per-request metadata to retrieve the usage number from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Cost_Response_Metadata_Input =
  {
    /** Key is the key to retrieve the usage number from the filter metadata. */
    key: Scalars['String']['input'];
    /** Namespace is the namespace of the dynamic metadata. */
    namespace: Scalars['String']['input'];
  };

/**
 * Limit holds the rate limit values.
 * This limit is applied for traffic flows when the selectors
 * compute to True, causing the request to be counted towards the limit.
 * The limit is enforced and the request is ratelimited, i.e. a response with
 * 429 HTTP status code is sent back to the client when
 * the selected requests have reached the limit.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Limit =
  {
    requests: Scalars['Int']['output'];
    unit: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Limit_Unit;
  };

/**
 * Limit holds the rate limit values.
 * This limit is applied for traffic flows when the selectors
 * compute to True, causing the request to be counted towards the limit.
 * The limit is enforced and the request is ratelimited, i.e. a response with
 * 429 HTTP status code is sent back to the client when
 * the selected requests have reached the limit.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Limit_Input =
  {
    requests: Scalars['Int']['input'];
    unit: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Limit_Unit;
  };

/**
 * RateLimitUnit specifies the intervals for setting rate limits.
 * Valid RateLimitUnit values are "Second", "Minute", "Hour", "Day", "Month" and "Year".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Global_Rules_Items_Limit_Unit =
  'Day' | 'Hour' | 'Minute' | 'Month' | 'Second' | 'Year';

/** Local defines local rate limit configuration. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local =
  {
    /**
     * Rules are a list of RateLimit selectors and limits. If a request matches
     * multiple rules, the strictest limit is applied. For example, if a request
     * matches two rules, one with 10rps and one with 20rps, the final limit will
     * be based on the rule with 10rps.
     */
    rules?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items>
      >
    >;
  };

/** Local defines local rate limit configuration. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Input =
  {
    /**
     * Rules are a list of RateLimit selectors and limits. If a request matches
     * multiple rules, the strictest limit is applied. For example, if a request
     * matches two rules, one with 10rps and one with 20rps, the final limit will
     * be based on the rule with 10rps.
     */
    rules?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Input>
      >
    >;
  };

/**
 * RateLimitRule defines the semantics for matching attributes
 * from the incoming requests, and setting limits for them.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items =
  {
    /**
     * ClientSelectors holds the list of select conditions to select
     * specific clients using attributes from the traffic flow.
     * All individual select conditions must hold True for this rule
     * and its limit to be applied.
     *
     * If no client selectors are specified, the rule applies to all traffic of
     * the targeted Route.
     *
     * If the policy targets a Gateway, the rule applies to each Route of the Gateway.
     * Please note that each Route has its own rate limit counters. For example,
     * if a Gateway has two Routes, and the policy has a rule with limit 10rps,
     * each Route will have its own 10rps limit.
     */
    clientSelectors?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items>
      >
    >;
    cost?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost>;
    limit: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Limit;
    /**
     * Shared determines whether this rate limit rule applies across all the policy targets.
     * If set to true, the rule is treated as a common bucket and is shared across all policy targets (xRoutes).
     * Default: false.
     */
    shared?: Maybe<Scalars['Boolean']['output']>;
  };

/**
 * RateLimitRule defines the semantics for matching attributes
 * from the incoming requests, and setting limits for them.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Input =
  {
    /**
     * ClientSelectors holds the list of select conditions to select
     * specific clients using attributes from the traffic flow.
     * All individual select conditions must hold True for this rule
     * and its limit to be applied.
     *
     * If no client selectors are specified, the rule applies to all traffic of
     * the targeted Route.
     *
     * If the policy targets a Gateway, the rule applies to each Route of the Gateway.
     * Please note that each Route has its own rate limit counters. For example,
     * if a Gateway has two Routes, and the policy has a rule with limit 10rps,
     * each Route will have its own 10rps limit.
     */
    clientSelectors?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_Input>
      >
    >;
    cost?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Input>;
    limit: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Limit_Input;
    /**
     * Shared determines whether this rate limit rule applies across all the policy targets.
     * If set to true, the rule is treated as a common bucket and is shared across all policy targets (xRoutes).
     * Default: false.
     */
    shared?: InputMaybe<Scalars['Boolean']['input']>;
  };

/**
 * RateLimitSelectCondition specifies the attributes within the traffic flow that can
 * be used to select a subset of clients to be ratelimited.
 * All the individual conditions must hold True for the overall condition to hold True.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items =
  {
    /**
     * Headers is a list of request headers to match. Multiple header values are ANDed together,
     * meaning, a request MUST match all the specified headers.
     * At least one of headers or sourceCIDR condition must be specified.
     */
    headers?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_Headers_Items>
      >
    >;
    sourceCIDR?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_SourceCidr>;
  };

/**
 * RateLimitSelectCondition specifies the attributes within the traffic flow that can
 * be used to select a subset of clients to be ratelimited.
 * All the individual conditions must hold True for the overall condition to hold True.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_Input =
  {
    /**
     * Headers is a list of request headers to match. Multiple header values are ANDed together,
     * meaning, a request MUST match all the specified headers.
     * At least one of headers or sourceCIDR condition must be specified.
     */
    headers?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_Headers_Items_Input>
      >
    >;
    sourceCIDR?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_SourceCidr_Input>;
  };

/** HeaderMatch defines the match attributes within the HTTP Headers of the request. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_Headers_Items =
  {
    /**
     * Invert specifies whether the value match result will be inverted.
     * Do not set this field when Type="Distinct", implying matching on any/all unique
     * values within the header.
     */
    invert?: Maybe<Scalars['Boolean']['output']>;
    /**
     * Name of the HTTP header.
     * The header name is case-insensitive unless PreserveHeaderCase is set to true.
     * For example, "Foo" and "foo" are considered the same header.
     */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_local_rules_items_clientSelectors_items_headers_items_name']['output'];
    type?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_Headers_Items_Type>;
    /**
     * Value within the HTTP header.
     * Do not set this field when Type="Distinct", implying matching on any/all unique
     * values within the header.
     */
    value?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_local_rules_items_clientSelectors_items_headers_items_value']['output']
    >;
  };

/** HeaderMatch defines the match attributes within the HTTP Headers of the request. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_Headers_Items_Input =
  {
    /**
     * Invert specifies whether the value match result will be inverted.
     * Do not set this field when Type="Distinct", implying matching on any/all unique
     * values within the header.
     */
    invert?: InputMaybe<Scalars['Boolean']['input']>;
    /**
     * Name of the HTTP header.
     * The header name is case-insensitive unless PreserveHeaderCase is set to true.
     * For example, "Foo" and "foo" are considered the same header.
     */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_local_rules_items_clientSelectors_items_headers_items_name']['input'];
    type?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_Headers_Items_Type>;
    /**
     * Value within the HTTP header.
     * Do not set this field when Type="Distinct", implying matching on any/all unique
     * values within the header.
     */
    value?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_local_rules_items_clientSelectors_items_headers_items_value']['input']
    >;
  };

/** Type specifies how to match against the value of the header. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_Headers_Items_Type =
  'Distinct' | 'Exact' | 'RegularExpression';

/**
 * SourceCIDR is the client IP Address range to match on.
 * At least one of headers or sourceCIDR condition must be specified.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_SourceCidr =
  {
    type?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_SourceCidr_Type>;
    /**
     * Value is the IP CIDR that represents the range of Source IP Addresses of the client.
     * These could also be the intermediate addresses through which the request has flown through and is part of the  `X-Forwarded-For` header.
     * For example, `192.168.0.1/32`, `192.168.0.0/24`, `001:db8::/64`.
     */
    value: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_local_rules_items_clientSelectors_items_sourceCIDR_value']['output'];
  };

/**
 * SourceCIDR is the client IP Address range to match on.
 * At least one of headers or sourceCIDR condition must be specified.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_SourceCidr_Input =
  {
    type?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_SourceCidr_Type>;
    /**
     * Value is the IP CIDR that represents the range of Source IP Addresses of the client.
     * These could also be the intermediate addresses through which the request has flown through and is part of the  `X-Forwarded-For` header.
     * For example, `192.168.0.1/32`, `192.168.0.0/24`, `001:db8::/64`.
     */
    value: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_rateLimit_local_rules_items_clientSelectors_items_sourceCIDR_value']['input'];
  };

export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_ClientSelectors_Items_SourceCidr_Type =
  'Distinct' | 'Exact';

/**
 * Cost specifies the cost of requests and responses for the rule.
 *
 * This is optional and if not specified, the default behavior is to reduce the rate limit counters by 1 on
 * the request path and do not reduce the rate limit counters on the response path.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost =
  {
    request?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Request>;
    response?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Response>;
  };

/**
 * Cost specifies the cost of requests and responses for the rule.
 *
 * This is optional and if not specified, the default behavior is to reduce the rate limit counters by 1 on
 * the request path and do not reduce the rate limit counters on the response path.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Input =
  {
    request?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Request_Input>;
    response?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Response_Input>;
  };

/**
 * Request specifies the number to reduce the rate limit counters
 * on the request path. If this is not specified, the default behavior
 * is to reduce the rate limit counters by 1.
 *
 * When Envoy receives a request that matches the rule, it tries to reduce the
 * rate limit counters by the specified number. If the counter doesn't have
 * enough capacity, the request is rate limited.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Request =
  {
    from: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Request_From;
    metadata?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Request_Metadata>;
    /**
     * Number specifies the fixed usage number to reduce the rate limit counters.
     * Using zero can be used to only check the rate limit counters without reducing them.
     */
    number?: Maybe<Scalars['BigInt']['output']>;
  };

/**
 * Request specifies the number to reduce the rate limit counters
 * on the request path. If this is not specified, the default behavior
 * is to reduce the rate limit counters by 1.
 *
 * When Envoy receives a request that matches the rule, it tries to reduce the
 * rate limit counters by the specified number. If the counter doesn't have
 * enough capacity, the request is rate limited.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Request_Input =
  {
    from: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Request_From;
    metadata?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Request_Metadata_Input>;
    /**
     * Number specifies the fixed usage number to reduce the rate limit counters.
     * Using zero can be used to only check the rate limit counters without reducing them.
     */
    number?: InputMaybe<Scalars['BigInt']['input']>;
  };

/** From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Request_From =
  'Metadata' | 'Number';

/** Metadata specifies the per-request metadata to retrieve the usage number from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Request_Metadata =
  {
    /** Key is the key to retrieve the usage number from the filter metadata. */
    key: Scalars['String']['output'];
    /** Namespace is the namespace of the dynamic metadata. */
    namespace: Scalars['String']['output'];
  };

/** Metadata specifies the per-request metadata to retrieve the usage number from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Request_Metadata_Input =
  {
    /** Key is the key to retrieve the usage number from the filter metadata. */
    key: Scalars['String']['input'];
    /** Namespace is the namespace of the dynamic metadata. */
    namespace: Scalars['String']['input'];
  };

/**
 * Response specifies the number to reduce the rate limit counters
 * after the response is sent back to the client or the request stream is closed.
 *
 * The cost is used to reduce the rate limit counters for the matching requests.
 * Since the reduction happens after the request stream is complete, the rate limit
 * won't be enforced for the current request, but for the subsequent matching requests.
 *
 * This is optional and if not specified, the rate limit counters are not reduced
 * on the response path.
 *
 * Currently, this is only supported for HTTP Global Rate Limits.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Response =
  {
    from: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Response_From;
    metadata?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Response_Metadata>;
    /**
     * Number specifies the fixed usage number to reduce the rate limit counters.
     * Using zero can be used to only check the rate limit counters without reducing them.
     */
    number?: Maybe<Scalars['BigInt']['output']>;
  };

/**
 * Response specifies the number to reduce the rate limit counters
 * after the response is sent back to the client or the request stream is closed.
 *
 * The cost is used to reduce the rate limit counters for the matching requests.
 * Since the reduction happens after the request stream is complete, the rate limit
 * won't be enforced for the current request, but for the subsequent matching requests.
 *
 * This is optional and if not specified, the rate limit counters are not reduced
 * on the response path.
 *
 * Currently, this is only supported for HTTP Global Rate Limits.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Response_Input =
  {
    from: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Response_From;
    metadata?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Response_Metadata_Input>;
    /**
     * Number specifies the fixed usage number to reduce the rate limit counters.
     * Using zero can be used to only check the rate limit counters without reducing them.
     */
    number?: InputMaybe<Scalars['BigInt']['input']>;
  };

/** From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Response_From =
  'Metadata' | 'Number';

/** Metadata specifies the per-request metadata to retrieve the usage number from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Response_Metadata =
  {
    /** Key is the key to retrieve the usage number from the filter metadata. */
    key: Scalars['String']['output'];
    /** Namespace is the namespace of the dynamic metadata. */
    namespace: Scalars['String']['output'];
  };

/** Metadata specifies the per-request metadata to retrieve the usage number from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Cost_Response_Metadata_Input =
  {
    /** Key is the key to retrieve the usage number from the filter metadata. */
    key: Scalars['String']['input'];
    /** Namespace is the namespace of the dynamic metadata. */
    namespace: Scalars['String']['input'];
  };

/**
 * Limit holds the rate limit values.
 * This limit is applied for traffic flows when the selectors
 * compute to True, causing the request to be counted towards the limit.
 * The limit is enforced and the request is ratelimited, i.e. a response with
 * 429 HTTP status code is sent back to the client when
 * the selected requests have reached the limit.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Limit =
  {
    requests: Scalars['Int']['output'];
    unit: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Limit_Unit;
  };

/**
 * Limit holds the rate limit values.
 * This limit is applied for traffic flows when the selectors
 * compute to True, causing the request to be counted towards the limit.
 * The limit is enforced and the request is ratelimited, i.e. a response with
 * 429 HTTP status code is sent back to the client when
 * the selected requests have reached the limit.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Limit_Input =
  {
    requests: Scalars['Int']['input'];
    unit: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Limit_Unit;
  };

/**
 * RateLimitUnit specifies the intervals for setting rate limits.
 * Valid RateLimitUnit values are "Second", "Minute", "Hour", "Day", "Month" and "Year".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Local_Rules_Items_Limit_Unit =
  'Day' | 'Hour' | 'Minute' | 'Month' | 'Second' | 'Year';

/**
 * Type decides the scope for the RateLimits.
 * Valid RateLimitType values are "Global" or "Local".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RateLimit_Type =
  'Global' | 'Local';

/**
 * RequestBuffer allows the gateway to buffer and fully receive each request from a client before continuing to send the request
 * upstream to the backends. This can be helpful to shield your backend servers from slow clients, and also to enforce a maximum size per request
 * as any requests larger than the buffer size will be rejected.
 *
 * This can have a negative performance impact so should only be enabled when necessary.
 *
 * When enabling this option, you should also configure your connection buffer size to account for these request buffers. There will also be an
 * increase in memory usage for Envoy that should be accounted for in your deployment settings.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RequestBuffer =
  {
    /**
     * Limit specifies the maximum allowed size in bytes for each incoming request buffer.
     * If exceeded, the request will be rejected with HTTP 413 Content Too Large.
     *
     * Accepts values in resource.Quantity format (e.g., "10Mi", "500Ki").
     */
    limit?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RequestBuffer_Limit>;
  };

/**
 * RequestBuffer allows the gateway to buffer and fully receive each request from a client before continuing to send the request
 * upstream to the backends. This can be helpful to shield your backend servers from slow clients, and also to enforce a maximum size per request
 * as any requests larger than the buffer size will be rejected.
 *
 * This can have a negative performance impact so should only be enabled when necessary.
 *
 * When enabling this option, you should also configure your connection buffer size to account for these request buffers. There will also be an
 * increase in memory usage for Envoy that should be accounted for in your deployment settings.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RequestBuffer_Input =
  {
    /**
     * Limit specifies the maximum allowed size in bytes for each incoming request buffer.
     * If exceeded, the request will be rejected with HTTP 413 Content Too Large.
     *
     * Accepts values in resource.Quantity format (e.g., "10Mi", "500Ki").
     */
    limit?: InputMaybe<Scalars['JSON']['input']>;
  };

/**
 * Limit specifies the maximum allowed size in bytes for each incoming request buffer.
 * If exceeded, the request will be rejected with HTTP 413 Content Too Large.
 *
 * Accepts values in resource.Quantity format (e.g., "10Mi", "500Ki").
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_RequestBuffer_Limit =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_requestBuffer_limit_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_requestBuffer_limit_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_requestBuffer_limit_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_requestBuffer_limit_allOf_1']['output']
    >;
  };

/** ResponseOverride defines the configuration to override specific responses with a custom one. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items =
  {
    match: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Match;
    redirect?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect>;
    response?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Response>;
  };

/** ResponseOverride defines the configuration to override specific responses with a custom one. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Input =
  {
    match: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Match_Input;
    redirect?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_Input>;
    response?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Response_Input>;
  };

/** Match configuration. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Match =
  {
    /** Status code to match on. The match evaluates to true if any of the matches are successful. */
    statusCodes: Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Match_StatusCodes_Items>
    >;
  };

/** Match configuration. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Match_Input =
  {
    /** Status code to match on. The match evaluates to true if any of the matches are successful. */
    statusCodes: Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Match_StatusCodes_Items_Input>
    >;
  };

/** StatusCodeMatch defines the configuration for matching a status code. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Match_StatusCodes_Items =
  {
    range?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Match_StatusCodes_Items_Range>;
    /**
     * Type is the type of value.
     * Valid values are Value and Range, default is Value.
     */
    type: Scalars['String']['output'];
    /** Value contains the value of the status code. */
    value?: Maybe<Scalars['Int']['output']>;
  };

/** StatusCodeMatch defines the configuration for matching a status code. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Match_StatusCodes_Items_Input =
  {
    range?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Match_StatusCodes_Items_Range_Input>;
    /**
     * Type is the type of value.
     * Valid values are Value and Range, default is Value.
     */
    type?: Scalars['String']['input'];
    /** Value contains the value of the status code. */
    value?: InputMaybe<Scalars['Int']['input']>;
  };

/** Range contains the range of status codes. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Match_StatusCodes_Items_Range =
  {
    /** End of the range, including the end value. */
    end: Scalars['Int']['output'];
    /** Start of the range, including the start value. */
    start: Scalars['Int']['output'];
  };

/** Range contains the range of status codes. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Match_StatusCodes_Items_Range_Input =
  {
    /** End of the range, including the end value. */
    end: Scalars['Int']['input'];
    /** Start of the range, including the start value. */
    start: Scalars['Int']['input'];
  };

/** Redirect configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect =
  {
    hostname?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_redirect_hostname']['output']
    >;
    path?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_Path>;
    /**
     * Port is the port to be used in the value of the `Location`
     * header in the response.
     *
     * If redirect scheme is not-empty, the well-known port associated with the redirect scheme will be used.
     * Specifically "http" to port 80 and "https" to port 443. If the redirect scheme does not have a
     * well-known port or redirect scheme is empty, the listener port of the Gateway will be used.
     *
     * Port will not be added in the 'Location' header if scheme is HTTP and port is 80
     * or scheme is HTTPS and port is 443.
     */
    port?: Maybe<Scalars['Int']['output']>;
    scheme?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_Scheme>;
    statusCode?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_StatusCode>;
  };

/** Redirect configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_redirect_hostname']['input']
    >;
    path?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_Path_Input>;
    /**
     * Port is the port to be used in the value of the `Location`
     * header in the response.
     *
     * If redirect scheme is not-empty, the well-known port associated with the redirect scheme will be used.
     * Specifically "http" to port 80 and "https" to port 443. If the redirect scheme does not have a
     * well-known port or redirect scheme is empty, the listener port of the Gateway will be used.
     *
     * Port will not be added in the 'Location' header if scheme is HTTP and port is 80
     * or scheme is HTTPS and port is 443.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    scheme?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_Scheme>;
    statusCode?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_StatusCode>;
  };

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 * Only ReplaceFullPath path modifier is supported currently.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_Path =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_redirect_path_replaceFullPath']['output']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_redirect_path_replacePrefixMatch']['output']
    >;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_Path_Type;
  };

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 * Only ReplaceFullPath path modifier is supported currently.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_Path_Input =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_redirect_path_replaceFullPath']['input']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_redirect_path_replacePrefixMatch']['input']
    >;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_Path_Type;
  };

/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_Path_Type =
  'ReplaceFullPath' | 'ReplacePrefixMatch';

/**
 * Scheme is the scheme to be used in the value of the `Location` header in
 * the response. When empty, the scheme of the request is used.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_Scheme =
  'http' | 'https';

/** StatusCode is the HTTP status code to be used in response. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Redirect_StatusCode =
  '_301' | '_302';

/** Response configuration. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Response =
  {
    body?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Response_Body>;
    /** Content Type of the response. This will be set in the Content-Type header. */
    contentType?: Maybe<Scalars['String']['output']>;
    /**
     * Status Code of the Custom Response
     * If unset, does not override the status of response.
     */
    statusCode?: Maybe<Scalars['Int']['output']>;
  };

/** Response configuration. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Response_Input =
  {
    body?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Response_Body_Input>;
    /** Content Type of the response. This will be set in the Content-Type header. */
    contentType?: InputMaybe<Scalars['String']['input']>;
    /**
     * Status Code of the Custom Response
     * If unset, does not override the status of response.
     */
    statusCode?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * Body of the Custom Response
 * Supports Envoy command operators for dynamic content (see https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Response_Body =
  {
    /** Inline contains the value as an inline string. */
    inline?: Maybe<Scalars['String']['output']>;
    /**
     * Type is the type of method to use to read the body value.
     * Valid values are Inline and ValueRef, default is Inline.
     */
    type: Scalars['String']['output'];
    valueRef?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Response_Body_ValueRef>;
  };

/**
 * Body of the Custom Response
 * Supports Envoy command operators for dynamic content (see https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Response_Body_Input =
  {
    /** Inline contains the value as an inline string. */
    inline?: InputMaybe<Scalars['String']['input']>;
    /**
     * Type is the type of method to use to read the body value.
     * Valid values are Inline and ValueRef, default is Inline.
     */
    type?: Scalars['String']['input'];
    valueRef?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Response_Body_ValueRef_Input>;
  };

/**
 * ValueRef contains the contents of the body
 * specified as a local object reference.
 * Only a reference to ConfigMap is supported.
 *
 * The value of key `response.body` in the ConfigMap will be used as the response body.
 * If the key is not found, the first value in the ConfigMap will be used.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Response_Body_ValueRef =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_response_body_valueRef_group']['output'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_response_body_valueRef_kind']['output'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_response_body_valueRef_name']['output'];
  };

/**
 * ValueRef contains the contents of the body
 * specified as a local object reference.
 * Only a reference to ConfigMap is supported.
 *
 * The value of key `response.body` in the ConfigMap will be used as the response body.
 * If the key is not found, the first value in the ConfigMap will be used.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_ResponseOverride_Items_Response_Body_ValueRef_Input =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_response_body_valueRef_group']['input'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_response_body_valueRef_kind']['input'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_responseOverride_items_response_body_valueRef_name']['input'];
  };

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry =
  {
    /**
     * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
     * that should be sent to the same priority before switching to a different one.
     * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
     */
    numAttemptsPerPriority?: Maybe<Scalars['Int']['output']>;
    /** NumRetries is the number of retries to be attempted. Defaults to 2. */
    numRetries?: Maybe<Scalars['Int']['output']>;
    perRetry?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_PerRetry>;
    retryOn?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_RetryOn>;
  };

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_Input =
  {
    /**
     * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
     * that should be sent to the same priority before switching to a different one.
     * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
     */
    numAttemptsPerPriority?: InputMaybe<Scalars['Int']['input']>;
    /** NumRetries is the number of retries to be attempted. Defaults to 2. */
    numRetries?: InputMaybe<Scalars['Int']['input']>;
    perRetry?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_PerRetry_Input>;
    retryOn?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_RetryOn_Input>;
  };

/** PerRetry is the retry policy to be applied per retry attempt. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_PerRetry =
  {
    backOff?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_PerRetry_BackOff>;
    timeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_retry_perRetry_timeout']['output']
    >;
  };

/** PerRetry is the retry policy to be applied per retry attempt. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_PerRetry_Input =
  {
    backOff?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_PerRetry_BackOff_Input>;
    timeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_retry_perRetry_timeout']['input']
    >;
  };

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_PerRetry_BackOff =
  {
    baseInterval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_retry_perRetry_backOff_baseInterval']['output']
    >;
    maxInterval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_retry_perRetry_backOff_maxInterval']['output']
    >;
  };

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_PerRetry_BackOff_Input =
  {
    baseInterval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_retry_perRetry_backOff_baseInterval']['input']
    >;
    maxInterval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_retry_perRetry_backOff_maxInterval']['input']
    >;
  };

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_RetryOn =
  {
    /**
     * HttpStatusCodes specifies the http status codes to be retried.
     * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
     */
    httpStatusCodes?: Maybe<Array<Maybe<Scalars['PositiveInt']['output']>>>;
    /** Triggers specifies the retry trigger condition(Http/Grpc). */
    triggers?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_RetryOn_Triggers_Items>
      >
    >;
  };

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_RetryOn_Input =
  {
    /**
     * HttpStatusCodes specifies the http status codes to be retried.
     * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
     */
    httpStatusCodes?: InputMaybe<Array<InputMaybe<Scalars['PositiveInt']['input']>>>;
    /** Triggers specifies the retry trigger condition(Http/Grpc). */
    triggers?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_RetryOn_Triggers_Items>
      >
    >;
  };

/** TriggerEnum specifies the conditions that trigger retries. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Retry_RetryOn_Triggers_Items =

    | '_5xx'
    | 'cancelled'
    | 'connect_failure'
    | 'deadline_exceeded'
    | 'gateway_error'
    | 'internal'
    | 'refused_stream'
    | 'reset'
    | 'reset_before_request'
    | 'resource_exhausted'
    | 'retriable_4xx'
    | 'retriable_status_codes'
    | 'unavailable';

/**
 * TargetRef is the name of the resource this policy is being attached to.
 * This policy and the TargetRef MUST be in the same namespace for this
 * Policy to have effect
 *
 * Deprecated: use targetRefs/targetSelectors instead
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetRef =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRef_group']['output'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRef_kind']['output'];
    /** Name is the name of the target resource. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRef_name']['output'];
    sectionName?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRef_sectionName']['output']
    >;
  };

/**
 * TargetRef is the name of the resource this policy is being attached to.
 * This policy and the TargetRef MUST be in the same namespace for this
 * Policy to have effect
 *
 * Deprecated: use targetRefs/targetSelectors instead
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetRef_Input =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRef_group']['input'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRef_kind']['input'];
    /** Name is the name of the target resource. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRef_name']['input'];
    sectionName?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRef_sectionName']['input']
    >;
  };

/**
 * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
 * direct policy to. This should be used as part of Policy resources that can
 * target single resources. For more information on how this policy attachment
 * mode works, and a sample Policy resource, refer to the policy attachment
 * documentation for Gateway API.
 *
 * Note: This should only be used for direct policy attachment when references
 * to SectionName are actually needed. In all other cases,
 * LocalPolicyTargetReference should be used.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetRefs_Items =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRefs_items_group']['output'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRefs_items_kind']['output'];
    /** Name is the name of the target resource. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRefs_items_name']['output'];
    sectionName?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRefs_items_sectionName']['output']
    >;
  };

/**
 * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
 * direct policy to. This should be used as part of Policy resources that can
 * target single resources. For more information on how this policy attachment
 * mode works, and a sample Policy resource, refer to the policy attachment
 * documentation for Gateway API.
 *
 * Note: This should only be used for direct policy attachment when references
 * to SectionName are actually needed. In all other cases,
 * LocalPolicyTargetReference should be used.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetRefs_Items_Input =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRefs_items_group']['input'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRefs_items_kind']['input'];
    /** Name is the name of the target resource. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRefs_items_name']['input'];
    sectionName?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetRefs_items_sectionName']['input']
    >;
  };

export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetSelectors_Items =
  {
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetSelectors_items_group']['output']
    >;
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetSelectors_items_kind']['output'];
    /** MatchExpressions is a list of label selector requirements. The requirements are ANDed. */
    matchExpressions?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetSelectors_Items_MatchExpressions_Items>
      >
    >;
    /** MatchLabels are the set of label selectors for identifying the targeted resource */
    matchLabels?: Maybe<Scalars['JSON']['output']>;
  };

export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetSelectors_Items_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetSelectors_items_group']['input']
    >;
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_targetSelectors_items_kind']['input'];
    /** MatchExpressions is a list of label selector requirements. The requirements are ANDed. */
    matchExpressions?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetSelectors_Items_MatchExpressions_Items_Input>
      >
    >;
    /** MatchLabels are the set of label selectors for identifying the targeted resource */
    matchLabels?: InputMaybe<Scalars['JSON']['input']>;
  };

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetSelectors_Items_MatchExpressions_Items =
  {
    /** key is the label key that the selector applies to. */
    key: Scalars['String']['output'];
    /**
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and DoesNotExist.
     */
    operator: Scalars['String']['output'];
    /**
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     */
    values?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  };

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TargetSelectors_Items_MatchExpressions_Items_Input =
  {
    /** key is the label key that the selector applies to. */
    key: Scalars['String']['input'];
    /**
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and DoesNotExist.
     */
    operator: Scalars['String']['input'];
    /**
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     */
    values?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  };

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TcpKeepalive =
  {
    idleTime?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_tcpKeepalive_idleTime']['output']
    >;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_tcpKeepalive_interval']['output']
    >;
    /**
     * The total number of unacknowledged probes to send before deciding
     * the connection is dead.
     * Defaults to 9.
     */
    probes?: Maybe<Scalars['Int']['output']>;
  };

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_TcpKeepalive_Input =
  {
    idleTime?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_tcpKeepalive_idleTime']['input']
    >;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_tcpKeepalive_interval']['input']
    >;
    /**
     * The total number of unacknowledged probes to send before deciding
     * the connection is dead.
     * Defaults to 9.
     */
    probes?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * Telemetry configures the telemetry settings for the policy target (Gateway or xRoute).
 * This will override the telemetry settings in the EnvoyProxy resource.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry =
  {
    tracing?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing>;
  };

/**
 * Telemetry configures the telemetry settings for the policy target (Gateway or xRoute).
 * This will override the telemetry settings in the EnvoyProxy resource.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Input =
  {
    tracing?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_Input>;
  };

/** Tracing configures the tracing settings for the backend or HTTPRoute. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing =
  {
    customTags?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_CustomTags>;
    samplingFraction?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_SamplingFraction>;
  };

/** Tracing configures the tracing settings for the backend or HTTPRoute. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_Input =
  {
    customTags?: InputMaybe<Scalars['JSON']['input']>;
    samplingFraction?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_SamplingFraction_Input>;
  };

/**
 * CustomTags defines the custom tags to add to each span.
 * If provider is kubernetes, pod name and namespace are added by default.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_CustomTags =
  {
    additionalProperties?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_CustomTags_AdditionalProperties_Entry>
      >
    >;
  };

export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_CustomTags_AdditionalProperties =
  {
    environment?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_CustomTags_AdditionalProperties_Environment>;
    literal?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_CustomTags_AdditionalProperties_Literal>;
    requestHeader?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_CustomTags_AdditionalProperties_RequestHeader>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_CustomTags_AdditionalProperties_Type;
  };

export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_CustomTags_AdditionalProperties_Entry =
  {
    key: Scalars['ID']['output'];
    value?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_CustomTags_AdditionalProperties>;
  };

/**
 * Environment adds value from environment variable to each span.
 * It's required when the type is "Environment".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_CustomTags_AdditionalProperties_Environment =
  {
    /** DefaultValue defines the default value to use if the environment variable is not set. */
    defaultValue?: Maybe<Scalars['String']['output']>;
    /** Name defines the name of the environment variable which to extract the value from. */
    name: Scalars['String']['output'];
  };

/**
 * Literal adds hard-coded value to each span.
 * It's required when the type is "Literal".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_CustomTags_AdditionalProperties_Literal =
  {
    /** Value defines the hard-coded value to add to each span. */
    value: Scalars['String']['output'];
  };

/**
 * RequestHeader adds value from request header to each span.
 * It's required when the type is "RequestHeader".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_CustomTags_AdditionalProperties_RequestHeader =
  {
    /** DefaultValue defines the default value to use if the request header is not set. */
    defaultValue?: Maybe<Scalars['String']['output']>;
    /** Name defines the name of the request header which to extract the value from. */
    name: Scalars['String']['output'];
  };

/** Type defines the type of custom tag. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_CustomTags_AdditionalProperties_Type =
  'Environment' | 'Literal' | 'RequestHeader';

/**
 * SamplingFraction represents the fraction of requests that should be
 * selected for tracing if no prior sampling decision has been made.
 *
 * This will take precedence over sampling fraction on EnvoyProxy if set.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_SamplingFraction =
  {
    denominator?: Maybe<Scalars['Int']['output']>;
    numerator: Scalars['Int']['output'];
  };

/**
 * SamplingFraction represents the fraction of requests that should be
 * selected for tracing if no prior sampling decision has been made.
 *
 * This will take precedence over sampling fraction on EnvoyProxy if set.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Telemetry_Tracing_SamplingFraction_Input =
  {
    denominator?: InputMaybe<Scalars['Int']['input']>;
    numerator: Scalars['Int']['input'];
  };

/** Timeout settings for the backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Timeout =
  {
    http?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Timeout_Http>;
    tcp?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Timeout_Tcp>;
  };

/** Timeout settings for the backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Timeout_Input =
  {
    http?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Timeout_Http_Input>;
    tcp?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Timeout_Tcp_Input>;
  };

/** Timeout settings for HTTP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Timeout_Http =
  {
    connectionIdleTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_timeout_http_connectionIdleTimeout']['output']
    >;
    maxConnectionDuration?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_timeout_http_maxConnectionDuration']['output']
    >;
    requestTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_timeout_http_requestTimeout']['output']
    >;
  };

/** Timeout settings for HTTP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Timeout_Http_Input =
  {
    connectionIdleTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_timeout_http_connectionIdleTimeout']['input']
    >;
    maxConnectionDuration?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_timeout_http_maxConnectionDuration']['input']
    >;
    requestTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_timeout_http_requestTimeout']['input']
    >;
  };

/** Timeout settings for TCP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Timeout_Tcp =
  {
    connectTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_timeout_tcp_connectTimeout']['output']
    >;
  };

/** Timeout settings for TCP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Spec_Timeout_Tcp_Input =
  {
    connectTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_spec_timeout_tcp_connectTimeout']['input']
    >;
  };

/** status defines the current status of BackendTrafficPolicy. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status =
  {
    /**
     * Ancestors is a list of ancestor resources (usually Gateways) that are
     * associated with the policy, and the status of the policy with respect to
     * each ancestor. When this policy attaches to a parent, the controller that
     * manages the parent and the ancestors MUST add an entry to this list when
     * the controller first sees the policy and SHOULD update the entry as
     * appropriate when the relevant ancestor is modified.
     *
     * Note that choosing the relevant ancestor is left to the Policy designers;
     * an important part of Policy design is designing the right object level at
     * which to namespace this status.
     *
     * Note also that implementations MUST ONLY populate ancestor status for
     * the Ancestor resources they are responsible for. Implementations MUST
     * use the ControllerName field to uniquely identify the entries in this list
     * that they are responsible for.
     *
     * Note that to achieve this, the list of PolicyAncestorStatus structs
     * MUST be treated as a map with a composite key, made up of the AncestorRef
     * and ControllerName fields combined.
     *
     * A maximum of 16 ancestors will be represented in this list. An empty list
     * means the Policy is not relevant for any ancestors.
     *
     * If this slice is full, implementations MUST NOT add further entries.
     * Instead they MUST consider the policy unimplementable and signal that
     * on any related resources such as the ancestor that would be referenced
     * here. For example, if this list was full on BackendTLSPolicy, no
     * additional Gateways would be able to reference the Service targeted by
     * the BackendTLSPolicy.
     */
    ancestors: Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items>
    >;
  };

/** status defines the current status of BackendTrafficPolicy. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * Ancestors is a list of ancestor resources (usually Gateways) that are
     * associated with the policy, and the status of the policy with respect to
     * each ancestor. When this policy attaches to a parent, the controller that
     * manages the parent and the ancestors MUST add an entry to this list when
     * the controller first sees the policy and SHOULD update the entry as
     * appropriate when the relevant ancestor is modified.
     *
     * Note that choosing the relevant ancestor is left to the Policy designers;
     * an important part of Policy design is designing the right object level at
     * which to namespace this status.
     *
     * Note also that implementations MUST ONLY populate ancestor status for
     * the Ancestor resources they are responsible for. Implementations MUST
     * use the ControllerName field to uniquely identify the entries in this list
     * that they are responsible for.
     *
     * Note that to achieve this, the list of PolicyAncestorStatus structs
     * MUST be treated as a map with a composite key, made up of the AncestorRef
     * and ControllerName fields combined.
     *
     * A maximum of 16 ancestors will be represented in this list. An empty list
     * means the Policy is not relevant for any ancestors.
     *
     * If this slice is full, implementations MUST NOT add further entries.
     * Instead they MUST consider the policy unimplementable and signal that
     * on any related resources such as the ancestor that would be referenced
     * here. For example, if this list was full on BackendTLSPolicy, no
     * additional Gateways would be able to reference the Service targeted by
     * the BackendTLSPolicy.
     */
    ancestors: Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Input>
    >;
  };

/**
 * PolicyAncestorStatus describes the status of a route with respect to an
 * associated Ancestor.
 *
 * Ancestors refer to objects that are either the Target of a policy or above it
 * in terms of object hierarchy. For example, if a policy targets a Service, the
 * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
 * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
 * useful object to place Policy status on, so we recommend that implementations
 * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
 * have a _very_ good reason otherwise.
 *
 * In the context of policy attachment, the Ancestor is used to distinguish which
 * resource results in a distinct application of this policy. For example, if a policy
 * targets a Service, it may have a distinct result per attached Gateway.
 *
 * Policies targeting the same resource may have different effects depending on the
 * ancestors of those resources. For example, different Gateways targeting the same
 * Service may have different capabilities, especially if they have different underlying
 * implementations.
 *
 * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
 * used as a backend in a HTTPRoute that is itself attached to a Gateway.
 * In this case, the relevant object for status is the Gateway, and that is the
 * ancestor object referred to in this status.
 *
 * Note that a parent is also an ancestor, so for objects where the parent is the
 * relevant object for status, this struct SHOULD still be used.
 *
 * This struct is intended to be used in a slice that's effectively a map,
 * with a composite key made up of the AncestorRef and the ControllerName.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items =
  {
    ancestorRef: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_AncestorRef;
    /** Conditions describes the status of the Policy with respect to the given Ancestor. */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items>
      >
    >;
    controllerName: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_controllerName']['output'];
  };

/**
 * PolicyAncestorStatus describes the status of a route with respect to an
 * associated Ancestor.
 *
 * Ancestors refer to objects that are either the Target of a policy or above it
 * in terms of object hierarchy. For example, if a policy targets a Service, the
 * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
 * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
 * useful object to place Policy status on, so we recommend that implementations
 * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
 * have a _very_ good reason otherwise.
 *
 * In the context of policy attachment, the Ancestor is used to distinguish which
 * resource results in a distinct application of this policy. For example, if a policy
 * targets a Service, it may have a distinct result per attached Gateway.
 *
 * Policies targeting the same resource may have different effects depending on the
 * ancestors of those resources. For example, different Gateways targeting the same
 * Service may have different capabilities, especially if they have different underlying
 * implementations.
 *
 * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
 * used as a backend in a HTTPRoute that is itself attached to a Gateway.
 * In this case, the relevant object for status is the Gateway, and that is the
 * ancestor object referred to in this status.
 *
 * Note that a parent is also an ancestor, so for objects where the parent is the
 * relevant object for status, this struct SHOULD still be used.
 *
 * This struct is intended to be used in a slice that's effectively a map,
 * with a composite key made up of the AncestorRef and the ControllerName.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Input =
  {
    ancestorRef: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_AncestorRef_Input;
    /** Conditions describes the status of the Policy with respect to the given Ancestor. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Input>
      >
    >;
    controllerName: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_controllerName']['input'];
  };

/**
 * AncestorRef corresponds with a ParentRef in the spec that this
 * PolicyAncestorStatus struct describes the status of.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_AncestorRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_kind']['output']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_namespace']['output']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     * <gateway:experimental:description>
     * When the parent resource is a Service, this targets a specific port in the
     * Service spec. When both Port (experimental) and SectionName are specified,
     * the name and port of the selected port must match both specified values.
     * </gateway:experimental:description>
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    sectionName?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_sectionName']['output']
    >;
  };

/**
 * AncestorRef corresponds with a ParentRef in the spec that this
 * PolicyAncestorStatus struct describes the status of.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_AncestorRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_kind']['input']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_namespace']['input']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     * <gateway:experimental:description>
     * When the parent resource is a Service, this targets a specific port in the
     * Service spec. When both Port (experimental) and SectionName are specified,
     * the name and port of the selected port must match both specified values.
     * </gateway:experimental:description>
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    sectionName?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_sectionName']['input']
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_reason']['output'];
    status: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_reason']['input'];
    status: Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1BackendTrafficPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** Spec defines the desired state of HTTPRouteFilter. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec =
  {
    credentialInjection?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_CredentialInjection>;
    directResponse?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_DirectResponse>;
    urlRewrite?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite>;
  };

/** Spec defines the desired state of HTTPRouteFilter. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_Input =
  {
    credentialInjection?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_CredentialInjection_Input>;
    directResponse?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_DirectResponse_Input>;
    urlRewrite?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Input>;
  };

/**
 * HTTPCredentialInjectionFilter defines the configuration to inject credentials into the request.
 * This is useful when the backend service requires credentials in the request, and the original
 * request does not contain them. The filter can inject credentials into the request before forwarding
 * it to the backend service.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_CredentialInjection =
  {
    credential: Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_CredentialInjection_Credential;
    /**
     * Header is the name of the header where the credentials are injected.
     * If not specified, the credentials are injected into the Authorization header.
     */
    header?: Maybe<Scalars['String']['output']>;
    /**
     * Whether to overwrite the value or not if the injected headers already exist.
     * If not specified, the default value is false.
     */
    overwrite?: Maybe<Scalars['Boolean']['output']>;
  };

/**
 * HTTPCredentialInjectionFilter defines the configuration to inject credentials into the request.
 * This is useful when the backend service requires credentials in the request, and the original
 * request does not contain them. The filter can inject credentials into the request before forwarding
 * it to the backend service.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_CredentialInjection_Input =
  {
    credential: Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_CredentialInjection_Credential_Input;
    /**
     * Header is the name of the header where the credentials are injected.
     * If not specified, the credentials are injected into the Authorization header.
     */
    header?: InputMaybe<Scalars['String']['input']>;
    /**
     * Whether to overwrite the value or not if the injected headers already exist.
     * If not specified, the default value is false.
     */
    overwrite?: InputMaybe<Scalars['Boolean']['input']>;
  };

/** Credential is the credential to be injected. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_CredentialInjection_Credential =
  {
    valueRef: Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_CredentialInjection_Credential_ValueRef;
  };

/** Credential is the credential to be injected. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_CredentialInjection_Credential_Input =
  {
    valueRef: Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_CredentialInjection_Credential_ValueRef_Input;
  };

/**
 * ValueRef is a reference to the secret containing the credentials to be injected.
 * This is an Opaque secret. The credential should be stored in the key
 * "credential", and the value should be the credential to be injected.
 * For example, for basic authentication, the value should be "Basic <base64 encoded username:password>".
 * for bearer token, the value should be "Bearer <token>".
 * Note: The secret must be in the same namespace as the HTTPRouteFilter.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_CredentialInjection_Credential_ValueRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_credentialInjection_credential_valueRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_credentialInjection_credential_valueRef_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_credentialInjection_credential_valueRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_credentialInjection_credential_valueRef_namespace']['output']
    >;
  };

/**
 * ValueRef is a reference to the secret containing the credentials to be injected.
 * This is an Opaque secret. The credential should be stored in the key
 * "credential", and the value should be the credential to be injected.
 * For example, for basic authentication, the value should be "Basic <base64 encoded username:password>".
 * for bearer token, the value should be "Bearer <token>".
 * Note: The secret must be in the same namespace as the HTTPRouteFilter.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_CredentialInjection_Credential_ValueRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_credentialInjection_credential_valueRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_credentialInjection_credential_valueRef_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_credentialInjection_credential_valueRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_credentialInjection_credential_valueRef_namespace']['input']
    >;
  };

/** HTTPDirectResponseFilter defines the configuration to return a fixed response. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_DirectResponse =
  {
    body?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_DirectResponse_Body>;
    /** Content Type of the response. This will be set in the Content-Type header. */
    contentType?: Maybe<Scalars['String']['output']>;
    /**
     * Status Code of the HTTP response
     * If unset, defaults to 200.
     */
    statusCode?: Maybe<Scalars['Int']['output']>;
  };

/** HTTPDirectResponseFilter defines the configuration to return a fixed response. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_DirectResponse_Input =
  {
    body?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_DirectResponse_Body_Input>;
    /** Content Type of the response. This will be set in the Content-Type header. */
    contentType?: InputMaybe<Scalars['String']['input']>;
    /**
     * Status Code of the HTTP response
     * If unset, defaults to 200.
     */
    statusCode?: InputMaybe<Scalars['Int']['input']>;
  };

/** Body of the Response */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_DirectResponse_Body =
  {
    /** Inline contains the value as an inline string. */
    inline?: Maybe<Scalars['String']['output']>;
    /**
     * Type is the type of method to use to read the body value.
     * Valid values are Inline and ValueRef, default is Inline.
     */
    type: Scalars['String']['output'];
    valueRef?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_DirectResponse_Body_ValueRef>;
  };

/** Body of the Response */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_DirectResponse_Body_Input =
  {
    /** Inline contains the value as an inline string. */
    inline?: InputMaybe<Scalars['String']['input']>;
    /**
     * Type is the type of method to use to read the body value.
     * Valid values are Inline and ValueRef, default is Inline.
     */
    type?: Scalars['String']['input'];
    valueRef?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_DirectResponse_Body_ValueRef_Input>;
  };

/**
 * ValueRef contains the contents of the body
 * specified as a local object reference.
 * Only a reference to ConfigMap is supported.
 *
 * The value of key `response.body` in the ConfigMap will be used as the response body.
 * If the key is not found, the first value in the ConfigMap will be used.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_DirectResponse_Body_ValueRef =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_directResponse_body_valueRef_group']['output'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_directResponse_body_valueRef_kind']['output'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_directResponse_body_valueRef_name']['output'];
  };

/**
 * ValueRef contains the contents of the body
 * specified as a local object reference.
 * Only a reference to ConfigMap is supported.
 *
 * The value of key `response.body` in the ConfigMap will be used as the response body.
 * If the key is not found, the first value in the ConfigMap will be used.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_DirectResponse_Body_ValueRef_Input =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_directResponse_body_valueRef_group']['input'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_directResponse_body_valueRef_kind']['input'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1HTTPRouteFilterForAllNamespaces_items_items_spec_directResponse_body_valueRef_name']['input'];
  };

/** HTTPURLRewriteFilter define rewrites of HTTP URL components such as path and host */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite =
  {
    hostname?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Hostname>;
    path?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Path>;
  };

/** HTTPURLRewriteFilter define rewrites of HTTP URL components such as path and host */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Input =
  {
    hostname?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Hostname_Input>;
    path?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Path_Input>;
  };

/**
 * Hostname is the value to be used to replace the Host header value during
 * forwarding.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Hostname =
  {
    /** Header is the name of the header whose value would be used to rewrite the Host header */
    header?: Maybe<Scalars['String']['output']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Hostname_Type;
  };

/**
 * Hostname is the value to be used to replace the Host header value during
 * forwarding.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Hostname_Input =
  {
    /** Header is the name of the header whose value would be used to rewrite the Host header */
    header?: InputMaybe<Scalars['String']['input']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Hostname_Type;
  };

/** HTTPPathModifierType defines the type of Hostname rewrite. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Hostname_Type =
  'Backend' | 'Header';

/** Path defines a path rewrite. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Path =
  {
    replaceRegexMatch?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Path_ReplaceRegexMatch>;
    type: ReplaceRegexMatch_Const;
  };

/** Path defines a path rewrite. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Path_Input =
  {
    replaceRegexMatch?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Path_ReplaceRegexMatch_Input>;
    type: ReplaceRegexMatch_Const;
  };

/**
 * ReplaceRegexMatch defines a path regex rewrite. The path portions matched by the regex pattern are replaced by the defined substitution.
 * https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-field-config-route-v3-routeaction-regex-rewrite
 * Some examples:
 * (1) replaceRegexMatch:
 *       pattern: ^/service/([^/]+)(/.*)$
 *       substitution: \2/instance/\1
 *     Would transform /service/foo/v1/api into /v1/api/instance/foo.
 * (2) replaceRegexMatch:
 *       pattern: one
 *       substitution: two
 *     Would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/two/zzz.
 * (3) replaceRegexMatch:
 *       pattern: ^(.*?)one(.*)$
 *       substitution: \1two\2
 *     Would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/one/zzz.
 * (3) replaceRegexMatch:
 *       pattern: (?i)/xxx/
 *       substitution: /yyy/
 *     Would transform path /aaa/XxX/bbb into /aaa/yyy/bbb (case-insensitive).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Path_ReplaceRegexMatch =
  {
    /**
     * Pattern matches a regular expression against the value of the HTTP Path.The regex string must
     * adhere to the syntax documented in https://github.com/google/re2/wiki/Syntax.
     */
    pattern: Scalars['NonEmptyString']['output'];
    /**
     * Substitution is an expression that replaces the matched portion.The expression may include numbered
     * capture groups that adhere to syntax documented in https://github.com/google/re2/wiki/Syntax.
     */
    substitution: Scalars['String']['output'];
  };

/**
 * ReplaceRegexMatch defines a path regex rewrite. The path portions matched by the regex pattern are replaced by the defined substitution.
 * https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-field-config-route-v3-routeaction-regex-rewrite
 * Some examples:
 * (1) replaceRegexMatch:
 *       pattern: ^/service/([^/]+)(/.*)$
 *       substitution: \2/instance/\1
 *     Would transform /service/foo/v1/api into /v1/api/instance/foo.
 * (2) replaceRegexMatch:
 *       pattern: one
 *       substitution: two
 *     Would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/two/zzz.
 * (3) replaceRegexMatch:
 *       pattern: ^(.*?)one(.*)$
 *       substitution: \1two\2
 *     Would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/one/zzz.
 * (3) replaceRegexMatch:
 *       pattern: (?i)/xxx/
 *       substitution: /yyy/
 *     Would transform path /aaa/XxX/bbb into /aaa/yyy/bbb (case-insensitive).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1HttpRouteFilterForAllNamespaces_Items_Items_Spec_UrlRewrite_Path_ReplaceRegexMatch_Input =
  {
    /**
     * Pattern matches a regular expression against the value of the HTTP Path.The regex string must
     * adhere to the syntax documented in https://github.com/google/re2/wiki/Syntax.
     */
    pattern: Scalars['NonEmptyString']['input'];
    /**
     * Substitution is an expression that replaces the matched portion.The expression may include numbered
     * capture groups that adhere to syntax documented in https://github.com/google/re2/wiki/Syntax.
     */
    substitution: Scalars['String']['input'];
  };

/** Spec defines the desired state of SecurityPolicy. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec = {
  apiKeyAuth?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ApiKeyAuth>;
  authorization?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization>;
  basicAuth?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_BasicAuth>;
  cors?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Cors>;
  extAuth?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth>;
  jwt?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt>;
  oidc?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc>;
  targetRef?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetRef>;
  /**
   * TargetRefs are the names of the Gateway resources this policy
   * is being attached to.
   */
  targetRefs?: Maybe<
    Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetRefs_Items>
    >
  >;
  /** TargetSelectors allow targeting resources for this policy based on labels */
  targetSelectors?: Maybe<
    Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetSelectors_Items>
    >
  >;
};

/** Spec defines the desired state of SecurityPolicy. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Input = {
  apiKeyAuth?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ApiKeyAuth_Input>;
  authorization?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Input>;
  basicAuth?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_BasicAuth_Input>;
  cors?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Cors_Input>;
  extAuth?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Input>;
  jwt?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Input>;
  oidc?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Input>;
  targetRef?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetRef_Input>;
  /**
   * TargetRefs are the names of the Gateway resources this policy
   * is being attached to.
   */
  targetRefs?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetRefs_Items_Input>
    >
  >;
  /** TargetSelectors allow targeting resources for this policy based on labels */
  targetSelectors?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetSelectors_Items_Input>
    >
  >;
};

/** APIKeyAuth defines the configuration for the API Key Authentication. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ApiKeyAuth =
  {
    /**
     * CredentialRefs is the Kubernetes secret which contains the API keys.
     * This is an Opaque secret.
     * Each API key is stored in the key representing the client id.
     * If the secrets have a key for a duplicated client, the first one will be used.
     */
    credentialRefs: Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ApiKeyAuth_CredentialRefs_Items>
    >;
    /**
     * ExtractFrom is where to fetch the key from the coming request.
     * The value from the first source that has a key will be used.
     */
    extractFrom: Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ApiKeyAuth_ExtractFrom_Items>
    >;
    /**
     * ForwardClientIDHeader is the name of the header to forward the client identity to the backend
     * service. The header will be added to the request with the client id as the value.
     */
    forwardClientIDHeader?: Maybe<Scalars['String']['output']>;
    /** Sanitize indicates whether to remove the API key from the request before forwarding it to the backend service. */
    sanitize?: Maybe<Scalars['Boolean']['output']>;
  };

/** APIKeyAuth defines the configuration for the API Key Authentication. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ApiKeyAuth_Input =
  {
    /**
     * CredentialRefs is the Kubernetes secret which contains the API keys.
     * This is an Opaque secret.
     * Each API key is stored in the key representing the client id.
     * If the secrets have a key for a duplicated client, the first one will be used.
     */
    credentialRefs: Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ApiKeyAuth_CredentialRefs_Items_Input>
    >;
    /**
     * ExtractFrom is where to fetch the key from the coming request.
     * The value from the first source that has a key will be used.
     */
    extractFrom: Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ApiKeyAuth_ExtractFrom_Items_Input>
    >;
    /**
     * ForwardClientIDHeader is the name of the header to forward the client identity to the backend
     * service. The header will be added to the request with the client id as the value.
     */
    forwardClientIDHeader?: InputMaybe<Scalars['String']['input']>;
    /** Sanitize indicates whether to remove the API key from the request before forwarding it to the backend service. */
    sanitize?: InputMaybe<Scalars['Boolean']['input']>;
  };

/**
 * SecretObjectReference identifies an API object including its namespace,
 * defaulting to Secret.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ApiKeyAuth_CredentialRefs_Items =
  {
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_apiKeyAuth_credentialRefs_items_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_apiKeyAuth_credentialRefs_items_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_apiKeyAuth_credentialRefs_items_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_apiKeyAuth_credentialRefs_items_namespace']['output']
    >;
  };

/**
 * SecretObjectReference identifies an API object including its namespace,
 * defaulting to Secret.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ApiKeyAuth_CredentialRefs_Items_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_apiKeyAuth_credentialRefs_items_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_apiKeyAuth_credentialRefs_items_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_apiKeyAuth_credentialRefs_items_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_apiKeyAuth_credentialRefs_items_namespace']['input']
    >;
  };

/**
 * ExtractFrom is where to fetch the key from the coming request.
 * Only one of header, param or cookie is supposed to be specified.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ApiKeyAuth_ExtractFrom_Items =
  {
    /**
     * Cookies is the names of the cookie to fetch the key from.
     * If multiple cookies are specified, envoy will look for the api key in the order of the list.
     * This field is optional, but only one of headers, params or cookies is supposed to be specified.
     */
    cookies?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Headers is the names of the header to fetch the key from.
     * If multiple headers are specified, envoy will look for the api key in the order of the list.
     * This field is optional, but only one of headers, params or cookies is supposed to be specified.
     */
    headers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Params is the names of the query parameter to fetch the key from.
     * If multiple params are specified, envoy will look for the api key in the order of the list.
     * This field is optional, but only one of headers, params or cookies is supposed to be specified.
     */
    params?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  };

/**
 * ExtractFrom is where to fetch the key from the coming request.
 * Only one of header, param or cookie is supposed to be specified.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ApiKeyAuth_ExtractFrom_Items_Input =
  {
    /**
     * Cookies is the names of the cookie to fetch the key from.
     * If multiple cookies are specified, envoy will look for the api key in the order of the list.
     * This field is optional, but only one of headers, params or cookies is supposed to be specified.
     */
    cookies?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Headers is the names of the header to fetch the key from.
     * If multiple headers are specified, envoy will look for the api key in the order of the list.
     * This field is optional, but only one of headers, params or cookies is supposed to be specified.
     */
    headers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Params is the names of the query parameter to fetch the key from.
     * If multiple params are specified, envoy will look for the api key in the order of the list.
     * This field is optional, but only one of headers, params or cookies is supposed to be specified.
     */
    params?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  };

/** Authorization defines the authorization configuration. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization =
  {
    defaultAction?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_DefaultAction>;
    /**
     * Rules defines a list of authorization rules.
     * These rules are evaluated in order, the first matching rule will be applied,
     * and the rest will be skipped.
     *
     * For example, if there are two rules: the first rule allows the request
     * and the second rule denies it, when a request matches both rules, it will be allowed.
     */
    rules?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items>
      >
    >;
  };

/** Authorization defines the authorization configuration. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Input =
  {
    defaultAction?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_DefaultAction>;
    /**
     * Rules defines a list of authorization rules.
     * These rules are evaluated in order, the first matching rule will be applied,
     * and the rest will be skipped.
     *
     * For example, if there are two rules: the first rule allows the request
     * and the second rule denies it, when a request matches both rules, it will be allowed.
     */
    rules?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Input>
      >
    >;
  };

/**
 * DefaultAction defines the default action to be taken if no rules match.
 * If not specified, the default action is Deny.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_DefaultAction =
  'Allow' | 'Deny';

/** AuthorizationRule defines a single authorization rule. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items =
  {
    action: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Action;
    /**
     * Name is a user-friendly name for the rule.
     * If not specified, Envoy Gateway will generate a unique name for the rule.
     */
    name?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_name']['output']
    >;
    operation?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Operation>;
    principal: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal;
  };

/** AuthorizationRule defines a single authorization rule. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Input =
  {
    action: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Action;
    /**
     * Name is a user-friendly name for the rule.
     * If not specified, Envoy Gateway will generate a unique name for the rule.
     */
    name?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_name']['input']
    >;
    operation?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Operation_Input>;
    principal: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Input;
  };

/** Action defines the action to be taken if the rule matches. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Action =
  'Allow' | 'Deny';

/**
 * Operation specifies the operation of a request, such as HTTP methods.
 * If not specified, all operations are matched on.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Operation =
  {
    /**
     * Methods are the HTTP methods of the request.
     * If multiple methods are specified, all specified methods are allowed or denied, based on the action of the rule.
     */
    methods: Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Operation_Methods_Items>
    >;
  };

/**
 * Operation specifies the operation of a request, such as HTTP methods.
 * If not specified, all operations are matched on.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Operation_Input =
  {
    /**
     * Methods are the HTTP methods of the request.
     * If multiple methods are specified, all specified methods are allowed or denied, based on the action of the rule.
     */
    methods: Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Operation_Methods_Items>
    >;
  };

/**
 * HTTPMethod describes how to select a HTTP route by matching the HTTP
 * method as defined by
 * [RFC 7231](https://datatracker.ietf.org/doc/html/rfc7231#section-4) and
 * [RFC 5789](https://datatracker.ietf.org/doc/html/rfc5789#section-2).
 * The value is expected in upper case.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Operation_Methods_Items =
  'CONNECT' | 'DELETE' | 'GET' | 'HEAD' | 'OPTIONS' | 'PATCH' | 'POST' | 'PUT' | 'TRACE';

/**
 * Principal specifies the client identity of a request.
 * If there are multiple principal types, all principals must match for the rule to match.
 * For example, if there are two principals: one for client IP and one for JWT claim,
 * the rule will match only if both the client IP and the JWT claim match.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal =
  {
    /**
     * ClientCIDRs are the IP CIDR ranges of the client.
     * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
     *
     * If multiple CIDR ranges are specified, one of the CIDR ranges must match
     * the client IP for the rule to match.
     *
     * The client IP is inferred from the X-Forwarded-For header, a custom header,
     * or the proxy protocol.
     * You can use the `ClientIPDetection` or the `ProxyProtocol` field in
     * the `ClientTrafficPolicy` to configure how the client IP is detected.
     */
    clientCIDRs?: Maybe<
      Array<
        Maybe<
          Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_clientCIDRs_items']['output']
        >
      >
    >;
    /**
     * Headers authorize the request based on user identity extracted from custom headers.
     * If multiple headers are specified, all headers must match for the rule to match.
     */
    headers?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Headers_Items>
      >
    >;
    jwt?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Jwt>;
  };

/**
 * Principal specifies the client identity of a request.
 * If there are multiple principal types, all principals must match for the rule to match.
 * For example, if there are two principals: one for client IP and one for JWT claim,
 * the rule will match only if both the client IP and the JWT claim match.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Input =
  {
    /**
     * ClientCIDRs are the IP CIDR ranges of the client.
     * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
     *
     * If multiple CIDR ranges are specified, one of the CIDR ranges must match
     * the client IP for the rule to match.
     *
     * The client IP is inferred from the X-Forwarded-For header, a custom header,
     * or the proxy protocol.
     * You can use the `ClientIPDetection` or the `ProxyProtocol` field in
     * the `ClientTrafficPolicy` to configure how the client IP is detected.
     */
    clientCIDRs?: InputMaybe<
      Array<
        InputMaybe<
          Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_clientCIDRs_items']['input']
        >
      >
    >;
    /**
     * Headers authorize the request based on user identity extracted from custom headers.
     * If multiple headers are specified, all headers must match for the rule to match.
     */
    headers?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Headers_Items_Input>
      >
    >;
    jwt?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Jwt_Input>;
  };

/** AuthorizationHeaderMatch specifies how to match against the value of an HTTP header within a authorization rule. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Headers_Items =
  {
    /**
     * Name of the HTTP header.
     * The header name is case-insensitive unless PreserveHeaderCase is set to true.
     * For example, "Foo" and "foo" are considered the same header.
     */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_headers_items_name']['output'];
    /**
     * Values are the values that the header must match.
     * If multiple values are specified, the rule will match if any of the values match.
     */
    values: Array<Maybe<Scalars['String']['output']>>;
  };

/** AuthorizationHeaderMatch specifies how to match against the value of an HTTP header within a authorization rule. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Headers_Items_Input =
  {
    /**
     * Name of the HTTP header.
     * The header name is case-insensitive unless PreserveHeaderCase is set to true.
     * For example, "Foo" and "foo" are considered the same header.
     */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_headers_items_name']['input'];
    /**
     * Values are the values that the header must match.
     * If multiple values are specified, the rule will match if any of the values match.
     */
    values: Array<InputMaybe<Scalars['String']['input']>>;
  };

/**
 * JWT authorize the request based on the JWT claims and scopes.
 * Note: in order to use JWT claims for authorization, you must configure the
 * JWT authentication in the same `SecurityPolicy`.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Jwt =
  {
    /**
     * Claims are the claims in a JWT token.
     *
     * If multiple claims are specified, all claims must match for the rule to match.
     * For example, if there are two claims: one for the audience and one for the issuer,
     * the rule will match only if both the audience and the issuer match.
     */
    claims?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Jwt_Claims_Items>
      >
    >;
    /**
     * Provider is the name of the JWT provider that used to verify the JWT token.
     * In order to use JWT claims for authorization, you must configure the JWT
     * authentication with the same provider in the same `SecurityPolicy`.
     */
    provider: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_jwt_provider']['output'];
    /**
     * Scopes are a special type of claim in a JWT token that represents the permissions of the client.
     *
     * The value of the scopes field should be a space delimited string that is expected in the scope parameter,
     * as defined in RFC 6749: https://datatracker.ietf.org/doc/html/rfc6749#page-23.
     *
     * If multiple scopes are specified, all scopes must match for the rule to match.
     */
    scopes?: Maybe<
      Array<
        Maybe<
          Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_jwt_scopes_items']['output']
        >
      >
    >;
  };

/**
 * JWT authorize the request based on the JWT claims and scopes.
 * Note: in order to use JWT claims for authorization, you must configure the
 * JWT authentication in the same `SecurityPolicy`.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Jwt_Input =
  {
    /**
     * Claims are the claims in a JWT token.
     *
     * If multiple claims are specified, all claims must match for the rule to match.
     * For example, if there are two claims: one for the audience and one for the issuer,
     * the rule will match only if both the audience and the issuer match.
     */
    claims?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Jwt_Claims_Items_Input>
      >
    >;
    /**
     * Provider is the name of the JWT provider that used to verify the JWT token.
     * In order to use JWT claims for authorization, you must configure the JWT
     * authentication with the same provider in the same `SecurityPolicy`.
     */
    provider: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_jwt_provider']['input'];
    /**
     * Scopes are a special type of claim in a JWT token that represents the permissions of the client.
     *
     * The value of the scopes field should be a space delimited string that is expected in the scope parameter,
     * as defined in RFC 6749: https://datatracker.ietf.org/doc/html/rfc6749#page-23.
     *
     * If multiple scopes are specified, all scopes must match for the rule to match.
     */
    scopes?: InputMaybe<
      Array<
        InputMaybe<
          Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_jwt_scopes_items']['input']
        >
      >
    >;
  };

/** JWTClaim specifies a claim in a JWT token. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Jwt_Claims_Items =
  {
    /**
     * Name is the name of the claim.
     * If it is a nested claim, use a dot (.) separated string as the name to
     * represent the full path to the claim.
     * For example, if the claim is in the "department" field in the "organization" field,
     * the name should be "organization.department".
     */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_jwt_claims_items_name']['output'];
    valueType?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Jwt_Claims_Items_ValueType>;
    /**
     * Values are the values that the claim must match.
     * If the claim is a string type, the specified value must match exactly.
     * If the claim is a string array type, the specified value must match one of the values in the array.
     * If multiple values are specified, one of the values must match for the rule to match.
     */
    values: Array<Maybe<Scalars['String']['output']>>;
  };

/** JWTClaim specifies a claim in a JWT token. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Jwt_Claims_Items_Input =
  {
    /**
     * Name is the name of the claim.
     * If it is a nested claim, use a dot (.) separated string as the name to
     * represent the full path to the claim.
     * For example, if the claim is in the "department" field in the "organization" field,
     * the name should be "organization.department".
     */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_authorization_rules_items_principal_jwt_claims_items_name']['input'];
    valueType?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Jwt_Claims_Items_ValueType>;
    /**
     * Values are the values that the claim must match.
     * If the claim is a string type, the specified value must match exactly.
     * If the claim is a string array type, the specified value must match one of the values in the array.
     * If multiple values are specified, one of the values must match for the rule to match.
     */
    values: Array<InputMaybe<Scalars['String']['input']>>;
  };

/**
 * ValueType is the type of the claim value.
 * Only String and StringArray types are supported for now.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Authorization_Rules_Items_Principal_Jwt_Claims_Items_ValueType =
  'String' | 'StringArray';

/** BasicAuth defines the configuration for the HTTP Basic Authentication. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_BasicAuth =
  {
    /**
     * This field specifies the header name to forward a successfully authenticated user to
     * the backend. The header will be added to the request with the username as the value.
     *
     * If it is not specified, the username will not be forwarded.
     */
    forwardUsernameHeader?: Maybe<Scalars['String']['output']>;
    users: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_BasicAuth_Users;
  };

/** BasicAuth defines the configuration for the HTTP Basic Authentication. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_BasicAuth_Input =
  {
    /**
     * This field specifies the header name to forward a successfully authenticated user to
     * the backend. The header will be added to the request with the username as the value.
     *
     * If it is not specified, the username will not be forwarded.
     */
    forwardUsernameHeader?: InputMaybe<Scalars['String']['input']>;
    users: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_BasicAuth_Users_Input;
  };

/**
 * The Kubernetes secret which contains the username-password pairs in
 * htpasswd format, used to verify user credentials in the "Authorization"
 * header.
 *
 * This is an Opaque secret. The username-password pairs should be stored in
 * the key ".htpasswd". As the key name indicates, the value needs to be the
 * htpasswd format, for example: "user1:{SHA}hashed_user1_password".
 * Right now, only SHA hash algorithm is supported.
 * Reference to https://httpd.apache.org/docs/2.4/programs/htpasswd.html
 * for more details.
 *
 * Note: The secret must be in the same namespace as the SecurityPolicy.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_BasicAuth_Users =
  {
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_basicAuth_users_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_basicAuth_users_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_basicAuth_users_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_basicAuth_users_namespace']['output']
    >;
  };

/**
 * The Kubernetes secret which contains the username-password pairs in
 * htpasswd format, used to verify user credentials in the "Authorization"
 * header.
 *
 * This is an Opaque secret. The username-password pairs should be stored in
 * the key ".htpasswd". As the key name indicates, the value needs to be the
 * htpasswd format, for example: "user1:{SHA}hashed_user1_password".
 * Right now, only SHA hash algorithm is supported.
 * Reference to https://httpd.apache.org/docs/2.4/programs/htpasswd.html
 * for more details.
 *
 * Note: The secret must be in the same namespace as the SecurityPolicy.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_BasicAuth_Users_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_basicAuth_users_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_basicAuth_users_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_basicAuth_users_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_basicAuth_users_namespace']['input']
    >;
  };

/** CORS defines the configuration for Cross-Origin Resource Sharing (CORS). */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Cors = {
  /**
   * AllowCredentials indicates whether a request can include user credentials
   * like cookies, authentication headers, or TLS client certificates.
   * It specifies the value in the Access-Control-Allow-Credentials CORS response header.
   */
  allowCredentials?: Maybe<Scalars['Boolean']['output']>;
  /**
   * AllowHeaders defines the headers that are allowed to be sent with requests.
   * It specifies the allowed headers in the Access-Control-Allow-Headers CORS response header..
   * The value "*" allows any header to be sent.
   */
  allowHeaders?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * AllowMethods defines the methods that are allowed to make requests.
   * It specifies the allowed methods in the Access-Control-Allow-Methods CORS response header..
   * The value "*" allows any method to be used.
   */
  allowMethods?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * AllowOrigins defines the origins that are allowed to make requests.
   * It specifies the allowed origins in the Access-Control-Allow-Origin CORS response header.
   * The value "*" allows any origin to make requests.
   */
  allowOrigins?: Maybe<
    Array<
      Maybe<
        Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_cors_allowOrigins_items']['output']
      >
    >
  >;
  /**
   * ExposeHeaders defines which response headers should be made accessible to
   * scripts running in the browser.
   * It specifies the headers in the Access-Control-Expose-Headers CORS response header..
   * The value "*" allows any header to be exposed.
   */
  exposeHeaders?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  maxAge?: Maybe<
    Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_cors_maxAge']['output']
  >;
};

/** CORS defines the configuration for Cross-Origin Resource Sharing (CORS). */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Cors_Input =
  {
    /**
     * AllowCredentials indicates whether a request can include user credentials
     * like cookies, authentication headers, or TLS client certificates.
     * It specifies the value in the Access-Control-Allow-Credentials CORS response header.
     */
    allowCredentials?: InputMaybe<Scalars['Boolean']['input']>;
    /**
     * AllowHeaders defines the headers that are allowed to be sent with requests.
     * It specifies the allowed headers in the Access-Control-Allow-Headers CORS response header..
     * The value "*" allows any header to be sent.
     */
    allowHeaders?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * AllowMethods defines the methods that are allowed to make requests.
     * It specifies the allowed methods in the Access-Control-Allow-Methods CORS response header..
     * The value "*" allows any method to be used.
     */
    allowMethods?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * AllowOrigins defines the origins that are allowed to make requests.
     * It specifies the allowed origins in the Access-Control-Allow-Origin CORS response header.
     * The value "*" allows any origin to make requests.
     */
    allowOrigins?: InputMaybe<
      Array<
        InputMaybe<
          Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_cors_allowOrigins_items']['input']
        >
      >
    >;
    /**
     * ExposeHeaders defines which response headers should be made accessible to
     * scripts running in the browser.
     * It specifies the headers in the Access-Control-Expose-Headers CORS response header..
     * The value "*" allows any header to be exposed.
     */
    exposeHeaders?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    maxAge?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_cors_maxAge']['input']
    >;
  };

/** ExtAuth defines the configuration for External Authorization. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth =
  {
    bodyToExtAuth?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_BodyToExtAuth>;
    /**
     * FailOpen is a switch used to control the behavior when a response from the External Authorization service cannot be obtained.
     * If FailOpen is set to true, the system allows the traffic to pass through.
     * Otherwise, if it is set to false or not set (defaulting to false),
     * the system blocks the traffic and returns a HTTP 5xx error, reflecting a fail-closed approach.
     * This setting determines whether to prioritize accessibility over strict security in case of authorization service failure.
     *
     * If set to true, the External Authorization will also be bypassed if its configuration is invalid.
     */
    failOpen?: Maybe<Scalars['Boolean']['output']>;
    grpc?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc>;
    /**
     * HeadersToExtAuth defines the client request headers that will be included
     * in the request to the external authorization service.
     * Note: If not specified, the default behavior for gRPC and HTTP external
     * authorization services is different due to backward compatibility reasons.
     * All headers will be included in the check request to a gRPC authorization server.
     * Only the following headers will be included in the check request to an HTTP
     * authorization server: Host, Method, Path, Content-Length, and Authorization.
     * And these headers will always be included to the check request to an HTTP
     * authorization server by default, no matter whether they are specified
     * in HeadersToExtAuth or not.
     */
    headersToExtAuth?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    http?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http>;
    /**
     * RecomputeRoute clears the route cache and recalculates the routing decision.
     * This field must be enabled if the headers added or modified by the ExtAuth are used for
     * route matching decisions. If the recomputation selects a new route, features targeting
     * the new matched route will be applied.
     */
    recomputeRoute?: Maybe<Scalars['Boolean']['output']>;
  };

/** ExtAuth defines the configuration for External Authorization. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Input =
  {
    bodyToExtAuth?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_BodyToExtAuth_Input>;
    /**
     * FailOpen is a switch used to control the behavior when a response from the External Authorization service cannot be obtained.
     * If FailOpen is set to true, the system allows the traffic to pass through.
     * Otherwise, if it is set to false or not set (defaulting to false),
     * the system blocks the traffic and returns a HTTP 5xx error, reflecting a fail-closed approach.
     * This setting determines whether to prioritize accessibility over strict security in case of authorization service failure.
     *
     * If set to true, the External Authorization will also be bypassed if its configuration is invalid.
     */
    failOpen?: InputMaybe<Scalars['Boolean']['input']>;
    grpc?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_Input>;
    /**
     * HeadersToExtAuth defines the client request headers that will be included
     * in the request to the external authorization service.
     * Note: If not specified, the default behavior for gRPC and HTTP external
     * authorization services is different due to backward compatibility reasons.
     * All headers will be included in the check request to a gRPC authorization server.
     * Only the following headers will be included in the check request to an HTTP
     * authorization server: Host, Method, Path, Content-Length, and Authorization.
     * And these headers will always be included to the check request to an HTTP
     * authorization server by default, no matter whether they are specified
     * in HeadersToExtAuth or not.
     */
    headersToExtAuth?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    http?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_Input>;
    /**
     * RecomputeRoute clears the route cache and recalculates the routing decision.
     * This field must be enabled if the headers added or modified by the ExtAuth are used for
     * route matching decisions. If the recomputation selects a new route, features targeting
     * the new matched route will be applied.
     */
    recomputeRoute?: InputMaybe<Scalars['Boolean']['input']>;
  };

/** BodyToExtAuth defines the Body to Ext Auth configuration. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_BodyToExtAuth =
  {
    /**
     * MaxRequestBytes is the maximum size of a message body that the filter will hold in memory.
     * Envoy will return HTTP 413 and will not initiate the authorization process when buffer
     * reaches the number set in this field.
     * Note that this setting will have precedence over failOpen mode.
     */
    maxRequestBytes: Scalars['Int']['output'];
  };

/** BodyToExtAuth defines the Body to Ext Auth configuration. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_BodyToExtAuth_Input =
  {
    /**
     * MaxRequestBytes is the maximum size of a message body that the filter will hold in memory.
     * Envoy will return HTTP 413 and will not initiate the authorization process when buffer
     * reaches the number set in this field.
     * Note that this setting will have precedence over failOpen mode.
     */
    maxRequestBytes: Scalars['Int']['input'];
  };

/**
 * GRPC defines the gRPC External Authorization service.
 * Either GRPCService or HTTPService must be specified,
 * and only one of them can be provided.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc =
  {
    backendRef?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendRef>;
    /**
     * BackendRefs references a Kubernetes object that represents the
     * backend server to which the authorization request will be sent.
     */
    backendRefs?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendRefs_Items>
      >
    >;
    backendSettings?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings>;
  };

/**
 * GRPC defines the gRPC External Authorization service.
 * Either GRPCService or HTTPService must be specified,
 * and only one of them can be provided.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_Input =
  {
    backendRef?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendRef_Input>;
    /**
     * BackendRefs references a Kubernetes object that represents the
     * backend server to which the authorization request will be sent.
     */
    backendRefs?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendRefs_Items_Input>
      >
    >;
    backendSettings?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Input>;
  };

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRef_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRef_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
  };

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRef_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRef_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
  };

/** BackendRef defines how an ObjectReference that is specific to BackendRef. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendRefs_Items =
  {
    /**
     * Fallback indicates whether the backend is designated as a fallback.
     * Multiple fallback backends can be configured.
     * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
     * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
     * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
     * the health of the active backends falls below 72%.
     */
    fallback?: Maybe<Scalars['Boolean']['output']>;
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRefs_items_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRefs_items_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRefs_items_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRefs_items_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
  };

/** BackendRef defines how an ObjectReference that is specific to BackendRef. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendRefs_Items_Input =
  {
    /**
     * Fallback indicates whether the backend is designated as a fallback.
     * Multiple fallback backends can be configured.
     * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
     * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
     * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
     * the health of the active backends falls below 72%.
     */
    fallback?: InputMaybe<Scalars['Boolean']['input']>;
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRefs_items_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRefs_items_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRefs_items_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendRefs_items_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings =
  {
    circuitBreaker?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_CircuitBreaker>;
    connection?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Connection>;
    dns?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Dns>;
    healthCheck?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck>;
    http2?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Http2>;
    loadBalancer?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer>;
    proxyProtocol?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_ProxyProtocol>;
    retry?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry>;
    tcpKeepalive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_TcpKeepalive>;
    timeout?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Timeout>;
  };

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Input =
  {
    circuitBreaker?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_CircuitBreaker_Input>;
    connection?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Connection_Input>;
    dns?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Dns_Input>;
    healthCheck?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Input>;
    http2?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Http2_Input>;
    loadBalancer?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_Input>;
    proxyProtocol?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_ProxyProtocol_Input>;
    retry?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_Input>;
    tcpKeepalive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_TcpKeepalive_Input>;
    timeout?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Timeout_Input>;
  };

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_CircuitBreaker =
  {
    /** The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule. */
    maxConnections?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRequests?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRetries?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule. */
    maxPendingRequests?: Maybe<Scalars['BigInt']['output']>;
    /**
     * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
     * Default: unlimited.
     */
    maxRequestsPerConnection?: Maybe<Scalars['BigInt']['output']>;
    perEndpoint?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_CircuitBreaker_PerEndpoint>;
  };

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_CircuitBreaker_Input =
  {
    /** The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule. */
    maxConnections?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRequests?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRetries?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule. */
    maxPendingRequests?: InputMaybe<Scalars['BigInt']['input']>;
    /**
     * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
     * Default: unlimited.
     */
    maxRequestsPerConnection?: InputMaybe<Scalars['BigInt']['input']>;
    perEndpoint?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_CircuitBreaker_PerEndpoint_Input>;
  };

/** PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_CircuitBreaker_PerEndpoint =
  {
    /** MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule. */
    maxConnections?: Maybe<Scalars['BigInt']['output']>;
  };

/** PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_CircuitBreaker_PerEndpoint_Input =
  {
    /** MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule. */
    maxConnections?: InputMaybe<Scalars['BigInt']['input']>;
  };

/** Connection includes backend connection settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Connection =
  {
    /**
     * BufferLimit Soft limit on size of the clusters connections read and write buffers.
     * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
     * If unspecified, an implementation defined default is applied (32768 bytes).
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note: that when the suffix is not provided, the value is interpreted as bytes.
     */
    bufferLimit?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Connection_BufferLimit>;
    /**
     * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
     * to backend.
     * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note that when the suffix is not provided, the value is interpreted as bytes.
     */
    socketBufferLimit?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Connection_SocketBufferLimit>;
  };

/** Connection includes backend connection settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Connection_Input =
  {
    /**
     * BufferLimit Soft limit on size of the clusters connections read and write buffers.
     * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
     * If unspecified, an implementation defined default is applied (32768 bytes).
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note: that when the suffix is not provided, the value is interpreted as bytes.
     */
    bufferLimit?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
     * to backend.
     * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note that when the suffix is not provided, the value is interpreted as bytes.
     */
    socketBufferLimit?: InputMaybe<Scalars['JSON']['input']>;
  };

/**
 * BufferLimit Soft limit on size of the clusters connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Connection_BufferLimit =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_connection_bufferLimit_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_connection_bufferLimit_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_connection_bufferLimit_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_connection_bufferLimit_allOf_1']['output']
    >;
  };

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Connection_SocketBufferLimit =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_connection_socketBufferLimit_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_connection_socketBufferLimit_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_connection_socketBufferLimit_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_connection_socketBufferLimit_allOf_1']['output']
    >;
  };

/** DNS includes dns resolution settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Dns =
  {
    dnsRefreshRate?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_dns_dnsRefreshRate']['output']
    >;
    lookupFamily?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Dns_LookupFamily>;
    /**
     * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
     * If the value is set to true, the DNS refresh rate will be set to the resource records TTL.
     * Defaults to true.
     */
    respectDnsTtl?: Maybe<Scalars['Boolean']['output']>;
  };

/** DNS includes dns resolution settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Dns_Input =
  {
    dnsRefreshRate?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_dns_dnsRefreshRate']['input']
    >;
    lookupFamily?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Dns_LookupFamily>;
    /**
     * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
     * If the value is set to true, the DNS refresh rate will be set to the resource records TTL.
     * Defaults to true.
     */
    respectDnsTtl?: InputMaybe<Scalars['Boolean']['input']>;
  };

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Dns_LookupFamily =
  'IPv4' | 'IPv4AndIPv6' | 'IPv4Preferred' | 'IPv6' | 'IPv6Preferred';

/** HealthCheck allows gateway to perform active health checking on backends. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck =
  {
    active?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active>;
    /**
     * When number of unhealthy endpoints for a backend reaches this threshold
     * Envoy will disregard health status and balance across all endpoints.
     * It's designed to prevent a situation in which host failures cascade throughout the cluster
     * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
     */
    panicThreshold?: Maybe<Scalars['Int']['output']>;
    passive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Passive>;
  };

/** HealthCheck allows gateway to perform active health checking on backends. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Input =
  {
    active?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Input>;
    /**
     * When number of unhealthy endpoints for a backend reaches this threshold
     * Envoy will disregard health status and balance across all endpoints.
     * It's designed to prevent a situation in which host failures cascade throughout the cluster
     * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
     */
    panicThreshold?: InputMaybe<Scalars['Int']['input']>;
    passive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Passive_Input>;
  };

/** Active health check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active =
  {
    grpc?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Grpc>;
    /** HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy. */
    healthyThreshold?: Maybe<Scalars['Int']['output']>;
    http?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Http>;
    initialJitter?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_initialJitter']['output']
    >;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_interval']['output']
    >;
    tcp?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Tcp>;
    timeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_timeout']['output']
    >;
    /** Type defines the type of health checker. */
    type: Scalars['String']['output'];
    /** UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy. */
    unhealthyThreshold?: Maybe<Scalars['Int']['output']>;
  };

/** Active health check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Input =
  {
    grpc?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Grpc_Input>;
    /** HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy. */
    healthyThreshold?: InputMaybe<Scalars['Int']['input']>;
    http?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Http_Input>;
    initialJitter?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_initialJitter']['input']
    >;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_interval']['input']
    >;
    tcp?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Tcp_Input>;
    timeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_timeout']['input']
    >;
    /** Type defines the type of health checker. */
    type: Scalars['String']['input'];
    /** UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy. */
    unhealthyThreshold?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Grpc =
  {
    /**
     * Service to send in the health check request.
     * If this is not specified, then the health check request applies to the entire
     * server and not to a specific service.
     */
    service?: Maybe<Scalars['String']['output']>;
  };

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Grpc_Input =
  {
    /**
     * Service to send in the health check request.
     * If this is not specified, then the health check request applies to the entire
     * server and not to a specific service.
     */
    service?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Http =
  {
    expectedResponse?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Http_ExpectedResponse>;
    /**
     * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
     * Defaults to 200 only
     */
    expectedStatuses?: Maybe<Array<Maybe<Scalars['PositiveInt']['output']>>>;
    hostname?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_http_hostname']['output']
    >;
    /**
     * Method defines the HTTP method used for health checking.
     * Defaults to GET
     */
    method?: Maybe<Scalars['String']['output']>;
    /** Path defines the HTTP path that will be requested during health checking. */
    path: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_http_path']['output'];
  };

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Http_Input =
  {
    expectedResponse?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Http_ExpectedResponse_Input>;
    /**
     * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
     * Defaults to 200 only
     */
    expectedStatuses?: InputMaybe<Array<InputMaybe<Scalars['PositiveInt']['input']>>>;
    hostname?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_http_hostname']['input']
    >;
    /**
     * Method defines the HTTP method used for health checking.
     * Defaults to GET
     */
    method?: InputMaybe<Scalars['String']['input']>;
    /** Path defines the HTTP path that will be requested during health checking. */
    path: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_active_http_path']['input'];
  };

/** ExpectedResponse defines a list of HTTP expected responses to match. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Http_ExpectedResponse =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** ExpectedResponse defines a list of HTTP expected responses to match. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Http_ExpectedResponse_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Tcp =
  {
    receive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Tcp_Receive>;
    send?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Tcp_Send>;
  };

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Tcp_Input =
  {
    receive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Tcp_Receive_Input>;
    send?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Tcp_Send_Input>;
  };

/** Receive defines the expected response payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Tcp_Receive =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** Receive defines the expected response payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Tcp_Receive_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/** Send defines the request payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Tcp_Send =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** Send defines the request payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Active_Tcp_Send_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/** Passive passive check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Passive =
  {
    baseEjectionTime?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_passive_baseEjectionTime']['output']
    >;
    /** Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection. */
    consecutive5XxErrors?: Maybe<Scalars['Int']['output']>;
    /** ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection. */
    consecutiveGatewayErrors?: Maybe<Scalars['Int']['output']>;
    /**
     * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
     * Parameter takes effect only when split_external_local_origin_errors is set to true.
     */
    consecutiveLocalOriginFailures?: Maybe<Scalars['Int']['output']>;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_passive_interval']['output']
    >;
    /** MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected. */
    maxEjectionPercent?: Maybe<Scalars['Int']['output']>;
    /** SplitExternalLocalOriginErrors enables splitting of errors between external and local origin. */
    splitExternalLocalOriginErrors?: Maybe<Scalars['Boolean']['output']>;
  };

/** Passive passive check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_HealthCheck_Passive_Input =
  {
    baseEjectionTime?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_passive_baseEjectionTime']['input']
    >;
    /** Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection. */
    consecutive5XxErrors?: InputMaybe<Scalars['Int']['input']>;
    /** ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection. */
    consecutiveGatewayErrors?: InputMaybe<Scalars['Int']['input']>;
    /**
     * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
     * Parameter takes effect only when split_external_local_origin_errors is set to true.
     */
    consecutiveLocalOriginFailures?: InputMaybe<Scalars['Int']['input']>;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_healthCheck_passive_interval']['input']
    >;
    /** MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected. */
    maxEjectionPercent?: InputMaybe<Scalars['Int']['input']>;
    /** SplitExternalLocalOriginErrors enables splitting of errors between external and local origin. */
    splitExternalLocalOriginErrors?: InputMaybe<Scalars['Boolean']['input']>;
  };

/** HTTP2 provides HTTP/2 configuration for backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Http2 =
  {
    /**
     * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
     * If not set, the default value is 1 MiB.
     */
    initialConnectionWindowSize?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Http2_InitialConnectionWindowSize>;
    /**
     * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
     * If not set, the default value is 64 KiB(64*1024).
     */
    initialStreamWindowSize?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Http2_InitialStreamWindowSize>;
    /**
     * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
     * If not set, the default value is 100.
     */
    maxConcurrentStreams?: Maybe<Scalars['Int']['output']>;
    /**
     * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
     * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
     * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
     * Default: TerminateConnection
     */
    onInvalidMessage?: Maybe<Scalars['String']['output']>;
  };

/** HTTP2 provides HTTP/2 configuration for backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Http2_Input =
  {
    /**
     * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
     * If not set, the default value is 1 MiB.
     */
    initialConnectionWindowSize?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
     * If not set, the default value is 64 KiB(64*1024).
     */
    initialStreamWindowSize?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
     * If not set, the default value is 100.
     */
    maxConcurrentStreams?: InputMaybe<Scalars['Int']['input']>;
    /**
     * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
     * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
     * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
     * Default: TerminateConnection
     */
    onInvalidMessage?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Http2_InitialConnectionWindowSize =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_http2_initialConnectionWindowSize_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_http2_initialConnectionWindowSize_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_http2_initialConnectionWindowSize_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_http2_initialConnectionWindowSize_allOf_1']['output']
    >;
  };

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Http2_InitialStreamWindowSize =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_http2_initialStreamWindowSize_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_http2_initialStreamWindowSize_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_http2_initialStreamWindowSize_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_http2_initialStreamWindowSize_allOf_1']['output']
    >;
  };

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer =
  {
    consistentHash?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash>;
    endpointOverride?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_EndpointOverride>;
    slowStart?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_SlowStart>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_Type;
    zoneAware?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ZoneAware>;
  };

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_Input =
  {
    consistentHash?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash_Input>;
    endpointOverride?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_EndpointOverride_Input>;
    slowStart?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_SlowStart_Input>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_Type;
    zoneAware?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ZoneAware_Input>;
  };

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash =
  {
    cookie?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash_Cookie>;
    header?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash_Header>;
    /** The table size for consistent hashing, must be prime number limited to 5000011. */
    tableSize?: Maybe<Scalars['BigInt']['output']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash_Type;
  };

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash_Input =
  {
    cookie?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash_Cookie_Input>;
    header?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash_Header_Input>;
    /** The table size for consistent hashing, must be prime number limited to 5000011. */
    tableSize?: InputMaybe<Scalars['BigInt']['input']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash_Type;
  };

/** Cookie configures the cookie hash policy when the consistent hash type is set to Cookie. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash_Cookie =
  {
    /** Additional Attributes to set for the generated cookie. */
    attributes?: Maybe<Scalars['JSON']['output']>;
    /**
     * Name of the cookie to hash.
     * If this cookie does not exist in the request, Envoy will generate a cookie and set
     * the TTL on the response back to the client based on Layer 4
     * attributes of the backend endpoint, to ensure that these future requests
     * go to the same backend endpoint. Make sure to set the TTL field for this case.
     */
    name: Scalars['String']['output'];
    ttl?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_loadBalancer_consistentHash_cookie_ttl']['output']
    >;
  };

/** Cookie configures the cookie hash policy when the consistent hash type is set to Cookie. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash_Cookie_Input =
  {
    /** Additional Attributes to set for the generated cookie. */
    attributes?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * Name of the cookie to hash.
     * If this cookie does not exist in the request, Envoy will generate a cookie and set
     * the TTL on the response back to the client based on Layer 4
     * attributes of the backend endpoint, to ensure that these future requests
     * go to the same backend endpoint. Make sure to set the TTL field for this case.
     */
    name: Scalars['String']['input'];
    ttl?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_loadBalancer_consistentHash_cookie_ttl']['input']
    >;
  };

/** Header configures the header hash policy when the consistent hash type is set to Header. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash_Header =
  {
    /** Name of the header to hash. */
    name: Scalars['String']['output'];
  };

/** Header configures the header hash policy when the consistent hash type is set to Header. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash_Header_Input =
  {
    /** Name of the header to hash. */
    name: Scalars['String']['input'];
  };

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Cookie".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ConsistentHash_Type =
  'Cookie' | 'Header' | 'SourceIP';

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_EndpointOverride =
  {
    /** ExtractFrom defines the sources to extract endpoint override information from. */
    extractFrom: Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items>
    >;
  };

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_EndpointOverride_Input =
  {
    /** ExtractFrom defines the sources to extract endpoint override information from. */
    extractFrom: Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items_Input>
    >;
  };

/** EndpointOverrideExtractFrom defines a source to extract endpoint override information from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items =
  {
    /**
     * Header defines the header to get the override endpoint addresses.
     * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
     * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
     * The IPv6 address is enclosed in square brackets.
     */
    header?: Maybe<Scalars['String']['output']>;
  };

/** EndpointOverrideExtractFrom defines a source to extract endpoint override information from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items_Input =
  {
    /**
     * Header defines the header to get the override endpoint addresses.
     * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
     * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
     * The IPv6 address is enclosed in square brackets.
     */
    header?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_SlowStart =
  {
    window: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_loadBalancer_slowStart_window']['output'];
  };

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_SlowStart_Input =
  {
    window: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_loadBalancer_slowStart_window']['input'];
  };

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_Type =
  'ConsistentHash' | 'LeastRequest' | 'Random' | 'RoundRobin';

/** ZoneAware defines the configuration related to the distribution of requests between locality zones. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ZoneAware =
  {
    preferLocal?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ZoneAware_PreferLocal>;
  };

/** ZoneAware defines the configuration related to the distribution of requests between locality zones. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ZoneAware_Input =
  {
    preferLocal?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Input>;
  };

/** PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ZoneAware_PreferLocal =
  {
    force?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force>;
    /** MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing. */
    minEndpointsThreshold?: Maybe<Scalars['BigInt']['output']>;
  };

/** PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Input =
  {
    force?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force_Input>;
    /** MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing. */
    minEndpointsThreshold?: InputMaybe<Scalars['BigInt']['input']>;
  };

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force =
  {
    /**
     * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
     * override. This is useful for protecting zones with fewer endpoints.
     */
    minEndpointsInZoneThreshold?: Maybe<Scalars['Int']['output']>;
  };

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force_Input =
  {
    /**
     * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
     * override. This is useful for protecting zones with fewer endpoints.
     */
    minEndpointsInZoneThreshold?: InputMaybe<Scalars['Int']['input']>;
  };

/** ProxyProtocol enables the Proxy Protocol when communicating with the backend. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_ProxyProtocol =
  {
    version: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_ProxyProtocol_Version;
  };

/** ProxyProtocol enables the Proxy Protocol when communicating with the backend. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_ProxyProtocol_Input =
  {
    version: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_ProxyProtocol_Version;
  };

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_ProxyProtocol_Version =
  'V1' | 'V2';

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry =
  {
    /**
     * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
     * that should be sent to the same priority before switching to a different one.
     * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
     */
    numAttemptsPerPriority?: Maybe<Scalars['Int']['output']>;
    /** NumRetries is the number of retries to be attempted. Defaults to 2. */
    numRetries?: Maybe<Scalars['Int']['output']>;
    perRetry?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_PerRetry>;
    retryOn?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_RetryOn>;
  };

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_Input =
  {
    /**
     * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
     * that should be sent to the same priority before switching to a different one.
     * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
     */
    numAttemptsPerPriority?: InputMaybe<Scalars['Int']['input']>;
    /** NumRetries is the number of retries to be attempted. Defaults to 2. */
    numRetries?: InputMaybe<Scalars['Int']['input']>;
    perRetry?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_PerRetry_Input>;
    retryOn?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_RetryOn_Input>;
  };

/** PerRetry is the retry policy to be applied per retry attempt. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_PerRetry =
  {
    backOff?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_PerRetry_BackOff>;
    timeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_retry_perRetry_timeout']['output']
    >;
  };

/** PerRetry is the retry policy to be applied per retry attempt. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_PerRetry_Input =
  {
    backOff?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_PerRetry_BackOff_Input>;
    timeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_retry_perRetry_timeout']['input']
    >;
  };

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_PerRetry_BackOff =
  {
    baseInterval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_retry_perRetry_backOff_baseInterval']['output']
    >;
    maxInterval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_retry_perRetry_backOff_maxInterval']['output']
    >;
  };

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_PerRetry_BackOff_Input =
  {
    baseInterval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_retry_perRetry_backOff_baseInterval']['input']
    >;
    maxInterval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_retry_perRetry_backOff_maxInterval']['input']
    >;
  };

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_RetryOn =
  {
    /**
     * HttpStatusCodes specifies the http status codes to be retried.
     * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
     */
    httpStatusCodes?: Maybe<Array<Maybe<Scalars['PositiveInt']['output']>>>;
    /** Triggers specifies the retry trigger condition(Http/Grpc). */
    triggers?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_RetryOn_Triggers_Items>
      >
    >;
  };

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_RetryOn_Input =
  {
    /**
     * HttpStatusCodes specifies the http status codes to be retried.
     * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
     */
    httpStatusCodes?: InputMaybe<Array<InputMaybe<Scalars['PositiveInt']['input']>>>;
    /** Triggers specifies the retry trigger condition(Http/Grpc). */
    triggers?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_RetryOn_Triggers_Items>
      >
    >;
  };

/** TriggerEnum specifies the conditions that trigger retries. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Retry_RetryOn_Triggers_Items =

    | '_5xx'
    | 'cancelled'
    | 'connect_failure'
    | 'deadline_exceeded'
    | 'gateway_error'
    | 'internal'
    | 'refused_stream'
    | 'reset'
    | 'reset_before_request'
    | 'resource_exhausted'
    | 'retriable_4xx'
    | 'retriable_status_codes'
    | 'unavailable';

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_TcpKeepalive =
  {
    idleTime?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_tcpKeepalive_idleTime']['output']
    >;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_tcpKeepalive_interval']['output']
    >;
    /**
     * The total number of unacknowledged probes to send before deciding
     * the connection is dead.
     * Defaults to 9.
     */
    probes?: Maybe<Scalars['Int']['output']>;
  };

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_TcpKeepalive_Input =
  {
    idleTime?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_tcpKeepalive_idleTime']['input']
    >;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_tcpKeepalive_interval']['input']
    >;
    /**
     * The total number of unacknowledged probes to send before deciding
     * the connection is dead.
     * Defaults to 9.
     */
    probes?: InputMaybe<Scalars['Int']['input']>;
  };

/** Timeout settings for the backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Timeout =
  {
    http?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Timeout_Http>;
    tcp?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Timeout_Tcp>;
  };

/** Timeout settings for the backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Timeout_Input =
  {
    http?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Timeout_Http_Input>;
    tcp?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Timeout_Tcp_Input>;
  };

/** Timeout settings for HTTP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Timeout_Http =
  {
    connectionIdleTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_timeout_http_connectionIdleTimeout']['output']
    >;
    maxConnectionDuration?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_timeout_http_maxConnectionDuration']['output']
    >;
    requestTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_timeout_http_requestTimeout']['output']
    >;
  };

/** Timeout settings for HTTP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Timeout_Http_Input =
  {
    connectionIdleTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_timeout_http_connectionIdleTimeout']['input']
    >;
    maxConnectionDuration?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_timeout_http_maxConnectionDuration']['input']
    >;
    requestTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_timeout_http_requestTimeout']['input']
    >;
  };

/** Timeout settings for TCP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Timeout_Tcp =
  {
    connectTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_timeout_tcp_connectTimeout']['output']
    >;
  };

/** Timeout settings for TCP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Grpc_BackendSettings_Timeout_Tcp_Input =
  {
    connectTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_grpc_backendSettings_timeout_tcp_connectTimeout']['input']
    >;
  };

/**
 * HTTP defines the HTTP External Authorization service.
 * Either GRPCService or HTTPService must be specified,
 * and only one of them can be provided.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http =
  {
    backendRef?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendRef>;
    /**
     * BackendRefs references a Kubernetes object that represents the
     * backend server to which the authorization request will be sent.
     */
    backendRefs?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendRefs_Items>
      >
    >;
    backendSettings?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings>;
    /**
     * HeadersToBackend are the authorization response headers that will be added
     * to the original client request before sending it to the backend server.
     * Note that coexisting headers will be overridden.
     * If not specified, no authorization response headers will be added to the
     * original client request.
     */
    headersToBackend?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Path is the path of the HTTP External Authorization service.
     * If path is specified, the authorization request will be sent to that path,
     * or else the authorization request will use the path of the original request.
     *
     * Please note that the original request path will be appended to the path specified here.
     * For example, if the original request path is "/hello", and the path specified here is "/auth",
     * then the path of the authorization request will be "/auth/hello". If the path is not specified,
     * the path of the authorization request will be "/hello".
     */
    path?: Maybe<Scalars['String']['output']>;
  };

/**
 * HTTP defines the HTTP External Authorization service.
 * Either GRPCService or HTTPService must be specified,
 * and only one of them can be provided.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_Input =
  {
    backendRef?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendRef_Input>;
    /**
     * BackendRefs references a Kubernetes object that represents the
     * backend server to which the authorization request will be sent.
     */
    backendRefs?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendRefs_Items_Input>
      >
    >;
    backendSettings?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Input>;
    /**
     * HeadersToBackend are the authorization response headers that will be added
     * to the original client request before sending it to the backend server.
     * Note that coexisting headers will be overridden.
     * If not specified, no authorization response headers will be added to the
     * original client request.
     */
    headersToBackend?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Path is the path of the HTTP External Authorization service.
     * If path is specified, the authorization request will be sent to that path,
     * or else the authorization request will use the path of the original request.
     *
     * Please note that the original request path will be appended to the path specified here.
     * For example, if the original request path is "/hello", and the path specified here is "/auth",
     * then the path of the authorization request will be "/auth/hello". If the path is not specified,
     * the path of the authorization request will be "/hello".
     */
    path?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRef_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRef_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
  };

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRef_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRef_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
  };

/** BackendRef defines how an ObjectReference that is specific to BackendRef. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendRefs_Items =
  {
    /**
     * Fallback indicates whether the backend is designated as a fallback.
     * Multiple fallback backends can be configured.
     * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
     * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
     * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
     * the health of the active backends falls below 72%.
     */
    fallback?: Maybe<Scalars['Boolean']['output']>;
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRefs_items_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRefs_items_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRefs_items_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRefs_items_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
  };

/** BackendRef defines how an ObjectReference that is specific to BackendRef. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendRefs_Items_Input =
  {
    /**
     * Fallback indicates whether the backend is designated as a fallback.
     * Multiple fallback backends can be configured.
     * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
     * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
     * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
     * the health of the active backends falls below 72%.
     */
    fallback?: InputMaybe<Scalars['Boolean']['input']>;
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRefs_items_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRefs_items_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRefs_items_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendRefs_items_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings =
  {
    circuitBreaker?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_CircuitBreaker>;
    connection?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Connection>;
    dns?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Dns>;
    healthCheck?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck>;
    http2?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Http2>;
    loadBalancer?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer>;
    proxyProtocol?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_ProxyProtocol>;
    retry?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry>;
    tcpKeepalive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_TcpKeepalive>;
    timeout?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Timeout>;
  };

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Input =
  {
    circuitBreaker?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_CircuitBreaker_Input>;
    connection?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Connection_Input>;
    dns?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Dns_Input>;
    healthCheck?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Input>;
    http2?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Http2_Input>;
    loadBalancer?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_Input>;
    proxyProtocol?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_ProxyProtocol_Input>;
    retry?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_Input>;
    tcpKeepalive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_TcpKeepalive_Input>;
    timeout?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Timeout_Input>;
  };

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_CircuitBreaker =
  {
    /** The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule. */
    maxConnections?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRequests?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRetries?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule. */
    maxPendingRequests?: Maybe<Scalars['BigInt']['output']>;
    /**
     * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
     * Default: unlimited.
     */
    maxRequestsPerConnection?: Maybe<Scalars['BigInt']['output']>;
    perEndpoint?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_CircuitBreaker_PerEndpoint>;
  };

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_CircuitBreaker_Input =
  {
    /** The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule. */
    maxConnections?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRequests?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRetries?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule. */
    maxPendingRequests?: InputMaybe<Scalars['BigInt']['input']>;
    /**
     * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
     * Default: unlimited.
     */
    maxRequestsPerConnection?: InputMaybe<Scalars['BigInt']['input']>;
    perEndpoint?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_CircuitBreaker_PerEndpoint_Input>;
  };

/** PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_CircuitBreaker_PerEndpoint =
  {
    /** MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule. */
    maxConnections?: Maybe<Scalars['BigInt']['output']>;
  };

/** PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_CircuitBreaker_PerEndpoint_Input =
  {
    /** MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule. */
    maxConnections?: InputMaybe<Scalars['BigInt']['input']>;
  };

/** Connection includes backend connection settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Connection =
  {
    /**
     * BufferLimit Soft limit on size of the clusters connections read and write buffers.
     * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
     * If unspecified, an implementation defined default is applied (32768 bytes).
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note: that when the suffix is not provided, the value is interpreted as bytes.
     */
    bufferLimit?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Connection_BufferLimit>;
    /**
     * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
     * to backend.
     * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note that when the suffix is not provided, the value is interpreted as bytes.
     */
    socketBufferLimit?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Connection_SocketBufferLimit>;
  };

/** Connection includes backend connection settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Connection_Input =
  {
    /**
     * BufferLimit Soft limit on size of the clusters connections read and write buffers.
     * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
     * If unspecified, an implementation defined default is applied (32768 bytes).
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note: that when the suffix is not provided, the value is interpreted as bytes.
     */
    bufferLimit?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
     * to backend.
     * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note that when the suffix is not provided, the value is interpreted as bytes.
     */
    socketBufferLimit?: InputMaybe<Scalars['JSON']['input']>;
  };

/**
 * BufferLimit Soft limit on size of the clusters connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Connection_BufferLimit =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_connection_bufferLimit_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_connection_bufferLimit_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_connection_bufferLimit_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_connection_bufferLimit_allOf_1']['output']
    >;
  };

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Connection_SocketBufferLimit =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_connection_socketBufferLimit_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_connection_socketBufferLimit_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_connection_socketBufferLimit_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_connection_socketBufferLimit_allOf_1']['output']
    >;
  };

/** DNS includes dns resolution settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Dns =
  {
    dnsRefreshRate?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_dns_dnsRefreshRate']['output']
    >;
    lookupFamily?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Dns_LookupFamily>;
    /**
     * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
     * If the value is set to true, the DNS refresh rate will be set to the resource records TTL.
     * Defaults to true.
     */
    respectDnsTtl?: Maybe<Scalars['Boolean']['output']>;
  };

/** DNS includes dns resolution settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Dns_Input =
  {
    dnsRefreshRate?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_dns_dnsRefreshRate']['input']
    >;
    lookupFamily?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Dns_LookupFamily>;
    /**
     * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
     * If the value is set to true, the DNS refresh rate will be set to the resource records TTL.
     * Defaults to true.
     */
    respectDnsTtl?: InputMaybe<Scalars['Boolean']['input']>;
  };

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Dns_LookupFamily =
  'IPv4' | 'IPv4AndIPv6' | 'IPv4Preferred' | 'IPv6' | 'IPv6Preferred';

/** HealthCheck allows gateway to perform active health checking on backends. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck =
  {
    active?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active>;
    /**
     * When number of unhealthy endpoints for a backend reaches this threshold
     * Envoy will disregard health status and balance across all endpoints.
     * It's designed to prevent a situation in which host failures cascade throughout the cluster
     * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
     */
    panicThreshold?: Maybe<Scalars['Int']['output']>;
    passive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Passive>;
  };

/** HealthCheck allows gateway to perform active health checking on backends. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Input =
  {
    active?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Input>;
    /**
     * When number of unhealthy endpoints for a backend reaches this threshold
     * Envoy will disregard health status and balance across all endpoints.
     * It's designed to prevent a situation in which host failures cascade throughout the cluster
     * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
     */
    panicThreshold?: InputMaybe<Scalars['Int']['input']>;
    passive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Passive_Input>;
  };

/** Active health check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active =
  {
    grpc?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Grpc>;
    /** HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy. */
    healthyThreshold?: Maybe<Scalars['Int']['output']>;
    http?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Http>;
    initialJitter?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_initialJitter']['output']
    >;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_interval']['output']
    >;
    tcp?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Tcp>;
    timeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_timeout']['output']
    >;
    /** Type defines the type of health checker. */
    type: Scalars['String']['output'];
    /** UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy. */
    unhealthyThreshold?: Maybe<Scalars['Int']['output']>;
  };

/** Active health check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Input =
  {
    grpc?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Grpc_Input>;
    /** HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy. */
    healthyThreshold?: InputMaybe<Scalars['Int']['input']>;
    http?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Http_Input>;
    initialJitter?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_initialJitter']['input']
    >;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_interval']['input']
    >;
    tcp?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Tcp_Input>;
    timeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_timeout']['input']
    >;
    /** Type defines the type of health checker. */
    type: Scalars['String']['input'];
    /** UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy. */
    unhealthyThreshold?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Grpc =
  {
    /**
     * Service to send in the health check request.
     * If this is not specified, then the health check request applies to the entire
     * server and not to a specific service.
     */
    service?: Maybe<Scalars['String']['output']>;
  };

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Grpc_Input =
  {
    /**
     * Service to send in the health check request.
     * If this is not specified, then the health check request applies to the entire
     * server and not to a specific service.
     */
    service?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Http =
  {
    expectedResponse?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Http_ExpectedResponse>;
    /**
     * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
     * Defaults to 200 only
     */
    expectedStatuses?: Maybe<Array<Maybe<Scalars['PositiveInt']['output']>>>;
    hostname?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_http_hostname']['output']
    >;
    /**
     * Method defines the HTTP method used for health checking.
     * Defaults to GET
     */
    method?: Maybe<Scalars['String']['output']>;
    /** Path defines the HTTP path that will be requested during health checking. */
    path: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_http_path']['output'];
  };

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Http_Input =
  {
    expectedResponse?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Http_ExpectedResponse_Input>;
    /**
     * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
     * Defaults to 200 only
     */
    expectedStatuses?: InputMaybe<Array<InputMaybe<Scalars['PositiveInt']['input']>>>;
    hostname?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_http_hostname']['input']
    >;
    /**
     * Method defines the HTTP method used for health checking.
     * Defaults to GET
     */
    method?: InputMaybe<Scalars['String']['input']>;
    /** Path defines the HTTP path that will be requested during health checking. */
    path: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_active_http_path']['input'];
  };

/** ExpectedResponse defines a list of HTTP expected responses to match. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Http_ExpectedResponse =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** ExpectedResponse defines a list of HTTP expected responses to match. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Http_ExpectedResponse_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Tcp =
  {
    receive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Tcp_Receive>;
    send?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Tcp_Send>;
  };

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Tcp_Input =
  {
    receive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Tcp_Receive_Input>;
    send?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Tcp_Send_Input>;
  };

/** Receive defines the expected response payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Tcp_Receive =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** Receive defines the expected response payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Tcp_Receive_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/** Send defines the request payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Tcp_Send =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** Send defines the request payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Active_Tcp_Send_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/** Passive passive check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Passive =
  {
    baseEjectionTime?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_passive_baseEjectionTime']['output']
    >;
    /** Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection. */
    consecutive5XxErrors?: Maybe<Scalars['Int']['output']>;
    /** ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection. */
    consecutiveGatewayErrors?: Maybe<Scalars['Int']['output']>;
    /**
     * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
     * Parameter takes effect only when split_external_local_origin_errors is set to true.
     */
    consecutiveLocalOriginFailures?: Maybe<Scalars['Int']['output']>;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_passive_interval']['output']
    >;
    /** MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected. */
    maxEjectionPercent?: Maybe<Scalars['Int']['output']>;
    /** SplitExternalLocalOriginErrors enables splitting of errors between external and local origin. */
    splitExternalLocalOriginErrors?: Maybe<Scalars['Boolean']['output']>;
  };

/** Passive passive check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_HealthCheck_Passive_Input =
  {
    baseEjectionTime?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_passive_baseEjectionTime']['input']
    >;
    /** Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection. */
    consecutive5XxErrors?: InputMaybe<Scalars['Int']['input']>;
    /** ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection. */
    consecutiveGatewayErrors?: InputMaybe<Scalars['Int']['input']>;
    /**
     * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
     * Parameter takes effect only when split_external_local_origin_errors is set to true.
     */
    consecutiveLocalOriginFailures?: InputMaybe<Scalars['Int']['input']>;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_healthCheck_passive_interval']['input']
    >;
    /** MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected. */
    maxEjectionPercent?: InputMaybe<Scalars['Int']['input']>;
    /** SplitExternalLocalOriginErrors enables splitting of errors between external and local origin. */
    splitExternalLocalOriginErrors?: InputMaybe<Scalars['Boolean']['input']>;
  };

/** HTTP2 provides HTTP/2 configuration for backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Http2 =
  {
    /**
     * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
     * If not set, the default value is 1 MiB.
     */
    initialConnectionWindowSize?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Http2_InitialConnectionWindowSize>;
    /**
     * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
     * If not set, the default value is 64 KiB(64*1024).
     */
    initialStreamWindowSize?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Http2_InitialStreamWindowSize>;
    /**
     * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
     * If not set, the default value is 100.
     */
    maxConcurrentStreams?: Maybe<Scalars['Int']['output']>;
    /**
     * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
     * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
     * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
     * Default: TerminateConnection
     */
    onInvalidMessage?: Maybe<Scalars['String']['output']>;
  };

/** HTTP2 provides HTTP/2 configuration for backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Http2_Input =
  {
    /**
     * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
     * If not set, the default value is 1 MiB.
     */
    initialConnectionWindowSize?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
     * If not set, the default value is 64 KiB(64*1024).
     */
    initialStreamWindowSize?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
     * If not set, the default value is 100.
     */
    maxConcurrentStreams?: InputMaybe<Scalars['Int']['input']>;
    /**
     * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
     * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
     * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
     * Default: TerminateConnection
     */
    onInvalidMessage?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Http2_InitialConnectionWindowSize =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_http2_initialConnectionWindowSize_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_http2_initialConnectionWindowSize_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_http2_initialConnectionWindowSize_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_http2_initialConnectionWindowSize_allOf_1']['output']
    >;
  };

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Http2_InitialStreamWindowSize =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_http2_initialStreamWindowSize_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_http2_initialStreamWindowSize_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_http2_initialStreamWindowSize_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_http2_initialStreamWindowSize_allOf_1']['output']
    >;
  };

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer =
  {
    consistentHash?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash>;
    endpointOverride?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_EndpointOverride>;
    slowStart?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_SlowStart>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_Type;
    zoneAware?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ZoneAware>;
  };

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_Input =
  {
    consistentHash?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash_Input>;
    endpointOverride?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_EndpointOverride_Input>;
    slowStart?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_SlowStart_Input>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_Type;
    zoneAware?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ZoneAware_Input>;
  };

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash =
  {
    cookie?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash_Cookie>;
    header?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash_Header>;
    /** The table size for consistent hashing, must be prime number limited to 5000011. */
    tableSize?: Maybe<Scalars['BigInt']['output']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash_Type;
  };

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash_Input =
  {
    cookie?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash_Cookie_Input>;
    header?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash_Header_Input>;
    /** The table size for consistent hashing, must be prime number limited to 5000011. */
    tableSize?: InputMaybe<Scalars['BigInt']['input']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash_Type;
  };

/** Cookie configures the cookie hash policy when the consistent hash type is set to Cookie. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash_Cookie =
  {
    /** Additional Attributes to set for the generated cookie. */
    attributes?: Maybe<Scalars['JSON']['output']>;
    /**
     * Name of the cookie to hash.
     * If this cookie does not exist in the request, Envoy will generate a cookie and set
     * the TTL on the response back to the client based on Layer 4
     * attributes of the backend endpoint, to ensure that these future requests
     * go to the same backend endpoint. Make sure to set the TTL field for this case.
     */
    name: Scalars['String']['output'];
    ttl?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_loadBalancer_consistentHash_cookie_ttl']['output']
    >;
  };

/** Cookie configures the cookie hash policy when the consistent hash type is set to Cookie. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash_Cookie_Input =
  {
    /** Additional Attributes to set for the generated cookie. */
    attributes?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * Name of the cookie to hash.
     * If this cookie does not exist in the request, Envoy will generate a cookie and set
     * the TTL on the response back to the client based on Layer 4
     * attributes of the backend endpoint, to ensure that these future requests
     * go to the same backend endpoint. Make sure to set the TTL field for this case.
     */
    name: Scalars['String']['input'];
    ttl?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_loadBalancer_consistentHash_cookie_ttl']['input']
    >;
  };

/** Header configures the header hash policy when the consistent hash type is set to Header. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash_Header =
  {
    /** Name of the header to hash. */
    name: Scalars['String']['output'];
  };

/** Header configures the header hash policy when the consistent hash type is set to Header. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash_Header_Input =
  {
    /** Name of the header to hash. */
    name: Scalars['String']['input'];
  };

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Cookie".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ConsistentHash_Type =
  'Cookie' | 'Header' | 'SourceIP';

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_EndpointOverride =
  {
    /** ExtractFrom defines the sources to extract endpoint override information from. */
    extractFrom: Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items>
    >;
  };

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_EndpointOverride_Input =
  {
    /** ExtractFrom defines the sources to extract endpoint override information from. */
    extractFrom: Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items_Input>
    >;
  };

/** EndpointOverrideExtractFrom defines a source to extract endpoint override information from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items =
  {
    /**
     * Header defines the header to get the override endpoint addresses.
     * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
     * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
     * The IPv6 address is enclosed in square brackets.
     */
    header?: Maybe<Scalars['String']['output']>;
  };

/** EndpointOverrideExtractFrom defines a source to extract endpoint override information from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items_Input =
  {
    /**
     * Header defines the header to get the override endpoint addresses.
     * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
     * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
     * The IPv6 address is enclosed in square brackets.
     */
    header?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_SlowStart =
  {
    window: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_loadBalancer_slowStart_window']['output'];
  };

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_SlowStart_Input =
  {
    window: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_loadBalancer_slowStart_window']['input'];
  };

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_Type =
  'ConsistentHash' | 'LeastRequest' | 'Random' | 'RoundRobin';

/** ZoneAware defines the configuration related to the distribution of requests between locality zones. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ZoneAware =
  {
    preferLocal?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ZoneAware_PreferLocal>;
  };

/** ZoneAware defines the configuration related to the distribution of requests between locality zones. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ZoneAware_Input =
  {
    preferLocal?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Input>;
  };

/** PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ZoneAware_PreferLocal =
  {
    force?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force>;
    /** MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing. */
    minEndpointsThreshold?: Maybe<Scalars['BigInt']['output']>;
  };

/** PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Input =
  {
    force?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force_Input>;
    /** MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing. */
    minEndpointsThreshold?: InputMaybe<Scalars['BigInt']['input']>;
  };

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force =
  {
    /**
     * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
     * override. This is useful for protecting zones with fewer endpoints.
     */
    minEndpointsInZoneThreshold?: Maybe<Scalars['Int']['output']>;
  };

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force_Input =
  {
    /**
     * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
     * override. This is useful for protecting zones with fewer endpoints.
     */
    minEndpointsInZoneThreshold?: InputMaybe<Scalars['Int']['input']>;
  };

/** ProxyProtocol enables the Proxy Protocol when communicating with the backend. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_ProxyProtocol =
  {
    version: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_ProxyProtocol_Version;
  };

/** ProxyProtocol enables the Proxy Protocol when communicating with the backend. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_ProxyProtocol_Input =
  {
    version: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_ProxyProtocol_Version;
  };

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_ProxyProtocol_Version =
  'V1' | 'V2';

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry =
  {
    /**
     * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
     * that should be sent to the same priority before switching to a different one.
     * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
     */
    numAttemptsPerPriority?: Maybe<Scalars['Int']['output']>;
    /** NumRetries is the number of retries to be attempted. Defaults to 2. */
    numRetries?: Maybe<Scalars['Int']['output']>;
    perRetry?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_PerRetry>;
    retryOn?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_RetryOn>;
  };

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_Input =
  {
    /**
     * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
     * that should be sent to the same priority before switching to a different one.
     * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
     */
    numAttemptsPerPriority?: InputMaybe<Scalars['Int']['input']>;
    /** NumRetries is the number of retries to be attempted. Defaults to 2. */
    numRetries?: InputMaybe<Scalars['Int']['input']>;
    perRetry?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_PerRetry_Input>;
    retryOn?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_RetryOn_Input>;
  };

/** PerRetry is the retry policy to be applied per retry attempt. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_PerRetry =
  {
    backOff?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_PerRetry_BackOff>;
    timeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_retry_perRetry_timeout']['output']
    >;
  };

/** PerRetry is the retry policy to be applied per retry attempt. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_PerRetry_Input =
  {
    backOff?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_PerRetry_BackOff_Input>;
    timeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_retry_perRetry_timeout']['input']
    >;
  };

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_PerRetry_BackOff =
  {
    baseInterval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_retry_perRetry_backOff_baseInterval']['output']
    >;
    maxInterval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_retry_perRetry_backOff_maxInterval']['output']
    >;
  };

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_PerRetry_BackOff_Input =
  {
    baseInterval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_retry_perRetry_backOff_baseInterval']['input']
    >;
    maxInterval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_retry_perRetry_backOff_maxInterval']['input']
    >;
  };

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_RetryOn =
  {
    /**
     * HttpStatusCodes specifies the http status codes to be retried.
     * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
     */
    httpStatusCodes?: Maybe<Array<Maybe<Scalars['PositiveInt']['output']>>>;
    /** Triggers specifies the retry trigger condition(Http/Grpc). */
    triggers?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_RetryOn_Triggers_Items>
      >
    >;
  };

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_RetryOn_Input =
  {
    /**
     * HttpStatusCodes specifies the http status codes to be retried.
     * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
     */
    httpStatusCodes?: InputMaybe<Array<InputMaybe<Scalars['PositiveInt']['input']>>>;
    /** Triggers specifies the retry trigger condition(Http/Grpc). */
    triggers?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_RetryOn_Triggers_Items>
      >
    >;
  };

/** TriggerEnum specifies the conditions that trigger retries. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Retry_RetryOn_Triggers_Items =

    | '_5xx'
    | 'cancelled'
    | 'connect_failure'
    | 'deadline_exceeded'
    | 'gateway_error'
    | 'internal'
    | 'refused_stream'
    | 'reset'
    | 'reset_before_request'
    | 'resource_exhausted'
    | 'retriable_4xx'
    | 'retriable_status_codes'
    | 'unavailable';

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_TcpKeepalive =
  {
    idleTime?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_tcpKeepalive_idleTime']['output']
    >;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_tcpKeepalive_interval']['output']
    >;
    /**
     * The total number of unacknowledged probes to send before deciding
     * the connection is dead.
     * Defaults to 9.
     */
    probes?: Maybe<Scalars['Int']['output']>;
  };

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_TcpKeepalive_Input =
  {
    idleTime?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_tcpKeepalive_idleTime']['input']
    >;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_tcpKeepalive_interval']['input']
    >;
    /**
     * The total number of unacknowledged probes to send before deciding
     * the connection is dead.
     * Defaults to 9.
     */
    probes?: InputMaybe<Scalars['Int']['input']>;
  };

/** Timeout settings for the backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Timeout =
  {
    http?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Timeout_Http>;
    tcp?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Timeout_Tcp>;
  };

/** Timeout settings for the backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Timeout_Input =
  {
    http?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Timeout_Http_Input>;
    tcp?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Timeout_Tcp_Input>;
  };

/** Timeout settings for HTTP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Timeout_Http =
  {
    connectionIdleTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_timeout_http_connectionIdleTimeout']['output']
    >;
    maxConnectionDuration?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_timeout_http_maxConnectionDuration']['output']
    >;
    requestTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_timeout_http_requestTimeout']['output']
    >;
  };

/** Timeout settings for HTTP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Timeout_Http_Input =
  {
    connectionIdleTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_timeout_http_connectionIdleTimeout']['input']
    >;
    maxConnectionDuration?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_timeout_http_maxConnectionDuration']['input']
    >;
    requestTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_timeout_http_requestTimeout']['input']
    >;
  };

/** Timeout settings for TCP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Timeout_Tcp =
  {
    connectTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_timeout_tcp_connectTimeout']['output']
    >;
  };

/** Timeout settings for TCP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_ExtAuth_Http_BackendSettings_Timeout_Tcp_Input =
  {
    connectTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_extAuth_http_backendSettings_timeout_tcp_connectTimeout']['input']
    >;
  };

/** JWT defines the configuration for JSON Web Token (JWT) authentication. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt = {
  /**
   * Optional determines whether a missing JWT is acceptable, defaulting to false if not specified.
   * Note: Even if optional is set to true, JWT authentication will still fail if an invalid JWT is presented.
   */
  optional?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Providers defines the JSON Web Token (JWT) authentication provider type.
   * When multiple JWT providers are specified, the JWT is considered valid if
   * any of the providers successfully validate the JWT. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/jwt_authn_filter.html.
   */
  providers: Array<
    Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items>
  >;
};

/** JWT defines the configuration for JSON Web Token (JWT) authentication. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Input =
  {
    /**
     * Optional determines whether a missing JWT is acceptable, defaulting to false if not specified.
     * Note: Even if optional is set to true, JWT authentication will still fail if an invalid JWT is presented.
     */
    optional?: InputMaybe<Scalars['Boolean']['input']>;
    /**
     * Providers defines the JSON Web Token (JWT) authentication provider type.
     * When multiple JWT providers are specified, the JWT is considered valid if
     * any of the providers successfully validate the JWT. For additional details,
     * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/jwt_authn_filter.html.
     */
    providers: Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_Input>
    >;
  };

/** JWTProvider defines how a JSON Web Token (JWT) can be verified. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items =
  {
    /**
     * Audiences is a list of JWT audiences allowed access. For additional details, see
     * https://tools.ietf.org/html/rfc7519#section-4.1.3. If not provided, JWT audiences
     * are not checked.
     */
    audiences?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * ClaimToHeaders is a list of JWT claims that must be extracted into HTTP request headers
     * For examples, following config:
     * The claim must be of type; string, int, double, bool. Array type claims are not supported
     */
    claimToHeaders?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_ClaimToHeaders_Items>
      >
    >;
    extractFrom?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_ExtractFrom>;
    /**
     * Issuer is the principal that issued the JWT and takes the form of a URL or email address.
     * For additional details, see https://tools.ietf.org/html/rfc7519#section-4.1.1 for
     * URL format and https://rfc-editor.org/rfc/rfc5322.html for email format. If not provided,
     * the JWT issuer is not checked.
     */
    issuer?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_issuer']['output']
    >;
    localJWKS?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_LocalJwks>;
    /**
     * Name defines a unique name for the JWT provider. A name can have a variety of forms,
     * including RFC1123 subdomains, RFC 1123 labels, or RFC 1035 labels.
     */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_name']['output'];
    /**
     * RecomputeRoute clears the route cache and recalculates the routing decision.
     * This field must be enabled if the headers generated from the claim are used for
     * route matching decisions. If the recomputation selects a new route, features targeting
     * the new matched route will be applied.
     */
    recomputeRoute?: Maybe<Scalars['Boolean']['output']>;
    remoteJWKS?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks>;
  };

/** JWTProvider defines how a JSON Web Token (JWT) can be verified. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_Input =
  {
    /**
     * Audiences is a list of JWT audiences allowed access. For additional details, see
     * https://tools.ietf.org/html/rfc7519#section-4.1.3. If not provided, JWT audiences
     * are not checked.
     */
    audiences?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * ClaimToHeaders is a list of JWT claims that must be extracted into HTTP request headers
     * For examples, following config:
     * The claim must be of type; string, int, double, bool. Array type claims are not supported
     */
    claimToHeaders?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_ClaimToHeaders_Items_Input>
      >
    >;
    extractFrom?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_ExtractFrom_Input>;
    /**
     * Issuer is the principal that issued the JWT and takes the form of a URL or email address.
     * For additional details, see https://tools.ietf.org/html/rfc7519#section-4.1.1 for
     * URL format and https://rfc-editor.org/rfc/rfc5322.html for email format. If not provided,
     * the JWT issuer is not checked.
     */
    issuer?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_issuer']['input']
    >;
    localJWKS?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_LocalJwks_Input>;
    /**
     * Name defines a unique name for the JWT provider. A name can have a variety of forms,
     * including RFC1123 subdomains, RFC 1123 labels, or RFC 1035 labels.
     */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_name']['input'];
    /**
     * RecomputeRoute clears the route cache and recalculates the routing decision.
     * This field must be enabled if the headers generated from the claim are used for
     * route matching decisions. If the recomputation selects a new route, features targeting
     * the new matched route will be applied.
     */
    recomputeRoute?: InputMaybe<Scalars['Boolean']['input']>;
    remoteJWKS?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_Input>;
  };

/** ClaimToHeader defines a configuration to convert JWT claims into HTTP headers */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_ClaimToHeaders_Items =
  {
    /**
     * Claim is the JWT Claim that should be saved into the header : it can be a nested claim of type
     * (eg. "claim.nested.key", "sub"). The nested claim name must use dot "."
     * to separate the JSON name path.
     */
    claim: Scalars['String']['output'];
    /** Header defines the name of the HTTP request header that the JWT Claim will be saved into. */
    header: Scalars['String']['output'];
  };

/** ClaimToHeader defines a configuration to convert JWT claims into HTTP headers */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_ClaimToHeaders_Items_Input =
  {
    /**
     * Claim is the JWT Claim that should be saved into the header : it can be a nested claim of type
     * (eg. "claim.nested.key", "sub"). The nested claim name must use dot "."
     * to separate the JSON name path.
     */
    claim: Scalars['String']['input'];
    /** Header defines the name of the HTTP request header that the JWT Claim will be saved into. */
    header: Scalars['String']['input'];
  };

/**
 * ExtractFrom defines different ways to extract the JWT token from HTTP request.
 * If empty, it defaults to extract JWT token from the Authorization HTTP request header using Bearer schema
 * or access_token from query parameters.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_ExtractFrom =
  {
    /** Cookies represents a list of cookie names to extract the JWT token from. */
    cookies?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /** Headers represents a list of HTTP request headers to extract the JWT token from. */
    headers?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_ExtractFrom_Headers_Items>
      >
    >;
    /** Params represents a list of query parameters to extract the JWT token from. */
    params?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  };

/**
 * ExtractFrom defines different ways to extract the JWT token from HTTP request.
 * If empty, it defaults to extract JWT token from the Authorization HTTP request header using Bearer schema
 * or access_token from query parameters.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_ExtractFrom_Input =
  {
    /** Cookies represents a list of cookie names to extract the JWT token from. */
    cookies?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /** Headers represents a list of HTTP request headers to extract the JWT token from. */
    headers?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_ExtractFrom_Headers_Items_Input>
      >
    >;
    /** Params represents a list of query parameters to extract the JWT token from. */
    params?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  };

/** JWTHeaderExtractor defines an HTTP header location to extract JWT token */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_ExtractFrom_Headers_Items =
  {
    /** Name is the HTTP header name to retrieve the token */
    name: Scalars['String']['output'];
    /**
     * ValuePrefix is the prefix that should be stripped before extracting the token.
     * The format would be used by Envoy like "{ValuePrefix}<TOKEN>".
     * For example, "Authorization: Bearer <TOKEN>", then the ValuePrefix="Bearer " with a space at the end.
     */
    valuePrefix?: Maybe<Scalars['String']['output']>;
  };

/** JWTHeaderExtractor defines an HTTP header location to extract JWT token */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_ExtractFrom_Headers_Items_Input =
  {
    /** Name is the HTTP header name to retrieve the token */
    name: Scalars['String']['input'];
    /**
     * ValuePrefix is the prefix that should be stripped before extracting the token.
     * The format would be used by Envoy like "{ValuePrefix}<TOKEN>".
     * For example, "Authorization: Bearer <TOKEN>", then the ValuePrefix="Bearer " with a space at the end.
     */
    valuePrefix?: InputMaybe<Scalars['String']['input']>;
  };

/** LocalJWKS defines how to get the JSON Web Key Sets (JWKS) from a local source. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_LocalJwks =
  {
    /** Inline contains the value as an inline string. */
    inline?: Maybe<Scalars['String']['output']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_LocalJwks_Type;
    valueRef?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_LocalJwks_ValueRef>;
  };

/** LocalJWKS defines how to get the JSON Web Key Sets (JWKS) from a local source. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_LocalJwks_Input =
  {
    /** Inline contains the value as an inline string. */
    inline?: InputMaybe<Scalars['String']['input']>;
    type?: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_LocalJwks_Type;
    valueRef?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_LocalJwks_ValueRef_Input>;
  };

/**
 * Type is the type of method to use to read the body value.
 * Valid values are Inline and ValueRef, default is Inline.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_LocalJwks_Type =
  'Inline' | 'ValueRef';

/**
 * ValueRef is a reference to a local ConfigMap that contains the JSON Web Key Sets (JWKS).
 *
 * The value of key `jwks` in the ConfigMap will be used.
 * If the key is not found, the first value in the ConfigMap will be used.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_LocalJwks_ValueRef =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_localJWKS_valueRef_group']['output'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_localJWKS_valueRef_kind']['output'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_localJWKS_valueRef_name']['output'];
  };

/**
 * ValueRef is a reference to a local ConfigMap that contains the JSON Web Key Sets (JWKS).
 *
 * The value of key `jwks` in the ConfigMap will be used.
 * If the key is not found, the first value in the ConfigMap will be used.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_LocalJwks_ValueRef_Input =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_localJWKS_valueRef_group']['input'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_localJWKS_valueRef_kind']['input'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_localJWKS_valueRef_name']['input'];
  };

/**
 * RemoteJWKS defines how to fetch and cache JSON Web Key Sets (JWKS) from a remote
 * HTTP/HTTPS endpoint.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks =
  {
    backendRef?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendRef>;
    /**
     * BackendRefs references a Kubernetes object that represents the
     * backend server to which the authorization request will be sent.
     */
    backendRefs?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendRefs_Items>
      >
    >;
    backendSettings?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings>;
    /**
     * URI is the HTTPS URI to fetch the JWKS. Envoy's system trust bundle is used to validate the server certificate.
     * If a custom trust bundle is needed, it can be specified in a BackendTLSConfig resource and target the BackendRefs.
     */
    uri: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_uri']['output'];
  };

/**
 * RemoteJWKS defines how to fetch and cache JSON Web Key Sets (JWKS) from a remote
 * HTTP/HTTPS endpoint.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_Input =
  {
    backendRef?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendRef_Input>;
    /**
     * BackendRefs references a Kubernetes object that represents the
     * backend server to which the authorization request will be sent.
     */
    backendRefs?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendRefs_Items_Input>
      >
    >;
    backendSettings?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Input>;
    /**
     * URI is the HTTPS URI to fetch the JWKS. Envoy's system trust bundle is used to validate the server certificate.
     * If a custom trust bundle is needed, it can be specified in a BackendTLSConfig resource and target the BackendRefs.
     */
    uri: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_uri']['input'];
  };

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRef_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRef_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
  };

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRef_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRef_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
  };

/** BackendRef defines how an ObjectReference that is specific to BackendRef. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendRefs_Items =
  {
    /**
     * Fallback indicates whether the backend is designated as a fallback.
     * Multiple fallback backends can be configured.
     * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
     * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
     * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
     * the health of the active backends falls below 72%.
     */
    fallback?: Maybe<Scalars['Boolean']['output']>;
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRefs_items_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRefs_items_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRefs_items_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRefs_items_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
  };

/** BackendRef defines how an ObjectReference that is specific to BackendRef. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendRefs_Items_Input =
  {
    /**
     * Fallback indicates whether the backend is designated as a fallback.
     * Multiple fallback backends can be configured.
     * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
     * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
     * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
     * the health of the active backends falls below 72%.
     */
    fallback?: InputMaybe<Scalars['Boolean']['input']>;
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRefs_items_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRefs_items_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRefs_items_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendRefs_items_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings =
  {
    circuitBreaker?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_CircuitBreaker>;
    connection?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Connection>;
    dns?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Dns>;
    healthCheck?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck>;
    http2?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Http2>;
    loadBalancer?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer>;
    proxyProtocol?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_ProxyProtocol>;
    retry?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry>;
    tcpKeepalive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_TcpKeepalive>;
    timeout?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Timeout>;
  };

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Input =
  {
    circuitBreaker?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_CircuitBreaker_Input>;
    connection?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Connection_Input>;
    dns?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Dns_Input>;
    healthCheck?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Input>;
    http2?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Http2_Input>;
    loadBalancer?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_Input>;
    proxyProtocol?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_ProxyProtocol_Input>;
    retry?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_Input>;
    tcpKeepalive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_TcpKeepalive_Input>;
    timeout?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Timeout_Input>;
  };

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_CircuitBreaker =
  {
    /** The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule. */
    maxConnections?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRequests?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRetries?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule. */
    maxPendingRequests?: Maybe<Scalars['BigInt']['output']>;
    /**
     * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
     * Default: unlimited.
     */
    maxRequestsPerConnection?: Maybe<Scalars['BigInt']['output']>;
    perEndpoint?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_CircuitBreaker_PerEndpoint>;
  };

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_CircuitBreaker_Input =
  {
    /** The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule. */
    maxConnections?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRequests?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRetries?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule. */
    maxPendingRequests?: InputMaybe<Scalars['BigInt']['input']>;
    /**
     * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
     * Default: unlimited.
     */
    maxRequestsPerConnection?: InputMaybe<Scalars['BigInt']['input']>;
    perEndpoint?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_CircuitBreaker_PerEndpoint_Input>;
  };

/** PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_CircuitBreaker_PerEndpoint =
  {
    /** MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule. */
    maxConnections?: Maybe<Scalars['BigInt']['output']>;
  };

/** PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_CircuitBreaker_PerEndpoint_Input =
  {
    /** MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule. */
    maxConnections?: InputMaybe<Scalars['BigInt']['input']>;
  };

/** Connection includes backend connection settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Connection =
  {
    /**
     * BufferLimit Soft limit on size of the clusters connections read and write buffers.
     * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
     * If unspecified, an implementation defined default is applied (32768 bytes).
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note: that when the suffix is not provided, the value is interpreted as bytes.
     */
    bufferLimit?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Connection_BufferLimit>;
    /**
     * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
     * to backend.
     * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note that when the suffix is not provided, the value is interpreted as bytes.
     */
    socketBufferLimit?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Connection_SocketBufferLimit>;
  };

/** Connection includes backend connection settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Connection_Input =
  {
    /**
     * BufferLimit Soft limit on size of the clusters connections read and write buffers.
     * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
     * If unspecified, an implementation defined default is applied (32768 bytes).
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note: that when the suffix is not provided, the value is interpreted as bytes.
     */
    bufferLimit?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
     * to backend.
     * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note that when the suffix is not provided, the value is interpreted as bytes.
     */
    socketBufferLimit?: InputMaybe<Scalars['JSON']['input']>;
  };

/**
 * BufferLimit Soft limit on size of the clusters connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Connection_BufferLimit =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_connection_bufferLimit_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_connection_bufferLimit_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_connection_bufferLimit_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_connection_bufferLimit_allOf_1']['output']
    >;
  };

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Connection_SocketBufferLimit =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_connection_socketBufferLimit_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_connection_socketBufferLimit_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_connection_socketBufferLimit_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_connection_socketBufferLimit_allOf_1']['output']
    >;
  };

/** DNS includes dns resolution settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Dns =
  {
    dnsRefreshRate?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_dns_dnsRefreshRate']['output']
    >;
    lookupFamily?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Dns_LookupFamily>;
    /**
     * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
     * If the value is set to true, the DNS refresh rate will be set to the resource records TTL.
     * Defaults to true.
     */
    respectDnsTtl?: Maybe<Scalars['Boolean']['output']>;
  };

/** DNS includes dns resolution settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Dns_Input =
  {
    dnsRefreshRate?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_dns_dnsRefreshRate']['input']
    >;
    lookupFamily?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Dns_LookupFamily>;
    /**
     * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
     * If the value is set to true, the DNS refresh rate will be set to the resource records TTL.
     * Defaults to true.
     */
    respectDnsTtl?: InputMaybe<Scalars['Boolean']['input']>;
  };

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Dns_LookupFamily =
  'IPv4' | 'IPv4AndIPv6' | 'IPv4Preferred' | 'IPv6' | 'IPv6Preferred';

/** HealthCheck allows gateway to perform active health checking on backends. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck =
  {
    active?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active>;
    /**
     * When number of unhealthy endpoints for a backend reaches this threshold
     * Envoy will disregard health status and balance across all endpoints.
     * It's designed to prevent a situation in which host failures cascade throughout the cluster
     * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
     */
    panicThreshold?: Maybe<Scalars['Int']['output']>;
    passive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Passive>;
  };

/** HealthCheck allows gateway to perform active health checking on backends. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Input =
  {
    active?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Input>;
    /**
     * When number of unhealthy endpoints for a backend reaches this threshold
     * Envoy will disregard health status and balance across all endpoints.
     * It's designed to prevent a situation in which host failures cascade throughout the cluster
     * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
     */
    panicThreshold?: InputMaybe<Scalars['Int']['input']>;
    passive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Passive_Input>;
  };

/** Active health check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active =
  {
    grpc?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Grpc>;
    /** HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy. */
    healthyThreshold?: Maybe<Scalars['Int']['output']>;
    http?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Http>;
    initialJitter?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_initialJitter']['output']
    >;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_interval']['output']
    >;
    tcp?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Tcp>;
    timeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_timeout']['output']
    >;
    /** Type defines the type of health checker. */
    type: Scalars['String']['output'];
    /** UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy. */
    unhealthyThreshold?: Maybe<Scalars['Int']['output']>;
  };

/** Active health check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Input =
  {
    grpc?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Grpc_Input>;
    /** HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy. */
    healthyThreshold?: InputMaybe<Scalars['Int']['input']>;
    http?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Http_Input>;
    initialJitter?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_initialJitter']['input']
    >;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_interval']['input']
    >;
    tcp?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Tcp_Input>;
    timeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_timeout']['input']
    >;
    /** Type defines the type of health checker. */
    type: Scalars['String']['input'];
    /** UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy. */
    unhealthyThreshold?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Grpc =
  {
    /**
     * Service to send in the health check request.
     * If this is not specified, then the health check request applies to the entire
     * server and not to a specific service.
     */
    service?: Maybe<Scalars['String']['output']>;
  };

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Grpc_Input =
  {
    /**
     * Service to send in the health check request.
     * If this is not specified, then the health check request applies to the entire
     * server and not to a specific service.
     */
    service?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Http =
  {
    expectedResponse?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Http_ExpectedResponse>;
    /**
     * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
     * Defaults to 200 only
     */
    expectedStatuses?: Maybe<Array<Maybe<Scalars['PositiveInt']['output']>>>;
    hostname?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_http_hostname']['output']
    >;
    /**
     * Method defines the HTTP method used for health checking.
     * Defaults to GET
     */
    method?: Maybe<Scalars['String']['output']>;
    /** Path defines the HTTP path that will be requested during health checking. */
    path: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_http_path']['output'];
  };

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Http_Input =
  {
    expectedResponse?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Http_ExpectedResponse_Input>;
    /**
     * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
     * Defaults to 200 only
     */
    expectedStatuses?: InputMaybe<Array<InputMaybe<Scalars['PositiveInt']['input']>>>;
    hostname?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_http_hostname']['input']
    >;
    /**
     * Method defines the HTTP method used for health checking.
     * Defaults to GET
     */
    method?: InputMaybe<Scalars['String']['input']>;
    /** Path defines the HTTP path that will be requested during health checking. */
    path: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_active_http_path']['input'];
  };

/** ExpectedResponse defines a list of HTTP expected responses to match. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Http_ExpectedResponse =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** ExpectedResponse defines a list of HTTP expected responses to match. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Http_ExpectedResponse_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Tcp =
  {
    receive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Tcp_Receive>;
    send?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Tcp_Send>;
  };

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Tcp_Input =
  {
    receive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Tcp_Receive_Input>;
    send?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Tcp_Send_Input>;
  };

/** Receive defines the expected response payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Tcp_Receive =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** Receive defines the expected response payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Tcp_Receive_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/** Send defines the request payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Tcp_Send =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** Send defines the request payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Active_Tcp_Send_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/** Passive passive check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Passive =
  {
    baseEjectionTime?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_passive_baseEjectionTime']['output']
    >;
    /** Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection. */
    consecutive5XxErrors?: Maybe<Scalars['Int']['output']>;
    /** ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection. */
    consecutiveGatewayErrors?: Maybe<Scalars['Int']['output']>;
    /**
     * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
     * Parameter takes effect only when split_external_local_origin_errors is set to true.
     */
    consecutiveLocalOriginFailures?: Maybe<Scalars['Int']['output']>;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_passive_interval']['output']
    >;
    /** MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected. */
    maxEjectionPercent?: Maybe<Scalars['Int']['output']>;
    /** SplitExternalLocalOriginErrors enables splitting of errors between external and local origin. */
    splitExternalLocalOriginErrors?: Maybe<Scalars['Boolean']['output']>;
  };

/** Passive passive check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_HealthCheck_Passive_Input =
  {
    baseEjectionTime?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_passive_baseEjectionTime']['input']
    >;
    /** Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection. */
    consecutive5XxErrors?: InputMaybe<Scalars['Int']['input']>;
    /** ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection. */
    consecutiveGatewayErrors?: InputMaybe<Scalars['Int']['input']>;
    /**
     * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
     * Parameter takes effect only when split_external_local_origin_errors is set to true.
     */
    consecutiveLocalOriginFailures?: InputMaybe<Scalars['Int']['input']>;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_healthCheck_passive_interval']['input']
    >;
    /** MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected. */
    maxEjectionPercent?: InputMaybe<Scalars['Int']['input']>;
    /** SplitExternalLocalOriginErrors enables splitting of errors between external and local origin. */
    splitExternalLocalOriginErrors?: InputMaybe<Scalars['Boolean']['input']>;
  };

/** HTTP2 provides HTTP/2 configuration for backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Http2 =
  {
    /**
     * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
     * If not set, the default value is 1 MiB.
     */
    initialConnectionWindowSize?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Http2_InitialConnectionWindowSize>;
    /**
     * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
     * If not set, the default value is 64 KiB(64*1024).
     */
    initialStreamWindowSize?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Http2_InitialStreamWindowSize>;
    /**
     * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
     * If not set, the default value is 100.
     */
    maxConcurrentStreams?: Maybe<Scalars['Int']['output']>;
    /**
     * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
     * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
     * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
     * Default: TerminateConnection
     */
    onInvalidMessage?: Maybe<Scalars['String']['output']>;
  };

/** HTTP2 provides HTTP/2 configuration for backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Http2_Input =
  {
    /**
     * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
     * If not set, the default value is 1 MiB.
     */
    initialConnectionWindowSize?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
     * If not set, the default value is 64 KiB(64*1024).
     */
    initialStreamWindowSize?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
     * If not set, the default value is 100.
     */
    maxConcurrentStreams?: InputMaybe<Scalars['Int']['input']>;
    /**
     * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
     * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
     * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
     * Default: TerminateConnection
     */
    onInvalidMessage?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Http2_InitialConnectionWindowSize =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_http2_initialConnectionWindowSize_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_http2_initialConnectionWindowSize_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_http2_initialConnectionWindowSize_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_http2_initialConnectionWindowSize_allOf_1']['output']
    >;
  };

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Http2_InitialStreamWindowSize =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_http2_initialStreamWindowSize_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_http2_initialStreamWindowSize_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_http2_initialStreamWindowSize_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_http2_initialStreamWindowSize_allOf_1']['output']
    >;
  };

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer =
  {
    consistentHash?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash>;
    endpointOverride?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_EndpointOverride>;
    slowStart?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_SlowStart>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_Type;
    zoneAware?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ZoneAware>;
  };

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_Input =
  {
    consistentHash?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash_Input>;
    endpointOverride?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_EndpointOverride_Input>;
    slowStart?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_SlowStart_Input>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_Type;
    zoneAware?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ZoneAware_Input>;
  };

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash =
  {
    cookie?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash_Cookie>;
    header?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash_Header>;
    /** The table size for consistent hashing, must be prime number limited to 5000011. */
    tableSize?: Maybe<Scalars['BigInt']['output']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash_Type;
  };

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash_Input =
  {
    cookie?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash_Cookie_Input>;
    header?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash_Header_Input>;
    /** The table size for consistent hashing, must be prime number limited to 5000011. */
    tableSize?: InputMaybe<Scalars['BigInt']['input']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash_Type;
  };

/** Cookie configures the cookie hash policy when the consistent hash type is set to Cookie. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash_Cookie =
  {
    /** Additional Attributes to set for the generated cookie. */
    attributes?: Maybe<Scalars['JSON']['output']>;
    /**
     * Name of the cookie to hash.
     * If this cookie does not exist in the request, Envoy will generate a cookie and set
     * the TTL on the response back to the client based on Layer 4
     * attributes of the backend endpoint, to ensure that these future requests
     * go to the same backend endpoint. Make sure to set the TTL field for this case.
     */
    name: Scalars['String']['output'];
    ttl?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_loadBalancer_consistentHash_cookie_ttl']['output']
    >;
  };

/** Cookie configures the cookie hash policy when the consistent hash type is set to Cookie. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash_Cookie_Input =
  {
    /** Additional Attributes to set for the generated cookie. */
    attributes?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * Name of the cookie to hash.
     * If this cookie does not exist in the request, Envoy will generate a cookie and set
     * the TTL on the response back to the client based on Layer 4
     * attributes of the backend endpoint, to ensure that these future requests
     * go to the same backend endpoint. Make sure to set the TTL field for this case.
     */
    name: Scalars['String']['input'];
    ttl?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_loadBalancer_consistentHash_cookie_ttl']['input']
    >;
  };

/** Header configures the header hash policy when the consistent hash type is set to Header. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash_Header =
  {
    /** Name of the header to hash. */
    name: Scalars['String']['output'];
  };

/** Header configures the header hash policy when the consistent hash type is set to Header. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash_Header_Input =
  {
    /** Name of the header to hash. */
    name: Scalars['String']['input'];
  };

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Cookie".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ConsistentHash_Type =
  'Cookie' | 'Header' | 'SourceIP';

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_EndpointOverride =
  {
    /** ExtractFrom defines the sources to extract endpoint override information from. */
    extractFrom: Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items>
    >;
  };

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_EndpointOverride_Input =
  {
    /** ExtractFrom defines the sources to extract endpoint override information from. */
    extractFrom: Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items_Input>
    >;
  };

/** EndpointOverrideExtractFrom defines a source to extract endpoint override information from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items =
  {
    /**
     * Header defines the header to get the override endpoint addresses.
     * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
     * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
     * The IPv6 address is enclosed in square brackets.
     */
    header?: Maybe<Scalars['String']['output']>;
  };

/** EndpointOverrideExtractFrom defines a source to extract endpoint override information from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items_Input =
  {
    /**
     * Header defines the header to get the override endpoint addresses.
     * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
     * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
     * The IPv6 address is enclosed in square brackets.
     */
    header?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_SlowStart =
  {
    window: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_loadBalancer_slowStart_window']['output'];
  };

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_SlowStart_Input =
  {
    window: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_loadBalancer_slowStart_window']['input'];
  };

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_Type =
  'ConsistentHash' | 'LeastRequest' | 'Random' | 'RoundRobin';

/** ZoneAware defines the configuration related to the distribution of requests between locality zones. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ZoneAware =
  {
    preferLocal?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ZoneAware_PreferLocal>;
  };

/** ZoneAware defines the configuration related to the distribution of requests between locality zones. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ZoneAware_Input =
  {
    preferLocal?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Input>;
  };

/** PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ZoneAware_PreferLocal =
  {
    force?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force>;
    /** MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing. */
    minEndpointsThreshold?: Maybe<Scalars['BigInt']['output']>;
  };

/** PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Input =
  {
    force?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force_Input>;
    /** MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing. */
    minEndpointsThreshold?: InputMaybe<Scalars['BigInt']['input']>;
  };

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force =
  {
    /**
     * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
     * override. This is useful for protecting zones with fewer endpoints.
     */
    minEndpointsInZoneThreshold?: Maybe<Scalars['Int']['output']>;
  };

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force_Input =
  {
    /**
     * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
     * override. This is useful for protecting zones with fewer endpoints.
     */
    minEndpointsInZoneThreshold?: InputMaybe<Scalars['Int']['input']>;
  };

/** ProxyProtocol enables the Proxy Protocol when communicating with the backend. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_ProxyProtocol =
  {
    version: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_ProxyProtocol_Version;
  };

/** ProxyProtocol enables the Proxy Protocol when communicating with the backend. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_ProxyProtocol_Input =
  {
    version: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_ProxyProtocol_Version;
  };

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_ProxyProtocol_Version =
  'V1' | 'V2';

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry =
  {
    /**
     * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
     * that should be sent to the same priority before switching to a different one.
     * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
     */
    numAttemptsPerPriority?: Maybe<Scalars['Int']['output']>;
    /** NumRetries is the number of retries to be attempted. Defaults to 2. */
    numRetries?: Maybe<Scalars['Int']['output']>;
    perRetry?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_PerRetry>;
    retryOn?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_RetryOn>;
  };

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_Input =
  {
    /**
     * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
     * that should be sent to the same priority before switching to a different one.
     * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
     */
    numAttemptsPerPriority?: InputMaybe<Scalars['Int']['input']>;
    /** NumRetries is the number of retries to be attempted. Defaults to 2. */
    numRetries?: InputMaybe<Scalars['Int']['input']>;
    perRetry?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_PerRetry_Input>;
    retryOn?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_RetryOn_Input>;
  };

/** PerRetry is the retry policy to be applied per retry attempt. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_PerRetry =
  {
    backOff?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_PerRetry_BackOff>;
    timeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_retry_perRetry_timeout']['output']
    >;
  };

/** PerRetry is the retry policy to be applied per retry attempt. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_PerRetry_Input =
  {
    backOff?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_PerRetry_BackOff_Input>;
    timeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_retry_perRetry_timeout']['input']
    >;
  };

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_PerRetry_BackOff =
  {
    baseInterval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_retry_perRetry_backOff_baseInterval']['output']
    >;
    maxInterval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_retry_perRetry_backOff_maxInterval']['output']
    >;
  };

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_PerRetry_BackOff_Input =
  {
    baseInterval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_retry_perRetry_backOff_baseInterval']['input']
    >;
    maxInterval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_retry_perRetry_backOff_maxInterval']['input']
    >;
  };

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_RetryOn =
  {
    /**
     * HttpStatusCodes specifies the http status codes to be retried.
     * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
     */
    httpStatusCodes?: Maybe<Array<Maybe<Scalars['PositiveInt']['output']>>>;
    /** Triggers specifies the retry trigger condition(Http/Grpc). */
    triggers?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_RetryOn_Triggers_Items>
      >
    >;
  };

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_RetryOn_Input =
  {
    /**
     * HttpStatusCodes specifies the http status codes to be retried.
     * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
     */
    httpStatusCodes?: InputMaybe<Array<InputMaybe<Scalars['PositiveInt']['input']>>>;
    /** Triggers specifies the retry trigger condition(Http/Grpc). */
    triggers?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_RetryOn_Triggers_Items>
      >
    >;
  };

/** TriggerEnum specifies the conditions that trigger retries. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Retry_RetryOn_Triggers_Items =

    | '_5xx'
    | 'cancelled'
    | 'connect_failure'
    | 'deadline_exceeded'
    | 'gateway_error'
    | 'internal'
    | 'refused_stream'
    | 'reset'
    | 'reset_before_request'
    | 'resource_exhausted'
    | 'retriable_4xx'
    | 'retriable_status_codes'
    | 'unavailable';

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_TcpKeepalive =
  {
    idleTime?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_tcpKeepalive_idleTime']['output']
    >;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_tcpKeepalive_interval']['output']
    >;
    /**
     * The total number of unacknowledged probes to send before deciding
     * the connection is dead.
     * Defaults to 9.
     */
    probes?: Maybe<Scalars['Int']['output']>;
  };

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_TcpKeepalive_Input =
  {
    idleTime?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_tcpKeepalive_idleTime']['input']
    >;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_tcpKeepalive_interval']['input']
    >;
    /**
     * The total number of unacknowledged probes to send before deciding
     * the connection is dead.
     * Defaults to 9.
     */
    probes?: InputMaybe<Scalars['Int']['input']>;
  };

/** Timeout settings for the backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Timeout =
  {
    http?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Timeout_Http>;
    tcp?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Timeout_Tcp>;
  };

/** Timeout settings for the backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Timeout_Input =
  {
    http?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Timeout_Http_Input>;
    tcp?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Timeout_Tcp_Input>;
  };

/** Timeout settings for HTTP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Timeout_Http =
  {
    connectionIdleTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_timeout_http_connectionIdleTimeout']['output']
    >;
    maxConnectionDuration?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_timeout_http_maxConnectionDuration']['output']
    >;
    requestTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_timeout_http_requestTimeout']['output']
    >;
  };

/** Timeout settings for HTTP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Timeout_Http_Input =
  {
    connectionIdleTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_timeout_http_connectionIdleTimeout']['input']
    >;
    maxConnectionDuration?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_timeout_http_maxConnectionDuration']['input']
    >;
    requestTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_timeout_http_requestTimeout']['input']
    >;
  };

/** Timeout settings for TCP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Timeout_Tcp =
  {
    connectTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_timeout_tcp_connectTimeout']['output']
    >;
  };

/** Timeout settings for TCP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Jwt_Providers_Items_RemoteJwks_BackendSettings_Timeout_Tcp_Input =
  {
    connectTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_jwt_providers_items_remoteJWKS_backendSettings_timeout_tcp_connectTimeout']['input']
    >;
  };

/** OIDC defines the configuration for the OpenID Connect (OIDC) authentication. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc = {
  /**
   * The client ID to be used in the OIDC
   * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
   *
   * Only one of clientID or clientIDRef must be set.
   */
  clientID?: Maybe<Scalars['NonEmptyString']['output']>;
  clientIDRef?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_ClientIdRef>;
  clientSecret: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_ClientSecret;
  cookieConfig?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_CookieConfig>;
  cookieDomain?: Maybe<
    Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_cookieDomain']['output']
  >;
  cookieNames?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_CookieNames>;
  defaultRefreshTokenTTL?: Maybe<
    Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_defaultRefreshTokenTTL']['output']
  >;
  defaultTokenTTL?: Maybe<
    Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_defaultTokenTTL']['output']
  >;
  denyRedirect?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_DenyRedirect>;
  /**
   * ForwardAccessToken indicates whether the Envoy should forward the access token
   * via the Authorization header Bearer scheme to the upstream.
   * If not specified, defaults to false.
   */
  forwardAccessToken?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The path to log a user out, clearing their credential cookies.
   *
   * If not specified, uses a default logout path "/logout"
   */
  logoutPath?: Maybe<Scalars['String']['output']>;
  /**
   * Skips OIDC authentication when the request contains a header that will be extracted by the JWT filter. Unless
   * explicitly stated otherwise in the extractFrom field, this will be the "Authorization: Bearer ..." header.
   *
   * The passThroughAuthHeader option is typically used for non-browser clients that may not be able to handle OIDC
   * redirects and wish to directly supply a token instead.
   *
   * If not specified, defaults to false.
   */
  passThroughAuthHeader?: Maybe<Scalars['Boolean']['output']>;
  provider: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider;
  /**
   * The redirect URL to be used in the OIDC
   * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
   * If not specified, uses the default redirect URI "%REQ(x-forwarded-proto)%://%REQ(:authority)%/oauth2/callback"
   */
  redirectURL?: Maybe<Scalars['String']['output']>;
  /**
   * RefreshToken indicates whether the Envoy should automatically refresh the
   * id token and access token when they expire.
   * When set to true, the Envoy will use the refresh token to get a new id token
   * and access token when they expire.
   *
   * If not specified, defaults to false.
   */
  refreshToken?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The OIDC resources to be used in the
   * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
   */
  resources?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * The OIDC scopes to be used in the
   * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
   * The "openid" scope is always added to the list of scopes if not already
   * specified.
   */
  scopes?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** OIDC defines the configuration for the OpenID Connect (OIDC) authentication. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Input =
  {
    /**
     * The client ID to be used in the OIDC
     * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
     *
     * Only one of clientID or clientIDRef must be set.
     */
    clientID?: InputMaybe<Scalars['NonEmptyString']['input']>;
    clientIDRef?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_ClientIdRef_Input>;
    clientSecret: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_ClientSecret_Input;
    cookieConfig?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_CookieConfig_Input>;
    cookieDomain?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_cookieDomain']['input']
    >;
    cookieNames?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_CookieNames_Input>;
    defaultRefreshTokenTTL?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_defaultRefreshTokenTTL']['input']
    >;
    defaultTokenTTL?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_defaultTokenTTL']['input']
    >;
    denyRedirect?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_DenyRedirect_Input>;
    /**
     * ForwardAccessToken indicates whether the Envoy should forward the access token
     * via the Authorization header Bearer scheme to the upstream.
     * If not specified, defaults to false.
     */
    forwardAccessToken?: InputMaybe<Scalars['Boolean']['input']>;
    /**
     * The path to log a user out, clearing their credential cookies.
     *
     * If not specified, uses a default logout path "/logout"
     */
    logoutPath?: InputMaybe<Scalars['String']['input']>;
    /**
     * Skips OIDC authentication when the request contains a header that will be extracted by the JWT filter. Unless
     * explicitly stated otherwise in the extractFrom field, this will be the "Authorization: Bearer ..." header.
     *
     * The passThroughAuthHeader option is typically used for non-browser clients that may not be able to handle OIDC
     * redirects and wish to directly supply a token instead.
     *
     * If not specified, defaults to false.
     */
    passThroughAuthHeader?: InputMaybe<Scalars['Boolean']['input']>;
    provider: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_Input;
    /**
     * The redirect URL to be used in the OIDC
     * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
     * If not specified, uses the default redirect URI "%REQ(x-forwarded-proto)%://%REQ(:authority)%/oauth2/callback"
     */
    redirectURL?: InputMaybe<Scalars['String']['input']>;
    /**
     * RefreshToken indicates whether the Envoy should automatically refresh the
     * id token and access token when they expire.
     * When set to true, the Envoy will use the refresh token to get a new id token
     * and access token when they expire.
     *
     * If not specified, defaults to false.
     */
    refreshToken?: InputMaybe<Scalars['Boolean']['input']>;
    /**
     * The OIDC resources to be used in the
     * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
     */
    resources?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * The OIDC scopes to be used in the
     * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
     * The "openid" scope is always added to the list of scopes if not already
     * specified.
     */
    scopes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  };

/**
 * The Kubernetes secret which contains the client ID to be used in the
 * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
 * Exactly one of clientID or clientIDRef must be set.
 * This is an Opaque secret. The client ID should be stored in the key "client-id".
 *
 * Only one of clientID or clientIDRef must be set.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_ClientIdRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientIDRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientIDRef_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientIDRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientIDRef_namespace']['output']
    >;
  };

/**
 * The Kubernetes secret which contains the client ID to be used in the
 * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
 * Exactly one of clientID or clientIDRef must be set.
 * This is an Opaque secret. The client ID should be stored in the key "client-id".
 *
 * Only one of clientID or clientIDRef must be set.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_ClientIdRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientIDRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientIDRef_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientIDRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientIDRef_namespace']['input']
    >;
  };

/**
 * The Kubernetes secret which contains the OIDC client secret to be used in the
 * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
 *
 * This is an Opaque secret. The client secret should be stored in the key
 * "client-secret".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_ClientSecret =
  {
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientSecret_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientSecret_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientSecret_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientSecret_namespace']['output']
    >;
  };

/**
 * The Kubernetes secret which contains the OIDC client secret to be used in the
 * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
 *
 * This is an Opaque secret. The client secret should be stored in the key
 * "client-secret".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_ClientSecret_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientSecret_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientSecret_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientSecret_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_clientSecret_namespace']['input']
    >;
  };

/**
 * CookieConfigs allows setting the SameSite attribute for OIDC cookies.
 * By default, its unset.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_CookieConfig =
  {
    sameSite?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_CookieConfig_SameSite>;
  };

/**
 * CookieConfigs allows setting the SameSite attribute for OIDC cookies.
 * By default, its unset.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_CookieConfig_Input =
  {
    sameSite?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_CookieConfig_SameSite>;
  };

export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_CookieConfig_SameSite =
  'Lax' | 'None' | 'Strict';

/**
 * The optional cookie name overrides to be used for Bearer and IdToken cookies in the
 * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
 * If not specified, uses a randomly generated suffix
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_CookieNames =
  {
    /**
     * The name of the cookie used to store the AccessToken in the
     * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
     * If not specified, defaults to "AccessToken-(randomly generated uid)"
     */
    accessToken?: Maybe<Scalars['String']['output']>;
    /**
     * The name of the cookie used to store the IdToken in the
     * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
     * If not specified, defaults to "IdToken-(randomly generated uid)"
     */
    idToken?: Maybe<Scalars['String']['output']>;
  };

/**
 * The optional cookie name overrides to be used for Bearer and IdToken cookies in the
 * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
 * If not specified, uses a randomly generated suffix
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_CookieNames_Input =
  {
    /**
     * The name of the cookie used to store the AccessToken in the
     * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
     * If not specified, defaults to "AccessToken-(randomly generated uid)"
     */
    accessToken?: InputMaybe<Scalars['String']['input']>;
    /**
     * The name of the cookie used to store the IdToken in the
     * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
     * If not specified, defaults to "IdToken-(randomly generated uid)"
     */
    idToken?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * Any request that matches any of the provided matchers (with either tokens that are expired or missing tokens) will not be redirected to the OIDC Provider.
 * This behavior can be useful for AJAX or machine requests.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_DenyRedirect =
  {
    /** Defines the headers to match against the request to deny redirect to the OIDC Provider. */
    headers: Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_DenyRedirect_Headers_Items>
    >;
  };

/**
 * Any request that matches any of the provided matchers (with either tokens that are expired or missing tokens) will not be redirected to the OIDC Provider.
 * This behavior can be useful for AJAX or machine requests.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_DenyRedirect_Input =
  {
    /** Defines the headers to match against the request to deny redirect to the OIDC Provider. */
    headers: Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_DenyRedirect_Headers_Items_Input>
    >;
  };

/** OIDCDenyRedirectHeader defines how a header is matched */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_DenyRedirect_Headers_Items =
  {
    /** Specifies the name of the header in the request. */
    name: Scalars['NonEmptyString']['output'];
    type?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_DenyRedirect_Headers_Items_Type>;
    /** Value specifies the string value that the match must have. */
    value: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_denyRedirect_headers_items_value']['output'];
  };

/** OIDCDenyRedirectHeader defines how a header is matched */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_DenyRedirect_Headers_Items_Input =
  {
    /** Specifies the name of the header in the request. */
    name: Scalars['NonEmptyString']['input'];
    type?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_DenyRedirect_Headers_Items_Type>;
    /** Value specifies the string value that the match must have. */
    value: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_denyRedirect_headers_items_value']['input'];
  };

/** Type specifies how to match against a string. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_DenyRedirect_Headers_Items_Type =
  'Exact' | 'Prefix' | 'RegularExpression' | 'Suffix';

/** The OIDC Provider configuration. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider =
  {
    /**
     * The OIDC Provider's [authorization endpoint](https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint).
     * If not provided, EG will try to discover it from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse).
     */
    authorizationEndpoint?: Maybe<Scalars['String']['output']>;
    backendRef?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendRef>;
    /**
     * BackendRefs references a Kubernetes object that represents the
     * backend server to which the authorization request will be sent.
     */
    backendRefs?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendRefs_Items>
      >
    >;
    backendSettings?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings>;
    /**
     * The OIDC Provider's [end session endpoint](https://openid.net/specs/openid-connect-core-1_0.html#RPLogout).
     *
     * If the end session endpoint is provided, EG will use it to log out the user from the OIDC Provider when the user accesses the logout path.
     * EG will also try to discover the end session endpoint from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse) when authorizationEndpoint or tokenEndpoint is not provided.
     */
    endSessionEndpoint?: Maybe<Scalars['String']['output']>;
    /**
     * The OIDC Provider's [issuer identifier](https://openid.net/specs/openid-connect-discovery-1_0.html#IssuerDiscovery).
     * Issuer MUST be a URI RFC 3986 [RFC3986] with a scheme component that MUST
     * be https, a host component, and optionally, port and path components and
     * no query or fragment components.
     */
    issuer: Scalars['NonEmptyString']['output'];
    /**
     * The OIDC Provider's [token endpoint](https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint).
     * If not provided, EG will try to discover it from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse).
     */
    tokenEndpoint?: Maybe<Scalars['String']['output']>;
  };

/** The OIDC Provider configuration. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_Input =
  {
    /**
     * The OIDC Provider's [authorization endpoint](https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint).
     * If not provided, EG will try to discover it from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse).
     */
    authorizationEndpoint?: InputMaybe<Scalars['String']['input']>;
    backendRef?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendRef_Input>;
    /**
     * BackendRefs references a Kubernetes object that represents the
     * backend server to which the authorization request will be sent.
     */
    backendRefs?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendRefs_Items_Input>
      >
    >;
    backendSettings?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Input>;
    /**
     * The OIDC Provider's [end session endpoint](https://openid.net/specs/openid-connect-core-1_0.html#RPLogout).
     *
     * If the end session endpoint is provided, EG will use it to log out the user from the OIDC Provider when the user accesses the logout path.
     * EG will also try to discover the end session endpoint from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse) when authorizationEndpoint or tokenEndpoint is not provided.
     */
    endSessionEndpoint?: InputMaybe<Scalars['String']['input']>;
    /**
     * The OIDC Provider's [issuer identifier](https://openid.net/specs/openid-connect-discovery-1_0.html#IssuerDiscovery).
     * Issuer MUST be a URI RFC 3986 [RFC3986] with a scheme component that MUST
     * be https, a host component, and optionally, port and path components and
     * no query or fragment components.
     */
    issuer: Scalars['NonEmptyString']['input'];
    /**
     * The OIDC Provider's [token endpoint](https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint).
     * If not provided, EG will try to discover it from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse).
     */
    tokenEndpoint?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRef_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRef_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
  };

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRef_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRef_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
  };

/** BackendRef defines how an ObjectReference that is specific to BackendRef. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendRefs_Items =
  {
    /**
     * Fallback indicates whether the backend is designated as a fallback.
     * Multiple fallback backends can be configured.
     * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
     * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
     * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
     * the health of the active backends falls below 72%.
     */
    fallback?: Maybe<Scalars['Boolean']['output']>;
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRefs_items_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRefs_items_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRefs_items_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRefs_items_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
  };

/** BackendRef defines how an ObjectReference that is specific to BackendRef. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendRefs_Items_Input =
  {
    /**
     * Fallback indicates whether the backend is designated as a fallback.
     * Multiple fallback backends can be configured.
     * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
     * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
     * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
     * the health of the active backends falls below 72%.
     */
    fallback?: InputMaybe<Scalars['Boolean']['input']>;
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRefs_items_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRefs_items_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRefs_items_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendRefs_items_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings =
  {
    circuitBreaker?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_CircuitBreaker>;
    connection?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Connection>;
    dns?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Dns>;
    healthCheck?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck>;
    http2?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Http2>;
    loadBalancer?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer>;
    proxyProtocol?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_ProxyProtocol>;
    retry?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry>;
    tcpKeepalive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_TcpKeepalive>;
    timeout?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Timeout>;
  };

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Input =
  {
    circuitBreaker?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_CircuitBreaker_Input>;
    connection?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Connection_Input>;
    dns?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Dns_Input>;
    healthCheck?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Input>;
    http2?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Http2_Input>;
    loadBalancer?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_Input>;
    proxyProtocol?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_ProxyProtocol_Input>;
    retry?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_Input>;
    tcpKeepalive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_TcpKeepalive_Input>;
    timeout?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Timeout_Input>;
  };

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_CircuitBreaker =
  {
    /** The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule. */
    maxConnections?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRequests?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRetries?: Maybe<Scalars['BigInt']['output']>;
    /** The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule. */
    maxPendingRequests?: Maybe<Scalars['BigInt']['output']>;
    /**
     * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
     * Default: unlimited.
     */
    maxRequestsPerConnection?: Maybe<Scalars['BigInt']['output']>;
    perEndpoint?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_CircuitBreaker_PerEndpoint>;
  };

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_CircuitBreaker_Input =
  {
    /** The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule. */
    maxConnections?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRequests?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule. */
    maxParallelRetries?: InputMaybe<Scalars['BigInt']['input']>;
    /** The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule. */
    maxPendingRequests?: InputMaybe<Scalars['BigInt']['input']>;
    /**
     * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
     * Default: unlimited.
     */
    maxRequestsPerConnection?: InputMaybe<Scalars['BigInt']['input']>;
    perEndpoint?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_CircuitBreaker_PerEndpoint_Input>;
  };

/** PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_CircuitBreaker_PerEndpoint =
  {
    /** MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule. */
    maxConnections?: Maybe<Scalars['BigInt']['output']>;
  };

/** PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_CircuitBreaker_PerEndpoint_Input =
  {
    /** MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule. */
    maxConnections?: InputMaybe<Scalars['BigInt']['input']>;
  };

/** Connection includes backend connection settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Connection =
  {
    /**
     * BufferLimit Soft limit on size of the clusters connections read and write buffers.
     * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
     * If unspecified, an implementation defined default is applied (32768 bytes).
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note: that when the suffix is not provided, the value is interpreted as bytes.
     */
    bufferLimit?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Connection_BufferLimit>;
    /**
     * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
     * to backend.
     * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note that when the suffix is not provided, the value is interpreted as bytes.
     */
    socketBufferLimit?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Connection_SocketBufferLimit>;
  };

/** Connection includes backend connection settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Connection_Input =
  {
    /**
     * BufferLimit Soft limit on size of the clusters connections read and write buffers.
     * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
     * If unspecified, an implementation defined default is applied (32768 bytes).
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note: that when the suffix is not provided, the value is interpreted as bytes.
     */
    bufferLimit?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
     * to backend.
     * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
     * For example, 20Mi, 1Gi, 256Ki etc.
     * Note that when the suffix is not provided, the value is interpreted as bytes.
     */
    socketBufferLimit?: InputMaybe<Scalars['JSON']['input']>;
  };

/**
 * BufferLimit Soft limit on size of the clusters connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Connection_BufferLimit =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_connection_bufferLimit_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_connection_bufferLimit_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_connection_bufferLimit_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_connection_bufferLimit_allOf_1']['output']
    >;
  };

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Connection_SocketBufferLimit =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_connection_socketBufferLimit_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_connection_socketBufferLimit_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_connection_socketBufferLimit_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_connection_socketBufferLimit_allOf_1']['output']
    >;
  };

/** DNS includes dns resolution settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Dns =
  {
    dnsRefreshRate?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_dns_dnsRefreshRate']['output']
    >;
    lookupFamily?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Dns_LookupFamily>;
    /**
     * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
     * If the value is set to true, the DNS refresh rate will be set to the resource records TTL.
     * Defaults to true.
     */
    respectDnsTtl?: Maybe<Scalars['Boolean']['output']>;
  };

/** DNS includes dns resolution settings. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Dns_Input =
  {
    dnsRefreshRate?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_dns_dnsRefreshRate']['input']
    >;
    lookupFamily?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Dns_LookupFamily>;
    /**
     * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
     * If the value is set to true, the DNS refresh rate will be set to the resource records TTL.
     * Defaults to true.
     */
    respectDnsTtl?: InputMaybe<Scalars['Boolean']['input']>;
  };

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Dns_LookupFamily =
  'IPv4' | 'IPv4AndIPv6' | 'IPv4Preferred' | 'IPv6' | 'IPv6Preferred';

/** HealthCheck allows gateway to perform active health checking on backends. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck =
  {
    active?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active>;
    /**
     * When number of unhealthy endpoints for a backend reaches this threshold
     * Envoy will disregard health status and balance across all endpoints.
     * It's designed to prevent a situation in which host failures cascade throughout the cluster
     * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
     */
    panicThreshold?: Maybe<Scalars['Int']['output']>;
    passive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Passive>;
  };

/** HealthCheck allows gateway to perform active health checking on backends. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Input =
  {
    active?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Input>;
    /**
     * When number of unhealthy endpoints for a backend reaches this threshold
     * Envoy will disregard health status and balance across all endpoints.
     * It's designed to prevent a situation in which host failures cascade throughout the cluster
     * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
     */
    panicThreshold?: InputMaybe<Scalars['Int']['input']>;
    passive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Passive_Input>;
  };

/** Active health check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active =
  {
    grpc?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Grpc>;
    /** HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy. */
    healthyThreshold?: Maybe<Scalars['Int']['output']>;
    http?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Http>;
    initialJitter?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_initialJitter']['output']
    >;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_interval']['output']
    >;
    tcp?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Tcp>;
    timeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_timeout']['output']
    >;
    /** Type defines the type of health checker. */
    type: Scalars['String']['output'];
    /** UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy. */
    unhealthyThreshold?: Maybe<Scalars['Int']['output']>;
  };

/** Active health check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Input =
  {
    grpc?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Grpc_Input>;
    /** HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy. */
    healthyThreshold?: InputMaybe<Scalars['Int']['input']>;
    http?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Http_Input>;
    initialJitter?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_initialJitter']['input']
    >;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_interval']['input']
    >;
    tcp?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Tcp_Input>;
    timeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_timeout']['input']
    >;
    /** Type defines the type of health checker. */
    type: Scalars['String']['input'];
    /** UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy. */
    unhealthyThreshold?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Grpc =
  {
    /**
     * Service to send in the health check request.
     * If this is not specified, then the health check request applies to the entire
     * server and not to a specific service.
     */
    service?: Maybe<Scalars['String']['output']>;
  };

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Grpc_Input =
  {
    /**
     * Service to send in the health check request.
     * If this is not specified, then the health check request applies to the entire
     * server and not to a specific service.
     */
    service?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Http =
  {
    expectedResponse?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Http_ExpectedResponse>;
    /**
     * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
     * Defaults to 200 only
     */
    expectedStatuses?: Maybe<Array<Maybe<Scalars['PositiveInt']['output']>>>;
    hostname?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_http_hostname']['output']
    >;
    /**
     * Method defines the HTTP method used for health checking.
     * Defaults to GET
     */
    method?: Maybe<Scalars['String']['output']>;
    /** Path defines the HTTP path that will be requested during health checking. */
    path: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_http_path']['output'];
  };

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Http_Input =
  {
    expectedResponse?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Http_ExpectedResponse_Input>;
    /**
     * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
     * Defaults to 200 only
     */
    expectedStatuses?: InputMaybe<Array<InputMaybe<Scalars['PositiveInt']['input']>>>;
    hostname?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_http_hostname']['input']
    >;
    /**
     * Method defines the HTTP method used for health checking.
     * Defaults to GET
     */
    method?: InputMaybe<Scalars['String']['input']>;
    /** Path defines the HTTP path that will be requested during health checking. */
    path: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_active_http_path']['input'];
  };

/** ExpectedResponse defines a list of HTTP expected responses to match. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Http_ExpectedResponse =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** ExpectedResponse defines a list of HTTP expected responses to match. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Http_ExpectedResponse_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Tcp =
  {
    receive?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Tcp_Receive>;
    send?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Tcp_Send>;
  };

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Tcp_Input =
  {
    receive?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Tcp_Receive_Input>;
    send?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Tcp_Send_Input>;
  };

/** Receive defines the expected response payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Tcp_Receive =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** Receive defines the expected response payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Tcp_Receive_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/** Send defines the request payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Tcp_Send =
  {
    /** Binary payload base64 encoded. */
    binary?: Maybe<Scalars['Byte']['output']>;
    /** Text payload in plain text. */
    text?: Maybe<Scalars['String']['output']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['output'];
  };

/** Send defines the request payload. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Active_Tcp_Send_Input =
  {
    /** Binary payload base64 encoded. */
    binary?: InputMaybe<Scalars['Byte']['input']>;
    /** Text payload in plain text. */
    text?: InputMaybe<Scalars['String']['input']>;
    /** Type defines the type of the payload. */
    type: Scalars['String']['input'];
  };

/** Passive passive check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Passive =
  {
    baseEjectionTime?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_passive_baseEjectionTime']['output']
    >;
    /** Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection. */
    consecutive5XxErrors?: Maybe<Scalars['Int']['output']>;
    /** ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection. */
    consecutiveGatewayErrors?: Maybe<Scalars['Int']['output']>;
    /**
     * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
     * Parameter takes effect only when split_external_local_origin_errors is set to true.
     */
    consecutiveLocalOriginFailures?: Maybe<Scalars['Int']['output']>;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_passive_interval']['output']
    >;
    /** MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected. */
    maxEjectionPercent?: Maybe<Scalars['Int']['output']>;
    /** SplitExternalLocalOriginErrors enables splitting of errors between external and local origin. */
    splitExternalLocalOriginErrors?: Maybe<Scalars['Boolean']['output']>;
  };

/** Passive passive check configuration */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_HealthCheck_Passive_Input =
  {
    baseEjectionTime?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_passive_baseEjectionTime']['input']
    >;
    /** Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection. */
    consecutive5XxErrors?: InputMaybe<Scalars['Int']['input']>;
    /** ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection. */
    consecutiveGatewayErrors?: InputMaybe<Scalars['Int']['input']>;
    /**
     * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
     * Parameter takes effect only when split_external_local_origin_errors is set to true.
     */
    consecutiveLocalOriginFailures?: InputMaybe<Scalars['Int']['input']>;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_healthCheck_passive_interval']['input']
    >;
    /** MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected. */
    maxEjectionPercent?: InputMaybe<Scalars['Int']['input']>;
    /** SplitExternalLocalOriginErrors enables splitting of errors between external and local origin. */
    splitExternalLocalOriginErrors?: InputMaybe<Scalars['Boolean']['input']>;
  };

/** HTTP2 provides HTTP/2 configuration for backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Http2 =
  {
    /**
     * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
     * If not set, the default value is 1 MiB.
     */
    initialConnectionWindowSize?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Http2_InitialConnectionWindowSize>;
    /**
     * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
     * If not set, the default value is 64 KiB(64*1024).
     */
    initialStreamWindowSize?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Http2_InitialStreamWindowSize>;
    /**
     * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
     * If not set, the default value is 100.
     */
    maxConcurrentStreams?: Maybe<Scalars['Int']['output']>;
    /**
     * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
     * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
     * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
     * Default: TerminateConnection
     */
    onInvalidMessage?: Maybe<Scalars['String']['output']>;
  };

/** HTTP2 provides HTTP/2 configuration for backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Http2_Input =
  {
    /**
     * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
     * If not set, the default value is 1 MiB.
     */
    initialConnectionWindowSize?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
     * If not set, the default value is 64 KiB(64*1024).
     */
    initialStreamWindowSize?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
     * If not set, the default value is 100.
     */
    maxConcurrentStreams?: InputMaybe<Scalars['Int']['input']>;
    /**
     * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
     * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
     * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
     * Default: TerminateConnection
     */
    onInvalidMessage?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Http2_InitialConnectionWindowSize =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_http2_initialConnectionWindowSize_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_http2_initialConnectionWindowSize_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_http2_initialConnectionWindowSize_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_http2_initialConnectionWindowSize_allOf_1']['output']
    >;
  };

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Http2_InitialStreamWindowSize =
  {
    Int?: Maybe<Scalars['Int']['output']>;
    String?: Maybe<Scalars['String']['output']>;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_http2_initialStreamWindowSize_allOf_0?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_http2_initialStreamWindowSize_allOf_0']['output']
    >;
    query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_http2_initialStreamWindowSize_allOf_1?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_http2_initialStreamWindowSize_allOf_1']['output']
    >;
  };

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer =
  {
    consistentHash?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash>;
    endpointOverride?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_EndpointOverride>;
    slowStart?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_SlowStart>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_Type;
    zoneAware?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ZoneAware>;
  };

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_Input =
  {
    consistentHash?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash_Input>;
    endpointOverride?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_EndpointOverride_Input>;
    slowStart?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_SlowStart_Input>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_Type;
    zoneAware?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ZoneAware_Input>;
  };

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash =
  {
    cookie?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash_Cookie>;
    header?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash_Header>;
    /** The table size for consistent hashing, must be prime number limited to 5000011. */
    tableSize?: Maybe<Scalars['BigInt']['output']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash_Type;
  };

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash_Input =
  {
    cookie?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash_Cookie_Input>;
    header?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash_Header_Input>;
    /** The table size for consistent hashing, must be prime number limited to 5000011. */
    tableSize?: InputMaybe<Scalars['BigInt']['input']>;
    type: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash_Type;
  };

/** Cookie configures the cookie hash policy when the consistent hash type is set to Cookie. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash_Cookie =
  {
    /** Additional Attributes to set for the generated cookie. */
    attributes?: Maybe<Scalars['JSON']['output']>;
    /**
     * Name of the cookie to hash.
     * If this cookie does not exist in the request, Envoy will generate a cookie and set
     * the TTL on the response back to the client based on Layer 4
     * attributes of the backend endpoint, to ensure that these future requests
     * go to the same backend endpoint. Make sure to set the TTL field for this case.
     */
    name: Scalars['String']['output'];
    ttl?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_loadBalancer_consistentHash_cookie_ttl']['output']
    >;
  };

/** Cookie configures the cookie hash policy when the consistent hash type is set to Cookie. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash_Cookie_Input =
  {
    /** Additional Attributes to set for the generated cookie. */
    attributes?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * Name of the cookie to hash.
     * If this cookie does not exist in the request, Envoy will generate a cookie and set
     * the TTL on the response back to the client based on Layer 4
     * attributes of the backend endpoint, to ensure that these future requests
     * go to the same backend endpoint. Make sure to set the TTL field for this case.
     */
    name: Scalars['String']['input'];
    ttl?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_loadBalancer_consistentHash_cookie_ttl']['input']
    >;
  };

/** Header configures the header hash policy when the consistent hash type is set to Header. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash_Header =
  {
    /** Name of the header to hash. */
    name: Scalars['String']['output'];
  };

/** Header configures the header hash policy when the consistent hash type is set to Header. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash_Header_Input =
  {
    /** Name of the header to hash. */
    name: Scalars['String']['input'];
  };

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Cookie".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ConsistentHash_Type =
  'Cookie' | 'Header' | 'SourceIP';

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_EndpointOverride =
  {
    /** ExtractFrom defines the sources to extract endpoint override information from. */
    extractFrom: Array<
      Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items>
    >;
  };

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_EndpointOverride_Input =
  {
    /** ExtractFrom defines the sources to extract endpoint override information from. */
    extractFrom: Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items_Input>
    >;
  };

/** EndpointOverrideExtractFrom defines a source to extract endpoint override information from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items =
  {
    /**
     * Header defines the header to get the override endpoint addresses.
     * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
     * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
     * The IPv6 address is enclosed in square brackets.
     */
    header?: Maybe<Scalars['String']['output']>;
  };

/** EndpointOverrideExtractFrom defines a source to extract endpoint override information from. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_EndpointOverride_ExtractFrom_Items_Input =
  {
    /**
     * Header defines the header to get the override endpoint addresses.
     * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
     * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
     * The IPv6 address is enclosed in square brackets.
     */
    header?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_SlowStart =
  {
    window: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_loadBalancer_slowStart_window']['output'];
  };

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_SlowStart_Input =
  {
    window: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_loadBalancer_slowStart_window']['input'];
  };

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_Type =
  'ConsistentHash' | 'LeastRequest' | 'Random' | 'RoundRobin';

/** ZoneAware defines the configuration related to the distribution of requests between locality zones. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ZoneAware =
  {
    preferLocal?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ZoneAware_PreferLocal>;
  };

/** ZoneAware defines the configuration related to the distribution of requests between locality zones. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ZoneAware_Input =
  {
    preferLocal?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Input>;
  };

/** PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ZoneAware_PreferLocal =
  {
    force?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force>;
    /** MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing. */
    minEndpointsThreshold?: Maybe<Scalars['BigInt']['output']>;
  };

/** PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Input =
  {
    force?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force_Input>;
    /** MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing. */
    minEndpointsThreshold?: InputMaybe<Scalars['BigInt']['input']>;
  };

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force =
  {
    /**
     * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
     * override. This is useful for protecting zones with fewer endpoints.
     */
    minEndpointsInZoneThreshold?: Maybe<Scalars['Int']['output']>;
  };

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_LoadBalancer_ZoneAware_PreferLocal_Force_Input =
  {
    /**
     * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
     * override. This is useful for protecting zones with fewer endpoints.
     */
    minEndpointsInZoneThreshold?: InputMaybe<Scalars['Int']['input']>;
  };

/** ProxyProtocol enables the Proxy Protocol when communicating with the backend. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_ProxyProtocol =
  {
    version: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_ProxyProtocol_Version;
  };

/** ProxyProtocol enables the Proxy Protocol when communicating with the backend. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_ProxyProtocol_Input =
  {
    version: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_ProxyProtocol_Version;
  };

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_ProxyProtocol_Version =
  'V1' | 'V2';

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry =
  {
    /**
     * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
     * that should be sent to the same priority before switching to a different one.
     * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
     */
    numAttemptsPerPriority?: Maybe<Scalars['Int']['output']>;
    /** NumRetries is the number of retries to be attempted. Defaults to 2. */
    numRetries?: Maybe<Scalars['Int']['output']>;
    perRetry?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_PerRetry>;
    retryOn?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_RetryOn>;
  };

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_Input =
  {
    /**
     * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
     * that should be sent to the same priority before switching to a different one.
     * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
     */
    numAttemptsPerPriority?: InputMaybe<Scalars['Int']['input']>;
    /** NumRetries is the number of retries to be attempted. Defaults to 2. */
    numRetries?: InputMaybe<Scalars['Int']['input']>;
    perRetry?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_PerRetry_Input>;
    retryOn?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_RetryOn_Input>;
  };

/** PerRetry is the retry policy to be applied per retry attempt. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_PerRetry =
  {
    backOff?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_PerRetry_BackOff>;
    timeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_retry_perRetry_timeout']['output']
    >;
  };

/** PerRetry is the retry policy to be applied per retry attempt. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_PerRetry_Input =
  {
    backOff?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_PerRetry_BackOff_Input>;
    timeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_retry_perRetry_timeout']['input']
    >;
  };

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_PerRetry_BackOff =
  {
    baseInterval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_retry_perRetry_backOff_baseInterval']['output']
    >;
    maxInterval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_retry_perRetry_backOff_maxInterval']['output']
    >;
  };

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_PerRetry_BackOff_Input =
  {
    baseInterval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_retry_perRetry_backOff_baseInterval']['input']
    >;
    maxInterval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_retry_perRetry_backOff_maxInterval']['input']
    >;
  };

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_RetryOn =
  {
    /**
     * HttpStatusCodes specifies the http status codes to be retried.
     * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
     */
    httpStatusCodes?: Maybe<Array<Maybe<Scalars['PositiveInt']['output']>>>;
    /** Triggers specifies the retry trigger condition(Http/Grpc). */
    triggers?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_RetryOn_Triggers_Items>
      >
    >;
  };

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_RetryOn_Input =
  {
    /**
     * HttpStatusCodes specifies the http status codes to be retried.
     * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
     */
    httpStatusCodes?: InputMaybe<Array<InputMaybe<Scalars['PositiveInt']['input']>>>;
    /** Triggers specifies the retry trigger condition(Http/Grpc). */
    triggers?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_RetryOn_Triggers_Items>
      >
    >;
  };

/** TriggerEnum specifies the conditions that trigger retries. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Retry_RetryOn_Triggers_Items =

    | '_5xx'
    | 'cancelled'
    | 'connect_failure'
    | 'deadline_exceeded'
    | 'gateway_error'
    | 'internal'
    | 'refused_stream'
    | 'reset'
    | 'reset_before_request'
    | 'resource_exhausted'
    | 'retriable_4xx'
    | 'retriable_status_codes'
    | 'unavailable';

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_TcpKeepalive =
  {
    idleTime?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_tcpKeepalive_idleTime']['output']
    >;
    interval?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_tcpKeepalive_interval']['output']
    >;
    /**
     * The total number of unacknowledged probes to send before deciding
     * the connection is dead.
     * Defaults to 9.
     */
    probes?: Maybe<Scalars['Int']['output']>;
  };

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_TcpKeepalive_Input =
  {
    idleTime?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_tcpKeepalive_idleTime']['input']
    >;
    interval?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_tcpKeepalive_interval']['input']
    >;
    /**
     * The total number of unacknowledged probes to send before deciding
     * the connection is dead.
     * Defaults to 9.
     */
    probes?: InputMaybe<Scalars['Int']['input']>;
  };

/** Timeout settings for the backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Timeout =
  {
    http?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Timeout_Http>;
    tcp?: Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Timeout_Tcp>;
  };

/** Timeout settings for the backend connections. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Timeout_Input =
  {
    http?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Timeout_Http_Input>;
    tcp?: InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Timeout_Tcp_Input>;
  };

/** Timeout settings for HTTP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Timeout_Http =
  {
    connectionIdleTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_timeout_http_connectionIdleTimeout']['output']
    >;
    maxConnectionDuration?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_timeout_http_maxConnectionDuration']['output']
    >;
    requestTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_timeout_http_requestTimeout']['output']
    >;
  };

/** Timeout settings for HTTP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Timeout_Http_Input =
  {
    connectionIdleTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_timeout_http_connectionIdleTimeout']['input']
    >;
    maxConnectionDuration?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_timeout_http_maxConnectionDuration']['input']
    >;
    requestTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_timeout_http_requestTimeout']['input']
    >;
  };

/** Timeout settings for TCP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Timeout_Tcp =
  {
    connectTimeout?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_timeout_tcp_connectTimeout']['output']
    >;
  };

/** Timeout settings for TCP. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_Oidc_Provider_BackendSettings_Timeout_Tcp_Input =
  {
    connectTimeout?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_oidc_provider_backendSettings_timeout_tcp_connectTimeout']['input']
    >;
  };

/**
 * TargetRef is the name of the resource this policy is being attached to.
 * This policy and the TargetRef MUST be in the same namespace for this
 * Policy to have effect
 *
 * Deprecated: use targetRefs/targetSelectors instead
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetRef =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRef_group']['output'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRef_kind']['output'];
    /** Name is the name of the target resource. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRef_name']['output'];
    sectionName?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRef_sectionName']['output']
    >;
  };

/**
 * TargetRef is the name of the resource this policy is being attached to.
 * This policy and the TargetRef MUST be in the same namespace for this
 * Policy to have effect
 *
 * Deprecated: use targetRefs/targetSelectors instead
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetRef_Input =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRef_group']['input'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRef_kind']['input'];
    /** Name is the name of the target resource. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRef_name']['input'];
    sectionName?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRef_sectionName']['input']
    >;
  };

/**
 * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
 * direct policy to. This should be used as part of Policy resources that can
 * target single resources. For more information on how this policy attachment
 * mode works, and a sample Policy resource, refer to the policy attachment
 * documentation for Gateway API.
 *
 * Note: This should only be used for direct policy attachment when references
 * to SectionName are actually needed. In all other cases,
 * LocalPolicyTargetReference should be used.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetRefs_Items =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRefs_items_group']['output'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRefs_items_kind']['output'];
    /** Name is the name of the target resource. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRefs_items_name']['output'];
    sectionName?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRefs_items_sectionName']['output']
    >;
  };

/**
 * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
 * direct policy to. This should be used as part of Policy resources that can
 * target single resources. For more information on how this policy attachment
 * mode works, and a sample Policy resource, refer to the policy attachment
 * documentation for Gateway API.
 *
 * Note: This should only be used for direct policy attachment when references
 * to SectionName are actually needed. In all other cases,
 * LocalPolicyTargetReference should be used.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetRefs_Items_Input =
  {
    group: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRefs_items_group']['input'];
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRefs_items_kind']['input'];
    /** Name is the name of the target resource. */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRefs_items_name']['input'];
    sectionName?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetRefs_items_sectionName']['input']
    >;
  };

export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetSelectors_Items =
  {
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetSelectors_items_group']['output']
    >;
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetSelectors_items_kind']['output'];
    /** MatchExpressions is a list of label selector requirements. The requirements are ANDed. */
    matchExpressions?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetSelectors_Items_MatchExpressions_Items>
      >
    >;
    /** MatchLabels are the set of label selectors for identifying the targeted resource */
    matchLabels?: Maybe<Scalars['JSON']['output']>;
  };

export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetSelectors_Items_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetSelectors_items_group']['input']
    >;
    kind: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_spec_targetSelectors_items_kind']['input'];
    /** MatchExpressions is a list of label selector requirements. The requirements are ANDed. */
    matchExpressions?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetSelectors_Items_MatchExpressions_Items_Input>
      >
    >;
    /** MatchLabels are the set of label selectors for identifying the targeted resource */
    matchLabels?: InputMaybe<Scalars['JSON']['input']>;
  };

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetSelectors_Items_MatchExpressions_Items =
  {
    /** key is the label key that the selector applies to. */
    key: Scalars['String']['output'];
    /**
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and DoesNotExist.
     */
    operator: Scalars['String']['output'];
    /**
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     */
    values?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  };

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Spec_TargetSelectors_Items_MatchExpressions_Items_Input =
  {
    /** key is the label key that the selector applies to. */
    key: Scalars['String']['input'];
    /**
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and DoesNotExist.
     */
    operator: Scalars['String']['input'];
    /**
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     */
    values?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  };

/** Status defines the current status of SecurityPolicy. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status = {
  /**
   * Ancestors is a list of ancestor resources (usually Gateways) that are
   * associated with the policy, and the status of the policy with respect to
   * each ancestor. When this policy attaches to a parent, the controller that
   * manages the parent and the ancestors MUST add an entry to this list when
   * the controller first sees the policy and SHOULD update the entry as
   * appropriate when the relevant ancestor is modified.
   *
   * Note that choosing the relevant ancestor is left to the Policy designers;
   * an important part of Policy design is designing the right object level at
   * which to namespace this status.
   *
   * Note also that implementations MUST ONLY populate ancestor status for
   * the Ancestor resources they are responsible for. Implementations MUST
   * use the ControllerName field to uniquely identify the entries in this list
   * that they are responsible for.
   *
   * Note that to achieve this, the list of PolicyAncestorStatus structs
   * MUST be treated as a map with a composite key, made up of the AncestorRef
   * and ControllerName fields combined.
   *
   * A maximum of 16 ancestors will be represented in this list. An empty list
   * means the Policy is not relevant for any ancestors.
   *
   * If this slice is full, implementations MUST NOT add further entries.
   * Instead they MUST consider the policy unimplementable and signal that
   * on any related resources such as the ancestor that would be referenced
   * here. For example, if this list was full on BackendTLSPolicy, no
   * additional Gateways would be able to reference the Service targeted by
   * the BackendTLSPolicy.
   */
  ancestors: Array<
    Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items>
  >;
};

/** Status defines the current status of SecurityPolicy. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Input =
  {
    /**
     * Ancestors is a list of ancestor resources (usually Gateways) that are
     * associated with the policy, and the status of the policy with respect to
     * each ancestor. When this policy attaches to a parent, the controller that
     * manages the parent and the ancestors MUST add an entry to this list when
     * the controller first sees the policy and SHOULD update the entry as
     * appropriate when the relevant ancestor is modified.
     *
     * Note that choosing the relevant ancestor is left to the Policy designers;
     * an important part of Policy design is designing the right object level at
     * which to namespace this status.
     *
     * Note also that implementations MUST ONLY populate ancestor status for
     * the Ancestor resources they are responsible for. Implementations MUST
     * use the ControllerName field to uniquely identify the entries in this list
     * that they are responsible for.
     *
     * Note that to achieve this, the list of PolicyAncestorStatus structs
     * MUST be treated as a map with a composite key, made up of the AncestorRef
     * and ControllerName fields combined.
     *
     * A maximum of 16 ancestors will be represented in this list. An empty list
     * means the Policy is not relevant for any ancestors.
     *
     * If this slice is full, implementations MUST NOT add further entries.
     * Instead they MUST consider the policy unimplementable and signal that
     * on any related resources such as the ancestor that would be referenced
     * here. For example, if this list was full on BackendTLSPolicy, no
     * additional Gateways would be able to reference the Service targeted by
     * the BackendTLSPolicy.
     */
    ancestors: Array<
      InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items_Input>
    >;
  };

/**
 * PolicyAncestorStatus describes the status of a route with respect to an
 * associated Ancestor.
 *
 * Ancestors refer to objects that are either the Target of a policy or above it
 * in terms of object hierarchy. For example, if a policy targets a Service, the
 * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
 * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
 * useful object to place Policy status on, so we recommend that implementations
 * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
 * have a _very_ good reason otherwise.
 *
 * In the context of policy attachment, the Ancestor is used to distinguish which
 * resource results in a distinct application of this policy. For example, if a policy
 * targets a Service, it may have a distinct result per attached Gateway.
 *
 * Policies targeting the same resource may have different effects depending on the
 * ancestors of those resources. For example, different Gateways targeting the same
 * Service may have different capabilities, especially if they have different underlying
 * implementations.
 *
 * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
 * used as a backend in a HTTPRoute that is itself attached to a Gateway.
 * In this case, the relevant object for status is the Gateway, and that is the
 * ancestor object referred to in this status.
 *
 * Note that a parent is also an ancestor, so for objects where the parent is the
 * relevant object for status, this struct SHOULD still be used.
 *
 * This struct is intended to be used in a slice that's effectively a map,
 * with a composite key made up of the AncestorRef and the ControllerName.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items =
  {
    ancestorRef: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items_AncestorRef;
    /** Conditions describes the status of the Policy with respect to the given Ancestor. */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items_Conditions_Items>
      >
    >;
    controllerName: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_controllerName']['output'];
  };

/**
 * PolicyAncestorStatus describes the status of a route with respect to an
 * associated Ancestor.
 *
 * Ancestors refer to objects that are either the Target of a policy or above it
 * in terms of object hierarchy. For example, if a policy targets a Service, the
 * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
 * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
 * useful object to place Policy status on, so we recommend that implementations
 * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
 * have a _very_ good reason otherwise.
 *
 * In the context of policy attachment, the Ancestor is used to distinguish which
 * resource results in a distinct application of this policy. For example, if a policy
 * targets a Service, it may have a distinct result per attached Gateway.
 *
 * Policies targeting the same resource may have different effects depending on the
 * ancestors of those resources. For example, different Gateways targeting the same
 * Service may have different capabilities, especially if they have different underlying
 * implementations.
 *
 * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
 * used as a backend in a HTTPRoute that is itself attached to a Gateway.
 * In this case, the relevant object for status is the Gateway, and that is the
 * ancestor object referred to in this status.
 *
 * Note that a parent is also an ancestor, so for objects where the parent is the
 * relevant object for status, this struct SHOULD still be used.
 *
 * This struct is intended to be used in a slice that's effectively a map,
 * with a composite key made up of the AncestorRef and the ControllerName.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items_Input =
  {
    ancestorRef: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items_AncestorRef_Input;
    /** Conditions describes the status of the Policy with respect to the given Ancestor. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items_Conditions_Items_Input>
      >
    >;
    controllerName: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_controllerName']['input'];
  };

/**
 * AncestorRef corresponds with a ParentRef in the spec that this
 * PolicyAncestorStatus struct describes the status of.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items_AncestorRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_kind']['output']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_namespace']['output']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     * <gateway:experimental:description>
     * When the parent resource is a Service, this targets a specific port in the
     * Service spec. When both Port (experimental) and SectionName are specified,
     * the name and port of the selected port must match both specified values.
     * </gateway:experimental:description>
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    sectionName?: Maybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_sectionName']['output']
    >;
  };

/**
 * AncestorRef corresponds with a ParentRef in the spec that this
 * PolicyAncestorStatus struct describes the status of.
 */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items_AncestorRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_kind']['input']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_namespace']['input']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     * <gateway:experimental:description>
     * When the parent resource is a Service, this targets a specific port in the
     * Service spec. When both Port (experimental) and SectionName are specified,
     * the name and port of the selected port must match both specified values.
     * </gateway:experimental:description>
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    sectionName?: InputMaybe<
      Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_ancestorRef_sectionName']['input']
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_conditions_items_reason']['output'];
    status: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_conditions_items_reason']['input'];
    status: Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_items_items_status_ancestors_items_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListGatewayEnvoyproxyIoV1alpha1NamespacedSecurityPolicy_Items_Items_Status_Ancestors_Items_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** Spec defines the desired state of BackendTLSPolicy. */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec = {
  /**
   * Options are a list of key/value pairs to enable extended TLS
   * configuration for each implementation. For example, configuring the
   * minimum TLS version or supported cipher suites.
   *
   * A set of common keys MAY be defined by the API in the future. To avoid
   * any ambiguity, implementation-specific definitions MUST use
   * domain-prefixed names, such as `example.com/my-custom-option`.
   * Un-prefixed names are reserved for key names defined by Gateway API.
   *
   * Support: Implementation-specific
   */
  options?: Maybe<Scalars['JSON']['output']>;
  /**
   * TargetRefs identifies an API object to apply the policy to.
   * Only Services have Extended support. Implementations MAY support
   * additional objects, with Implementation Specific support.
   * Note that this config applies to the entire referenced resource
   * by default, but this default may change in the future to provide
   * a more granular application of the policy.
   *
   * TargetRefs must be _distinct_. This means either that:
   *
   * * They select different targets. If this is the case, then targetRef
   *   entries are distinct. In terms of fields, this means that the
   *   multi-part key defined by `group`, `kind`, and `name` must
   *   be unique across all targetRef entries in the BackendTLSPolicy.
   * * They select different sectionNames in the same target.
   *
   * When more than one BackendTLSPolicy selects the same target and
   * sectionName, implementations MUST determine precedence using the
   * following criteria, continuing on ties:
   *
   * * The older policy by creation timestamp takes precedence. For
   *   example, a policy with a creation timestamp of "2021-07-15
   *   01:02:03" MUST be given precedence over a policy with a
   *   creation timestamp of "2021-07-15 01:02:04".
   * * The policy appearing first in alphabetical order by {name}.
   *   For example, a policy named `bar` is given precedence over a
   *   policy named `baz`.
   *
   * For any BackendTLSPolicy that does not take precedence, the
   * implementation MUST ensure the `Accepted` Condition is set to
   * `status: False`, with Reason `Conflicted`.
   *
   * Support: Extended for Kubernetes Service
   *
   * Support: Implementation-specific for any other resource
   */
  targetRefs: Array<
    Maybe<Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_TargetRefs_Items>
  >;
  validation: Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation;
};

/** Spec defines the desired state of BackendTLSPolicy. */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Input = {
  /**
   * Options are a list of key/value pairs to enable extended TLS
   * configuration for each implementation. For example, configuring the
   * minimum TLS version or supported cipher suites.
   *
   * A set of common keys MAY be defined by the API in the future. To avoid
   * any ambiguity, implementation-specific definitions MUST use
   * domain-prefixed names, such as `example.com/my-custom-option`.
   * Un-prefixed names are reserved for key names defined by Gateway API.
   *
   * Support: Implementation-specific
   */
  options?: InputMaybe<Scalars['JSON']['input']>;
  /**
   * TargetRefs identifies an API object to apply the policy to.
   * Only Services have Extended support. Implementations MAY support
   * additional objects, with Implementation Specific support.
   * Note that this config applies to the entire referenced resource
   * by default, but this default may change in the future to provide
   * a more granular application of the policy.
   *
   * TargetRefs must be _distinct_. This means either that:
   *
   * * They select different targets. If this is the case, then targetRef
   *   entries are distinct. In terms of fields, this means that the
   *   multi-part key defined by `group`, `kind`, and `name` must
   *   be unique across all targetRef entries in the BackendTLSPolicy.
   * * They select different sectionNames in the same target.
   *
   * When more than one BackendTLSPolicy selects the same target and
   * sectionName, implementations MUST determine precedence using the
   * following criteria, continuing on ties:
   *
   * * The older policy by creation timestamp takes precedence. For
   *   example, a policy with a creation timestamp of "2021-07-15
   *   01:02:03" MUST be given precedence over a policy with a
   *   creation timestamp of "2021-07-15 01:02:04".
   * * The policy appearing first in alphabetical order by {name}.
   *   For example, a policy named `bar` is given precedence over a
   *   policy named `baz`.
   *
   * For any BackendTLSPolicy that does not take precedence, the
   * implementation MUST ensure the `Accepted` Condition is set to
   * `status: False`, with Reason `Conflicted`.
   *
   * Support: Extended for Kubernetes Service
   *
   * Support: Implementation-specific for any other resource
   */
  targetRefs: Array<
    InputMaybe<Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_TargetRefs_Items_Input>
  >;
  validation: Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_Input;
};

/**
 * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
 * direct policy to. This should be used as part of Policy resources that can
 * target single resources. For more information on how this policy attachment
 * mode works, and a sample Policy resource, refer to the policy attachment
 * documentation for Gateway API.
 *
 * Note: This should only be used for direct policy attachment when references
 * to SectionName are actually needed. In all other cases,
 * LocalPolicyTargetReference should be used.
 */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_TargetRefs_Items =
  {
    group: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_group']['output'];
    kind: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_kind']['output'];
    /** Name is the name of the target resource. */
    name: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_name']['output'];
    sectionName?: Maybe<
      Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_sectionName']['output']
    >;
  };

/**
 * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
 * direct policy to. This should be used as part of Policy resources that can
 * target single resources. For more information on how this policy attachment
 * mode works, and a sample Policy resource, refer to the policy attachment
 * documentation for Gateway API.
 *
 * Note: This should only be used for direct policy attachment when references
 * to SectionName are actually needed. In all other cases,
 * LocalPolicyTargetReference should be used.
 */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_TargetRefs_Items_Input =
  {
    group: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_group']['input'];
    kind: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_kind']['input'];
    /** Name is the name of the target resource. */
    name: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_name']['input'];
    sectionName?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_sectionName']['input']
    >;
  };

/** Validation contains backend TLS validation configuration. */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation =
  {
    /**
     * CACertificateRefs contains one or more references to Kubernetes objects that
     * contain a PEM-encoded TLS CA certificate bundle, which is used to
     * validate a TLS handshake between the Gateway and backend Pod.
     *
     * If CACertificateRefs is empty or unspecified, then WellKnownCACertificates must be
     * specified. Only one of CACertificateRefs or WellKnownCACertificates may be specified,
     * not both. If CACertificateRefs is empty or unspecified, the configuration for
     * WellKnownCACertificates MUST be honored instead if supported by the implementation.
     *
     * A CACertificateRef is invalid if:
     *
     * * It refers to a resource that cannot be resolved (e.g., the referenced resource
     *   does not exist) or is misconfigured (e.g., a ConfigMap does not contain a key
     *   named `ca.crt`). In this case, the Reason must be set to `InvalidCACertificateRef`
     *   and the Message of the Condition must indicate which reference is invalid and why.
     *
     * * It refers to an unknown or unsupported kind of resource. In this case, the Reason
     *   must be set to `InvalidKind` and the Message of the Condition must explain which
     *   kind of resource is unknown or unsupported.
     *
     * * It refers to a resource in another namespace. This may change in future
     *   spec updates.
     *
     * Implementations MAY choose to perform further validation of the certificate
     * content (e.g., checking expiry or enforcing specific formats). In such cases,
     * an implementation-specific Reason and Message must be set for the invalid reference.
     *
     * In all cases, the implementation MUST ensure the `ResolvedRefs` Condition on
     * the BackendTLSPolicy is set to `status: False`, with a Reason and Message
     * that indicate the cause of the error. Connections using an invalid
     * CACertificateRef MUST fail, and the client MUST receive an HTTP 5xx error
     * response. If ALL CACertificateRefs are invalid, the implementation MUST also
     * ensure the `Accepted` Condition on the BackendTLSPolicy is set to
     * `status: False`, with a Reason `NoValidCACertificate`.
     *
     * A single CACertificateRef to a Kubernetes ConfigMap kind has "Core" support.
     * Implementations MAY choose to support attaching multiple certificates to
     * a backend, but this behavior is implementation-specific.
     *
     * Support: Core - An optional single reference to a Kubernetes ConfigMap,
     * with the CA certificate in a key named `ca.crt`.
     *
     * Support: Implementation-specific - More than one reference, other kinds
     * of resources, or a single reference that includes multiple certificates.
     */
    caCertificateRefs?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_CaCertificateRefs_Items>
      >
    >;
    hostname: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_hostname']['output'];
    /**
     * SubjectAltNames contains one or more Subject Alternative Names.
     * When specified the certificate served from the backend MUST
     * have at least one Subject Alternate Name matching one of the specified SubjectAltNames.
     *
     * Support: Extended
     */
    subjectAltNames?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_SubjectAltNames_Items>
      >
    >;
    wellKnownCACertificates?: Maybe<System_Const>;
  };

/** Validation contains backend TLS validation configuration. */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_Input =
  {
    /**
     * CACertificateRefs contains one or more references to Kubernetes objects that
     * contain a PEM-encoded TLS CA certificate bundle, which is used to
     * validate a TLS handshake between the Gateway and backend Pod.
     *
     * If CACertificateRefs is empty or unspecified, then WellKnownCACertificates must be
     * specified. Only one of CACertificateRefs or WellKnownCACertificates may be specified,
     * not both. If CACertificateRefs is empty or unspecified, the configuration for
     * WellKnownCACertificates MUST be honored instead if supported by the implementation.
     *
     * A CACertificateRef is invalid if:
     *
     * * It refers to a resource that cannot be resolved (e.g., the referenced resource
     *   does not exist) or is misconfigured (e.g., a ConfigMap does not contain a key
     *   named `ca.crt`). In this case, the Reason must be set to `InvalidCACertificateRef`
     *   and the Message of the Condition must indicate which reference is invalid and why.
     *
     * * It refers to an unknown or unsupported kind of resource. In this case, the Reason
     *   must be set to `InvalidKind` and the Message of the Condition must explain which
     *   kind of resource is unknown or unsupported.
     *
     * * It refers to a resource in another namespace. This may change in future
     *   spec updates.
     *
     * Implementations MAY choose to perform further validation of the certificate
     * content (e.g., checking expiry or enforcing specific formats). In such cases,
     * an implementation-specific Reason and Message must be set for the invalid reference.
     *
     * In all cases, the implementation MUST ensure the `ResolvedRefs` Condition on
     * the BackendTLSPolicy is set to `status: False`, with a Reason and Message
     * that indicate the cause of the error. Connections using an invalid
     * CACertificateRef MUST fail, and the client MUST receive an HTTP 5xx error
     * response. If ALL CACertificateRefs are invalid, the implementation MUST also
     * ensure the `Accepted` Condition on the BackendTLSPolicy is set to
     * `status: False`, with a Reason `NoValidCACertificate`.
     *
     * A single CACertificateRef to a Kubernetes ConfigMap kind has "Core" support.
     * Implementations MAY choose to support attaching multiple certificates to
     * a backend, but this behavior is implementation-specific.
     *
     * Support: Core - An optional single reference to a Kubernetes ConfigMap,
     * with the CA certificate in a key named `ca.crt`.
     *
     * Support: Implementation-specific - More than one reference, other kinds
     * of resources, or a single reference that includes multiple certificates.
     */
    caCertificateRefs?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_CaCertificateRefs_Items_Input>
      >
    >;
    hostname: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_hostname']['input'];
    /**
     * SubjectAltNames contains one or more Subject Alternative Names.
     * When specified the certificate served from the backend MUST
     * have at least one Subject Alternate Name matching one of the specified SubjectAltNames.
     *
     * Support: Extended
     */
    subjectAltNames?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_SubjectAltNames_Items_Input>
      >
    >;
    wellKnownCACertificates?: InputMaybe<System_Const>;
  };

/**
 * LocalObjectReference identifies an API object within the namespace of the
 * referrer.
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_CaCertificateRefs_Items =
  {
    group: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_group']['output'];
    kind: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_kind']['output'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_name']['output'];
  };

/**
 * LocalObjectReference identifies an API object within the namespace of the
 * referrer.
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_CaCertificateRefs_Items_Input =
  {
    group: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_group']['input'];
    kind: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_kind']['input'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_name']['input'];
  };

/** SubjectAltName represents Subject Alternative Name. */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_SubjectAltNames_Items =
  {
    hostname?: Maybe<
      Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_subjectAltNames_items_hostname']['output']
    >;
    type: Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_SubjectAltNames_Items_Type;
    uri?: Maybe<
      Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_subjectAltNames_items_uri']['output']
    >;
  };

/** SubjectAltName represents Subject Alternative Name. */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_SubjectAltNames_Items_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_subjectAltNames_items_hostname']['input']
    >;
    type: Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_SubjectAltNames_Items_Type;
    uri?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_spec_validation_subjectAltNames_items_uri']['input']
    >;
  };

/**
 * Type determines the format of the Subject Alternative Name. Always required.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_SubjectAltNames_Items_Type =
  'Hostname' | 'URI';

/** Status defines the current state of BackendTLSPolicy. */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status = {
  /**
   * Ancestors is a list of ancestor resources (usually Gateways) that are
   * associated with the policy, and the status of the policy with respect to
   * each ancestor. When this policy attaches to a parent, the controller that
   * manages the parent and the ancestors MUST add an entry to this list when
   * the controller first sees the policy and SHOULD update the entry as
   * appropriate when the relevant ancestor is modified.
   *
   * Note that choosing the relevant ancestor is left to the Policy designers;
   * an important part of Policy design is designing the right object level at
   * which to namespace this status.
   *
   * Note also that implementations MUST ONLY populate ancestor status for
   * the Ancestor resources they are responsible for. Implementations MUST
   * use the ControllerName field to uniquely identify the entries in this list
   * that they are responsible for.
   *
   * Note that to achieve this, the list of PolicyAncestorStatus structs
   * MUST be treated as a map with a composite key, made up of the AncestorRef
   * and ControllerName fields combined.
   *
   * A maximum of 16 ancestors will be represented in this list. An empty list
   * means the Policy is not relevant for any ancestors.
   *
   * If this slice is full, implementations MUST NOT add further entries.
   * Instead they MUST consider the policy unimplementable and signal that
   * on any related resources such as the ancestor that would be referenced
   * here. For example, if this list was full on BackendTLSPolicy, no
   * additional Gateways would be able to reference the Service targeted by
   * the BackendTLSPolicy.
   */
  ancestors: Array<
    Maybe<Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items>
  >;
};

/** Status defines the current state of BackendTLSPolicy. */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * Ancestors is a list of ancestor resources (usually Gateways) that are
     * associated with the policy, and the status of the policy with respect to
     * each ancestor. When this policy attaches to a parent, the controller that
     * manages the parent and the ancestors MUST add an entry to this list when
     * the controller first sees the policy and SHOULD update the entry as
     * appropriate when the relevant ancestor is modified.
     *
     * Note that choosing the relevant ancestor is left to the Policy designers;
     * an important part of Policy design is designing the right object level at
     * which to namespace this status.
     *
     * Note also that implementations MUST ONLY populate ancestor status for
     * the Ancestor resources they are responsible for. Implementations MUST
     * use the ControllerName field to uniquely identify the entries in this list
     * that they are responsible for.
     *
     * Note that to achieve this, the list of PolicyAncestorStatus structs
     * MUST be treated as a map with a composite key, made up of the AncestorRef
     * and ControllerName fields combined.
     *
     * A maximum of 16 ancestors will be represented in this list. An empty list
     * means the Policy is not relevant for any ancestors.
     *
     * If this slice is full, implementations MUST NOT add further entries.
     * Instead they MUST consider the policy unimplementable and signal that
     * on any related resources such as the ancestor that would be referenced
     * here. For example, if this list was full on BackendTLSPolicy, no
     * additional Gateways would be able to reference the Service targeted by
     * the BackendTLSPolicy.
     */
    ancestors: Array<
      InputMaybe<Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Input>
    >;
  };

/**
 * PolicyAncestorStatus describes the status of a route with respect to an
 * associated Ancestor.
 *
 * Ancestors refer to objects that are either the Target of a policy or above it
 * in terms of object hierarchy. For example, if a policy targets a Service, the
 * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
 * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
 * useful object to place Policy status on, so we recommend that implementations
 * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
 * have a _very_ good reason otherwise.
 *
 * In the context of policy attachment, the Ancestor is used to distinguish which
 * resource results in a distinct application of this policy. For example, if a policy
 * targets a Service, it may have a distinct result per attached Gateway.
 *
 * Policies targeting the same resource may have different effects depending on the
 * ancestors of those resources. For example, different Gateways targeting the same
 * Service may have different capabilities, especially if they have different underlying
 * implementations.
 *
 * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
 * used as a backend in a HTTPRoute that is itself attached to a Gateway.
 * In this case, the relevant object for status is the Gateway, and that is the
 * ancestor object referred to in this status.
 *
 * Note that a parent is also an ancestor, so for objects where the parent is the
 * relevant object for status, this struct SHOULD still be used.
 *
 * This struct is intended to be used in a slice that's effectively a map,
 * with a composite key made up of the AncestorRef and the ControllerName.
 */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items =
  {
    ancestorRef: Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_AncestorRef;
    /** Conditions describes the status of the Policy with respect to the given Ancestor. */
    conditions: Array<
      Maybe<Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items>
    >;
    controllerName: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_controllerName']['output'];
  };

/**
 * PolicyAncestorStatus describes the status of a route with respect to an
 * associated Ancestor.
 *
 * Ancestors refer to objects that are either the Target of a policy or above it
 * in terms of object hierarchy. For example, if a policy targets a Service, the
 * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
 * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
 * useful object to place Policy status on, so we recommend that implementations
 * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
 * have a _very_ good reason otherwise.
 *
 * In the context of policy attachment, the Ancestor is used to distinguish which
 * resource results in a distinct application of this policy. For example, if a policy
 * targets a Service, it may have a distinct result per attached Gateway.
 *
 * Policies targeting the same resource may have different effects depending on the
 * ancestors of those resources. For example, different Gateways targeting the same
 * Service may have different capabilities, especially if they have different underlying
 * implementations.
 *
 * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
 * used as a backend in a HTTPRoute that is itself attached to a Gateway.
 * In this case, the relevant object for status is the Gateway, and that is the
 * ancestor object referred to in this status.
 *
 * Note that a parent is also an ancestor, so for objects where the parent is the
 * relevant object for status, this struct SHOULD still be used.
 *
 * This struct is intended to be used in a slice that's effectively a map,
 * with a composite key made up of the AncestorRef and the ControllerName.
 */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Input =
  {
    ancestorRef: Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_AncestorRef_Input;
    /** Conditions describes the status of the Policy with respect to the given Ancestor. */
    conditions: Array<
      InputMaybe<Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Input>
    >;
    controllerName: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_controllerName']['input'];
  };

/**
 * AncestorRef corresponds with a ParentRef in the spec that this
 * PolicyAncestorStatus struct describes the status of.
 */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_AncestorRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_kind']['output']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_namespace']['output']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     *
     * When the parent resource is a Service, this targets a specific port in the
     * Service spec. When both Port (experimental) and SectionName are specified,
     * the name and port of the selected port must match both specified values.
     *
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    sectionName?: Maybe<
      Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_sectionName']['output']
    >;
  };

/**
 * AncestorRef corresponds with a ParentRef in the spec that this
 * PolicyAncestorStatus struct describes the status of.
 */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_AncestorRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_kind']['input']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_namespace']['input']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     *
     * When the parent resource is a Service, this targets a specific port in the
     * Service spec. When both Port (experimental) and SectionName are specified,
     * the name and port of the selected port must match both specified values.
     *
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    sectionName?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_sectionName']['input']
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_reason']['output'];
    status: Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_reason']['input'];
    status: Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListGatewayNetworkingV1BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** Spec defines the desired state of GatewayClass. */
export type Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Spec = {
  controllerName: Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_spec_controllerName']['output'];
  /** Description helps describe a GatewayClass with more details. */
  description?: Maybe<
    Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_spec_description']['output']
  >;
  parametersRef?: Maybe<Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Spec_ParametersRef>;
};

/** Spec defines the desired state of GatewayClass. */
export type Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Spec_Input = {
  controllerName: Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_spec_controllerName']['input'];
  /** Description helps describe a GatewayClass with more details. */
  description?: InputMaybe<
    Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_spec_description']['input']
  >;
  parametersRef?: InputMaybe<Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Spec_ParametersRef_Input>;
};

/**
 * ParametersRef is a reference to a resource that contains the configuration
 * parameters corresponding to the GatewayClass. This is optional if the
 * controller does not require any additional configuration.
 *
 * ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
 * or an implementation-specific custom resource. The resource can be
 * cluster-scoped or namespace-scoped.
 *
 * If the referent cannot be found, refers to an unsupported kind, or when
 * the data within that resource is malformed, the GatewayClass SHOULD be
 * rejected with the "Accepted" status condition set to "False" and an
 * "InvalidParameters" reason.
 *
 * A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
 * the merging behavior is implementation specific.
 * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Spec_ParametersRef = {
  group: Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_spec_parametersRef_group']['output'];
  kind: Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_spec_parametersRef_kind']['output'];
  /** Name is the name of the referent. */
  name: Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_spec_parametersRef_name']['output'];
  namespace?: Maybe<
    Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_spec_parametersRef_namespace']['output']
  >;
};

/**
 * ParametersRef is a reference to a resource that contains the configuration
 * parameters corresponding to the GatewayClass. This is optional if the
 * controller does not require any additional configuration.
 *
 * ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
 * or an implementation-specific custom resource. The resource can be
 * cluster-scoped or namespace-scoped.
 *
 * If the referent cannot be found, refers to an unsupported kind, or when
 * the data within that resource is malformed, the GatewayClass SHOULD be
 * rejected with the "Accepted" status condition set to "False" and an
 * "InvalidParameters" reason.
 *
 * A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
 * the merging behavior is implementation specific.
 * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Spec_ParametersRef_Input = {
  group: Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_spec_parametersRef_group']['input'];
  kind: Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_spec_parametersRef_kind']['input'];
  /** Name is the name of the referent. */
  name: Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_spec_parametersRef_name']['input'];
  namespace?: InputMaybe<
    Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_spec_parametersRef_namespace']['input']
  >;
};

/**
 * Status defines the current state of GatewayClass.
 *
 * Implementations MUST populate status on all GatewayClass resources which
 * specify their controller name.
 */
export type Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Status = {
  /**
   * Conditions is the current status from the controller for
   * this GatewayClass.
   *
   * Controllers should prefer to publish conditions using values
   * of GatewayClassConditionType for the type of each Condition.
   */
  conditions?: Maybe<
    Array<Maybe<Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Status_Conditions_Items>>
  >;
};

/**
 * Status defines the current state of GatewayClass.
 *
 * Implementations MUST populate status on all GatewayClass resources which
 * specify their controller name.
 */
export type Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Status_Input = {
  /**
   * Conditions is the current status from the controller for
   * this GatewayClass.
   *
   * Controllers should prefer to publish conditions using values
   * of GatewayClassConditionType for the type of each Condition.
   */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Status_Conditions_Items_Input>
    >
  >;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Status_Conditions_Items = {
  /**
   * lastTransitionTime is the last time the condition transitioned from one status to another.
   * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
   */
  lastTransitionTime: Scalars['DateTime']['output'];
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  message: Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_status_conditions_items_message']['output'];
  /**
   * observedGeneration represents the .metadata.generation that the condition was set based upon.
   * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
   * with respect to the current state of the instance.
   */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
  reason: Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_status_conditions_items_reason']['output'];
  status: Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Status_Conditions_Items_Status;
  type: Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_status_conditions_items_type']['output'];
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Status_Conditions_Items_Input = {
  /**
   * lastTransitionTime is the last time the condition transitioned from one status to another.
   * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
   */
  lastTransitionTime: Scalars['DateTime']['input'];
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  message: Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_status_conditions_items_message']['input'];
  /**
   * observedGeneration represents the .metadata.generation that the condition was set based upon.
   * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
   * with respect to the current state of the instance.
   */
  observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
  reason: Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_status_conditions_items_reason']['input'];
  status: Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Status_Conditions_Items_Status;
  type: Scalars['query_listGatewayNetworkingV1GatewayClass_items_items_status_conditions_items_type']['input'];
};

/** status of the condition, one of True, False, Unknown. */
export type Query_ListGatewayNetworkingV1GatewayClass_Items_Items_Status_Conditions_Items_Status =
  | 'False'
  | 'True'
  | 'Unknown';

/** Spec defines the desired state of Gateway. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec = {
  /**
   * Addresses requested for this Gateway. This is optional and behavior can
   * depend on the implementation. If a value is set in the spec and the
   * requested address is invalid or unavailable, the implementation MUST
   * indicate this in the associated entry in GatewayStatus.Addresses.
   *
   * The Addresses field represents a request for the address(es) on the
   * "outside of the Gateway", that traffic bound for this Gateway will use.
   * This could be the IP address or hostname of an external load balancer or
   * other networking infrastructure, or some other address that traffic will
   * be sent to.
   *
   * If no Addresses are specified, the implementation MAY schedule the
   * Gateway in an implementation-specific manner, assigning an appropriate
   * set of Addresses.
   *
   * The implementation MUST bind all Listeners to every GatewayAddress that
   * it assigns to the Gateway and add a corresponding entry in
   * GatewayStatus.Addresses.
   *
   * Support: Extended
   */
  addresses?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Addresses_Items>
    >
  >;
  /**
   * GatewayClassName used for this Gateway. This is the name of a
   * GatewayClass resource.
   */
  gatewayClassName: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_gatewayClassName']['output'];
  infrastructure?: Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure>;
  /**
   * Listeners associated with this Gateway. Listeners define
   * logical endpoints that are bound on this Gateway's addresses.
   * At least one Listener MUST be specified.
   *
   * ## Distinct Listeners
   *
   * Each Listener in a set of Listeners (for example, in a single Gateway)
   * MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
   * exactly one listener. (This section uses "set of Listeners" rather than
   * "Listeners in a single Gateway" because implementations MAY merge configuration
   * from multiple Gateways onto a single data plane, and these rules _also_
   * apply in that case).
   *
   * Practically, this means that each listener in a set MUST have a unique
   * combination of Port, Protocol, and, if supported by the protocol, Hostname.
   *
   * Some combinations of port, protocol, and TLS settings are considered
   * Core support and MUST be supported by implementations based on the objects
   * they support:
   *
   * HTTPRoute
   *
   * 1. HTTPRoute, Port: 80, Protocol: HTTP
   * 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
   *
   * TLSRoute
   *
   * 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
   *
   * "Distinct" Listeners have the following property:
   *
   * **The implementation can match inbound requests to a single distinct
   * Listener**.
   *
   * When multiple Listeners share values for fields (for
   * example, two Listeners with the same Port value), the implementation
   * can match requests to only one of the Listeners using other
   * Listener fields.
   *
   * When multiple listeners have the same value for the Protocol field, then
   * each of the Listeners with matching Protocol values MUST have different
   * values for other fields.
   *
   * The set of fields that MUST be different for a Listener differs per protocol.
   * The following rules define the rules for what fields MUST be considered for
   * Listeners to be distinct with each protocol currently defined in the
   * Gateway API spec.
   *
   * The set of listeners that all share a protocol value MUST have _different_
   * values for _at least one_ of these fields to be distinct:
   *
   * * **HTTP, HTTPS, TLS**: Port, Hostname
   * * **TCP, UDP**: Port
   *
   * One **very** important rule to call out involves what happens when an
   * implementation:
   *
   * * Supports TCP protocol Listeners, as well as HTTP, HTTPS, or TLS protocol
   *   Listeners, and
   * * sees HTTP, HTTPS, or TLS protocols with the same `port` as one with TCP
   *   Protocol.
   *
   * In this case all the Listeners that share a port with the
   * TCP Listener are not distinct and so MUST NOT be accepted.
   *
   * If an implementation does not support TCP Protocol Listeners, then the
   * previous rule does not apply, and the TCP Listeners SHOULD NOT be
   * accepted.
   *
   * Note that the `tls` field is not used for determining if a listener is distinct, because
   * Listeners that _only_ differ on TLS config will still conflict in all cases.
   *
   * ### Listeners that are distinct only by Hostname
   *
   * When the Listeners are distinct based only on Hostname, inbound request
   * hostnames MUST match from the most specific to least specific Hostname
   * values to choose the correct Listener and its associated set of Routes.
   *
   * Exact matches MUST be processed before wildcard matches, and wildcard
   * matches MUST be processed before fallback (empty Hostname value)
   * matches. For example, `"foo.example.com"` takes precedence over
   * `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
   *
   * Additionally, if there are multiple wildcard entries, more specific
   * wildcard entries must be processed before less specific wildcard entries.
   * For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
   *
   * The precise definition here is that the higher the number of dots in the
   * hostname to the right of the wildcard character, the higher the precedence.
   *
   * The wildcard character will match any number of characters _and dots_ to
   * the left, however, so `"*.example.com"` will match both
   * `"foo.bar.example.com"` _and_ `"bar.example.com"`.
   *
   * ## Handling indistinct Listeners
   *
   * If a set of Listeners contains Listeners that are not distinct, then those
   * Listeners are _Conflicted_, and the implementation MUST set the "Conflicted"
   * condition in the Listener Status to "True".
   *
   * The words "indistinct" and "conflicted" are considered equivalent for the
   * purpose of this documentation.
   *
   * Implementations MAY choose to accept a Gateway with some Conflicted
   * Listeners only if they only accept the partial Listener set that contains
   * no Conflicted Listeners.
   *
   * Specifically, an implementation MAY accept a partial Listener set subject to
   * the following rules:
   *
   * * The implementation MUST NOT pick one conflicting Listener as the winner.
   *   ALL indistinct Listeners must not be accepted for processing.
   * * At least one distinct Listener MUST be present, or else the Gateway effectively
   *   contains _no_ Listeners, and must be rejected from processing as a whole.
   *
   * The implementation MUST set a "ListenersNotValid" condition on the
   * Gateway Status when the Gateway contains Conflicted Listeners whether or
   * not they accept the Gateway. That Condition SHOULD clearly
   * indicate in the Message which Listeners are conflicted, and which are
   * Accepted. Additionally, the Listener status for those listeners SHOULD
   * indicate which Listeners are conflicted and not Accepted.
   *
   * ## General Listener behavior
   *
   * Note that, for all distinct Listeners, requests SHOULD match at most one Listener.
   * For example, if Listeners are defined for "foo.example.com" and "*.example.com", a
   * request to "foo.example.com" SHOULD only be routed using routes attached
   * to the "foo.example.com" Listener (and not the "*.example.com" Listener).
   *
   * This concept is known as "Listener Isolation", and it is an Extended feature
   * of Gateway API. Implementations that do not support Listener Isolation MUST
   * clearly document this, and MUST NOT claim support for the
   * `GatewayHTTPListenerIsolation` feature.
   *
   * Implementations that _do_ support Listener Isolation SHOULD claim support
   * for the Extended `GatewayHTTPListenerIsolation` feature and pass the associated
   * conformance tests.
   *
   * ## Compatible Listeners
   *
   * A Gateway's Listeners are considered _compatible_ if:
   *
   * 1. They are distinct.
   * 2. The implementation can serve them in compliance with the Addresses
   *    requirement that all Listeners are available on all assigned
   *    addresses.
   *
   * Compatible combinations in Extended support are expected to vary across
   * implementations. A combination that is compatible for one implementation
   * may not be compatible for another.
   *
   * For example, an implementation that cannot serve both TCP and UDP listeners
   * on the same address, or cannot mix HTTPS and generic TLS listens on the same port
   * would not consider those cases compatible, even though they are distinct.
   *
   * Implementations MAY merge separate Gateways onto a single set of
   * Addresses if all Listeners across all Gateways are compatible.
   *
   * In a future release the MinItems=1 requirement MAY be dropped.
   *
   * Support: Core
   */
  listeners: Array<
    Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items>
  >;
};

/** Spec defines the desired state of Gateway. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Input = {
  /**
   * Addresses requested for this Gateway. This is optional and behavior can
   * depend on the implementation. If a value is set in the spec and the
   * requested address is invalid or unavailable, the implementation MUST
   * indicate this in the associated entry in GatewayStatus.Addresses.
   *
   * The Addresses field represents a request for the address(es) on the
   * "outside of the Gateway", that traffic bound for this Gateway will use.
   * This could be the IP address or hostname of an external load balancer or
   * other networking infrastructure, or some other address that traffic will
   * be sent to.
   *
   * If no Addresses are specified, the implementation MAY schedule the
   * Gateway in an implementation-specific manner, assigning an appropriate
   * set of Addresses.
   *
   * The implementation MUST bind all Listeners to every GatewayAddress that
   * it assigns to the Gateway and add a corresponding entry in
   * GatewayStatus.Addresses.
   *
   * Support: Extended
   */
  addresses?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Addresses_Items_Input>
    >
  >;
  /**
   * GatewayClassName used for this Gateway. This is the name of a
   * GatewayClass resource.
   */
  gatewayClassName: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_gatewayClassName']['input'];
  infrastructure?: InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure_Input>;
  /**
   * Listeners associated with this Gateway. Listeners define
   * logical endpoints that are bound on this Gateway's addresses.
   * At least one Listener MUST be specified.
   *
   * ## Distinct Listeners
   *
   * Each Listener in a set of Listeners (for example, in a single Gateway)
   * MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
   * exactly one listener. (This section uses "set of Listeners" rather than
   * "Listeners in a single Gateway" because implementations MAY merge configuration
   * from multiple Gateways onto a single data plane, and these rules _also_
   * apply in that case).
   *
   * Practically, this means that each listener in a set MUST have a unique
   * combination of Port, Protocol, and, if supported by the protocol, Hostname.
   *
   * Some combinations of port, protocol, and TLS settings are considered
   * Core support and MUST be supported by implementations based on the objects
   * they support:
   *
   * HTTPRoute
   *
   * 1. HTTPRoute, Port: 80, Protocol: HTTP
   * 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
   *
   * TLSRoute
   *
   * 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
   *
   * "Distinct" Listeners have the following property:
   *
   * **The implementation can match inbound requests to a single distinct
   * Listener**.
   *
   * When multiple Listeners share values for fields (for
   * example, two Listeners with the same Port value), the implementation
   * can match requests to only one of the Listeners using other
   * Listener fields.
   *
   * When multiple listeners have the same value for the Protocol field, then
   * each of the Listeners with matching Protocol values MUST have different
   * values for other fields.
   *
   * The set of fields that MUST be different for a Listener differs per protocol.
   * The following rules define the rules for what fields MUST be considered for
   * Listeners to be distinct with each protocol currently defined in the
   * Gateway API spec.
   *
   * The set of listeners that all share a protocol value MUST have _different_
   * values for _at least one_ of these fields to be distinct:
   *
   * * **HTTP, HTTPS, TLS**: Port, Hostname
   * * **TCP, UDP**: Port
   *
   * One **very** important rule to call out involves what happens when an
   * implementation:
   *
   * * Supports TCP protocol Listeners, as well as HTTP, HTTPS, or TLS protocol
   *   Listeners, and
   * * sees HTTP, HTTPS, or TLS protocols with the same `port` as one with TCP
   *   Protocol.
   *
   * In this case all the Listeners that share a port with the
   * TCP Listener are not distinct and so MUST NOT be accepted.
   *
   * If an implementation does not support TCP Protocol Listeners, then the
   * previous rule does not apply, and the TCP Listeners SHOULD NOT be
   * accepted.
   *
   * Note that the `tls` field is not used for determining if a listener is distinct, because
   * Listeners that _only_ differ on TLS config will still conflict in all cases.
   *
   * ### Listeners that are distinct only by Hostname
   *
   * When the Listeners are distinct based only on Hostname, inbound request
   * hostnames MUST match from the most specific to least specific Hostname
   * values to choose the correct Listener and its associated set of Routes.
   *
   * Exact matches MUST be processed before wildcard matches, and wildcard
   * matches MUST be processed before fallback (empty Hostname value)
   * matches. For example, `"foo.example.com"` takes precedence over
   * `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
   *
   * Additionally, if there are multiple wildcard entries, more specific
   * wildcard entries must be processed before less specific wildcard entries.
   * For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
   *
   * The precise definition here is that the higher the number of dots in the
   * hostname to the right of the wildcard character, the higher the precedence.
   *
   * The wildcard character will match any number of characters _and dots_ to
   * the left, however, so `"*.example.com"` will match both
   * `"foo.bar.example.com"` _and_ `"bar.example.com"`.
   *
   * ## Handling indistinct Listeners
   *
   * If a set of Listeners contains Listeners that are not distinct, then those
   * Listeners are _Conflicted_, and the implementation MUST set the "Conflicted"
   * condition in the Listener Status to "True".
   *
   * The words "indistinct" and "conflicted" are considered equivalent for the
   * purpose of this documentation.
   *
   * Implementations MAY choose to accept a Gateway with some Conflicted
   * Listeners only if they only accept the partial Listener set that contains
   * no Conflicted Listeners.
   *
   * Specifically, an implementation MAY accept a partial Listener set subject to
   * the following rules:
   *
   * * The implementation MUST NOT pick one conflicting Listener as the winner.
   *   ALL indistinct Listeners must not be accepted for processing.
   * * At least one distinct Listener MUST be present, or else the Gateway effectively
   *   contains _no_ Listeners, and must be rejected from processing as a whole.
   *
   * The implementation MUST set a "ListenersNotValid" condition on the
   * Gateway Status when the Gateway contains Conflicted Listeners whether or
   * not they accept the Gateway. That Condition SHOULD clearly
   * indicate in the Message which Listeners are conflicted, and which are
   * Accepted. Additionally, the Listener status for those listeners SHOULD
   * indicate which Listeners are conflicted and not Accepted.
   *
   * ## General Listener behavior
   *
   * Note that, for all distinct Listeners, requests SHOULD match at most one Listener.
   * For example, if Listeners are defined for "foo.example.com" and "*.example.com", a
   * request to "foo.example.com" SHOULD only be routed using routes attached
   * to the "foo.example.com" Listener (and not the "*.example.com" Listener).
   *
   * This concept is known as "Listener Isolation", and it is an Extended feature
   * of Gateway API. Implementations that do not support Listener Isolation MUST
   * clearly document this, and MUST NOT claim support for the
   * `GatewayHTTPListenerIsolation` feature.
   *
   * Implementations that _do_ support Listener Isolation SHOULD claim support
   * for the Extended `GatewayHTTPListenerIsolation` feature and pass the associated
   * conformance tests.
   *
   * ## Compatible Listeners
   *
   * A Gateway's Listeners are considered _compatible_ if:
   *
   * 1. They are distinct.
   * 2. The implementation can serve them in compliance with the Addresses
   *    requirement that all Listeners are available on all assigned
   *    addresses.
   *
   * Compatible combinations in Extended support are expected to vary across
   * implementations. A combination that is compatible for one implementation
   * may not be compatible for another.
   *
   * For example, an implementation that cannot serve both TCP and UDP listeners
   * on the same address, or cannot mix HTTPS and generic TLS listens on the same port
   * would not consider those cases compatible, even though they are distinct.
   *
   * Implementations MAY merge separate Gateways onto a single set of
   * Addresses if all Listeners across all Gateways are compatible.
   *
   * In a future release the MinItems=1 requirement MAY be dropped.
   *
   * Support: Core
   */
  listeners: Array<
    InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Input>
  >;
};

/** GatewaySpecAddress describes an address that can be bound to a Gateway. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Addresses_Items =
  {
    type?: Maybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_addresses_items_type']['output']
    >;
    /**
     * When a value is unspecified, an implementation SHOULD automatically
     * assign an address matching the requested type if possible.
     *
     * If an implementation does not support an empty value, they MUST set the
     * "Programmed" condition in status to False with a reason of "AddressNotAssigned".
     *
     * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
     */
    value?: Maybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_addresses_items_value']['output']
    >;
  };

/** GatewaySpecAddress describes an address that can be bound to a Gateway. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Addresses_Items_Input =
  {
    type?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_addresses_items_type']['input']
    >;
    /**
     * When a value is unspecified, an implementation SHOULD automatically
     * assign an address matching the requested type if possible.
     *
     * If an implementation does not support an empty value, they MUST set the
     * "Programmed" condition in status to False with a reason of "AddressNotAssigned".
     *
     * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
     */
    value?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_addresses_items_value']['input']
    >;
  };

/**
 * Infrastructure defines infrastructure level attributes about this Gateway instance.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure = {
  /**
   * Annotations that SHOULD be applied to any resources created in response to this Gateway.
   *
   * For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
   * For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
   *
   * An implementation may chose to add additional implementation-specific annotations as they see fit.
   *
   * Support: Extended
   */
  annotations?: Maybe<Scalars['JSON']['output']>;
  /**
   * Labels that SHOULD be applied to any resources created in response to this Gateway.
   *
   * For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
   * For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
   *
   * An implementation may chose to add additional implementation-specific labels as they see fit.
   *
   * If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
   * change, it SHOULD clearly warn about this behavior in documentation.
   *
   * Support: Extended
   */
  labels?: Maybe<Scalars['JSON']['output']>;
  parametersRef?: Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure_ParametersRef>;
};

/**
 * Infrastructure defines infrastructure level attributes about this Gateway instance.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure_Input =
  {
    /**
     * Annotations that SHOULD be applied to any resources created in response to this Gateway.
     *
     * For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
     * For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
     *
     * An implementation may chose to add additional implementation-specific annotations as they see fit.
     *
     * Support: Extended
     */
    annotations?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * Labels that SHOULD be applied to any resources created in response to this Gateway.
     *
     * For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
     * For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
     *
     * An implementation may chose to add additional implementation-specific labels as they see fit.
     *
     * If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
     * change, it SHOULD clearly warn about this behavior in documentation.
     *
     * Support: Extended
     */
    labels?: InputMaybe<Scalars['JSON']['input']>;
    parametersRef?: InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure_ParametersRef_Input>;
  };

/**
 * ParametersRef is a reference to a resource that contains the configuration
 * parameters corresponding to the Gateway. This is optional if the
 * controller does not require any additional configuration.
 *
 * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
 *
 * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
 * the merging behavior is implementation specific.
 * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
 *
 * If the referent cannot be found, refers to an unsupported kind, or when
 * the data within that resource is malformed, the Gateway SHOULD be
 * rejected with the "Accepted" status condition set to "False" and an
 * "InvalidParameters" reason.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure_ParametersRef =
  {
    group: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_group']['output'];
    kind: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_kind']['output'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_name']['output'];
  };

/**
 * ParametersRef is a reference to a resource that contains the configuration
 * parameters corresponding to the Gateway. This is optional if the
 * controller does not require any additional configuration.
 *
 * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
 *
 * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
 * the merging behavior is implementation specific.
 * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
 *
 * If the referent cannot be found, refers to an unsupported kind, or when
 * the data within that resource is malformed, the Gateway SHOULD be
 * rejected with the "Accepted" status condition set to "False" and an
 * "InvalidParameters" reason.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure_ParametersRef_Input =
  {
    group: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_group']['input'];
    kind: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_kind']['input'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_name']['input'];
  };

/**
 * Listener embodies the concept of a logical endpoint where a Gateway accepts
 * network connections.
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items =
  {
    allowedRoutes?: Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes>;
    hostname?: Maybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_hostname']['output']
    >;
    name: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_name']['output'];
    /**
     * Port is the network port. Multiple listeners may use the
     * same port, subject to the Listener compatibility rules.
     *
     * Support: Core
     */
    port: Scalars['Int']['output'];
    protocol: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_protocol']['output'];
    tls?: Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls>;
  };

/**
 * Listener embodies the concept of a logical endpoint where a Gateway accepts
 * network connections.
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Input =
  {
    allowedRoutes?: InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Input>;
    hostname?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_hostname']['input']
    >;
    name: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_name']['input'];
    /**
     * Port is the network port. Multiple listeners may use the
     * same port, subject to the Listener compatibility rules.
     *
     * Support: Core
     */
    port: Scalars['Int']['input'];
    protocol: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_protocol']['input'];
    tls?: InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_Input>;
  };

/**
 * AllowedRoutes defines the types of routes that MAY be attached to a
 * Listener and the trusted namespaces where those Route resources MAY be
 * present.
 *
 * Although a client request may match multiple route rules, only one rule
 * may ultimately receive the request. Matching precedence MUST be
 * determined in order of the following criteria:
 *
 * * The most specific match as defined by the Route type.
 * * The oldest Route based on creation timestamp. For example, a Route with
 *   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
 *   a Route with a creation timestamp of "2020-09-08 01:02:04".
 * * If everything else is equivalent, the Route appearing first in
 *   alphabetical order (namespace/name) should be given precedence. For
 *   example, foo/bar is given precedence over foo/baz.
 *
 * All valid rules within a Route attached to this Listener should be
 * implemented. Invalid Route rules can be ignored (sometimes that will mean
 * the full Route). If a Route rule transitions from valid to invalid,
 * support for that Route rule should be dropped to ensure consistency. For
 * example, even if a filter specified by a Route rule is invalid, the rest
 * of the rules within that Route should still be supported.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes =
  {
    /**
     * Kinds specifies the groups and kinds of Routes that are allowed to bind
     * to this Gateway Listener. When unspecified or empty, the kinds of Routes
     * selected are determined using the Listener protocol.
     *
     * A RouteGroupKind MUST correspond to kinds of Routes that are compatible
     * with the application protocol specified in the Listener's Protocol field.
     * If an implementation does not support or recognize this resource type, it
     * MUST set the "ResolvedRefs" condition to False for this Listener with the
     * "InvalidRouteKinds" reason.
     *
     * Support: Core
     */
    kinds?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Kinds_Items>
      >
    >;
    namespaces?: Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces>;
  };

/**
 * AllowedRoutes defines the types of routes that MAY be attached to a
 * Listener and the trusted namespaces where those Route resources MAY be
 * present.
 *
 * Although a client request may match multiple route rules, only one rule
 * may ultimately receive the request. Matching precedence MUST be
 * determined in order of the following criteria:
 *
 * * The most specific match as defined by the Route type.
 * * The oldest Route based on creation timestamp. For example, a Route with
 *   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
 *   a Route with a creation timestamp of "2020-09-08 01:02:04".
 * * If everything else is equivalent, the Route appearing first in
 *   alphabetical order (namespace/name) should be given precedence. For
 *   example, foo/bar is given precedence over foo/baz.
 *
 * All valid rules within a Route attached to this Listener should be
 * implemented. Invalid Route rules can be ignored (sometimes that will mean
 * the full Route). If a Route rule transitions from valid to invalid,
 * support for that Route rule should be dropped to ensure consistency. For
 * example, even if a filter specified by a Route rule is invalid, the rest
 * of the rules within that Route should still be supported.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Input =
  {
    /**
     * Kinds specifies the groups and kinds of Routes that are allowed to bind
     * to this Gateway Listener. When unspecified or empty, the kinds of Routes
     * selected are determined using the Listener protocol.
     *
     * A RouteGroupKind MUST correspond to kinds of Routes that are compatible
     * with the application protocol specified in the Listener's Protocol field.
     * If an implementation does not support or recognize this resource type, it
     * MUST set the "ResolvedRefs" condition to False for this Listener with the
     * "InvalidRouteKinds" reason.
     *
     * Support: Core
     */
    kinds?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Kinds_Items_Input>
      >
    >;
    namespaces?: InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Input>;
  };

/** RouteGroupKind indicates the group and kind of a Route resource. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Kinds_Items =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_allowedRoutes_kinds_items_group']['output']
    >;
    kind: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_allowedRoutes_kinds_items_kind']['output'];
  };

/** RouteGroupKind indicates the group and kind of a Route resource. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Kinds_Items_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_allowedRoutes_kinds_items_group']['input']
    >;
    kind: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_allowedRoutes_kinds_items_kind']['input'];
  };

/**
 * Namespaces indicates namespaces from which Routes may be attached to this
 * Listener. This is restricted to the namespace of this Gateway by default.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces =
  {
    from?: Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_From>;
    selector?: Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector>;
  };

/**
 * Namespaces indicates namespaces from which Routes may be attached to this
 * Listener. This is restricted to the namespace of this Gateway by default.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Input =
  {
    from?: InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_From>;
    selector?: InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector_Input>;
  };

/**
 * From indicates where Routes will be selected for this Gateway. Possible
 * values are:
 *
 * * All: Routes in all namespaces may be used by this Gateway.
 * * Selector: Routes in namespaces selected by the selector may be used by
 *   this Gateway.
 * * Same: Only Routes in the same namespace may be used by this Gateway.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_From =
  'All' | 'Same' | 'Selector';

/**
 * Selector must be specified when From is set to "Selector". In that case,
 * only Routes in Namespaces matching this Selector will be selected by this
 * Gateway. This field is ignored for other values of "From".
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector =
  {
    /** matchExpressions is a list of label selector requirements. The requirements are ANDed. */
    matchExpressions?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector_MatchExpressions_Items>
      >
    >;
    /**
     * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
     * map is equivalent to an element of matchExpressions, whose key field is "key", the
     * operator is "In", and the values array contains only "value". The requirements are ANDed.
     */
    matchLabels?: Maybe<Scalars['JSON']['output']>;
  };

/**
 * Selector must be specified when From is set to "Selector". In that case,
 * only Routes in Namespaces matching this Selector will be selected by this
 * Gateway. This field is ignored for other values of "From".
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector_Input =
  {
    /** matchExpressions is a list of label selector requirements. The requirements are ANDed. */
    matchExpressions?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector_MatchExpressions_Items_Input>
      >
    >;
    /**
     * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
     * map is equivalent to an element of matchExpressions, whose key field is "key", the
     * operator is "In", and the values array contains only "value". The requirements are ANDed.
     */
    matchLabels?: InputMaybe<Scalars['JSON']['input']>;
  };

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector_MatchExpressions_Items =
  {
    /** key is the label key that the selector applies to. */
    key: Scalars['String']['output'];
    /**
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and DoesNotExist.
     */
    operator: Scalars['String']['output'];
    /**
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     */
    values?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  };

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector_MatchExpressions_Items_Input =
  {
    /** key is the label key that the selector applies to. */
    key: Scalars['String']['input'];
    /**
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and DoesNotExist.
     */
    operator: Scalars['String']['input'];
    /**
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     */
    values?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  };

/**
 * TLS is the TLS configuration for the Listener. This field is required if
 * the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
 * if the Protocol field is "HTTP", "TCP", or "UDP".
 *
 * The association of SNIs to Certificate defined in GatewayTLSConfig is
 * defined based on the Hostname field for this listener.
 *
 * The GatewayClass MUST use the longest matching SNI out of all
 * available certificates for any TLS handshake.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls =
  {
    /**
     * CertificateRefs contains a series of references to Kubernetes objects that
     * contains TLS certificates and private keys. These certificates are used to
     * establish a TLS handshake for requests that match the hostname of the
     * associated listener.
     *
     * A single CertificateRef to a Kubernetes Secret has "Core" support.
     * Implementations MAY choose to support attaching multiple certificates to
     * a Listener, but this behavior is implementation-specific.
     *
     * References to a resource in different namespace are invalid UNLESS there
     * is a ReferenceGrant in the target namespace that allows the certificate
     * to be attached. If a ReferenceGrant does not allow this reference, the
     * "ResolvedRefs" condition MUST be set to False for this listener with the
     * "RefNotPermitted" reason.
     *
     * This field is required to have at least one element when the mode is set
     * to "Terminate" (default) and is optional otherwise.
     *
     * CertificateRefs can reference to standard Kubernetes resources, i.e.
     * Secret, or implementation-specific custom resources.
     *
     * Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
     *
     * Support: Implementation-specific (More than one reference or other resource types)
     */
    certificateRefs?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_CertificateRefs_Items>
      >
    >;
    mode?: Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_Mode>;
    /**
     * Options are a list of key/value pairs to enable extended TLS
     * configuration for each implementation. For example, configuring the
     * minimum TLS version or supported cipher suites.
     *
     * A set of common keys MAY be defined by the API in the future. To avoid
     * any ambiguity, implementation-specific definitions MUST use
     * domain-prefixed names, such as `example.com/my-custom-option`.
     * Un-prefixed names are reserved for key names defined by Gateway API.
     *
     * Support: Implementation-specific
     */
    options?: Maybe<Scalars['JSON']['output']>;
  };

/**
 * TLS is the TLS configuration for the Listener. This field is required if
 * the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
 * if the Protocol field is "HTTP", "TCP", or "UDP".
 *
 * The association of SNIs to Certificate defined in GatewayTLSConfig is
 * defined based on the Hostname field for this listener.
 *
 * The GatewayClass MUST use the longest matching SNI out of all
 * available certificates for any TLS handshake.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_Input =
  {
    /**
     * CertificateRefs contains a series of references to Kubernetes objects that
     * contains TLS certificates and private keys. These certificates are used to
     * establish a TLS handshake for requests that match the hostname of the
     * associated listener.
     *
     * A single CertificateRef to a Kubernetes Secret has "Core" support.
     * Implementations MAY choose to support attaching multiple certificates to
     * a Listener, but this behavior is implementation-specific.
     *
     * References to a resource in different namespace are invalid UNLESS there
     * is a ReferenceGrant in the target namespace that allows the certificate
     * to be attached. If a ReferenceGrant does not allow this reference, the
     * "ResolvedRefs" condition MUST be set to False for this listener with the
     * "RefNotPermitted" reason.
     *
     * This field is required to have at least one element when the mode is set
     * to "Terminate" (default) and is optional otherwise.
     *
     * CertificateRefs can reference to standard Kubernetes resources, i.e.
     * Secret, or implementation-specific custom resources.
     *
     * Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
     *
     * Support: Implementation-specific (More than one reference or other resource types)
     */
    certificateRefs?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_CertificateRefs_Items_Input>
      >
    >;
    mode?: InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_Mode>;
    /**
     * Options are a list of key/value pairs to enable extended TLS
     * configuration for each implementation. For example, configuring the
     * minimum TLS version or supported cipher suites.
     *
     * A set of common keys MAY be defined by the API in the future. To avoid
     * any ambiguity, implementation-specific definitions MUST use
     * domain-prefixed names, such as `example.com/my-custom-option`.
     * Un-prefixed names are reserved for key names defined by Gateway API.
     *
     * Support: Implementation-specific
     */
    options?: InputMaybe<Scalars['JSON']['input']>;
  };

/**
 * SecretObjectReference identifies an API object including its namespace,
 * defaulting to Secret.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_CertificateRefs_Items =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_namespace']['output']
    >;
  };

/**
 * SecretObjectReference identifies an API object including its namespace,
 * defaulting to Secret.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_CertificateRefs_Items_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_namespace']['input']
    >;
  };

/**
 * Mode defines the TLS behavior for the TLS session initiated by the client.
 * There are two possible modes:
 *
 * - Terminate: The TLS session between the downstream client and the
 *   Gateway is terminated at the Gateway. This mode requires certificates
 *   to be specified in some way, such as populating the certificateRefs
 *   field.
 * - Passthrough: The TLS session is NOT terminated by the Gateway. This
 *   implies that the Gateway can't decipher the TLS stream except for
 *   the ClientHello message of the TLS protocol. The certificateRefs field
 *   is ignored in this mode.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_Mode =
  'Passthrough' | 'Terminate';

/** Status defines the current state of Gateway. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status = {
  /**
   * Addresses lists the network addresses that have been bound to the
   * Gateway.
   *
   * This list may differ from the addresses provided in the spec under some
   * conditions:
   *
   *   * no addresses are specified, all addresses are dynamically assigned
   *   * a combination of specified and dynamic addresses are assigned
   *   * a specified address was unusable (e.g. already in use)
   */
  addresses?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Addresses_Items>
    >
  >;
  /**
   * Conditions describe the current conditions of the Gateway.
   *
   * Implementations should prefer to express Gateway conditions
   * using the `GatewayConditionType` and `GatewayConditionReason`
   * constants so that operators and tools can converge on a common
   * vocabulary to describe Gateway state.
   *
   * Known condition types are:
   *
   * * "Accepted"
   * * "Programmed"
   * * "Ready"
   */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
  /** Listeners provide status for each unique listener port defined in the Spec. */
  listeners?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items>
    >
  >;
};

/** Status defines the current state of Gateway. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Input = {
  /**
   * Addresses lists the network addresses that have been bound to the
   * Gateway.
   *
   * This list may differ from the addresses provided in the spec under some
   * conditions:
   *
   *   * no addresses are specified, all addresses are dynamically assigned
   *   * a combination of specified and dynamic addresses are assigned
   *   * a specified address was unusable (e.g. already in use)
   */
  addresses?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Addresses_Items_Input>
    >
  >;
  /**
   * Conditions describe the current conditions of the Gateway.
   *
   * Implementations should prefer to express Gateway conditions
   * using the `GatewayConditionType` and `GatewayConditionReason`
   * constants so that operators and tools can converge on a common
   * vocabulary to describe Gateway state.
   *
   * Known condition types are:
   *
   * * "Accepted"
   * * "Programmed"
   * * "Ready"
   */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /** Listeners provide status for each unique listener port defined in the Spec. */
  listeners?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Input>
    >
  >;
};

/** GatewayStatusAddress describes a network address that is bound to a Gateway. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Addresses_Items =
  {
    type?: Maybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_addresses_items_type']['output']
    >;
    /**
     * Value of the address. The validity of the values will depend
     * on the type and support by the controller.
     *
     * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
     */
    value: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_addresses_items_value']['output'];
  };

/** GatewayStatusAddress describes a network address that is bound to a Gateway. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Addresses_Items_Input =
  {
    type?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_addresses_items_type']['input']
    >;
    /**
     * Value of the address. The validity of the values will depend
     * on the type and support by the controller.
     *
     * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
     */
    value: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_addresses_items_value']['input'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** ListenerStatus is the status associated with a Listener. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items =
  {
    /**
     * AttachedRoutes represents the total number of Routes that have been
     * successfully attached to this Listener.
     *
     * Successful attachment of a Route to a Listener is based solely on the
     * combination of the AllowedRoutes field on the corresponding Listener
     * and the Route's ParentRefs field. A Route is successfully attached to
     * a Listener when it is selected by the Listener's AllowedRoutes field
     * AND the Route has a valid ParentRef selecting the whole Gateway
     * resource or a specific Listener as a parent resource (more detail on
     * attachment semantics can be found in the documentation on the various
     * Route kinds ParentRefs fields). Listener or Route status does not impact
     * successful attachment, i.e. the AttachedRoutes field count MUST be set
     * for Listeners with condition Accepted: false and MUST count successfully
     * attached Routes that may themselves have Accepted: false conditions.
     *
     * Uses for this field include troubleshooting Route attachment and
     * measuring blast radius/impact of changes to a Listener.
     */
    attachedRoutes: Scalars['Int']['output'];
    /** Conditions describe the current condition of this listener. */
    conditions: Array<
      Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Conditions_Items>
    >;
    name: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_name']['output'];
    /**
     * SupportedKinds is the list indicating the Kinds supported by this
     * listener. This MUST represent the kinds an implementation supports for
     * that Listener configuration.
     *
     * If kinds are specified in Spec that are not supported, they MUST NOT
     * appear in this list and an implementation MUST set the "ResolvedRefs"
     * condition to "False" with the "InvalidRouteKinds" reason. If both valid
     * and invalid Route kinds are specified, the implementation MUST
     * reference the valid Route kinds that have been specified.
     */
    supportedKinds: Array<
      Maybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_SupportedKinds_Items>
    >;
  };

/** ListenerStatus is the status associated with a Listener. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Input =
  {
    /**
     * AttachedRoutes represents the total number of Routes that have been
     * successfully attached to this Listener.
     *
     * Successful attachment of a Route to a Listener is based solely on the
     * combination of the AllowedRoutes field on the corresponding Listener
     * and the Route's ParentRefs field. A Route is successfully attached to
     * a Listener when it is selected by the Listener's AllowedRoutes field
     * AND the Route has a valid ParentRef selecting the whole Gateway
     * resource or a specific Listener as a parent resource (more detail on
     * attachment semantics can be found in the documentation on the various
     * Route kinds ParentRefs fields). Listener or Route status does not impact
     * successful attachment, i.e. the AttachedRoutes field count MUST be set
     * for Listeners with condition Accepted: false and MUST count successfully
     * attached Routes that may themselves have Accepted: false conditions.
     *
     * Uses for this field include troubleshooting Route attachment and
     * measuring blast radius/impact of changes to a Listener.
     */
    attachedRoutes: Scalars['Int']['input'];
    /** Conditions describe the current condition of this listener. */
    conditions: Array<
      InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Conditions_Items_Input>
    >;
    name: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_name']['input'];
    /**
     * SupportedKinds is the list indicating the Kinds supported by this
     * listener. This MUST represent the kinds an implementation supports for
     * that Listener configuration.
     *
     * If kinds are specified in Spec that are not supported, they MUST NOT
     * appear in this list and an implementation MUST set the "ResolvedRefs"
     * condition to "False" with the "InvalidRouteKinds" reason. If both valid
     * and invalid Route kinds are specified, the implementation MUST
     * reference the valid Route kinds that have been specified.
     */
    supportedKinds: Array<
      InputMaybe<Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_SupportedKinds_Items_Input>
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_reason']['output'];
    status: Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_reason']['input'];
    status: Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** RouteGroupKind indicates the group and kind of a Route resource. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_SupportedKinds_Items =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_supportedKinds_items_group']['output']
    >;
    kind: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_supportedKinds_items_kind']['output'];
  };

/** RouteGroupKind indicates the group and kind of a Route resource. */
export type Query_ListGatewayNetworkingV1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_SupportedKinds_Items_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_supportedKinds_items_group']['input']
    >;
    kind: Scalars['query_listGatewayNetworkingV1GatewayForAllNamespaces_items_items_status_listeners_items_supportedKinds_items_kind']['input'];
  };

/** Spec defines the desired state of HTTPRoute. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec = {
  /**
   * Hostnames defines a set of hostnames that should match against the HTTP Host
   * header to select a HTTPRoute used to process the request. Implementations
   * MUST ignore any port value specified in the HTTP Host header while
   * performing a match and (absent of any applicable header modification
   * configuration) MUST forward this header unmodified to the backend.
   *
   * Valid values for Hostnames are determined by RFC 1123 definition of a
   * hostname with 2 notable exceptions:
   *
   * 1. IPs are not allowed.
   * 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
   *    label must appear by itself as the first label.
   *
   * If a hostname is specified by both the Listener and HTTPRoute, there
   * must be at least one intersecting hostname for the HTTPRoute to be
   * attached to the Listener. For example:
   *
   * * A Listener with `test.example.com` as the hostname matches HTTPRoutes
   *   that have either not specified any hostnames, or have specified at
   *   least one of `test.example.com` or `*.example.com`.
   * * A Listener with `*.example.com` as the hostname matches HTTPRoutes
   *   that have either not specified any hostnames or have specified at least
   *   one hostname that matches the Listener hostname. For example,
   *   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
   *   all match. On the other hand, `example.com` and `test.example.net` would
   *   not match.
   *
   * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
   * as a suffix match. That means that a match for `*.example.com` would match
   * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
   *
   * If both the Listener and HTTPRoute have specified hostnames, any
   * HTTPRoute hostnames that do not match the Listener hostname MUST be
   * ignored. For example, if a Listener specified `*.example.com`, and the
   * HTTPRoute specified `test.example.com` and `test.example.net`,
   * `test.example.net` must not be considered for a match.
   *
   * If both the Listener and HTTPRoute have specified hostnames, and none
   * match with the criteria above, then the HTTPRoute is not accepted. The
   * implementation must raise an 'Accepted' Condition with a status of
   * `False` in the corresponding RouteParentStatus.
   *
   * In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
   * overlapping wildcard matching and exact matching hostnames), precedence must
   * be given to rules from the HTTPRoute with the largest number of:
   *
   * * Characters in a matching non-wildcard hostname.
   * * Characters in a matching hostname.
   *
   * If ties exist across multiple Routes, the matching precedence rules for
   * HTTPRouteMatches takes over.
   *
   * Support: Core
   */
  hostnames?: Maybe<
    Array<
      Maybe<
        Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_hostnames_items']['output']
      >
    >
  >;
  /**
   * ParentRefs references the resources (usually Gateways) that a Route wants
   * to be attached to. Note that the referenced parent resource needs to
   * allow this for the attachment to be complete. For Gateways, that means
   * the Gateway needs to allow attachment from Routes of this kind and
   * namespace. For Services, that means the Service must either be in the same
   * namespace for a "producer" route, or the mesh implementation must support
   * and allow "consumer" routes for the referenced Service. ReferenceGrant is
   * not applicable for governing ParentRefs to Services - it is not possible to
   * create a "producer" route for a Service in a different namespace from the
   * Route.
   *
   * There are two kinds of parent resources with "Core" support:
   *
   * * Gateway (Gateway conformance profile)
   * * Service (Mesh conformance profile, ClusterIP Services only)
   *
   * This API may be extended in the future to support additional kinds of parent
   * resources.
   *
   * ParentRefs must be _distinct_. This means either that:
   *
   * * They select different objects.  If this is the case, then parentRef
   *   entries are distinct. In terms of fields, this means that the
   *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
   *   be unique across all parentRef entries in the Route.
   * * They do not select different objects, but for each optional field used,
   *   each ParentRef that selects the same object must set the same set of
   *   optional fields to different values. If one ParentRef sets a
   *   combination of optional fields, all must set the same combination.
   *
   * Some examples:
   *
   * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
   *   same object must also set `sectionName`.
   * * If one ParentRef sets `port`, all ParentRefs referencing the same
   *   object must also set `port`.
   * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
   *   referencing the same object must also set `sectionName` and `port`.
   *
   * It is possible to separately reference multiple distinct objects that may
   * be collapsed by an implementation. For example, some implementations may
   * choose to merge compatible Gateway Listeners together. If that is the
   * case, the list of routes attached to those resources should also be
   * merged.
   *
   * Note that for ParentRefs that cross namespace boundaries, there are specific
   * rules. Cross-namespace references are only valid if they are explicitly
   * allowed by something in the namespace they are referring to. For example,
   * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
   * generic way to enable other kinds of cross-namespace reference.
   */
  parentRefs?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_ParentRefs_Items>
    >
  >;
  /** Rules are a list of HTTP matchers, filters and actions. */
  rules?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items>
    >
  >;
};

/** Spec defines the desired state of HTTPRoute. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Input = {
  /**
   * Hostnames defines a set of hostnames that should match against the HTTP Host
   * header to select a HTTPRoute used to process the request. Implementations
   * MUST ignore any port value specified in the HTTP Host header while
   * performing a match and (absent of any applicable header modification
   * configuration) MUST forward this header unmodified to the backend.
   *
   * Valid values for Hostnames are determined by RFC 1123 definition of a
   * hostname with 2 notable exceptions:
   *
   * 1. IPs are not allowed.
   * 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
   *    label must appear by itself as the first label.
   *
   * If a hostname is specified by both the Listener and HTTPRoute, there
   * must be at least one intersecting hostname for the HTTPRoute to be
   * attached to the Listener. For example:
   *
   * * A Listener with `test.example.com` as the hostname matches HTTPRoutes
   *   that have either not specified any hostnames, or have specified at
   *   least one of `test.example.com` or `*.example.com`.
   * * A Listener with `*.example.com` as the hostname matches HTTPRoutes
   *   that have either not specified any hostnames or have specified at least
   *   one hostname that matches the Listener hostname. For example,
   *   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
   *   all match. On the other hand, `example.com` and `test.example.net` would
   *   not match.
   *
   * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
   * as a suffix match. That means that a match for `*.example.com` would match
   * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
   *
   * If both the Listener and HTTPRoute have specified hostnames, any
   * HTTPRoute hostnames that do not match the Listener hostname MUST be
   * ignored. For example, if a Listener specified `*.example.com`, and the
   * HTTPRoute specified `test.example.com` and `test.example.net`,
   * `test.example.net` must not be considered for a match.
   *
   * If both the Listener and HTTPRoute have specified hostnames, and none
   * match with the criteria above, then the HTTPRoute is not accepted. The
   * implementation must raise an 'Accepted' Condition with a status of
   * `False` in the corresponding RouteParentStatus.
   *
   * In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
   * overlapping wildcard matching and exact matching hostnames), precedence must
   * be given to rules from the HTTPRoute with the largest number of:
   *
   * * Characters in a matching non-wildcard hostname.
   * * Characters in a matching hostname.
   *
   * If ties exist across multiple Routes, the matching precedence rules for
   * HTTPRouteMatches takes over.
   *
   * Support: Core
   */
  hostnames?: InputMaybe<
    Array<
      InputMaybe<
        Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_hostnames_items']['input']
      >
    >
  >;
  /**
   * ParentRefs references the resources (usually Gateways) that a Route wants
   * to be attached to. Note that the referenced parent resource needs to
   * allow this for the attachment to be complete. For Gateways, that means
   * the Gateway needs to allow attachment from Routes of this kind and
   * namespace. For Services, that means the Service must either be in the same
   * namespace for a "producer" route, or the mesh implementation must support
   * and allow "consumer" routes for the referenced Service. ReferenceGrant is
   * not applicable for governing ParentRefs to Services - it is not possible to
   * create a "producer" route for a Service in a different namespace from the
   * Route.
   *
   * There are two kinds of parent resources with "Core" support:
   *
   * * Gateway (Gateway conformance profile)
   * * Service (Mesh conformance profile, ClusterIP Services only)
   *
   * This API may be extended in the future to support additional kinds of parent
   * resources.
   *
   * ParentRefs must be _distinct_. This means either that:
   *
   * * They select different objects.  If this is the case, then parentRef
   *   entries are distinct. In terms of fields, this means that the
   *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
   *   be unique across all parentRef entries in the Route.
   * * They do not select different objects, but for each optional field used,
   *   each ParentRef that selects the same object must set the same set of
   *   optional fields to different values. If one ParentRef sets a
   *   combination of optional fields, all must set the same combination.
   *
   * Some examples:
   *
   * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
   *   same object must also set `sectionName`.
   * * If one ParentRef sets `port`, all ParentRefs referencing the same
   *   object must also set `port`.
   * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
   *   referencing the same object must also set `sectionName` and `port`.
   *
   * It is possible to separately reference multiple distinct objects that may
   * be collapsed by an implementation. For example, some implementations may
   * choose to merge compatible Gateway Listeners together. If that is the
   * case, the list of routes attached to those resources should also be
   * merged.
   *
   * Note that for ParentRefs that cross namespace boundaries, there are specific
   * rules. Cross-namespace references are only valid if they are explicitly
   * allowed by something in the namespace they are referring to. For example,
   * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
   * generic way to enable other kinds of cross-namespace reference.
   */
  parentRefs?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_ParentRefs_Items_Input>
    >
  >;
  /** Rules are a list of HTTP matchers, filters and actions. */
  rules?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Input>
    >
  >;
};

/**
 * ParentReference identifies an API object (usually a Gateway) that can be considered
 * a parent of this resource (usually a route). There are two kinds of parent resources
 * with "Core" support:
 *
 * * Gateway (Gateway conformance profile)
 * * Service (Mesh conformance profile, ClusterIP Services only)
 *
 * This API may be extended in the future to support additional kinds of parent
 * resources.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_ParentRefs_Items =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_kind']['output']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_namespace']['output']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    sectionName?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_sectionName']['output']
    >;
  };

/**
 * ParentReference identifies an API object (usually a Gateway) that can be considered
 * a parent of this resource (usually a route). There are two kinds of parent resources
 * with "Core" support:
 *
 * * Gateway (Gateway conformance profile)
 * * Service (Mesh conformance profile, ClusterIP Services only)
 *
 * This API may be extended in the future to support additional kinds of parent
 * resources.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_ParentRefs_Items_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_kind']['input']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_namespace']['input']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    sectionName?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_sectionName']['input']
    >;
  };

/**
 * HTTPRouteRule defines semantics for matching an HTTP request based on
 * conditions (matches), processing it (filters), and forwarding the request to
 * an API object (backendRefs).
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items = {
  /**
   * BackendRefs defines the backend(s) where matching requests should be
   * sent.
   *
   * Failure behavior here depends on how many BackendRefs are specified and
   * how many are invalid.
   *
   * If *all* entries in BackendRefs are invalid, and there are also no filters
   * specified in this route rule, *all* traffic which matches this rule MUST
   * receive a 500 status code.
   *
   * See the HTTPBackendRef definition for the rules about what makes a single
   * HTTPBackendRef invalid.
   *
   * When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
   * requests that would have otherwise been routed to an invalid backend. If
   * multiple backends are specified, and some are invalid, the proportion of
   * requests that would otherwise have been routed to an invalid backend
   * MUST receive a 500 status code.
   *
   * For example, if two backends are specified with equal weights, and one is
   * invalid, 50 percent of traffic must receive a 500. Implementations may
   * choose how that 50 percent is determined.
   *
   * When a HTTPBackendRef refers to a Service that has no ready endpoints,
   * implementations SHOULD return a 503 for requests to that backend instead.
   * If an implementation chooses to do this, all of the above rules for 500 responses
   * MUST also apply for responses that return a 503.
   *
   * Support: Core for Kubernetes Service
   *
   * Support: Extended for Kubernetes ServiceImport
   *
   * Support: Implementation-specific for any other resource
   *
   * Support for weight: Core
   */
  backendRefs?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items>
    >
  >;
  /**
   * Filters define the filters that are applied to requests that match
   * this rule.
   *
   * Wherever possible, implementations SHOULD implement filters in the order
   * they are specified.
   *
   * Implementations MAY choose to implement this ordering strictly, rejecting
   * any combination or order of filters that cannot be supported. If implementations
   * choose a strict interpretation of filter ordering, they MUST clearly document
   * that behavior.
   *
   * To reject an invalid combination or order of filters, implementations SHOULD
   * consider the Route Rules with this configuration invalid. If all Route Rules
   * in a Route are invalid, the entire Route would be considered invalid. If only
   * a portion of Route Rules are invalid, implementations MUST set the
   * "PartiallyInvalid" condition for the Route.
   *
   * Conformance-levels at this level are defined based on the type of filter:
   *
   * - ALL core filters MUST be supported by all implementations.
   * - Implementers are encouraged to support extended filters.
   * - Implementation-specific custom filters have no API guarantees across
   *   implementations.
   *
   * Specifying the same filter multiple times is not supported unless explicitly
   * indicated in the filter.
   *
   * All filters are expected to be compatible with each other except for the
   * URLRewrite and RequestRedirect filters, which may not be combined. If an
   * implementation cannot support other combinations of filters, they must clearly
   * document that limitation. In cases where incompatible or unsupported
   * filters are specified and cause the `Accepted` condition to be set to status
   * `False`, implementations may use the `IncompatibleFilters` reason to specify
   * this configuration error.
   *
   * Support: Core
   */
  filters?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items>
    >
  >;
  /**
   * Matches define conditions used for matching the rule against incoming
   * HTTP requests. Each match is independent, i.e. this rule will be matched
   * if **any** one of the matches is satisfied.
   *
   * For example, take the following matches configuration:
   *
   * ```
   * matches:
   * - path:
   *     value: "/foo"
   *   headers:
   *   - name: "version"
   *     value: "v2"
   * - path:
   *     value: "/v2/foo"
   * ```
   *
   * For a request to match against this rule, a request must satisfy
   * EITHER of the two conditions:
   *
   * - path prefixed with `/foo` AND contains the header `version: v2`
   * - path prefix of `/v2/foo`
   *
   * See the documentation for HTTPRouteMatch on how to specify multiple
   * match conditions that should be ANDed together.
   *
   * If no matches are specified, the default is a prefix
   * path match on "/", which has the effect of matching every
   * HTTP request.
   *
   * Proxy or Load Balancer routing configuration generated from HTTPRoutes
   * MUST prioritize matches based on the following criteria, continuing on
   * ties. Across all rules specified on applicable Routes, precedence must be
   * given to the match having:
   *
   * * "Exact" path match.
   * * "Prefix" path match with largest number of characters.
   * * Method match.
   * * Largest number of header matches.
   * * Largest number of query param matches.
   *
   * Note: The precedence of RegularExpression path matches are implementation-specific.
   *
   * If ties still exist across multiple Routes, matching precedence MUST be
   * determined in order of the following criteria, continuing on ties:
   *
   * * The oldest Route based on creation timestamp.
   * * The Route appearing first in alphabetical order by
   *   "{namespace}/{name}".
   *
   * If ties still exist within an HTTPRoute, matching precedence MUST be granted
   * to the FIRST matching rule (in list order) with a match meeting the above
   * criteria.
   *
   * When no rules matching a request have been successfully attached to the
   * parent a request is coming from, a HTTP 404 status code MUST be returned.
   */
  matches?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items>
    >
  >;
  timeouts?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Timeouts>;
};

/**
 * HTTPRouteRule defines semantics for matching an HTTP request based on
 * conditions (matches), processing it (filters), and forwarding the request to
 * an API object (backendRefs).
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Input =
  {
    /**
     * BackendRefs defines the backend(s) where matching requests should be
     * sent.
     *
     * Failure behavior here depends on how many BackendRefs are specified and
     * how many are invalid.
     *
     * If *all* entries in BackendRefs are invalid, and there are also no filters
     * specified in this route rule, *all* traffic which matches this rule MUST
     * receive a 500 status code.
     *
     * See the HTTPBackendRef definition for the rules about what makes a single
     * HTTPBackendRef invalid.
     *
     * When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
     * requests that would have otherwise been routed to an invalid backend. If
     * multiple backends are specified, and some are invalid, the proportion of
     * requests that would otherwise have been routed to an invalid backend
     * MUST receive a 500 status code.
     *
     * For example, if two backends are specified with equal weights, and one is
     * invalid, 50 percent of traffic must receive a 500. Implementations may
     * choose how that 50 percent is determined.
     *
     * When a HTTPBackendRef refers to a Service that has no ready endpoints,
     * implementations SHOULD return a 503 for requests to that backend instead.
     * If an implementation chooses to do this, all of the above rules for 500 responses
     * MUST also apply for responses that return a 503.
     *
     * Support: Core for Kubernetes Service
     *
     * Support: Extended for Kubernetes ServiceImport
     *
     * Support: Implementation-specific for any other resource
     *
     * Support for weight: Core
     */
    backendRefs?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Input>
      >
    >;
    /**
     * Filters define the filters that are applied to requests that match
     * this rule.
     *
     * Wherever possible, implementations SHOULD implement filters in the order
     * they are specified.
     *
     * Implementations MAY choose to implement this ordering strictly, rejecting
     * any combination or order of filters that cannot be supported. If implementations
     * choose a strict interpretation of filter ordering, they MUST clearly document
     * that behavior.
     *
     * To reject an invalid combination or order of filters, implementations SHOULD
     * consider the Route Rules with this configuration invalid. If all Route Rules
     * in a Route are invalid, the entire Route would be considered invalid. If only
     * a portion of Route Rules are invalid, implementations MUST set the
     * "PartiallyInvalid" condition for the Route.
     *
     * Conformance-levels at this level are defined based on the type of filter:
     *
     * - ALL core filters MUST be supported by all implementations.
     * - Implementers are encouraged to support extended filters.
     * - Implementation-specific custom filters have no API guarantees across
     *   implementations.
     *
     * Specifying the same filter multiple times is not supported unless explicitly
     * indicated in the filter.
     *
     * All filters are expected to be compatible with each other except for the
     * URLRewrite and RequestRedirect filters, which may not be combined. If an
     * implementation cannot support other combinations of filters, they must clearly
     * document that limitation. In cases where incompatible or unsupported
     * filters are specified and cause the `Accepted` condition to be set to status
     * `False`, implementations may use the `IncompatibleFilters` reason to specify
     * this configuration error.
     *
     * Support: Core
     */
    filters?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Input>
      >
    >;
    /**
     * Matches define conditions used for matching the rule against incoming
     * HTTP requests. Each match is independent, i.e. this rule will be matched
     * if **any** one of the matches is satisfied.
     *
     * For example, take the following matches configuration:
     *
     * ```
     * matches:
     * - path:
     *     value: "/foo"
     *   headers:
     *   - name: "version"
     *     value: "v2"
     * - path:
     *     value: "/v2/foo"
     * ```
     *
     * For a request to match against this rule, a request must satisfy
     * EITHER of the two conditions:
     *
     * - path prefixed with `/foo` AND contains the header `version: v2`
     * - path prefix of `/v2/foo`
     *
     * See the documentation for HTTPRouteMatch on how to specify multiple
     * match conditions that should be ANDed together.
     *
     * If no matches are specified, the default is a prefix
     * path match on "/", which has the effect of matching every
     * HTTP request.
     *
     * Proxy or Load Balancer routing configuration generated from HTTPRoutes
     * MUST prioritize matches based on the following criteria, continuing on
     * ties. Across all rules specified on applicable Routes, precedence must be
     * given to the match having:
     *
     * * "Exact" path match.
     * * "Prefix" path match with largest number of characters.
     * * Method match.
     * * Largest number of header matches.
     * * Largest number of query param matches.
     *
     * Note: The precedence of RegularExpression path matches are implementation-specific.
     *
     * If ties still exist across multiple Routes, matching precedence MUST be
     * determined in order of the following criteria, continuing on ties:
     *
     * * The oldest Route based on creation timestamp.
     * * The Route appearing first in alphabetical order by
     *   "{namespace}/{name}".
     *
     * If ties still exist within an HTTPRoute, matching precedence MUST be granted
     * to the FIRST matching rule (in list order) with a match meeting the above
     * criteria.
     *
     * When no rules matching a request have been successfully attached to the
     * parent a request is coming from, a HTTP 404 status code MUST be returned.
     */
    matches?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Input>
      >
    >;
    timeouts?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Timeouts_Input>;
  };

/**
 * HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
 *
 * Note that when a namespace different than the local namespace is specified, a
 * ReferenceGrant object is required in the referent namespace to allow that
 * namespace's owner to accept the reference. See the ReferenceGrant
 * documentation for details.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items =
  {
    /**
     * Filters defined at this level should be executed if and only if the
     * request is being forwarded to the backend defined here.
     *
     * Support: Implementation-specific (For broader support of filters, use the
     * Filters field in HTTPRouteRule.)
     */
    filters?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items>
      >
    >;
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
    /**
     * Weight specifies the proportion of requests forwarded to the referenced
     * backend. This is computed as weight/(sum of all weights in this
     * BackendRefs list). For non-zero values, there may be some epsilon from
     * the exact proportion defined here depending on the precision an
     * implementation supports. Weight is not a percentage and the sum of
     * weights does not need to equal 100.
     *
     * If only one backend is specified and it has a weight greater than 0, 100%
     * of the traffic is forwarded to that backend. If weight is set to 0, no
     * traffic should be forwarded for this entry. If unspecified, weight
     * defaults to 1.
     *
     * Support for this field varies based on the context where used.
     */
    weight?: Maybe<Scalars['Int']['output']>;
  };

/**
 * HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
 *
 * Note that when a namespace different than the local namespace is specified, a
 * ReferenceGrant object is required in the referent namespace to allow that
 * namespace's owner to accept the reference. See the ReferenceGrant
 * documentation for details.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Input =
  {
    /**
     * Filters defined at this level should be executed if and only if the
     * request is being forwarded to the backend defined here.
     *
     * Support: Implementation-specific (For broader support of filters, use the
     * Filters field in HTTPRouteRule.)
     */
    filters?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_Input>
      >
    >;
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    /**
     * Weight specifies the proportion of requests forwarded to the referenced
     * backend. This is computed as weight/(sum of all weights in this
     * BackendRefs list). For non-zero values, there may be some epsilon from
     * the exact proportion defined here depending on the precision an
     * implementation supports. Weight is not a percentage and the sum of
     * weights does not need to equal 100.
     *
     * If only one backend is specified and it has a weight greater than 0, 100%
     * of the traffic is forwarded to that backend. If weight is set to 0, no
     * traffic should be forwarded for this entry. If unspecified, weight
     * defaults to 1.
     *
     * Support for this field varies based on the context where used.
     */
    weight?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * HTTPRouteFilter defines processing steps that must be completed during the
 * request or response lifecycle. HTTPRouteFilters are meant as an extension
 * point to express processing that may be done in Gateway implementations. Some
 * examples include request or response modification, implementing
 * authentication strategies, rate-limiting, and traffic shaping. API
 * guarantee/conformance is defined based on the type of the filter.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items =
  {
    extensionRef?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ExtensionRef>;
    requestHeaderModifier?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier>;
    requestMirror?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror>;
    requestRedirect?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect>;
    responseHeaderModifier?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier>;
    type: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_Type;
    urlRewrite?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite>;
  };

/**
 * HTTPRouteFilter defines processing steps that must be completed during the
 * request or response lifecycle. HTTPRouteFilters are meant as an extension
 * point to express processing that may be done in Gateway implementations. Some
 * examples include request or response modification, implementing
 * authentication strategies, rate-limiting, and traffic shaping. API
 * guarantee/conformance is defined based on the type of the filter.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_Input =
  {
    extensionRef?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ExtensionRef_Input>;
    requestHeaderModifier?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Input>;
    requestMirror?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_Input>;
    requestRedirect?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Input>;
    responseHeaderModifier?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Input>;
    type: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_Type;
    urlRewrite?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Input>;
  };

/**
 * ExtensionRef is an optional, implementation-specific extension to the
 * "filter" behavior.  For example, resource "myroutefilter" in group
 * "networking.example.net"). ExtensionRef MUST NOT be used for core and
 * extended filters.
 *
 * This filter can be used multiple times within the same rule.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ExtensionRef =
  {
    group: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_group']['output'];
    kind: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_kind']['output'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_name']['output'];
  };

/**
 * ExtensionRef is an optional, implementation-specific extension to the
 * "filter" behavior.  For example, resource "myroutefilter" in group
 * "networking.example.net"). ExtensionRef MUST NOT be used for core and
 * extended filters.
 *
 * This filter can be used multiple times within the same rule.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ExtensionRef_Input =
  {
    group: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_group']['input'];
    kind: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_kind']['input'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_name']['input'];
  };

/**
 * RequestHeaderModifier defines a schema for a filter that modifies request
 * headers.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Add_Items>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Set_Items>
      >
    >;
  };

/**
 * RequestHeaderModifier defines a schema for a filter that modifies request
 * headers.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Input =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Add_Items_Input>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Set_Items_Input>
      >
    >;
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Add_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_add_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_add_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Add_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_add_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_add_items_value']['input'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Set_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_set_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_set_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Set_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_set_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_set_items_value']['input'];
  };

/**
 * RequestMirror defines a schema for a filter that mirrors requests.
 * Requests are sent to the specified destination, but responses from
 * that destination are ignored.
 *
 * This filter can be used multiple times within the same rule. Note that
 * not all implementations will be able to support mirroring to multiple
 * backends.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror =
  {
    backendRef: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_BackendRef;
    fraction?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_Fraction>;
    /**
     * Percent represents the percentage of requests that should be
     * mirrored to BackendRef. Its minimum value is 0 (indicating 0% of
     * requests) and its maximum value is 100 (indicating 100% of requests).
     *
     * Only one of Fraction or Percent may be specified. If neither field
     * is specified, 100% of requests will be mirrored.
     */
    percent?: Maybe<Scalars['Int']['output']>;
  };

/**
 * RequestMirror defines a schema for a filter that mirrors requests.
 * Requests are sent to the specified destination, but responses from
 * that destination are ignored.
 *
 * This filter can be used multiple times within the same rule. Note that
 * not all implementations will be able to support mirroring to multiple
 * backends.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_Input =
  {
    backendRef: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_BackendRef_Input;
    fraction?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_Fraction_Input>;
    /**
     * Percent represents the percentage of requests that should be
     * mirrored to BackendRef. Its minimum value is 0 (indicating 0% of
     * requests) and its maximum value is 100 (indicating 100% of requests).
     *
     * Only one of Fraction or Percent may be specified. If neither field
     * is specified, 100% of requests will be mirrored.
     */
    percent?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * BackendRef references a resource where mirrored requests are sent.
 *
 * Mirrored requests must be sent only to a single destination endpoint
 * within this BackendRef, irrespective of how many endpoints are present
 * within this BackendRef.
 *
 * If the referent cannot be found, this BackendRef is invalid and must be
 * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
 * condition on the Route status is set to `status: False` and not configure
 * this backend in the underlying implementation.
 *
 * If there is a cross-namespace reference to an *existing* object
 * that is not allowed by a ReferenceGrant, the controller must ensure the
 * "ResolvedRefs"  condition on the Route is set to `status: False`,
 * with the "RefNotPermitted" reason and not configure this backend in the
 * underlying implementation.
 *
 * In either error case, the Message of the `ResolvedRefs` Condition
 * should be used to provide more detail about the problem.
 *
 * Support: Extended for Kubernetes Service
 *
 * Support: Implementation-specific for any other resource
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_BackendRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
  };

/**
 * BackendRef references a resource where mirrored requests are sent.
 *
 * Mirrored requests must be sent only to a single destination endpoint
 * within this BackendRef, irrespective of how many endpoints are present
 * within this BackendRef.
 *
 * If the referent cannot be found, this BackendRef is invalid and must be
 * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
 * condition on the Route status is set to `status: False` and not configure
 * this backend in the underlying implementation.
 *
 * If there is a cross-namespace reference to an *existing* object
 * that is not allowed by a ReferenceGrant, the controller must ensure the
 * "ResolvedRefs"  condition on the Route is set to `status: False`,
 * with the "RefNotPermitted" reason and not configure this backend in the
 * underlying implementation.
 *
 * In either error case, the Message of the `ResolvedRefs` Condition
 * should be used to provide more detail about the problem.
 *
 * Support: Extended for Kubernetes Service
 *
 * Support: Implementation-specific for any other resource
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_BackendRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * Fraction represents the fraction of requests that should be
 * mirrored to BackendRef.
 *
 * Only one of Fraction or Percent may be specified. If neither field
 * is specified, 100% of requests will be mirrored.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_Fraction =
  {
    denominator?: Maybe<Scalars['Int']['output']>;
    numerator: Scalars['Int']['output'];
  };

/**
 * Fraction represents the fraction of requests that should be
 * mirrored to BackendRef.
 *
 * Only one of Fraction or Percent may be specified. If neither field
 * is specified, 100% of requests will be mirrored.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_Fraction_Input =
  {
    denominator?: InputMaybe<Scalars['Int']['input']>;
    numerator: Scalars['Int']['input'];
  };

/**
 * RequestRedirect defines a schema for a filter that responds to the
 * request with an HTTP redirection.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect =
  {
    hostname?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_hostname']['output']
    >;
    path?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Path>;
    /**
     * Port is the port to be used in the value of the `Location`
     * header in the response.
     *
     * If no port is specified, the redirect port MUST be derived using the
     * following rules:
     *
     * * If redirect scheme is not-empty, the redirect port MUST be the well-known
     *   port associated with the redirect scheme. Specifically "http" to port 80
     *   and "https" to port 443. If the redirect scheme does not have a
     *   well-known port, the listener port of the Gateway SHOULD be used.
     * * If redirect scheme is empty, the redirect port MUST be the Gateway
     *   Listener port.
     *
     * Implementations SHOULD NOT add the port number in the 'Location'
     * header in the following cases:
     *
     * * A Location header that will use HTTP (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 80.
     * * A Location header that will use HTTPS (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 443.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    scheme?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Scheme>;
    statusCode?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_StatusCode>;
  };

/**
 * RequestRedirect defines a schema for a filter that responds to the
 * request with an HTTP redirection.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_hostname']['input']
    >;
    path?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Path_Input>;
    /**
     * Port is the port to be used in the value of the `Location`
     * header in the response.
     *
     * If no port is specified, the redirect port MUST be derived using the
     * following rules:
     *
     * * If redirect scheme is not-empty, the redirect port MUST be the well-known
     *   port associated with the redirect scheme. Specifically "http" to port 80
     *   and "https" to port 443. If the redirect scheme does not have a
     *   well-known port, the listener port of the Gateway SHOULD be used.
     * * If redirect scheme is empty, the redirect port MUST be the Gateway
     *   Listener port.
     *
     * Implementations SHOULD NOT add the port number in the 'Location'
     * header in the following cases:
     *
     * * A Location header that will use HTTP (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 80.
     * * A Location header that will use HTTPS (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 443.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    scheme?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Scheme>;
    statusCode?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_StatusCode>;
  };

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Path =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_path_replaceFullPath']['output']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_path_replacePrefixMatch']['output']
    >;
    type: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Path_Type;
  };

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Path_Input =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_path_replaceFullPath']['input']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_path_replacePrefixMatch']['input']
    >;
    type: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Path_Type;
  };

/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Path_Type =
  'ReplaceFullPath' | 'ReplacePrefixMatch';

/**
 * Scheme is the scheme to be used in the value of the `Location` header in
 * the response. When empty, the scheme of the request is used.
 *
 * Scheme redirects can affect the port of the redirect, for more information,
 * refer to the documentation for the port field of this filter.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Scheme =
  'http' | 'https';

/**
 * StatusCode is the HTTP status code to be used in response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_StatusCode =
  '_301' | '_302';

/**
 * ResponseHeaderModifier defines a schema for a filter that modifies response
 * headers.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Add_Items>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Set_Items>
      >
    >;
  };

/**
 * ResponseHeaderModifier defines a schema for a filter that modifies response
 * headers.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Input =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Add_Items_Input>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Set_Items_Input>
      >
    >;
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Add_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_add_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_add_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Add_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_add_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_add_items_value']['input'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Set_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_set_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_set_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Set_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_set_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_set_items_value']['input'];
  };

/**
 * Type identifies the type of filter to apply. As with other API fields,
 * types are classified into three conformance levels:
 *
 * - Core: Filter types and their corresponding configuration defined by
 *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
 *   implementations must support core filters.
 *
 * - Extended: Filter types and their corresponding configuration defined by
 *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
 *   are encouraged to support extended filters.
 *
 * - Implementation-specific: Filters that are defined and supported by
 *   specific vendors.
 *   In the future, filters showing convergence in behavior across multiple
 *   implementations will be considered for inclusion in extended or core
 *   conformance levels. Filter-specific configuration for such filters
 *   is specified using the ExtensionRef field. `Type` should be set to
 *   "ExtensionRef" for custom filters.
 *
 * Implementers are encouraged to define custom implementation types to
 * extend the core API with implementation-specific behavior.
 *
 * If a reference to a custom filter type cannot be resolved, the filter
 * MUST NOT be skipped. Instead, requests that would have been processed by
 * that filter MUST receive a HTTP error response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_Type =

    | 'ExtensionRef'
    | 'RequestHeaderModifier'
    | 'RequestMirror'
    | 'RequestRedirect'
    | 'ResponseHeaderModifier'
    | 'URLRewrite';

/**
 * URLRewrite defines a schema for a filter that modifies a request during forwarding.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite =
  {
    hostname?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_hostname']['output']
    >;
    path?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Path>;
  };

/**
 * URLRewrite defines a schema for a filter that modifies a request during forwarding.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_hostname']['input']
    >;
    path?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Path_Input>;
  };

/**
 * Path defines a path rewrite.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Path =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_path_replaceFullPath']['output']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_path_replacePrefixMatch']['output']
    >;
    type: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Path_Type;
  };

/**
 * Path defines a path rewrite.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Path_Input =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_path_replaceFullPath']['input']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_path_replacePrefixMatch']['input']
    >;
    type: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Path_Type;
  };

/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Path_Type =
  'ReplaceFullPath' | 'ReplacePrefixMatch';

/**
 * HTTPRouteFilter defines processing steps that must be completed during the
 * request or response lifecycle. HTTPRouteFilters are meant as an extension
 * point to express processing that may be done in Gateway implementations. Some
 * examples include request or response modification, implementing
 * authentication strategies, rate-limiting, and traffic shaping. API
 * guarantee/conformance is defined based on the type of the filter.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items =
  {
    extensionRef?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ExtensionRef>;
    requestHeaderModifier?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier>;
    requestMirror?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror>;
    requestRedirect?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect>;
    responseHeaderModifier?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier>;
    type: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Type;
    urlRewrite?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite>;
  };

/**
 * HTTPRouteFilter defines processing steps that must be completed during the
 * request or response lifecycle. HTTPRouteFilters are meant as an extension
 * point to express processing that may be done in Gateway implementations. Some
 * examples include request or response modification, implementing
 * authentication strategies, rate-limiting, and traffic shaping. API
 * guarantee/conformance is defined based on the type of the filter.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Input =
  {
    extensionRef?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ExtensionRef_Input>;
    requestHeaderModifier?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Input>;
    requestMirror?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Input>;
    requestRedirect?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Input>;
    responseHeaderModifier?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Input>;
    type: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Type;
    urlRewrite?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Input>;
  };

/**
 * ExtensionRef is an optional, implementation-specific extension to the
 * "filter" behavior.  For example, resource "myroutefilter" in group
 * "networking.example.net"). ExtensionRef MUST NOT be used for core and
 * extended filters.
 *
 * This filter can be used multiple times within the same rule.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ExtensionRef =
  {
    group: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_group']['output'];
    kind: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_kind']['output'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_name']['output'];
  };

/**
 * ExtensionRef is an optional, implementation-specific extension to the
 * "filter" behavior.  For example, resource "myroutefilter" in group
 * "networking.example.net"). ExtensionRef MUST NOT be used for core and
 * extended filters.
 *
 * This filter can be used multiple times within the same rule.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ExtensionRef_Input =
  {
    group: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_group']['input'];
    kind: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_kind']['input'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_name']['input'];
  };

/**
 * RequestHeaderModifier defines a schema for a filter that modifies request
 * headers.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Add_Items>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Set_Items>
      >
    >;
  };

/**
 * RequestHeaderModifier defines a schema for a filter that modifies request
 * headers.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Input =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Add_Items_Input>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Set_Items_Input>
      >
    >;
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Add_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Add_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_value']['input'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Set_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Set_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_value']['input'];
  };

/**
 * RequestMirror defines a schema for a filter that mirrors requests.
 * Requests are sent to the specified destination, but responses from
 * that destination are ignored.
 *
 * This filter can be used multiple times within the same rule. Note that
 * not all implementations will be able to support mirroring to multiple
 * backends.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror =
  {
    backendRef: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_BackendRef;
    fraction?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Fraction>;
    /**
     * Percent represents the percentage of requests that should be
     * mirrored to BackendRef. Its minimum value is 0 (indicating 0% of
     * requests) and its maximum value is 100 (indicating 100% of requests).
     *
     * Only one of Fraction or Percent may be specified. If neither field
     * is specified, 100% of requests will be mirrored.
     */
    percent?: Maybe<Scalars['Int']['output']>;
  };

/**
 * RequestMirror defines a schema for a filter that mirrors requests.
 * Requests are sent to the specified destination, but responses from
 * that destination are ignored.
 *
 * This filter can be used multiple times within the same rule. Note that
 * not all implementations will be able to support mirroring to multiple
 * backends.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Input =
  {
    backendRef: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_BackendRef_Input;
    fraction?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Fraction_Input>;
    /**
     * Percent represents the percentage of requests that should be
     * mirrored to BackendRef. Its minimum value is 0 (indicating 0% of
     * requests) and its maximum value is 100 (indicating 100% of requests).
     *
     * Only one of Fraction or Percent may be specified. If neither field
     * is specified, 100% of requests will be mirrored.
     */
    percent?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * BackendRef references a resource where mirrored requests are sent.
 *
 * Mirrored requests must be sent only to a single destination endpoint
 * within this BackendRef, irrespective of how many endpoints are present
 * within this BackendRef.
 *
 * If the referent cannot be found, this BackendRef is invalid and must be
 * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
 * condition on the Route status is set to `status: False` and not configure
 * this backend in the underlying implementation.
 *
 * If there is a cross-namespace reference to an *existing* object
 * that is not allowed by a ReferenceGrant, the controller must ensure the
 * "ResolvedRefs"  condition on the Route is set to `status: False`,
 * with the "RefNotPermitted" reason and not configure this backend in the
 * underlying implementation.
 *
 * In either error case, the Message of the `ResolvedRefs` Condition
 * should be used to provide more detail about the problem.
 *
 * Support: Extended for Kubernetes Service
 *
 * Support: Implementation-specific for any other resource
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_BackendRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
  };

/**
 * BackendRef references a resource where mirrored requests are sent.
 *
 * Mirrored requests must be sent only to a single destination endpoint
 * within this BackendRef, irrespective of how many endpoints are present
 * within this BackendRef.
 *
 * If the referent cannot be found, this BackendRef is invalid and must be
 * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
 * condition on the Route status is set to `status: False` and not configure
 * this backend in the underlying implementation.
 *
 * If there is a cross-namespace reference to an *existing* object
 * that is not allowed by a ReferenceGrant, the controller must ensure the
 * "ResolvedRefs"  condition on the Route is set to `status: False`,
 * with the "RefNotPermitted" reason and not configure this backend in the
 * underlying implementation.
 *
 * In either error case, the Message of the `ResolvedRefs` Condition
 * should be used to provide more detail about the problem.
 *
 * Support: Extended for Kubernetes Service
 *
 * Support: Implementation-specific for any other resource
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_BackendRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * Fraction represents the fraction of requests that should be
 * mirrored to BackendRef.
 *
 * Only one of Fraction or Percent may be specified. If neither field
 * is specified, 100% of requests will be mirrored.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Fraction =
  {
    denominator?: Maybe<Scalars['Int']['output']>;
    numerator: Scalars['Int']['output'];
  };

/**
 * Fraction represents the fraction of requests that should be
 * mirrored to BackendRef.
 *
 * Only one of Fraction or Percent may be specified. If neither field
 * is specified, 100% of requests will be mirrored.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Fraction_Input =
  {
    denominator?: InputMaybe<Scalars['Int']['input']>;
    numerator: Scalars['Int']['input'];
  };

/**
 * RequestRedirect defines a schema for a filter that responds to the
 * request with an HTTP redirection.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect =
  {
    hostname?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_hostname']['output']
    >;
    path?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path>;
    /**
     * Port is the port to be used in the value of the `Location`
     * header in the response.
     *
     * If no port is specified, the redirect port MUST be derived using the
     * following rules:
     *
     * * If redirect scheme is not-empty, the redirect port MUST be the well-known
     *   port associated with the redirect scheme. Specifically "http" to port 80
     *   and "https" to port 443. If the redirect scheme does not have a
     *   well-known port, the listener port of the Gateway SHOULD be used.
     * * If redirect scheme is empty, the redirect port MUST be the Gateway
     *   Listener port.
     *
     * Implementations SHOULD NOT add the port number in the 'Location'
     * header in the following cases:
     *
     * * A Location header that will use HTTP (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 80.
     * * A Location header that will use HTTPS (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 443.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    scheme?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Scheme>;
    statusCode?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_StatusCode>;
  };

/**
 * RequestRedirect defines a schema for a filter that responds to the
 * request with an HTTP redirection.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_hostname']['input']
    >;
    path?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Input>;
    /**
     * Port is the port to be used in the value of the `Location`
     * header in the response.
     *
     * If no port is specified, the redirect port MUST be derived using the
     * following rules:
     *
     * * If redirect scheme is not-empty, the redirect port MUST be the well-known
     *   port associated with the redirect scheme. Specifically "http" to port 80
     *   and "https" to port 443. If the redirect scheme does not have a
     *   well-known port, the listener port of the Gateway SHOULD be used.
     * * If redirect scheme is empty, the redirect port MUST be the Gateway
     *   Listener port.
     *
     * Implementations SHOULD NOT add the port number in the 'Location'
     * header in the following cases:
     *
     * * A Location header that will use HTTP (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 80.
     * * A Location header that will use HTTPS (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 443.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    scheme?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Scheme>;
    statusCode?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_StatusCode>;
  };

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replaceFullPath']['output']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replacePrefixMatch']['output']
    >;
    type: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Type;
  };

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Input =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replaceFullPath']['input']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replacePrefixMatch']['input']
    >;
    type: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Type;
  };

/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Type =
  'ReplaceFullPath' | 'ReplacePrefixMatch';

/**
 * Scheme is the scheme to be used in the value of the `Location` header in
 * the response. When empty, the scheme of the request is used.
 *
 * Scheme redirects can affect the port of the redirect, for more information,
 * refer to the documentation for the port field of this filter.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Scheme =
  'http' | 'https';

/**
 * StatusCode is the HTTP status code to be used in response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_StatusCode =
  '_301' | '_302';

/**
 * ResponseHeaderModifier defines a schema for a filter that modifies response
 * headers.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Add_Items>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Set_Items>
      >
    >;
  };

/**
 * ResponseHeaderModifier defines a schema for a filter that modifies response
 * headers.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Input =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Add_Items_Input>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Set_Items_Input>
      >
    >;
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Add_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Add_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_value']['input'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Set_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Set_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_value']['input'];
  };

/**
 * Type identifies the type of filter to apply. As with other API fields,
 * types are classified into three conformance levels:
 *
 * - Core: Filter types and their corresponding configuration defined by
 *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
 *   implementations must support core filters.
 *
 * - Extended: Filter types and their corresponding configuration defined by
 *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
 *   are encouraged to support extended filters.
 *
 * - Implementation-specific: Filters that are defined and supported by
 *   specific vendors.
 *   In the future, filters showing convergence in behavior across multiple
 *   implementations will be considered for inclusion in extended or core
 *   conformance levels. Filter-specific configuration for such filters
 *   is specified using the ExtensionRef field. `Type` should be set to
 *   "ExtensionRef" for custom filters.
 *
 * Implementers are encouraged to define custom implementation types to
 * extend the core API with implementation-specific behavior.
 *
 * If a reference to a custom filter type cannot be resolved, the filter
 * MUST NOT be skipped. Instead, requests that would have been processed by
 * that filter MUST receive a HTTP error response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Type =

    | 'ExtensionRef'
    | 'RequestHeaderModifier'
    | 'RequestMirror'
    | 'RequestRedirect'
    | 'ResponseHeaderModifier'
    | 'URLRewrite';

/**
 * URLRewrite defines a schema for a filter that modifies a request during forwarding.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite =
  {
    hostname?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_hostname']['output']
    >;
    path?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path>;
  };

/**
 * URLRewrite defines a schema for a filter that modifies a request during forwarding.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_hostname']['input']
    >;
    path?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Input>;
  };

/**
 * Path defines a path rewrite.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replaceFullPath']['output']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replacePrefixMatch']['output']
    >;
    type: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Type;
  };

/**
 * Path defines a path rewrite.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Input =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replaceFullPath']['input']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replacePrefixMatch']['input']
    >;
    type: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Type;
  };

/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Type =
  'ReplaceFullPath' | 'ReplacePrefixMatch';

/**
 * HTTPRouteMatch defines the predicate used to match requests to a given
 * action. Multiple match types are ANDed together, i.e. the match will
 * evaluate to true only if all conditions are satisfied.
 *
 * For example, the match below will match a HTTP request only if its path
 * starts with `/foo` AND it contains the `version: v1` header:
 *
 * ```
 * match:
 *
 * 	path:
 * 	  value: "/foo"
 * 	headers:
 * 	- name: "version"
 * 	  value "v1"
 *
 * ```
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items =
  {
    /**
     * Headers specifies HTTP request header matchers. Multiple match values are
     * ANDed together, meaning, a request must match all the specified headers
     * to select the route.
     */
    headers?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items>
      >
    >;
    method?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Method>;
    path?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path>;
    /**
     * QueryParams specifies HTTP query parameter matchers. Multiple match
     * values are ANDed together, meaning, a request must match all the
     * specified query parameters to select the route.
     *
     * Support: Extended
     */
    queryParams?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items>
      >
    >;
  };

/**
 * HTTPRouteMatch defines the predicate used to match requests to a given
 * action. Multiple match types are ANDed together, i.e. the match will
 * evaluate to true only if all conditions are satisfied.
 *
 * For example, the match below will match a HTTP request only if its path
 * starts with `/foo` AND it contains the `version: v1` header:
 *
 * ```
 * match:
 *
 * 	path:
 * 	  value: "/foo"
 * 	headers:
 * 	- name: "version"
 * 	  value "v1"
 *
 * ```
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Input =
  {
    /**
     * Headers specifies HTTP request header matchers. Multiple match values are
     * ANDed together, meaning, a request must match all the specified headers
     * to select the route.
     */
    headers?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Input>
      >
    >;
    method?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Method>;
    path?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Input>;
    /**
     * QueryParams specifies HTTP query parameter matchers. Multiple match
     * values are ANDed together, meaning, a request must match all the
     * specified query parameters to select the route.
     *
     * Support: Extended
     */
    queryParams?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Input>
      >
    >;
  };

/**
 * HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
 * headers.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_name']['output'];
    type?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Type>;
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_value']['output'];
  };

/**
 * HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
 * headers.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_name']['input'];
    type?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Type>;
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_value']['input'];
  };

/**
 * Type specifies how to match against the value of the header.
 *
 * Support: Core (Exact)
 *
 * Support: Implementation-specific (RegularExpression)
 *
 * Since RegularExpression HeaderMatchType has implementation-specific
 * conformance, implementations can support POSIX, PCRE or any other dialects
 * of regular expressions. Please read the implementation's documentation to
 * determine the supported dialect.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Type =
  'Exact' | 'RegularExpression';

/**
 * Method specifies HTTP method matcher.
 * When specified, this route will be matched only if the request has the
 * specified method.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Method =
  'CONNECT' | 'DELETE' | 'GET' | 'HEAD' | 'OPTIONS' | 'PATCH' | 'POST' | 'PUT' | 'TRACE';

/**
 * Path specifies a HTTP request path matcher. If this field is not
 * specified, a default prefix match on the "/" path is provided.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path =
  {
    type?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Type>;
    /** Value of the HTTP path to match against. */
    value?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_path_value']['output']
    >;
  };

/**
 * Path specifies a HTTP request path matcher. If this field is not
 * specified, a default prefix match on the "/" path is provided.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Input =
  {
    type?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Type>;
    /** Value of the HTTP path to match against. */
    value?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_path_value']['input']
    >;
  };

/**
 * Type specifies how to match against the path Value.
 *
 * Support: Core (Exact, PathPrefix)
 *
 * Support: Implementation-specific (RegularExpression)
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Type =
  'Exact' | 'PathPrefix' | 'RegularExpression';

/**
 * HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
 * query parameters.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_name']['output'];
    type?: Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Type>;
    /** Value is the value of HTTP query param to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_value']['output'];
  };

/**
 * HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
 * query parameters.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_name']['input'];
    type?: InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Type>;
    /** Value is the value of HTTP query param to be matched. */
    value: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_value']['input'];
  };

/**
 * Type specifies how to match against the value of the query parameter.
 *
 * Support: Extended (Exact)
 *
 * Support: Implementation-specific (RegularExpression)
 *
 * Since RegularExpression QueryParamMatchType has Implementation-specific
 * conformance, implementations can support POSIX, PCRE or any other
 * dialects of regular expressions. Please read the implementation's
 * documentation to determine the supported dialect.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Type =
  'Exact' | 'RegularExpression';

/**
 * Timeouts defines the timeouts that can be configured for an HTTP request.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Timeouts =
  {
    backendRequest?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_timeouts_backendRequest']['output']
    >;
    request?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_timeouts_request']['output']
    >;
  };

/**
 * Timeouts defines the timeouts that can be configured for an HTTP request.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Timeouts_Input =
  {
    backendRequest?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_timeouts_backendRequest']['input']
    >;
    request?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_spec_rules_items_timeouts_request']['input']
    >;
  };

/** Status defines the current state of HTTPRoute. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status = {
  /**
   * Parents is a list of parent resources (usually Gateways) that are
   * associated with the route, and the status of the route with respect to
   * each parent. When this route attaches to a parent, the controller that
   * manages the parent must add an entry to this list when the controller
   * first sees the route and should update the entry as appropriate when the
   * route or gateway is modified.
   *
   * Note that parent references that cannot be resolved by an implementation
   * of this API will not be added to this list. Implementations of this API
   * can only populate Route status for the Gateways/parent resources they are
   * responsible for.
   *
   * A maximum of 32 Gateways will be represented in this list. An empty list
   * means the route has not been attached to any Gateway.
   */
  parents: Array<
    Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items>
  >;
};

/** Status defines the current state of HTTPRoute. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Input = {
  /**
   * Parents is a list of parent resources (usually Gateways) that are
   * associated with the route, and the status of the route with respect to
   * each parent. When this route attaches to a parent, the controller that
   * manages the parent must add an entry to this list when the controller
   * first sees the route and should update the entry as appropriate when the
   * route or gateway is modified.
   *
   * Note that parent references that cannot be resolved by an implementation
   * of this API will not be added to this list. Implementations of this API
   * can only populate Route status for the Gateways/parent resources they are
   * responsible for.
   *
   * A maximum of 32 Gateways will be represented in this list. An empty list
   * means the route has not been attached to any Gateway.
   */
  parents: Array<
    InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Input>
  >;
};

/**
 * RouteParentStatus describes the status of a route with respect to an
 * associated Parent.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items =
  {
    /**
     * Conditions describes the status of the route with respect to the Gateway.
     * Note that the route's availability is also subject to the Gateway's own
     * status conditions and listener status.
     *
     * If the Route's ParentRef specifies an existing Gateway that supports
     * Routes of this kind AND that Gateway's controller has sufficient access,
     * then that Gateway's controller MUST set the "Accepted" condition on the
     * Route, to indicate whether the route has been accepted or rejected by the
     * Gateway, and why.
     *
     * A Route MUST be considered "Accepted" if at least one of the Route's
     * rules is implemented by the Gateway.
     *
     * There are a number of cases where the "Accepted" condition may not be set
     * due to lack of controller visibility, that includes when:
     *
     * * The Route refers to a nonexistent parent.
     * * The Route is of a type that the controller does not support.
     * * The Route is in a namespace the controller does not have access to.
     */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Conditions_Items>
      >
    >;
    controllerName: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_controllerName']['output'];
    parentRef: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_ParentRef;
  };

/**
 * RouteParentStatus describes the status of a route with respect to an
 * associated Parent.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Input =
  {
    /**
     * Conditions describes the status of the route with respect to the Gateway.
     * Note that the route's availability is also subject to the Gateway's own
     * status conditions and listener status.
     *
     * If the Route's ParentRef specifies an existing Gateway that supports
     * Routes of this kind AND that Gateway's controller has sufficient access,
     * then that Gateway's controller MUST set the "Accepted" condition on the
     * Route, to indicate whether the route has been accepted or rejected by the
     * Gateway, and why.
     *
     * A Route MUST be considered "Accepted" if at least one of the Route's
     * rules is implemented by the Gateway.
     *
     * There are a number of cases where the "Accepted" condition may not be set
     * due to lack of controller visibility, that includes when:
     *
     * * The Route refers to a nonexistent parent.
     * * The Route is of a type that the controller does not support.
     * * The Route is in a namespace the controller does not have access to.
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Conditions_Items_Input>
      >
    >;
    controllerName: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_controllerName']['input'];
    parentRef: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_ParentRef_Input;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_reason']['output'];
    status: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_reason']['input'];
    status: Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * ParentRef corresponds with a ParentRef in the spec that this
 * RouteParentStatus struct describes the status of.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_ParentRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_kind']['output']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_namespace']['output']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    sectionName?: Maybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_sectionName']['output']
    >;
  };

/**
 * ParentRef corresponds with a ParentRef in the spec that this
 * RouteParentStatus struct describes the status of.
 */
export type Query_ListGatewayNetworkingV1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_ParentRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_kind']['input']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_namespace']['input']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    sectionName?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_sectionName']['input']
    >;
  };

/** Spec defines the desired state of BackendTLSPolicy. */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec = {
  /**
   * Options are a list of key/value pairs to enable extended TLS
   * configuration for each implementation. For example, configuring the
   * minimum TLS version or supported cipher suites.
   *
   * A set of common keys MAY be defined by the API in the future. To avoid
   * any ambiguity, implementation-specific definitions MUST use
   * domain-prefixed names, such as `example.com/my-custom-option`.
   * Un-prefixed names are reserved for key names defined by Gateway API.
   *
   * Support: Implementation-specific
   */
  options?: Maybe<Scalars['JSON']['output']>;
  /**
   * TargetRefs identifies an API object to apply the policy to.
   * Only Services have Extended support. Implementations MAY support
   * additional objects, with Implementation Specific support.
   * Note that this config applies to the entire referenced resource
   * by default, but this default may change in the future to provide
   * a more granular application of the policy.
   *
   * TargetRefs must be _distinct_. This means either that:
   *
   * * They select different targets. If this is the case, then targetRef
   *   entries are distinct. In terms of fields, this means that the
   *   multi-part key defined by `group`, `kind`, and `name` must
   *   be unique across all targetRef entries in the BackendTLSPolicy.
   * * They select different sectionNames in the same target.
   *
   * When more than one BackendTLSPolicy selects the same target and
   * sectionName, implementations MUST determine precedence using the
   * following criteria, continuing on ties:
   *
   * * The older policy by creation timestamp takes precedence. For
   *   example, a policy with a creation timestamp of "2021-07-15
   *   01:02:03" MUST be given precedence over a policy with a
   *   creation timestamp of "2021-07-15 01:02:04".
   * * The policy appearing first in alphabetical order by {name}.
   *   For example, a policy named `bar` is given precedence over a
   *   policy named `baz`.
   *
   * For any BackendTLSPolicy that does not take precedence, the
   * implementation MUST ensure the `Accepted` Condition is set to
   * `status: False`, with Reason `Conflicted`.
   *
   * Support: Extended for Kubernetes Service
   *
   * Support: Implementation-specific for any other resource
   */
  targetRefs: Array<
    Maybe<Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_TargetRefs_Items>
  >;
  validation: Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation;
};

/** Spec defines the desired state of BackendTLSPolicy. */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Input =
  {
    /**
     * Options are a list of key/value pairs to enable extended TLS
     * configuration for each implementation. For example, configuring the
     * minimum TLS version or supported cipher suites.
     *
     * A set of common keys MAY be defined by the API in the future. To avoid
     * any ambiguity, implementation-specific definitions MUST use
     * domain-prefixed names, such as `example.com/my-custom-option`.
     * Un-prefixed names are reserved for key names defined by Gateway API.
     *
     * Support: Implementation-specific
     */
    options?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * TargetRefs identifies an API object to apply the policy to.
     * Only Services have Extended support. Implementations MAY support
     * additional objects, with Implementation Specific support.
     * Note that this config applies to the entire referenced resource
     * by default, but this default may change in the future to provide
     * a more granular application of the policy.
     *
     * TargetRefs must be _distinct_. This means either that:
     *
     * * They select different targets. If this is the case, then targetRef
     *   entries are distinct. In terms of fields, this means that the
     *   multi-part key defined by `group`, `kind`, and `name` must
     *   be unique across all targetRef entries in the BackendTLSPolicy.
     * * They select different sectionNames in the same target.
     *
     * When more than one BackendTLSPolicy selects the same target and
     * sectionName, implementations MUST determine precedence using the
     * following criteria, continuing on ties:
     *
     * * The older policy by creation timestamp takes precedence. For
     *   example, a policy with a creation timestamp of "2021-07-15
     *   01:02:03" MUST be given precedence over a policy with a
     *   creation timestamp of "2021-07-15 01:02:04".
     * * The policy appearing first in alphabetical order by {name}.
     *   For example, a policy named `bar` is given precedence over a
     *   policy named `baz`.
     *
     * For any BackendTLSPolicy that does not take precedence, the
     * implementation MUST ensure the `Accepted` Condition is set to
     * `status: False`, with Reason `Conflicted`.
     *
     * Support: Extended for Kubernetes Service
     *
     * Support: Implementation-specific for any other resource
     */
    targetRefs: Array<
      InputMaybe<Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_TargetRefs_Items_Input>
    >;
    validation: Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_Input;
  };

/**
 * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
 * direct policy to. This should be used as part of Policy resources that can
 * target single resources. For more information on how this policy attachment
 * mode works, and a sample Policy resource, refer to the policy attachment
 * documentation for Gateway API.
 *
 * Note: This should only be used for direct policy attachment when references
 * to SectionName are actually needed. In all other cases,
 * LocalPolicyTargetReference should be used.
 */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_TargetRefs_Items =
  {
    group: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_group']['output'];
    kind: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_kind']['output'];
    /** Name is the name of the target resource. */
    name: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_name']['output'];
    sectionName?: Maybe<
      Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_sectionName']['output']
    >;
  };

/**
 * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
 * direct policy to. This should be used as part of Policy resources that can
 * target single resources. For more information on how this policy attachment
 * mode works, and a sample Policy resource, refer to the policy attachment
 * documentation for Gateway API.
 *
 * Note: This should only be used for direct policy attachment when references
 * to SectionName are actually needed. In all other cases,
 * LocalPolicyTargetReference should be used.
 */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_TargetRefs_Items_Input =
  {
    group: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_group']['input'];
    kind: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_kind']['input'];
    /** Name is the name of the target resource. */
    name: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_name']['input'];
    sectionName?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_targetRefs_items_sectionName']['input']
    >;
  };

/** Validation contains backend TLS validation configuration. */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation =
  {
    /**
     * CACertificateRefs contains one or more references to Kubernetes objects that
     * contain a PEM-encoded TLS CA certificate bundle, which is used to
     * validate a TLS handshake between the Gateway and backend Pod.
     *
     * If CACertificateRefs is empty or unspecified, then WellKnownCACertificates must be
     * specified. Only one of CACertificateRefs or WellKnownCACertificates may be specified,
     * not both. If CACertificateRefs is empty or unspecified, the configuration for
     * WellKnownCACertificates MUST be honored instead if supported by the implementation.
     *
     * A CACertificateRef is invalid if:
     *
     * * It refers to a resource that cannot be resolved (e.g., the referenced resource
     *   does not exist) or is misconfigured (e.g., a ConfigMap does not contain a key
     *   named `ca.crt`). In this case, the Reason must be set to `InvalidCACertificateRef`
     *   and the Message of the Condition must indicate which reference is invalid and why.
     *
     * * It refers to an unknown or unsupported kind of resource. In this case, the Reason
     *   must be set to `InvalidKind` and the Message of the Condition must explain which
     *   kind of resource is unknown or unsupported.
     *
     * * It refers to a resource in another namespace. This may change in future
     *   spec updates.
     *
     * Implementations MAY choose to perform further validation of the certificate
     * content (e.g., checking expiry or enforcing specific formats). In such cases,
     * an implementation-specific Reason and Message must be set for the invalid reference.
     *
     * In all cases, the implementation MUST ensure the `ResolvedRefs` Condition on
     * the BackendTLSPolicy is set to `status: False`, with a Reason and Message
     * that indicate the cause of the error. Connections using an invalid
     * CACertificateRef MUST fail, and the client MUST receive an HTTP 5xx error
     * response. If ALL CACertificateRefs are invalid, the implementation MUST also
     * ensure the `Accepted` Condition on the BackendTLSPolicy is set to
     * `status: False`, with a Reason `NoValidCACertificate`.
     *
     * A single CACertificateRef to a Kubernetes ConfigMap kind has "Core" support.
     * Implementations MAY choose to support attaching multiple certificates to
     * a backend, but this behavior is implementation-specific.
     *
     * Support: Core - An optional single reference to a Kubernetes ConfigMap,
     * with the CA certificate in a key named `ca.crt`.
     *
     * Support: Implementation-specific - More than one reference, other kinds
     * of resources, or a single reference that includes multiple certificates.
     */
    caCertificateRefs?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_CaCertificateRefs_Items>
      >
    >;
    hostname: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_hostname']['output'];
    /**
     * SubjectAltNames contains one or more Subject Alternative Names.
     * When specified the certificate served from the backend MUST
     * have at least one Subject Alternate Name matching one of the specified SubjectAltNames.
     *
     * Support: Extended
     */
    subjectAltNames?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_SubjectAltNames_Items>
      >
    >;
    wellKnownCACertificates?: Maybe<System_Const>;
  };

/** Validation contains backend TLS validation configuration. */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_Input =
  {
    /**
     * CACertificateRefs contains one or more references to Kubernetes objects that
     * contain a PEM-encoded TLS CA certificate bundle, which is used to
     * validate a TLS handshake between the Gateway and backend Pod.
     *
     * If CACertificateRefs is empty or unspecified, then WellKnownCACertificates must be
     * specified. Only one of CACertificateRefs or WellKnownCACertificates may be specified,
     * not both. If CACertificateRefs is empty or unspecified, the configuration for
     * WellKnownCACertificates MUST be honored instead if supported by the implementation.
     *
     * A CACertificateRef is invalid if:
     *
     * * It refers to a resource that cannot be resolved (e.g., the referenced resource
     *   does not exist) or is misconfigured (e.g., a ConfigMap does not contain a key
     *   named `ca.crt`). In this case, the Reason must be set to `InvalidCACertificateRef`
     *   and the Message of the Condition must indicate which reference is invalid and why.
     *
     * * It refers to an unknown or unsupported kind of resource. In this case, the Reason
     *   must be set to `InvalidKind` and the Message of the Condition must explain which
     *   kind of resource is unknown or unsupported.
     *
     * * It refers to a resource in another namespace. This may change in future
     *   spec updates.
     *
     * Implementations MAY choose to perform further validation of the certificate
     * content (e.g., checking expiry or enforcing specific formats). In such cases,
     * an implementation-specific Reason and Message must be set for the invalid reference.
     *
     * In all cases, the implementation MUST ensure the `ResolvedRefs` Condition on
     * the BackendTLSPolicy is set to `status: False`, with a Reason and Message
     * that indicate the cause of the error. Connections using an invalid
     * CACertificateRef MUST fail, and the client MUST receive an HTTP 5xx error
     * response. If ALL CACertificateRefs are invalid, the implementation MUST also
     * ensure the `Accepted` Condition on the BackendTLSPolicy is set to
     * `status: False`, with a Reason `NoValidCACertificate`.
     *
     * A single CACertificateRef to a Kubernetes ConfigMap kind has "Core" support.
     * Implementations MAY choose to support attaching multiple certificates to
     * a backend, but this behavior is implementation-specific.
     *
     * Support: Core - An optional single reference to a Kubernetes ConfigMap,
     * with the CA certificate in a key named `ca.crt`.
     *
     * Support: Implementation-specific - More than one reference, other kinds
     * of resources, or a single reference that includes multiple certificates.
     */
    caCertificateRefs?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_CaCertificateRefs_Items_Input>
      >
    >;
    hostname: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_hostname']['input'];
    /**
     * SubjectAltNames contains one or more Subject Alternative Names.
     * When specified the certificate served from the backend MUST
     * have at least one Subject Alternate Name matching one of the specified SubjectAltNames.
     *
     * Support: Extended
     */
    subjectAltNames?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_SubjectAltNames_Items_Input>
      >
    >;
    wellKnownCACertificates?: InputMaybe<System_Const>;
  };

/**
 * LocalObjectReference identifies an API object within the namespace of the
 * referrer.
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_CaCertificateRefs_Items =
  {
    group: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_group']['output'];
    kind: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_kind']['output'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_name']['output'];
  };

/**
 * LocalObjectReference identifies an API object within the namespace of the
 * referrer.
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_CaCertificateRefs_Items_Input =
  {
    group: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_group']['input'];
    kind: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_kind']['input'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_caCertificateRefs_items_name']['input'];
  };

/** SubjectAltName represents Subject Alternative Name. */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_SubjectAltNames_Items =
  {
    hostname?: Maybe<
      Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_subjectAltNames_items_hostname']['output']
    >;
    type: Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_SubjectAltNames_Items_Type;
    uri?: Maybe<
      Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_subjectAltNames_items_uri']['output']
    >;
  };

/** SubjectAltName represents Subject Alternative Name. */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_SubjectAltNames_Items_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_subjectAltNames_items_hostname']['input']
    >;
    type: Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_SubjectAltNames_Items_Type;
    uri?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_spec_validation_subjectAltNames_items_uri']['input']
    >;
  };

/**
 * Type determines the format of the Subject Alternative Name. Always required.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Spec_Validation_SubjectAltNames_Items_Type =
  'Hostname' | 'URI';

/** Status defines the current state of BackendTLSPolicy. */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status =
  {
    /**
     * Ancestors is a list of ancestor resources (usually Gateways) that are
     * associated with the policy, and the status of the policy with respect to
     * each ancestor. When this policy attaches to a parent, the controller that
     * manages the parent and the ancestors MUST add an entry to this list when
     * the controller first sees the policy and SHOULD update the entry as
     * appropriate when the relevant ancestor is modified.
     *
     * Note that choosing the relevant ancestor is left to the Policy designers;
     * an important part of Policy design is designing the right object level at
     * which to namespace this status.
     *
     * Note also that implementations MUST ONLY populate ancestor status for
     * the Ancestor resources they are responsible for. Implementations MUST
     * use the ControllerName field to uniquely identify the entries in this list
     * that they are responsible for.
     *
     * Note that to achieve this, the list of PolicyAncestorStatus structs
     * MUST be treated as a map with a composite key, made up of the AncestorRef
     * and ControllerName fields combined.
     *
     * A maximum of 16 ancestors will be represented in this list. An empty list
     * means the Policy is not relevant for any ancestors.
     *
     * If this slice is full, implementations MUST NOT add further entries.
     * Instead they MUST consider the policy unimplementable and signal that
     * on any related resources such as the ancestor that would be referenced
     * here. For example, if this list was full on BackendTLSPolicy, no
     * additional Gateways would be able to reference the Service targeted by
     * the BackendTLSPolicy.
     */
    ancestors: Array<
      Maybe<Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items>
    >;
  };

/** Status defines the current state of BackendTLSPolicy. */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * Ancestors is a list of ancestor resources (usually Gateways) that are
     * associated with the policy, and the status of the policy with respect to
     * each ancestor. When this policy attaches to a parent, the controller that
     * manages the parent and the ancestors MUST add an entry to this list when
     * the controller first sees the policy and SHOULD update the entry as
     * appropriate when the relevant ancestor is modified.
     *
     * Note that choosing the relevant ancestor is left to the Policy designers;
     * an important part of Policy design is designing the right object level at
     * which to namespace this status.
     *
     * Note also that implementations MUST ONLY populate ancestor status for
     * the Ancestor resources they are responsible for. Implementations MUST
     * use the ControllerName field to uniquely identify the entries in this list
     * that they are responsible for.
     *
     * Note that to achieve this, the list of PolicyAncestorStatus structs
     * MUST be treated as a map with a composite key, made up of the AncestorRef
     * and ControllerName fields combined.
     *
     * A maximum of 16 ancestors will be represented in this list. An empty list
     * means the Policy is not relevant for any ancestors.
     *
     * If this slice is full, implementations MUST NOT add further entries.
     * Instead they MUST consider the policy unimplementable and signal that
     * on any related resources such as the ancestor that would be referenced
     * here. For example, if this list was full on BackendTLSPolicy, no
     * additional Gateways would be able to reference the Service targeted by
     * the BackendTLSPolicy.
     */
    ancestors: Array<
      InputMaybe<Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Input>
    >;
  };

/**
 * PolicyAncestorStatus describes the status of a route with respect to an
 * associated Ancestor.
 *
 * Ancestors refer to objects that are either the Target of a policy or above it
 * in terms of object hierarchy. For example, if a policy targets a Service, the
 * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
 * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
 * useful object to place Policy status on, so we recommend that implementations
 * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
 * have a _very_ good reason otherwise.
 *
 * In the context of policy attachment, the Ancestor is used to distinguish which
 * resource results in a distinct application of this policy. For example, if a policy
 * targets a Service, it may have a distinct result per attached Gateway.
 *
 * Policies targeting the same resource may have different effects depending on the
 * ancestors of those resources. For example, different Gateways targeting the same
 * Service may have different capabilities, especially if they have different underlying
 * implementations.
 *
 * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
 * used as a backend in a HTTPRoute that is itself attached to a Gateway.
 * In this case, the relevant object for status is the Gateway, and that is the
 * ancestor object referred to in this status.
 *
 * Note that a parent is also an ancestor, so for objects where the parent is the
 * relevant object for status, this struct SHOULD still be used.
 *
 * This struct is intended to be used in a slice that's effectively a map,
 * with a composite key made up of the AncestorRef and the ControllerName.
 */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items =
  {
    ancestorRef: Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_AncestorRef;
    /** Conditions describes the status of the Policy with respect to the given Ancestor. */
    conditions: Array<
      Maybe<Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items>
    >;
    controllerName: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_controllerName']['output'];
  };

/**
 * PolicyAncestorStatus describes the status of a route with respect to an
 * associated Ancestor.
 *
 * Ancestors refer to objects that are either the Target of a policy or above it
 * in terms of object hierarchy. For example, if a policy targets a Service, the
 * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
 * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
 * useful object to place Policy status on, so we recommend that implementations
 * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
 * have a _very_ good reason otherwise.
 *
 * In the context of policy attachment, the Ancestor is used to distinguish which
 * resource results in a distinct application of this policy. For example, if a policy
 * targets a Service, it may have a distinct result per attached Gateway.
 *
 * Policies targeting the same resource may have different effects depending on the
 * ancestors of those resources. For example, different Gateways targeting the same
 * Service may have different capabilities, especially if they have different underlying
 * implementations.
 *
 * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
 * used as a backend in a HTTPRoute that is itself attached to a Gateway.
 * In this case, the relevant object for status is the Gateway, and that is the
 * ancestor object referred to in this status.
 *
 * Note that a parent is also an ancestor, so for objects where the parent is the
 * relevant object for status, this struct SHOULD still be used.
 *
 * This struct is intended to be used in a slice that's effectively a map,
 * with a composite key made up of the AncestorRef and the ControllerName.
 */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Input =
  {
    ancestorRef: Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_AncestorRef_Input;
    /** Conditions describes the status of the Policy with respect to the given Ancestor. */
    conditions: Array<
      InputMaybe<Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Input>
    >;
    controllerName: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_controllerName']['input'];
  };

/**
 * AncestorRef corresponds with a ParentRef in the spec that this
 * PolicyAncestorStatus struct describes the status of.
 */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_AncestorRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_kind']['output']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_namespace']['output']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     *
     * When the parent resource is a Service, this targets a specific port in the
     * Service spec. When both Port (experimental) and SectionName are specified,
     * the name and port of the selected port must match both specified values.
     *
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    sectionName?: Maybe<
      Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_sectionName']['output']
    >;
  };

/**
 * AncestorRef corresponds with a ParentRef in the spec that this
 * PolicyAncestorStatus struct describes the status of.
 */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_AncestorRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_kind']['input']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_namespace']['input']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     *
     * When the parent resource is a Service, this targets a specific port in the
     * Service spec. When both Port (experimental) and SectionName are specified,
     * the name and port of the selected port must match both specified values.
     *
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    sectionName?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_ancestorRef_sectionName']['input']
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_reason']['output'];
    status: Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_reason']['input'];
    status: Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1alpha3BackendTLSPolicyForAllNamespaces_items_items_status_ancestors_items_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListGatewayNetworkingV1alpha3BackendTlsPolicyForAllNamespaces_Items_Items_Status_Ancestors_Items_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** Spec defines the desired state of GatewayClass. */
export type Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Spec = {
  controllerName: Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_controllerName']['output'];
  /** Description helps describe a GatewayClass with more details. */
  description?: Maybe<
    Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_description']['output']
  >;
  parametersRef?: Maybe<Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Spec_ParametersRef>;
};

/** Spec defines the desired state of GatewayClass. */
export type Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Spec_Input = {
  controllerName: Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_controllerName']['input'];
  /** Description helps describe a GatewayClass with more details. */
  description?: InputMaybe<
    Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_description']['input']
  >;
  parametersRef?: InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Spec_ParametersRef_Input>;
};

/**
 * ParametersRef is a reference to a resource that contains the configuration
 * parameters corresponding to the GatewayClass. This is optional if the
 * controller does not require any additional configuration.
 *
 * ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
 * or an implementation-specific custom resource. The resource can be
 * cluster-scoped or namespace-scoped.
 *
 * If the referent cannot be found, refers to an unsupported kind, or when
 * the data within that resource is malformed, the GatewayClass SHOULD be
 * rejected with the "Accepted" status condition set to "False" and an
 * "InvalidParameters" reason.
 *
 * A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
 * the merging behavior is implementation specific.
 * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Spec_ParametersRef = {
  group: Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_parametersRef_group']['output'];
  kind: Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_parametersRef_kind']['output'];
  /** Name is the name of the referent. */
  name: Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_parametersRef_name']['output'];
  namespace?: Maybe<
    Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_parametersRef_namespace']['output']
  >;
};

/**
 * ParametersRef is a reference to a resource that contains the configuration
 * parameters corresponding to the GatewayClass. This is optional if the
 * controller does not require any additional configuration.
 *
 * ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
 * or an implementation-specific custom resource. The resource can be
 * cluster-scoped or namespace-scoped.
 *
 * If the referent cannot be found, refers to an unsupported kind, or when
 * the data within that resource is malformed, the GatewayClass SHOULD be
 * rejected with the "Accepted" status condition set to "False" and an
 * "InvalidParameters" reason.
 *
 * A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
 * the merging behavior is implementation specific.
 * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Spec_ParametersRef_Input = {
  group: Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_parametersRef_group']['input'];
  kind: Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_parametersRef_kind']['input'];
  /** Name is the name of the referent. */
  name: Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_parametersRef_name']['input'];
  namespace?: InputMaybe<
    Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_spec_parametersRef_namespace']['input']
  >;
};

/**
 * Status defines the current state of GatewayClass.
 *
 * Implementations MUST populate status on all GatewayClass resources which
 * specify their controller name.
 */
export type Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Status = {
  /**
   * Conditions is the current status from the controller for
   * this GatewayClass.
   *
   * Controllers should prefer to publish conditions using values
   * of GatewayClassConditionType for the type of each Condition.
   */
  conditions?: Maybe<
    Array<Maybe<Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Status_Conditions_Items>>
  >;
};

/**
 * Status defines the current state of GatewayClass.
 *
 * Implementations MUST populate status on all GatewayClass resources which
 * specify their controller name.
 */
export type Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Status_Input = {
  /**
   * Conditions is the current status from the controller for
   * this GatewayClass.
   *
   * Controllers should prefer to publish conditions using values
   * of GatewayClassConditionType for the type of each Condition.
   */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Status_Conditions_Items_Input>
    >
  >;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Status_Conditions_Items = {
  /**
   * lastTransitionTime is the last time the condition transitioned from one status to another.
   * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
   */
  lastTransitionTime: Scalars['DateTime']['output'];
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  message: Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_status_conditions_items_message']['output'];
  /**
   * observedGeneration represents the .metadata.generation that the condition was set based upon.
   * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
   * with respect to the current state of the instance.
   */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
  reason: Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_status_conditions_items_reason']['output'];
  status: Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Status_Conditions_Items_Status;
  type: Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_status_conditions_items_type']['output'];
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_status_conditions_items_reason']['input'];
    status: Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1beta1GatewayClass_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListGatewayNetworkingV1beta1GatewayClass_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** Spec defines the desired state of Gateway. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec = {
  /**
   * Addresses requested for this Gateway. This is optional and behavior can
   * depend on the implementation. If a value is set in the spec and the
   * requested address is invalid or unavailable, the implementation MUST
   * indicate this in the associated entry in GatewayStatus.Addresses.
   *
   * The Addresses field represents a request for the address(es) on the
   * "outside of the Gateway", that traffic bound for this Gateway will use.
   * This could be the IP address or hostname of an external load balancer or
   * other networking infrastructure, or some other address that traffic will
   * be sent to.
   *
   * If no Addresses are specified, the implementation MAY schedule the
   * Gateway in an implementation-specific manner, assigning an appropriate
   * set of Addresses.
   *
   * The implementation MUST bind all Listeners to every GatewayAddress that
   * it assigns to the Gateway and add a corresponding entry in
   * GatewayStatus.Addresses.
   *
   * Support: Extended
   */
  addresses?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Addresses_Items>
    >
  >;
  /**
   * GatewayClassName used for this Gateway. This is the name of a
   * GatewayClass resource.
   */
  gatewayClassName: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_gatewayClassName']['output'];
  infrastructure?: Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure>;
  /**
   * Listeners associated with this Gateway. Listeners define
   * logical endpoints that are bound on this Gateway's addresses.
   * At least one Listener MUST be specified.
   *
   * ## Distinct Listeners
   *
   * Each Listener in a set of Listeners (for example, in a single Gateway)
   * MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
   * exactly one listener. (This section uses "set of Listeners" rather than
   * "Listeners in a single Gateway" because implementations MAY merge configuration
   * from multiple Gateways onto a single data plane, and these rules _also_
   * apply in that case).
   *
   * Practically, this means that each listener in a set MUST have a unique
   * combination of Port, Protocol, and, if supported by the protocol, Hostname.
   *
   * Some combinations of port, protocol, and TLS settings are considered
   * Core support and MUST be supported by implementations based on the objects
   * they support:
   *
   * HTTPRoute
   *
   * 1. HTTPRoute, Port: 80, Protocol: HTTP
   * 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
   *
   * TLSRoute
   *
   * 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
   *
   * "Distinct" Listeners have the following property:
   *
   * **The implementation can match inbound requests to a single distinct
   * Listener**.
   *
   * When multiple Listeners share values for fields (for
   * example, two Listeners with the same Port value), the implementation
   * can match requests to only one of the Listeners using other
   * Listener fields.
   *
   * When multiple listeners have the same value for the Protocol field, then
   * each of the Listeners with matching Protocol values MUST have different
   * values for other fields.
   *
   * The set of fields that MUST be different for a Listener differs per protocol.
   * The following rules define the rules for what fields MUST be considered for
   * Listeners to be distinct with each protocol currently defined in the
   * Gateway API spec.
   *
   * The set of listeners that all share a protocol value MUST have _different_
   * values for _at least one_ of these fields to be distinct:
   *
   * * **HTTP, HTTPS, TLS**: Port, Hostname
   * * **TCP, UDP**: Port
   *
   * One **very** important rule to call out involves what happens when an
   * implementation:
   *
   * * Supports TCP protocol Listeners, as well as HTTP, HTTPS, or TLS protocol
   *   Listeners, and
   * * sees HTTP, HTTPS, or TLS protocols with the same `port` as one with TCP
   *   Protocol.
   *
   * In this case all the Listeners that share a port with the
   * TCP Listener are not distinct and so MUST NOT be accepted.
   *
   * If an implementation does not support TCP Protocol Listeners, then the
   * previous rule does not apply, and the TCP Listeners SHOULD NOT be
   * accepted.
   *
   * Note that the `tls` field is not used for determining if a listener is distinct, because
   * Listeners that _only_ differ on TLS config will still conflict in all cases.
   *
   * ### Listeners that are distinct only by Hostname
   *
   * When the Listeners are distinct based only on Hostname, inbound request
   * hostnames MUST match from the most specific to least specific Hostname
   * values to choose the correct Listener and its associated set of Routes.
   *
   * Exact matches MUST be processed before wildcard matches, and wildcard
   * matches MUST be processed before fallback (empty Hostname value)
   * matches. For example, `"foo.example.com"` takes precedence over
   * `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
   *
   * Additionally, if there are multiple wildcard entries, more specific
   * wildcard entries must be processed before less specific wildcard entries.
   * For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
   *
   * The precise definition here is that the higher the number of dots in the
   * hostname to the right of the wildcard character, the higher the precedence.
   *
   * The wildcard character will match any number of characters _and dots_ to
   * the left, however, so `"*.example.com"` will match both
   * `"foo.bar.example.com"` _and_ `"bar.example.com"`.
   *
   * ## Handling indistinct Listeners
   *
   * If a set of Listeners contains Listeners that are not distinct, then those
   * Listeners are _Conflicted_, and the implementation MUST set the "Conflicted"
   * condition in the Listener Status to "True".
   *
   * The words "indistinct" and "conflicted" are considered equivalent for the
   * purpose of this documentation.
   *
   * Implementations MAY choose to accept a Gateway with some Conflicted
   * Listeners only if they only accept the partial Listener set that contains
   * no Conflicted Listeners.
   *
   * Specifically, an implementation MAY accept a partial Listener set subject to
   * the following rules:
   *
   * * The implementation MUST NOT pick one conflicting Listener as the winner.
   *   ALL indistinct Listeners must not be accepted for processing.
   * * At least one distinct Listener MUST be present, or else the Gateway effectively
   *   contains _no_ Listeners, and must be rejected from processing as a whole.
   *
   * The implementation MUST set a "ListenersNotValid" condition on the
   * Gateway Status when the Gateway contains Conflicted Listeners whether or
   * not they accept the Gateway. That Condition SHOULD clearly
   * indicate in the Message which Listeners are conflicted, and which are
   * Accepted. Additionally, the Listener status for those listeners SHOULD
   * indicate which Listeners are conflicted and not Accepted.
   *
   * ## General Listener behavior
   *
   * Note that, for all distinct Listeners, requests SHOULD match at most one Listener.
   * For example, if Listeners are defined for "foo.example.com" and "*.example.com", a
   * request to "foo.example.com" SHOULD only be routed using routes attached
   * to the "foo.example.com" Listener (and not the "*.example.com" Listener).
   *
   * This concept is known as "Listener Isolation", and it is an Extended feature
   * of Gateway API. Implementations that do not support Listener Isolation MUST
   * clearly document this, and MUST NOT claim support for the
   * `GatewayHTTPListenerIsolation` feature.
   *
   * Implementations that _do_ support Listener Isolation SHOULD claim support
   * for the Extended `GatewayHTTPListenerIsolation` feature and pass the associated
   * conformance tests.
   *
   * ## Compatible Listeners
   *
   * A Gateway's Listeners are considered _compatible_ if:
   *
   * 1. They are distinct.
   * 2. The implementation can serve them in compliance with the Addresses
   *    requirement that all Listeners are available on all assigned
   *    addresses.
   *
   * Compatible combinations in Extended support are expected to vary across
   * implementations. A combination that is compatible for one implementation
   * may not be compatible for another.
   *
   * For example, an implementation that cannot serve both TCP and UDP listeners
   * on the same address, or cannot mix HTTPS and generic TLS listens on the same port
   * would not consider those cases compatible, even though they are distinct.
   *
   * Implementations MAY merge separate Gateways onto a single set of
   * Addresses if all Listeners across all Gateways are compatible.
   *
   * In a future release the MinItems=1 requirement MAY be dropped.
   *
   * Support: Core
   */
  listeners: Array<
    Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items>
  >;
};

/** Spec defines the desired state of Gateway. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Input = {
  /**
   * Addresses requested for this Gateway. This is optional and behavior can
   * depend on the implementation. If a value is set in the spec and the
   * requested address is invalid or unavailable, the implementation MUST
   * indicate this in the associated entry in GatewayStatus.Addresses.
   *
   * The Addresses field represents a request for the address(es) on the
   * "outside of the Gateway", that traffic bound for this Gateway will use.
   * This could be the IP address or hostname of an external load balancer or
   * other networking infrastructure, or some other address that traffic will
   * be sent to.
   *
   * If no Addresses are specified, the implementation MAY schedule the
   * Gateway in an implementation-specific manner, assigning an appropriate
   * set of Addresses.
   *
   * The implementation MUST bind all Listeners to every GatewayAddress that
   * it assigns to the Gateway and add a corresponding entry in
   * GatewayStatus.Addresses.
   *
   * Support: Extended
   */
  addresses?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Addresses_Items_Input>
    >
  >;
  /**
   * GatewayClassName used for this Gateway. This is the name of a
   * GatewayClass resource.
   */
  gatewayClassName: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_gatewayClassName']['input'];
  infrastructure?: InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure_Input>;
  /**
   * Listeners associated with this Gateway. Listeners define
   * logical endpoints that are bound on this Gateway's addresses.
   * At least one Listener MUST be specified.
   *
   * ## Distinct Listeners
   *
   * Each Listener in a set of Listeners (for example, in a single Gateway)
   * MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
   * exactly one listener. (This section uses "set of Listeners" rather than
   * "Listeners in a single Gateway" because implementations MAY merge configuration
   * from multiple Gateways onto a single data plane, and these rules _also_
   * apply in that case).
   *
   * Practically, this means that each listener in a set MUST have a unique
   * combination of Port, Protocol, and, if supported by the protocol, Hostname.
   *
   * Some combinations of port, protocol, and TLS settings are considered
   * Core support and MUST be supported by implementations based on the objects
   * they support:
   *
   * HTTPRoute
   *
   * 1. HTTPRoute, Port: 80, Protocol: HTTP
   * 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
   *
   * TLSRoute
   *
   * 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
   *
   * "Distinct" Listeners have the following property:
   *
   * **The implementation can match inbound requests to a single distinct
   * Listener**.
   *
   * When multiple Listeners share values for fields (for
   * example, two Listeners with the same Port value), the implementation
   * can match requests to only one of the Listeners using other
   * Listener fields.
   *
   * When multiple listeners have the same value for the Protocol field, then
   * each of the Listeners with matching Protocol values MUST have different
   * values for other fields.
   *
   * The set of fields that MUST be different for a Listener differs per protocol.
   * The following rules define the rules for what fields MUST be considered for
   * Listeners to be distinct with each protocol currently defined in the
   * Gateway API spec.
   *
   * The set of listeners that all share a protocol value MUST have _different_
   * values for _at least one_ of these fields to be distinct:
   *
   * * **HTTP, HTTPS, TLS**: Port, Hostname
   * * **TCP, UDP**: Port
   *
   * One **very** important rule to call out involves what happens when an
   * implementation:
   *
   * * Supports TCP protocol Listeners, as well as HTTP, HTTPS, or TLS protocol
   *   Listeners, and
   * * sees HTTP, HTTPS, or TLS protocols with the same `port` as one with TCP
   *   Protocol.
   *
   * In this case all the Listeners that share a port with the
   * TCP Listener are not distinct and so MUST NOT be accepted.
   *
   * If an implementation does not support TCP Protocol Listeners, then the
   * previous rule does not apply, and the TCP Listeners SHOULD NOT be
   * accepted.
   *
   * Note that the `tls` field is not used for determining if a listener is distinct, because
   * Listeners that _only_ differ on TLS config will still conflict in all cases.
   *
   * ### Listeners that are distinct only by Hostname
   *
   * When the Listeners are distinct based only on Hostname, inbound request
   * hostnames MUST match from the most specific to least specific Hostname
   * values to choose the correct Listener and its associated set of Routes.
   *
   * Exact matches MUST be processed before wildcard matches, and wildcard
   * matches MUST be processed before fallback (empty Hostname value)
   * matches. For example, `"foo.example.com"` takes precedence over
   * `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
   *
   * Additionally, if there are multiple wildcard entries, more specific
   * wildcard entries must be processed before less specific wildcard entries.
   * For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
   *
   * The precise definition here is that the higher the number of dots in the
   * hostname to the right of the wildcard character, the higher the precedence.
   *
   * The wildcard character will match any number of characters _and dots_ to
   * the left, however, so `"*.example.com"` will match both
   * `"foo.bar.example.com"` _and_ `"bar.example.com"`.
   *
   * ## Handling indistinct Listeners
   *
   * If a set of Listeners contains Listeners that are not distinct, then those
   * Listeners are _Conflicted_, and the implementation MUST set the "Conflicted"
   * condition in the Listener Status to "True".
   *
   * The words "indistinct" and "conflicted" are considered equivalent for the
   * purpose of this documentation.
   *
   * Implementations MAY choose to accept a Gateway with some Conflicted
   * Listeners only if they only accept the partial Listener set that contains
   * no Conflicted Listeners.
   *
   * Specifically, an implementation MAY accept a partial Listener set subject to
   * the following rules:
   *
   * * The implementation MUST NOT pick one conflicting Listener as the winner.
   *   ALL indistinct Listeners must not be accepted for processing.
   * * At least one distinct Listener MUST be present, or else the Gateway effectively
   *   contains _no_ Listeners, and must be rejected from processing as a whole.
   *
   * The implementation MUST set a "ListenersNotValid" condition on the
   * Gateway Status when the Gateway contains Conflicted Listeners whether or
   * not they accept the Gateway. That Condition SHOULD clearly
   * indicate in the Message which Listeners are conflicted, and which are
   * Accepted. Additionally, the Listener status for those listeners SHOULD
   * indicate which Listeners are conflicted and not Accepted.
   *
   * ## General Listener behavior
   *
   * Note that, for all distinct Listeners, requests SHOULD match at most one Listener.
   * For example, if Listeners are defined for "foo.example.com" and "*.example.com", a
   * request to "foo.example.com" SHOULD only be routed using routes attached
   * to the "foo.example.com" Listener (and not the "*.example.com" Listener).
   *
   * This concept is known as "Listener Isolation", and it is an Extended feature
   * of Gateway API. Implementations that do not support Listener Isolation MUST
   * clearly document this, and MUST NOT claim support for the
   * `GatewayHTTPListenerIsolation` feature.
   *
   * Implementations that _do_ support Listener Isolation SHOULD claim support
   * for the Extended `GatewayHTTPListenerIsolation` feature and pass the associated
   * conformance tests.
   *
   * ## Compatible Listeners
   *
   * A Gateway's Listeners are considered _compatible_ if:
   *
   * 1. They are distinct.
   * 2. The implementation can serve them in compliance with the Addresses
   *    requirement that all Listeners are available on all assigned
   *    addresses.
   *
   * Compatible combinations in Extended support are expected to vary across
   * implementations. A combination that is compatible for one implementation
   * may not be compatible for another.
   *
   * For example, an implementation that cannot serve both TCP and UDP listeners
   * on the same address, or cannot mix HTTPS and generic TLS listens on the same port
   * would not consider those cases compatible, even though they are distinct.
   *
   * Implementations MAY merge separate Gateways onto a single set of
   * Addresses if all Listeners across all Gateways are compatible.
   *
   * In a future release the MinItems=1 requirement MAY be dropped.
   *
   * Support: Core
   */
  listeners: Array<
    InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Input>
  >;
};

/** GatewaySpecAddress describes an address that can be bound to a Gateway. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Addresses_Items =
  {
    type?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_addresses_items_type']['output']
    >;
    /**
     * When a value is unspecified, an implementation SHOULD automatically
     * assign an address matching the requested type if possible.
     *
     * If an implementation does not support an empty value, they MUST set the
     * "Programmed" condition in status to False with a reason of "AddressNotAssigned".
     *
     * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
     */
    value?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_addresses_items_value']['output']
    >;
  };

/** GatewaySpecAddress describes an address that can be bound to a Gateway. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Addresses_Items_Input =
  {
    type?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_addresses_items_type']['input']
    >;
    /**
     * When a value is unspecified, an implementation SHOULD automatically
     * assign an address matching the requested type if possible.
     *
     * If an implementation does not support an empty value, they MUST set the
     * "Programmed" condition in status to False with a reason of "AddressNotAssigned".
     *
     * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
     */
    value?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_addresses_items_value']['input']
    >;
  };

/**
 * Infrastructure defines infrastructure level attributes about this Gateway instance.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure =
  {
    /**
     * Annotations that SHOULD be applied to any resources created in response to this Gateway.
     *
     * For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
     * For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
     *
     * An implementation may chose to add additional implementation-specific annotations as they see fit.
     *
     * Support: Extended
     */
    annotations?: Maybe<Scalars['JSON']['output']>;
    /**
     * Labels that SHOULD be applied to any resources created in response to this Gateway.
     *
     * For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
     * For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
     *
     * An implementation may chose to add additional implementation-specific labels as they see fit.
     *
     * If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
     * change, it SHOULD clearly warn about this behavior in documentation.
     *
     * Support: Extended
     */
    labels?: Maybe<Scalars['JSON']['output']>;
    parametersRef?: Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure_ParametersRef>;
  };

/**
 * Infrastructure defines infrastructure level attributes about this Gateway instance.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure_Input =
  {
    /**
     * Annotations that SHOULD be applied to any resources created in response to this Gateway.
     *
     * For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
     * For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
     *
     * An implementation may chose to add additional implementation-specific annotations as they see fit.
     *
     * Support: Extended
     */
    annotations?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * Labels that SHOULD be applied to any resources created in response to this Gateway.
     *
     * For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
     * For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
     *
     * An implementation may chose to add additional implementation-specific labels as they see fit.
     *
     * If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
     * change, it SHOULD clearly warn about this behavior in documentation.
     *
     * Support: Extended
     */
    labels?: InputMaybe<Scalars['JSON']['input']>;
    parametersRef?: InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure_ParametersRef_Input>;
  };

/**
 * ParametersRef is a reference to a resource that contains the configuration
 * parameters corresponding to the Gateway. This is optional if the
 * controller does not require any additional configuration.
 *
 * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
 *
 * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
 * the merging behavior is implementation specific.
 * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
 *
 * If the referent cannot be found, refers to an unsupported kind, or when
 * the data within that resource is malformed, the Gateway SHOULD be
 * rejected with the "Accepted" status condition set to "False" and an
 * "InvalidParameters" reason.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure_ParametersRef =
  {
    group: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_group']['output'];
    kind: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_kind']['output'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_name']['output'];
  };

/**
 * ParametersRef is a reference to a resource that contains the configuration
 * parameters corresponding to the Gateway. This is optional if the
 * controller does not require any additional configuration.
 *
 * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
 *
 * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
 * the merging behavior is implementation specific.
 * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
 *
 * If the referent cannot be found, refers to an unsupported kind, or when
 * the data within that resource is malformed, the Gateway SHOULD be
 * rejected with the "Accepted" status condition set to "False" and an
 * "InvalidParameters" reason.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Infrastructure_ParametersRef_Input =
  {
    group: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_group']['input'];
    kind: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_kind']['input'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_infrastructure_parametersRef_name']['input'];
  };

/**
 * Listener embodies the concept of a logical endpoint where a Gateway accepts
 * network connections.
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items =
  {
    allowedRoutes?: Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes>;
    hostname?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_hostname']['output']
    >;
    name: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_name']['output'];
    /**
     * Port is the network port. Multiple listeners may use the
     * same port, subject to the Listener compatibility rules.
     *
     * Support: Core
     */
    port: Scalars['Int']['output'];
    protocol: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_protocol']['output'];
    tls?: Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls>;
  };

/**
 * Listener embodies the concept of a logical endpoint where a Gateway accepts
 * network connections.
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Input =
  {
    allowedRoutes?: InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Input>;
    hostname?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_hostname']['input']
    >;
    name: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_name']['input'];
    /**
     * Port is the network port. Multiple listeners may use the
     * same port, subject to the Listener compatibility rules.
     *
     * Support: Core
     */
    port: Scalars['Int']['input'];
    protocol: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_protocol']['input'];
    tls?: InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_Input>;
  };

/**
 * AllowedRoutes defines the types of routes that MAY be attached to a
 * Listener and the trusted namespaces where those Route resources MAY be
 * present.
 *
 * Although a client request may match multiple route rules, only one rule
 * may ultimately receive the request. Matching precedence MUST be
 * determined in order of the following criteria:
 *
 * * The most specific match as defined by the Route type.
 * * The oldest Route based on creation timestamp. For example, a Route with
 *   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
 *   a Route with a creation timestamp of "2020-09-08 01:02:04".
 * * If everything else is equivalent, the Route appearing first in
 *   alphabetical order (namespace/name) should be given precedence. For
 *   example, foo/bar is given precedence over foo/baz.
 *
 * All valid rules within a Route attached to this Listener should be
 * implemented. Invalid Route rules can be ignored (sometimes that will mean
 * the full Route). If a Route rule transitions from valid to invalid,
 * support for that Route rule should be dropped to ensure consistency. For
 * example, even if a filter specified by a Route rule is invalid, the rest
 * of the rules within that Route should still be supported.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes =
  {
    /**
     * Kinds specifies the groups and kinds of Routes that are allowed to bind
     * to this Gateway Listener. When unspecified or empty, the kinds of Routes
     * selected are determined using the Listener protocol.
     *
     * A RouteGroupKind MUST correspond to kinds of Routes that are compatible
     * with the application protocol specified in the Listener's Protocol field.
     * If an implementation does not support or recognize this resource type, it
     * MUST set the "ResolvedRefs" condition to False for this Listener with the
     * "InvalidRouteKinds" reason.
     *
     * Support: Core
     */
    kinds?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Kinds_Items>
      >
    >;
    namespaces?: Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces>;
  };

/**
 * AllowedRoutes defines the types of routes that MAY be attached to a
 * Listener and the trusted namespaces where those Route resources MAY be
 * present.
 *
 * Although a client request may match multiple route rules, only one rule
 * may ultimately receive the request. Matching precedence MUST be
 * determined in order of the following criteria:
 *
 * * The most specific match as defined by the Route type.
 * * The oldest Route based on creation timestamp. For example, a Route with
 *   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
 *   a Route with a creation timestamp of "2020-09-08 01:02:04".
 * * If everything else is equivalent, the Route appearing first in
 *   alphabetical order (namespace/name) should be given precedence. For
 *   example, foo/bar is given precedence over foo/baz.
 *
 * All valid rules within a Route attached to this Listener should be
 * implemented. Invalid Route rules can be ignored (sometimes that will mean
 * the full Route). If a Route rule transitions from valid to invalid,
 * support for that Route rule should be dropped to ensure consistency. For
 * example, even if a filter specified by a Route rule is invalid, the rest
 * of the rules within that Route should still be supported.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Input =
  {
    /**
     * Kinds specifies the groups and kinds of Routes that are allowed to bind
     * to this Gateway Listener. When unspecified or empty, the kinds of Routes
     * selected are determined using the Listener protocol.
     *
     * A RouteGroupKind MUST correspond to kinds of Routes that are compatible
     * with the application protocol specified in the Listener's Protocol field.
     * If an implementation does not support or recognize this resource type, it
     * MUST set the "ResolvedRefs" condition to False for this Listener with the
     * "InvalidRouteKinds" reason.
     *
     * Support: Core
     */
    kinds?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Kinds_Items_Input>
      >
    >;
    namespaces?: InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Input>;
  };

/** RouteGroupKind indicates the group and kind of a Route resource. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Kinds_Items =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_allowedRoutes_kinds_items_group']['output']
    >;
    kind: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_allowedRoutes_kinds_items_kind']['output'];
  };

/** RouteGroupKind indicates the group and kind of a Route resource. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Kinds_Items_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_allowedRoutes_kinds_items_group']['input']
    >;
    kind: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_allowedRoutes_kinds_items_kind']['input'];
  };

/**
 * Namespaces indicates namespaces from which Routes may be attached to this
 * Listener. This is restricted to the namespace of this Gateway by default.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces =
  {
    from?: Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_From>;
    selector?: Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector>;
  };

/**
 * Namespaces indicates namespaces from which Routes may be attached to this
 * Listener. This is restricted to the namespace of this Gateway by default.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Input =
  {
    from?: InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_From>;
    selector?: InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector_Input>;
  };

/**
 * From indicates where Routes will be selected for this Gateway. Possible
 * values are:
 *
 * * All: Routes in all namespaces may be used by this Gateway.
 * * Selector: Routes in namespaces selected by the selector may be used by
 *   this Gateway.
 * * Same: Only Routes in the same namespace may be used by this Gateway.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_From =
  'All' | 'Same' | 'Selector';

/**
 * Selector must be specified when From is set to "Selector". In that case,
 * only Routes in Namespaces matching this Selector will be selected by this
 * Gateway. This field is ignored for other values of "From".
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector =
  {
    /** matchExpressions is a list of label selector requirements. The requirements are ANDed. */
    matchExpressions?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector_MatchExpressions_Items>
      >
    >;
    /**
     * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
     * map is equivalent to an element of matchExpressions, whose key field is "key", the
     * operator is "In", and the values array contains only "value". The requirements are ANDed.
     */
    matchLabels?: Maybe<Scalars['JSON']['output']>;
  };

/**
 * Selector must be specified when From is set to "Selector". In that case,
 * only Routes in Namespaces matching this Selector will be selected by this
 * Gateway. This field is ignored for other values of "From".
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector_Input =
  {
    /** matchExpressions is a list of label selector requirements. The requirements are ANDed. */
    matchExpressions?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector_MatchExpressions_Items_Input>
      >
    >;
    /**
     * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
     * map is equivalent to an element of matchExpressions, whose key field is "key", the
     * operator is "In", and the values array contains only "value". The requirements are ANDed.
     */
    matchLabels?: InputMaybe<Scalars['JSON']['input']>;
  };

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector_MatchExpressions_Items =
  {
    /** key is the label key that the selector applies to. */
    key: Scalars['String']['output'];
    /**
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and DoesNotExist.
     */
    operator: Scalars['String']['output'];
    /**
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     */
    values?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  };

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_AllowedRoutes_Namespaces_Selector_MatchExpressions_Items_Input =
  {
    /** key is the label key that the selector applies to. */
    key: Scalars['String']['input'];
    /**
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and DoesNotExist.
     */
    operator: Scalars['String']['input'];
    /**
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     */
    values?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  };

/**
 * TLS is the TLS configuration for the Listener. This field is required if
 * the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
 * if the Protocol field is "HTTP", "TCP", or "UDP".
 *
 * The association of SNIs to Certificate defined in GatewayTLSConfig is
 * defined based on the Hostname field for this listener.
 *
 * The GatewayClass MUST use the longest matching SNI out of all
 * available certificates for any TLS handshake.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls =
  {
    /**
     * CertificateRefs contains a series of references to Kubernetes objects that
     * contains TLS certificates and private keys. These certificates are used to
     * establish a TLS handshake for requests that match the hostname of the
     * associated listener.
     *
     * A single CertificateRef to a Kubernetes Secret has "Core" support.
     * Implementations MAY choose to support attaching multiple certificates to
     * a Listener, but this behavior is implementation-specific.
     *
     * References to a resource in different namespace are invalid UNLESS there
     * is a ReferenceGrant in the target namespace that allows the certificate
     * to be attached. If a ReferenceGrant does not allow this reference, the
     * "ResolvedRefs" condition MUST be set to False for this listener with the
     * "RefNotPermitted" reason.
     *
     * This field is required to have at least one element when the mode is set
     * to "Terminate" (default) and is optional otherwise.
     *
     * CertificateRefs can reference to standard Kubernetes resources, i.e.
     * Secret, or implementation-specific custom resources.
     *
     * Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
     *
     * Support: Implementation-specific (More than one reference or other resource types)
     */
    certificateRefs?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_CertificateRefs_Items>
      >
    >;
    mode?: Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_Mode>;
    /**
     * Options are a list of key/value pairs to enable extended TLS
     * configuration for each implementation. For example, configuring the
     * minimum TLS version or supported cipher suites.
     *
     * A set of common keys MAY be defined by the API in the future. To avoid
     * any ambiguity, implementation-specific definitions MUST use
     * domain-prefixed names, such as `example.com/my-custom-option`.
     * Un-prefixed names are reserved for key names defined by Gateway API.
     *
     * Support: Implementation-specific
     */
    options?: Maybe<Scalars['JSON']['output']>;
  };

/**
 * TLS is the TLS configuration for the Listener. This field is required if
 * the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
 * if the Protocol field is "HTTP", "TCP", or "UDP".
 *
 * The association of SNIs to Certificate defined in GatewayTLSConfig is
 * defined based on the Hostname field for this listener.
 *
 * The GatewayClass MUST use the longest matching SNI out of all
 * available certificates for any TLS handshake.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_Input =
  {
    /**
     * CertificateRefs contains a series of references to Kubernetes objects that
     * contains TLS certificates and private keys. These certificates are used to
     * establish a TLS handshake for requests that match the hostname of the
     * associated listener.
     *
     * A single CertificateRef to a Kubernetes Secret has "Core" support.
     * Implementations MAY choose to support attaching multiple certificates to
     * a Listener, but this behavior is implementation-specific.
     *
     * References to a resource in different namespace are invalid UNLESS there
     * is a ReferenceGrant in the target namespace that allows the certificate
     * to be attached. If a ReferenceGrant does not allow this reference, the
     * "ResolvedRefs" condition MUST be set to False for this listener with the
     * "RefNotPermitted" reason.
     *
     * This field is required to have at least one element when the mode is set
     * to "Terminate" (default) and is optional otherwise.
     *
     * CertificateRefs can reference to standard Kubernetes resources, i.e.
     * Secret, or implementation-specific custom resources.
     *
     * Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
     *
     * Support: Implementation-specific (More than one reference or other resource types)
     */
    certificateRefs?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_CertificateRefs_Items_Input>
      >
    >;
    mode?: InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_Mode>;
    /**
     * Options are a list of key/value pairs to enable extended TLS
     * configuration for each implementation. For example, configuring the
     * minimum TLS version or supported cipher suites.
     *
     * A set of common keys MAY be defined by the API in the future. To avoid
     * any ambiguity, implementation-specific definitions MUST use
     * domain-prefixed names, such as `example.com/my-custom-option`.
     * Un-prefixed names are reserved for key names defined by Gateway API.
     *
     * Support: Implementation-specific
     */
    options?: InputMaybe<Scalars['JSON']['input']>;
  };

/**
 * SecretObjectReference identifies an API object including its namespace,
 * defaulting to Secret.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_CertificateRefs_Items =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_namespace']['output']
    >;
  };

/**
 * SecretObjectReference identifies an API object including its namespace,
 * defaulting to Secret.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_CertificateRefs_Items_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_spec_listeners_items_tls_certificateRefs_items_namespace']['input']
    >;
  };

/**
 * Mode defines the TLS behavior for the TLS session initiated by the client.
 * There are two possible modes:
 *
 * - Terminate: The TLS session between the downstream client and the
 *   Gateway is terminated at the Gateway. This mode requires certificates
 *   to be specified in some way, such as populating the certificateRefs
 *   field.
 * - Passthrough: The TLS session is NOT terminated by the Gateway. This
 *   implies that the Gateway can't decipher the TLS stream except for
 *   the ClientHello message of the TLS protocol. The certificateRefs field
 *   is ignored in this mode.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Spec_Listeners_Items_Tls_Mode =
  'Passthrough' | 'Terminate';

/** Status defines the current state of Gateway. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status = {
  /**
   * Addresses lists the network addresses that have been bound to the
   * Gateway.
   *
   * This list may differ from the addresses provided in the spec under some
   * conditions:
   *
   *   * no addresses are specified, all addresses are dynamically assigned
   *   * a combination of specified and dynamic addresses are assigned
   *   * a specified address was unusable (e.g. already in use)
   */
  addresses?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Addresses_Items>
    >
  >;
  /**
   * Conditions describe the current conditions of the Gateway.
   *
   * Implementations should prefer to express Gateway conditions
   * using the `GatewayConditionType` and `GatewayConditionReason`
   * constants so that operators and tools can converge on a common
   * vocabulary to describe Gateway state.
   *
   * Known condition types are:
   *
   * * "Accepted"
   * * "Programmed"
   * * "Ready"
   */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
  /** Listeners provide status for each unique listener port defined in the Spec. */
  listeners?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items>
    >
  >;
};

/** Status defines the current state of Gateway. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Input = {
  /**
   * Addresses lists the network addresses that have been bound to the
   * Gateway.
   *
   * This list may differ from the addresses provided in the spec under some
   * conditions:
   *
   *   * no addresses are specified, all addresses are dynamically assigned
   *   * a combination of specified and dynamic addresses are assigned
   *   * a specified address was unusable (e.g. already in use)
   */
  addresses?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Addresses_Items_Input>
    >
  >;
  /**
   * Conditions describe the current conditions of the Gateway.
   *
   * Implementations should prefer to express Gateway conditions
   * using the `GatewayConditionType` and `GatewayConditionReason`
   * constants so that operators and tools can converge on a common
   * vocabulary to describe Gateway state.
   *
   * Known condition types are:
   *
   * * "Accepted"
   * * "Programmed"
   * * "Ready"
   */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /** Listeners provide status for each unique listener port defined in the Spec. */
  listeners?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Input>
    >
  >;
};

/** GatewayStatusAddress describes a network address that is bound to a Gateway. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Addresses_Items =
  {
    type?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_addresses_items_type']['output']
    >;
    /**
     * Value of the address. The validity of the values will depend
     * on the type and support by the controller.
     *
     * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
     */
    value: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_addresses_items_value']['output'];
  };

/** GatewayStatusAddress describes a network address that is bound to a Gateway. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Addresses_Items_Input =
  {
    type?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_addresses_items_type']['input']
    >;
    /**
     * Value of the address. The validity of the values will depend
     * on the type and support by the controller.
     *
     * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
     */
    value: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_addresses_items_value']['input'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** ListenerStatus is the status associated with a Listener. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items =
  {
    /**
     * AttachedRoutes represents the total number of Routes that have been
     * successfully attached to this Listener.
     *
     * Successful attachment of a Route to a Listener is based solely on the
     * combination of the AllowedRoutes field on the corresponding Listener
     * and the Route's ParentRefs field. A Route is successfully attached to
     * a Listener when it is selected by the Listener's AllowedRoutes field
     * AND the Route has a valid ParentRef selecting the whole Gateway
     * resource or a specific Listener as a parent resource (more detail on
     * attachment semantics can be found in the documentation on the various
     * Route kinds ParentRefs fields). Listener or Route status does not impact
     * successful attachment, i.e. the AttachedRoutes field count MUST be set
     * for Listeners with condition Accepted: false and MUST count successfully
     * attached Routes that may themselves have Accepted: false conditions.
     *
     * Uses for this field include troubleshooting Route attachment and
     * measuring blast radius/impact of changes to a Listener.
     */
    attachedRoutes: Scalars['Int']['output'];
    /** Conditions describe the current condition of this listener. */
    conditions: Array<
      Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Conditions_Items>
    >;
    name: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_name']['output'];
    /**
     * SupportedKinds is the list indicating the Kinds supported by this
     * listener. This MUST represent the kinds an implementation supports for
     * that Listener configuration.
     *
     * If kinds are specified in Spec that are not supported, they MUST NOT
     * appear in this list and an implementation MUST set the "ResolvedRefs"
     * condition to "False" with the "InvalidRouteKinds" reason. If both valid
     * and invalid Route kinds are specified, the implementation MUST
     * reference the valid Route kinds that have been specified.
     */
    supportedKinds: Array<
      Maybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_SupportedKinds_Items>
    >;
  };

/** ListenerStatus is the status associated with a Listener. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Input =
  {
    /**
     * AttachedRoutes represents the total number of Routes that have been
     * successfully attached to this Listener.
     *
     * Successful attachment of a Route to a Listener is based solely on the
     * combination of the AllowedRoutes field on the corresponding Listener
     * and the Route's ParentRefs field. A Route is successfully attached to
     * a Listener when it is selected by the Listener's AllowedRoutes field
     * AND the Route has a valid ParentRef selecting the whole Gateway
     * resource or a specific Listener as a parent resource (more detail on
     * attachment semantics can be found in the documentation on the various
     * Route kinds ParentRefs fields). Listener or Route status does not impact
     * successful attachment, i.e. the AttachedRoutes field count MUST be set
     * for Listeners with condition Accepted: false and MUST count successfully
     * attached Routes that may themselves have Accepted: false conditions.
     *
     * Uses for this field include troubleshooting Route attachment and
     * measuring blast radius/impact of changes to a Listener.
     */
    attachedRoutes: Scalars['Int']['input'];
    /** Conditions describe the current condition of this listener. */
    conditions: Array<
      InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Conditions_Items_Input>
    >;
    name: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_name']['input'];
    /**
     * SupportedKinds is the list indicating the Kinds supported by this
     * listener. This MUST represent the kinds an implementation supports for
     * that Listener configuration.
     *
     * If kinds are specified in Spec that are not supported, they MUST NOT
     * appear in this list and an implementation MUST set the "ResolvedRefs"
     * condition to "False" with the "InvalidRouteKinds" reason. If both valid
     * and invalid Route kinds are specified, the implementation MUST
     * reference the valid Route kinds that have been specified.
     */
    supportedKinds: Array<
      InputMaybe<Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_SupportedKinds_Items_Input>
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_reason']['output'];
    status: Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_reason']['input'];
    status: Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** RouteGroupKind indicates the group and kind of a Route resource. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_SupportedKinds_Items =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_supportedKinds_items_group']['output']
    >;
    kind: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_supportedKinds_items_kind']['output'];
  };

/** RouteGroupKind indicates the group and kind of a Route resource. */
export type Query_ListGatewayNetworkingV1beta1GatewayForAllNamespaces_Items_Items_Status_Listeners_Items_SupportedKinds_Items_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_supportedKinds_items_group']['input']
    >;
    kind: Scalars['query_listGatewayNetworkingV1beta1GatewayForAllNamespaces_items_items_status_listeners_items_supportedKinds_items_kind']['input'];
  };

/** Spec defines the desired state of HTTPRoute. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec = {
  /**
   * Hostnames defines a set of hostnames that should match against the HTTP Host
   * header to select a HTTPRoute used to process the request. Implementations
   * MUST ignore any port value specified in the HTTP Host header while
   * performing a match and (absent of any applicable header modification
   * configuration) MUST forward this header unmodified to the backend.
   *
   * Valid values for Hostnames are determined by RFC 1123 definition of a
   * hostname with 2 notable exceptions:
   *
   * 1. IPs are not allowed.
   * 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
   *    label must appear by itself as the first label.
   *
   * If a hostname is specified by both the Listener and HTTPRoute, there
   * must be at least one intersecting hostname for the HTTPRoute to be
   * attached to the Listener. For example:
   *
   * * A Listener with `test.example.com` as the hostname matches HTTPRoutes
   *   that have either not specified any hostnames, or have specified at
   *   least one of `test.example.com` or `*.example.com`.
   * * A Listener with `*.example.com` as the hostname matches HTTPRoutes
   *   that have either not specified any hostnames or have specified at least
   *   one hostname that matches the Listener hostname. For example,
   *   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
   *   all match. On the other hand, `example.com` and `test.example.net` would
   *   not match.
   *
   * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
   * as a suffix match. That means that a match for `*.example.com` would match
   * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
   *
   * If both the Listener and HTTPRoute have specified hostnames, any
   * HTTPRoute hostnames that do not match the Listener hostname MUST be
   * ignored. For example, if a Listener specified `*.example.com`, and the
   * HTTPRoute specified `test.example.com` and `test.example.net`,
   * `test.example.net` must not be considered for a match.
   *
   * If both the Listener and HTTPRoute have specified hostnames, and none
   * match with the criteria above, then the HTTPRoute is not accepted. The
   * implementation must raise an 'Accepted' Condition with a status of
   * `False` in the corresponding RouteParentStatus.
   *
   * In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
   * overlapping wildcard matching and exact matching hostnames), precedence must
   * be given to rules from the HTTPRoute with the largest number of:
   *
   * * Characters in a matching non-wildcard hostname.
   * * Characters in a matching hostname.
   *
   * If ties exist across multiple Routes, the matching precedence rules for
   * HTTPRouteMatches takes over.
   *
   * Support: Core
   */
  hostnames?: Maybe<
    Array<
      Maybe<
        Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_hostnames_items']['output']
      >
    >
  >;
  /**
   * ParentRefs references the resources (usually Gateways) that a Route wants
   * to be attached to. Note that the referenced parent resource needs to
   * allow this for the attachment to be complete. For Gateways, that means
   * the Gateway needs to allow attachment from Routes of this kind and
   * namespace. For Services, that means the Service must either be in the same
   * namespace for a "producer" route, or the mesh implementation must support
   * and allow "consumer" routes for the referenced Service. ReferenceGrant is
   * not applicable for governing ParentRefs to Services - it is not possible to
   * create a "producer" route for a Service in a different namespace from the
   * Route.
   *
   * There are two kinds of parent resources with "Core" support:
   *
   * * Gateway (Gateway conformance profile)
   * * Service (Mesh conformance profile, ClusterIP Services only)
   *
   * This API may be extended in the future to support additional kinds of parent
   * resources.
   *
   * ParentRefs must be _distinct_. This means either that:
   *
   * * They select different objects.  If this is the case, then parentRef
   *   entries are distinct. In terms of fields, this means that the
   *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
   *   be unique across all parentRef entries in the Route.
   * * They do not select different objects, but for each optional field used,
   *   each ParentRef that selects the same object must set the same set of
   *   optional fields to different values. If one ParentRef sets a
   *   combination of optional fields, all must set the same combination.
   *
   * Some examples:
   *
   * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
   *   same object must also set `sectionName`.
   * * If one ParentRef sets `port`, all ParentRefs referencing the same
   *   object must also set `port`.
   * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
   *   referencing the same object must also set `sectionName` and `port`.
   *
   * It is possible to separately reference multiple distinct objects that may
   * be collapsed by an implementation. For example, some implementations may
   * choose to merge compatible Gateway Listeners together. If that is the
   * case, the list of routes attached to those resources should also be
   * merged.
   *
   * Note that for ParentRefs that cross namespace boundaries, there are specific
   * rules. Cross-namespace references are only valid if they are explicitly
   * allowed by something in the namespace they are referring to. For example,
   * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
   * generic way to enable other kinds of cross-namespace reference.
   */
  parentRefs?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_ParentRefs_Items>
    >
  >;
  /** Rules are a list of HTTP matchers, filters and actions. */
  rules?: Maybe<
    Array<
      Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items>
    >
  >;
};

/** Spec defines the desired state of HTTPRoute. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Input = {
  /**
   * Hostnames defines a set of hostnames that should match against the HTTP Host
   * header to select a HTTPRoute used to process the request. Implementations
   * MUST ignore any port value specified in the HTTP Host header while
   * performing a match and (absent of any applicable header modification
   * configuration) MUST forward this header unmodified to the backend.
   *
   * Valid values for Hostnames are determined by RFC 1123 definition of a
   * hostname with 2 notable exceptions:
   *
   * 1. IPs are not allowed.
   * 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
   *    label must appear by itself as the first label.
   *
   * If a hostname is specified by both the Listener and HTTPRoute, there
   * must be at least one intersecting hostname for the HTTPRoute to be
   * attached to the Listener. For example:
   *
   * * A Listener with `test.example.com` as the hostname matches HTTPRoutes
   *   that have either not specified any hostnames, or have specified at
   *   least one of `test.example.com` or `*.example.com`.
   * * A Listener with `*.example.com` as the hostname matches HTTPRoutes
   *   that have either not specified any hostnames or have specified at least
   *   one hostname that matches the Listener hostname. For example,
   *   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
   *   all match. On the other hand, `example.com` and `test.example.net` would
   *   not match.
   *
   * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
   * as a suffix match. That means that a match for `*.example.com` would match
   * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
   *
   * If both the Listener and HTTPRoute have specified hostnames, any
   * HTTPRoute hostnames that do not match the Listener hostname MUST be
   * ignored. For example, if a Listener specified `*.example.com`, and the
   * HTTPRoute specified `test.example.com` and `test.example.net`,
   * `test.example.net` must not be considered for a match.
   *
   * If both the Listener and HTTPRoute have specified hostnames, and none
   * match with the criteria above, then the HTTPRoute is not accepted. The
   * implementation must raise an 'Accepted' Condition with a status of
   * `False` in the corresponding RouteParentStatus.
   *
   * In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
   * overlapping wildcard matching and exact matching hostnames), precedence must
   * be given to rules from the HTTPRoute with the largest number of:
   *
   * * Characters in a matching non-wildcard hostname.
   * * Characters in a matching hostname.
   *
   * If ties exist across multiple Routes, the matching precedence rules for
   * HTTPRouteMatches takes over.
   *
   * Support: Core
   */
  hostnames?: InputMaybe<
    Array<
      InputMaybe<
        Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_hostnames_items']['input']
      >
    >
  >;
  /**
   * ParentRefs references the resources (usually Gateways) that a Route wants
   * to be attached to. Note that the referenced parent resource needs to
   * allow this for the attachment to be complete. For Gateways, that means
   * the Gateway needs to allow attachment from Routes of this kind and
   * namespace. For Services, that means the Service must either be in the same
   * namespace for a "producer" route, or the mesh implementation must support
   * and allow "consumer" routes for the referenced Service. ReferenceGrant is
   * not applicable for governing ParentRefs to Services - it is not possible to
   * create a "producer" route for a Service in a different namespace from the
   * Route.
   *
   * There are two kinds of parent resources with "Core" support:
   *
   * * Gateway (Gateway conformance profile)
   * * Service (Mesh conformance profile, ClusterIP Services only)
   *
   * This API may be extended in the future to support additional kinds of parent
   * resources.
   *
   * ParentRefs must be _distinct_. This means either that:
   *
   * * They select different objects.  If this is the case, then parentRef
   *   entries are distinct. In terms of fields, this means that the
   *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
   *   be unique across all parentRef entries in the Route.
   * * They do not select different objects, but for each optional field used,
   *   each ParentRef that selects the same object must set the same set of
   *   optional fields to different values. If one ParentRef sets a
   *   combination of optional fields, all must set the same combination.
   *
   * Some examples:
   *
   * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
   *   same object must also set `sectionName`.
   * * If one ParentRef sets `port`, all ParentRefs referencing the same
   *   object must also set `port`.
   * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
   *   referencing the same object must also set `sectionName` and `port`.
   *
   * It is possible to separately reference multiple distinct objects that may
   * be collapsed by an implementation. For example, some implementations may
   * choose to merge compatible Gateway Listeners together. If that is the
   * case, the list of routes attached to those resources should also be
   * merged.
   *
   * Note that for ParentRefs that cross namespace boundaries, there are specific
   * rules. Cross-namespace references are only valid if they are explicitly
   * allowed by something in the namespace they are referring to. For example,
   * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
   * generic way to enable other kinds of cross-namespace reference.
   */
  parentRefs?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_ParentRefs_Items_Input>
    >
  >;
  /** Rules are a list of HTTP matchers, filters and actions. */
  rules?: InputMaybe<
    Array<
      InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Input>
    >
  >;
};

/**
 * ParentReference identifies an API object (usually a Gateway) that can be considered
 * a parent of this resource (usually a route). There are two kinds of parent resources
 * with "Core" support:
 *
 * * Gateway (Gateway conformance profile)
 * * Service (Mesh conformance profile, ClusterIP Services only)
 *
 * This API may be extended in the future to support additional kinds of parent
 * resources.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_ParentRefs_Items =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_kind']['output']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_namespace']['output']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    sectionName?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_sectionName']['output']
    >;
  };

/**
 * ParentReference identifies an API object (usually a Gateway) that can be considered
 * a parent of this resource (usually a route). There are two kinds of parent resources
 * with "Core" support:
 *
 * * Gateway (Gateway conformance profile)
 * * Service (Mesh conformance profile, ClusterIP Services only)
 *
 * This API may be extended in the future to support additional kinds of parent
 * resources.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_ParentRefs_Items_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_kind']['input']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_namespace']['input']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    sectionName?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_parentRefs_items_sectionName']['input']
    >;
  };

/**
 * HTTPRouteRule defines semantics for matching an HTTP request based on
 * conditions (matches), processing it (filters), and forwarding the request to
 * an API object (backendRefs).
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items =
  {
    /**
     * BackendRefs defines the backend(s) where matching requests should be
     * sent.
     *
     * Failure behavior here depends on how many BackendRefs are specified and
     * how many are invalid.
     *
     * If *all* entries in BackendRefs are invalid, and there are also no filters
     * specified in this route rule, *all* traffic which matches this rule MUST
     * receive a 500 status code.
     *
     * See the HTTPBackendRef definition for the rules about what makes a single
     * HTTPBackendRef invalid.
     *
     * When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
     * requests that would have otherwise been routed to an invalid backend. If
     * multiple backends are specified, and some are invalid, the proportion of
     * requests that would otherwise have been routed to an invalid backend
     * MUST receive a 500 status code.
     *
     * For example, if two backends are specified with equal weights, and one is
     * invalid, 50 percent of traffic must receive a 500. Implementations may
     * choose how that 50 percent is determined.
     *
     * When a HTTPBackendRef refers to a Service that has no ready endpoints,
     * implementations SHOULD return a 503 for requests to that backend instead.
     * If an implementation chooses to do this, all of the above rules for 500 responses
     * MUST also apply for responses that return a 503.
     *
     * Support: Core for Kubernetes Service
     *
     * Support: Extended for Kubernetes ServiceImport
     *
     * Support: Implementation-specific for any other resource
     *
     * Support for weight: Core
     */
    backendRefs?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items>
      >
    >;
    /**
     * Filters define the filters that are applied to requests that match
     * this rule.
     *
     * Wherever possible, implementations SHOULD implement filters in the order
     * they are specified.
     *
     * Implementations MAY choose to implement this ordering strictly, rejecting
     * any combination or order of filters that cannot be supported. If implementations
     * choose a strict interpretation of filter ordering, they MUST clearly document
     * that behavior.
     *
     * To reject an invalid combination or order of filters, implementations SHOULD
     * consider the Route Rules with this configuration invalid. If all Route Rules
     * in a Route are invalid, the entire Route would be considered invalid. If only
     * a portion of Route Rules are invalid, implementations MUST set the
     * "PartiallyInvalid" condition for the Route.
     *
     * Conformance-levels at this level are defined based on the type of filter:
     *
     * - ALL core filters MUST be supported by all implementations.
     * - Implementers are encouraged to support extended filters.
     * - Implementation-specific custom filters have no API guarantees across
     *   implementations.
     *
     * Specifying the same filter multiple times is not supported unless explicitly
     * indicated in the filter.
     *
     * All filters are expected to be compatible with each other except for the
     * URLRewrite and RequestRedirect filters, which may not be combined. If an
     * implementation cannot support other combinations of filters, they must clearly
     * document that limitation. In cases where incompatible or unsupported
     * filters are specified and cause the `Accepted` condition to be set to status
     * `False`, implementations may use the `IncompatibleFilters` reason to specify
     * this configuration error.
     *
     * Support: Core
     */
    filters?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items>
      >
    >;
    /**
     * Matches define conditions used for matching the rule against incoming
     * HTTP requests. Each match is independent, i.e. this rule will be matched
     * if **any** one of the matches is satisfied.
     *
     * For example, take the following matches configuration:
     *
     * ```
     * matches:
     * - path:
     *     value: "/foo"
     *   headers:
     *   - name: "version"
     *     value: "v2"
     * - path:
     *     value: "/v2/foo"
     * ```
     *
     * For a request to match against this rule, a request must satisfy
     * EITHER of the two conditions:
     *
     * - path prefixed with `/foo` AND contains the header `version: v2`
     * - path prefix of `/v2/foo`
     *
     * See the documentation for HTTPRouteMatch on how to specify multiple
     * match conditions that should be ANDed together.
     *
     * If no matches are specified, the default is a prefix
     * path match on "/", which has the effect of matching every
     * HTTP request.
     *
     * Proxy or Load Balancer routing configuration generated from HTTPRoutes
     * MUST prioritize matches based on the following criteria, continuing on
     * ties. Across all rules specified on applicable Routes, precedence must be
     * given to the match having:
     *
     * * "Exact" path match.
     * * "Prefix" path match with largest number of characters.
     * * Method match.
     * * Largest number of header matches.
     * * Largest number of query param matches.
     *
     * Note: The precedence of RegularExpression path matches are implementation-specific.
     *
     * If ties still exist across multiple Routes, matching precedence MUST be
     * determined in order of the following criteria, continuing on ties:
     *
     * * The oldest Route based on creation timestamp.
     * * The Route appearing first in alphabetical order by
     *   "{namespace}/{name}".
     *
     * If ties still exist within an HTTPRoute, matching precedence MUST be granted
     * to the FIRST matching rule (in list order) with a match meeting the above
     * criteria.
     *
     * When no rules matching a request have been successfully attached to the
     * parent a request is coming from, a HTTP 404 status code MUST be returned.
     */
    matches?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items>
      >
    >;
    timeouts?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Timeouts>;
  };

/**
 * HTTPRouteRule defines semantics for matching an HTTP request based on
 * conditions (matches), processing it (filters), and forwarding the request to
 * an API object (backendRefs).
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Input =
  {
    /**
     * BackendRefs defines the backend(s) where matching requests should be
     * sent.
     *
     * Failure behavior here depends on how many BackendRefs are specified and
     * how many are invalid.
     *
     * If *all* entries in BackendRefs are invalid, and there are also no filters
     * specified in this route rule, *all* traffic which matches this rule MUST
     * receive a 500 status code.
     *
     * See the HTTPBackendRef definition for the rules about what makes a single
     * HTTPBackendRef invalid.
     *
     * When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
     * requests that would have otherwise been routed to an invalid backend. If
     * multiple backends are specified, and some are invalid, the proportion of
     * requests that would otherwise have been routed to an invalid backend
     * MUST receive a 500 status code.
     *
     * For example, if two backends are specified with equal weights, and one is
     * invalid, 50 percent of traffic must receive a 500. Implementations may
     * choose how that 50 percent is determined.
     *
     * When a HTTPBackendRef refers to a Service that has no ready endpoints,
     * implementations SHOULD return a 503 for requests to that backend instead.
     * If an implementation chooses to do this, all of the above rules for 500 responses
     * MUST also apply for responses that return a 503.
     *
     * Support: Core for Kubernetes Service
     *
     * Support: Extended for Kubernetes ServiceImport
     *
     * Support: Implementation-specific for any other resource
     *
     * Support for weight: Core
     */
    backendRefs?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Input>
      >
    >;
    /**
     * Filters define the filters that are applied to requests that match
     * this rule.
     *
     * Wherever possible, implementations SHOULD implement filters in the order
     * they are specified.
     *
     * Implementations MAY choose to implement this ordering strictly, rejecting
     * any combination or order of filters that cannot be supported. If implementations
     * choose a strict interpretation of filter ordering, they MUST clearly document
     * that behavior.
     *
     * To reject an invalid combination or order of filters, implementations SHOULD
     * consider the Route Rules with this configuration invalid. If all Route Rules
     * in a Route are invalid, the entire Route would be considered invalid. If only
     * a portion of Route Rules are invalid, implementations MUST set the
     * "PartiallyInvalid" condition for the Route.
     *
     * Conformance-levels at this level are defined based on the type of filter:
     *
     * - ALL core filters MUST be supported by all implementations.
     * - Implementers are encouraged to support extended filters.
     * - Implementation-specific custom filters have no API guarantees across
     *   implementations.
     *
     * Specifying the same filter multiple times is not supported unless explicitly
     * indicated in the filter.
     *
     * All filters are expected to be compatible with each other except for the
     * URLRewrite and RequestRedirect filters, which may not be combined. If an
     * implementation cannot support other combinations of filters, they must clearly
     * document that limitation. In cases where incompatible or unsupported
     * filters are specified and cause the `Accepted` condition to be set to status
     * `False`, implementations may use the `IncompatibleFilters` reason to specify
     * this configuration error.
     *
     * Support: Core
     */
    filters?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Input>
      >
    >;
    /**
     * Matches define conditions used for matching the rule against incoming
     * HTTP requests. Each match is independent, i.e. this rule will be matched
     * if **any** one of the matches is satisfied.
     *
     * For example, take the following matches configuration:
     *
     * ```
     * matches:
     * - path:
     *     value: "/foo"
     *   headers:
     *   - name: "version"
     *     value: "v2"
     * - path:
     *     value: "/v2/foo"
     * ```
     *
     * For a request to match against this rule, a request must satisfy
     * EITHER of the two conditions:
     *
     * - path prefixed with `/foo` AND contains the header `version: v2`
     * - path prefix of `/v2/foo`
     *
     * See the documentation for HTTPRouteMatch on how to specify multiple
     * match conditions that should be ANDed together.
     *
     * If no matches are specified, the default is a prefix
     * path match on "/", which has the effect of matching every
     * HTTP request.
     *
     * Proxy or Load Balancer routing configuration generated from HTTPRoutes
     * MUST prioritize matches based on the following criteria, continuing on
     * ties. Across all rules specified on applicable Routes, precedence must be
     * given to the match having:
     *
     * * "Exact" path match.
     * * "Prefix" path match with largest number of characters.
     * * Method match.
     * * Largest number of header matches.
     * * Largest number of query param matches.
     *
     * Note: The precedence of RegularExpression path matches are implementation-specific.
     *
     * If ties still exist across multiple Routes, matching precedence MUST be
     * determined in order of the following criteria, continuing on ties:
     *
     * * The oldest Route based on creation timestamp.
     * * The Route appearing first in alphabetical order by
     *   "{namespace}/{name}".
     *
     * If ties still exist within an HTTPRoute, matching precedence MUST be granted
     * to the FIRST matching rule (in list order) with a match meeting the above
     * criteria.
     *
     * When no rules matching a request have been successfully attached to the
     * parent a request is coming from, a HTTP 404 status code MUST be returned.
     */
    matches?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Input>
      >
    >;
    timeouts?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Timeouts_Input>;
  };

/**
 * HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
 *
 * Note that when a namespace different than the local namespace is specified, a
 * ReferenceGrant object is required in the referent namespace to allow that
 * namespace's owner to accept the reference. See the ReferenceGrant
 * documentation for details.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items =
  {
    /**
     * Filters defined at this level should be executed if and only if the
     * request is being forwarded to the backend defined here.
     *
     * Support: Implementation-specific (For broader support of filters, use the
     * Filters field in HTTPRouteRule.)
     */
    filters?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items>
      >
    >;
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
    /**
     * Weight specifies the proportion of requests forwarded to the referenced
     * backend. This is computed as weight/(sum of all weights in this
     * BackendRefs list). For non-zero values, there may be some epsilon from
     * the exact proportion defined here depending on the precision an
     * implementation supports. Weight is not a percentage and the sum of
     * weights does not need to equal 100.
     *
     * If only one backend is specified and it has a weight greater than 0, 100%
     * of the traffic is forwarded to that backend. If weight is set to 0, no
     * traffic should be forwarded for this entry. If unspecified, weight
     * defaults to 1.
     *
     * Support for this field varies based on the context where used.
     */
    weight?: Maybe<Scalars['Int']['output']>;
  };

/**
 * HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
 *
 * Note that when a namespace different than the local namespace is specified, a
 * ReferenceGrant object is required in the referent namespace to allow that
 * namespace's owner to accept the reference. See the ReferenceGrant
 * documentation for details.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Input =
  {
    /**
     * Filters defined at this level should be executed if and only if the
     * request is being forwarded to the backend defined here.
     *
     * Support: Implementation-specific (For broader support of filters, use the
     * Filters field in HTTPRouteRule.)
     */
    filters?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_Input>
      >
    >;
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    /**
     * Weight specifies the proportion of requests forwarded to the referenced
     * backend. This is computed as weight/(sum of all weights in this
     * BackendRefs list). For non-zero values, there may be some epsilon from
     * the exact proportion defined here depending on the precision an
     * implementation supports. Weight is not a percentage and the sum of
     * weights does not need to equal 100.
     *
     * If only one backend is specified and it has a weight greater than 0, 100%
     * of the traffic is forwarded to that backend. If weight is set to 0, no
     * traffic should be forwarded for this entry. If unspecified, weight
     * defaults to 1.
     *
     * Support for this field varies based on the context where used.
     */
    weight?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * HTTPRouteFilter defines processing steps that must be completed during the
 * request or response lifecycle. HTTPRouteFilters are meant as an extension
 * point to express processing that may be done in Gateway implementations. Some
 * examples include request or response modification, implementing
 * authentication strategies, rate-limiting, and traffic shaping. API
 * guarantee/conformance is defined based on the type of the filter.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items =
  {
    extensionRef?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ExtensionRef>;
    requestHeaderModifier?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier>;
    requestMirror?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror>;
    requestRedirect?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect>;
    responseHeaderModifier?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier>;
    type: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_Type;
    urlRewrite?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite>;
  };

/**
 * HTTPRouteFilter defines processing steps that must be completed during the
 * request or response lifecycle. HTTPRouteFilters are meant as an extension
 * point to express processing that may be done in Gateway implementations. Some
 * examples include request or response modification, implementing
 * authentication strategies, rate-limiting, and traffic shaping. API
 * guarantee/conformance is defined based on the type of the filter.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_Input =
  {
    extensionRef?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ExtensionRef_Input>;
    requestHeaderModifier?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Input>;
    requestMirror?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_Input>;
    requestRedirect?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Input>;
    responseHeaderModifier?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Input>;
    type: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_Type;
    urlRewrite?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Input>;
  };

/**
 * ExtensionRef is an optional, implementation-specific extension to the
 * "filter" behavior.  For example, resource "myroutefilter" in group
 * "networking.example.net"). ExtensionRef MUST NOT be used for core and
 * extended filters.
 *
 * This filter can be used multiple times within the same rule.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ExtensionRef =
  {
    group: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_group']['output'];
    kind: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_kind']['output'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_name']['output'];
  };

/**
 * ExtensionRef is an optional, implementation-specific extension to the
 * "filter" behavior.  For example, resource "myroutefilter" in group
 * "networking.example.net"). ExtensionRef MUST NOT be used for core and
 * extended filters.
 *
 * This filter can be used multiple times within the same rule.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ExtensionRef_Input =
  {
    group: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_group']['input'];
    kind: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_kind']['input'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_extensionRef_name']['input'];
  };

/**
 * RequestHeaderModifier defines a schema for a filter that modifies request
 * headers.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Add_Items>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Set_Items>
      >
    >;
  };

/**
 * RequestHeaderModifier defines a schema for a filter that modifies request
 * headers.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Input =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Add_Items_Input>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Set_Items_Input>
      >
    >;
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Add_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_add_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_add_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Add_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_add_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_add_items_value']['input'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Set_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_set_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_set_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestHeaderModifier_Set_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_set_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestHeaderModifier_set_items_value']['input'];
  };

/**
 * RequestMirror defines a schema for a filter that mirrors requests.
 * Requests are sent to the specified destination, but responses from
 * that destination are ignored.
 *
 * This filter can be used multiple times within the same rule. Note that
 * not all implementations will be able to support mirroring to multiple
 * backends.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror =
  {
    backendRef: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_BackendRef;
    fraction?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_Fraction>;
    /**
     * Percent represents the percentage of requests that should be
     * mirrored to BackendRef. Its minimum value is 0 (indicating 0% of
     * requests) and its maximum value is 100 (indicating 100% of requests).
     *
     * Only one of Fraction or Percent may be specified. If neither field
     * is specified, 100% of requests will be mirrored.
     */
    percent?: Maybe<Scalars['Int']['output']>;
  };

/**
 * RequestMirror defines a schema for a filter that mirrors requests.
 * Requests are sent to the specified destination, but responses from
 * that destination are ignored.
 *
 * This filter can be used multiple times within the same rule. Note that
 * not all implementations will be able to support mirroring to multiple
 * backends.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_Input =
  {
    backendRef: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_BackendRef_Input;
    fraction?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_Fraction_Input>;
    /**
     * Percent represents the percentage of requests that should be
     * mirrored to BackendRef. Its minimum value is 0 (indicating 0% of
     * requests) and its maximum value is 100 (indicating 100% of requests).
     *
     * Only one of Fraction or Percent may be specified. If neither field
     * is specified, 100% of requests will be mirrored.
     */
    percent?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * BackendRef references a resource where mirrored requests are sent.
 *
 * Mirrored requests must be sent only to a single destination endpoint
 * within this BackendRef, irrespective of how many endpoints are present
 * within this BackendRef.
 *
 * If the referent cannot be found, this BackendRef is invalid and must be
 * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
 * condition on the Route status is set to `status: False` and not configure
 * this backend in the underlying implementation.
 *
 * If there is a cross-namespace reference to an *existing* object
 * that is not allowed by a ReferenceGrant, the controller must ensure the
 * "ResolvedRefs"  condition on the Route is set to `status: False`,
 * with the "RefNotPermitted" reason and not configure this backend in the
 * underlying implementation.
 *
 * In either error case, the Message of the `ResolvedRefs` Condition
 * should be used to provide more detail about the problem.
 *
 * Support: Extended for Kubernetes Service
 *
 * Support: Implementation-specific for any other resource
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_BackendRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
  };

/**
 * BackendRef references a resource where mirrored requests are sent.
 *
 * Mirrored requests must be sent only to a single destination endpoint
 * within this BackendRef, irrespective of how many endpoints are present
 * within this BackendRef.
 *
 * If the referent cannot be found, this BackendRef is invalid and must be
 * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
 * condition on the Route status is set to `status: False` and not configure
 * this backend in the underlying implementation.
 *
 * If there is a cross-namespace reference to an *existing* object
 * that is not allowed by a ReferenceGrant, the controller must ensure the
 * "ResolvedRefs"  condition on the Route is set to `status: False`,
 * with the "RefNotPermitted" reason and not configure this backend in the
 * underlying implementation.
 *
 * In either error case, the Message of the `ResolvedRefs` Condition
 * should be used to provide more detail about the problem.
 *
 * Support: Extended for Kubernetes Service
 *
 * Support: Implementation-specific for any other resource
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_BackendRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestMirror_backendRef_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * Fraction represents the fraction of requests that should be
 * mirrored to BackendRef.
 *
 * Only one of Fraction or Percent may be specified. If neither field
 * is specified, 100% of requests will be mirrored.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_Fraction =
  {
    denominator?: Maybe<Scalars['Int']['output']>;
    numerator: Scalars['Int']['output'];
  };

/**
 * Fraction represents the fraction of requests that should be
 * mirrored to BackendRef.
 *
 * Only one of Fraction or Percent may be specified. If neither field
 * is specified, 100% of requests will be mirrored.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestMirror_Fraction_Input =
  {
    denominator?: InputMaybe<Scalars['Int']['input']>;
    numerator: Scalars['Int']['input'];
  };

/**
 * RequestRedirect defines a schema for a filter that responds to the
 * request with an HTTP redirection.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect =
  {
    hostname?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_hostname']['output']
    >;
    path?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Path>;
    /**
     * Port is the port to be used in the value of the `Location`
     * header in the response.
     *
     * If no port is specified, the redirect port MUST be derived using the
     * following rules:
     *
     * * If redirect scheme is not-empty, the redirect port MUST be the well-known
     *   port associated with the redirect scheme. Specifically "http" to port 80
     *   and "https" to port 443. If the redirect scheme does not have a
     *   well-known port, the listener port of the Gateway SHOULD be used.
     * * If redirect scheme is empty, the redirect port MUST be the Gateway
     *   Listener port.
     *
     * Implementations SHOULD NOT add the port number in the 'Location'
     * header in the following cases:
     *
     * * A Location header that will use HTTP (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 80.
     * * A Location header that will use HTTPS (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 443.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    scheme?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Scheme>;
    statusCode?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_StatusCode>;
  };

/**
 * RequestRedirect defines a schema for a filter that responds to the
 * request with an HTTP redirection.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_hostname']['input']
    >;
    path?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Path_Input>;
    /**
     * Port is the port to be used in the value of the `Location`
     * header in the response.
     *
     * If no port is specified, the redirect port MUST be derived using the
     * following rules:
     *
     * * If redirect scheme is not-empty, the redirect port MUST be the well-known
     *   port associated with the redirect scheme. Specifically "http" to port 80
     *   and "https" to port 443. If the redirect scheme does not have a
     *   well-known port, the listener port of the Gateway SHOULD be used.
     * * If redirect scheme is empty, the redirect port MUST be the Gateway
     *   Listener port.
     *
     * Implementations SHOULD NOT add the port number in the 'Location'
     * header in the following cases:
     *
     * * A Location header that will use HTTP (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 80.
     * * A Location header that will use HTTPS (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 443.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    scheme?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Scheme>;
    statusCode?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_StatusCode>;
  };

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Path =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_path_replaceFullPath']['output']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_path_replacePrefixMatch']['output']
    >;
    type: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Path_Type;
  };

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Path_Input =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_path_replaceFullPath']['input']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_requestRedirect_path_replacePrefixMatch']['input']
    >;
    type: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Path_Type;
  };

/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Path_Type =
  'ReplaceFullPath' | 'ReplacePrefixMatch';

/**
 * Scheme is the scheme to be used in the value of the `Location` header in
 * the response. When empty, the scheme of the request is used.
 *
 * Scheme redirects can affect the port of the redirect, for more information,
 * refer to the documentation for the port field of this filter.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_Scheme =
  'http' | 'https';

/**
 * StatusCode is the HTTP status code to be used in response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_RequestRedirect_StatusCode =
  '_301' | '_302';

/**
 * ResponseHeaderModifier defines a schema for a filter that modifies response
 * headers.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Add_Items>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Set_Items>
      >
    >;
  };

/**
 * ResponseHeaderModifier defines a schema for a filter that modifies response
 * headers.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Input =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Add_Items_Input>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Set_Items_Input>
      >
    >;
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Add_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_add_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_add_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Add_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_add_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_add_items_value']['input'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Set_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_set_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_set_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_ResponseHeaderModifier_Set_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_set_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_responseHeaderModifier_set_items_value']['input'];
  };

/**
 * Type identifies the type of filter to apply. As with other API fields,
 * types are classified into three conformance levels:
 *
 * - Core: Filter types and their corresponding configuration defined by
 *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
 *   implementations must support core filters.
 *
 * - Extended: Filter types and their corresponding configuration defined by
 *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
 *   are encouraged to support extended filters.
 *
 * - Implementation-specific: Filters that are defined and supported by
 *   specific vendors.
 *   In the future, filters showing convergence in behavior across multiple
 *   implementations will be considered for inclusion in extended or core
 *   conformance levels. Filter-specific configuration for such filters
 *   is specified using the ExtensionRef field. `Type` should be set to
 *   "ExtensionRef" for custom filters.
 *
 * Implementers are encouraged to define custom implementation types to
 * extend the core API with implementation-specific behavior.
 *
 * If a reference to a custom filter type cannot be resolved, the filter
 * MUST NOT be skipped. Instead, requests that would have been processed by
 * that filter MUST receive a HTTP error response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_Type =

    | 'ExtensionRef'
    | 'RequestHeaderModifier'
    | 'RequestMirror'
    | 'RequestRedirect'
    | 'ResponseHeaderModifier'
    | 'URLRewrite';

/**
 * URLRewrite defines a schema for a filter that modifies a request during forwarding.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite =
  {
    hostname?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_hostname']['output']
    >;
    path?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Path>;
  };

/**
 * URLRewrite defines a schema for a filter that modifies a request during forwarding.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_hostname']['input']
    >;
    path?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Path_Input>;
  };

/**
 * Path defines a path rewrite.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Path =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_path_replaceFullPath']['output']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_path_replacePrefixMatch']['output']
    >;
    type: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Path_Type;
  };

/**
 * Path defines a path rewrite.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Path_Input =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_path_replaceFullPath']['input']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_backendRefs_items_filters_items_urlRewrite_path_replacePrefixMatch']['input']
    >;
    type: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Path_Type;
  };

/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_BackendRefs_Items_Filters_Items_UrlRewrite_Path_Type =
  'ReplaceFullPath' | 'ReplacePrefixMatch';

/**
 * HTTPRouteFilter defines processing steps that must be completed during the
 * request or response lifecycle. HTTPRouteFilters are meant as an extension
 * point to express processing that may be done in Gateway implementations. Some
 * examples include request or response modification, implementing
 * authentication strategies, rate-limiting, and traffic shaping. API
 * guarantee/conformance is defined based on the type of the filter.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items =
  {
    extensionRef?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ExtensionRef>;
    requestHeaderModifier?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier>;
    requestMirror?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror>;
    requestRedirect?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect>;
    responseHeaderModifier?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier>;
    type: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Type;
    urlRewrite?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite>;
  };

/**
 * HTTPRouteFilter defines processing steps that must be completed during the
 * request or response lifecycle. HTTPRouteFilters are meant as an extension
 * point to express processing that may be done in Gateway implementations. Some
 * examples include request or response modification, implementing
 * authentication strategies, rate-limiting, and traffic shaping. API
 * guarantee/conformance is defined based on the type of the filter.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Input =
  {
    extensionRef?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ExtensionRef_Input>;
    requestHeaderModifier?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Input>;
    requestMirror?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Input>;
    requestRedirect?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Input>;
    responseHeaderModifier?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Input>;
    type: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Type;
    urlRewrite?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Input>;
  };

/**
 * ExtensionRef is an optional, implementation-specific extension to the
 * "filter" behavior.  For example, resource "myroutefilter" in group
 * "networking.example.net"). ExtensionRef MUST NOT be used for core and
 * extended filters.
 *
 * This filter can be used multiple times within the same rule.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ExtensionRef =
  {
    group: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_group']['output'];
    kind: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_kind']['output'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_name']['output'];
  };

/**
 * ExtensionRef is an optional, implementation-specific extension to the
 * "filter" behavior.  For example, resource "myroutefilter" in group
 * "networking.example.net"). ExtensionRef MUST NOT be used for core and
 * extended filters.
 *
 * This filter can be used multiple times within the same rule.
 *
 * Support: Implementation-specific
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ExtensionRef_Input =
  {
    group: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_group']['input'];
    kind: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_kind']['input'];
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_name']['input'];
  };

/**
 * RequestHeaderModifier defines a schema for a filter that modifies request
 * headers.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Add_Items>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Set_Items>
      >
    >;
  };

/**
 * RequestHeaderModifier defines a schema for a filter that modifies request
 * headers.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Input =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Add_Items_Input>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Set_Items_Input>
      >
    >;
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Add_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Add_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_value']['input'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Set_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Set_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_value']['input'];
  };

/**
 * RequestMirror defines a schema for a filter that mirrors requests.
 * Requests are sent to the specified destination, but responses from
 * that destination are ignored.
 *
 * This filter can be used multiple times within the same rule. Note that
 * not all implementations will be able to support mirroring to multiple
 * backends.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror =
  {
    backendRef: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_BackendRef;
    fraction?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Fraction>;
    /**
     * Percent represents the percentage of requests that should be
     * mirrored to BackendRef. Its minimum value is 0 (indicating 0% of
     * requests) and its maximum value is 100 (indicating 100% of requests).
     *
     * Only one of Fraction or Percent may be specified. If neither field
     * is specified, 100% of requests will be mirrored.
     */
    percent?: Maybe<Scalars['Int']['output']>;
  };

/**
 * RequestMirror defines a schema for a filter that mirrors requests.
 * Requests are sent to the specified destination, but responses from
 * that destination are ignored.
 *
 * This filter can be used multiple times within the same rule. Note that
 * not all implementations will be able to support mirroring to multiple
 * backends.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Input =
  {
    backendRef: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_BackendRef_Input;
    fraction?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Fraction_Input>;
    /**
     * Percent represents the percentage of requests that should be
     * mirrored to BackendRef. Its minimum value is 0 (indicating 0% of
     * requests) and its maximum value is 100 (indicating 100% of requests).
     *
     * Only one of Fraction or Percent may be specified. If neither field
     * is specified, 100% of requests will be mirrored.
     */
    percent?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * BackendRef references a resource where mirrored requests are sent.
 *
 * Mirrored requests must be sent only to a single destination endpoint
 * within this BackendRef, irrespective of how many endpoints are present
 * within this BackendRef.
 *
 * If the referent cannot be found, this BackendRef is invalid and must be
 * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
 * condition on the Route status is set to `status: False` and not configure
 * this backend in the underlying implementation.
 *
 * If there is a cross-namespace reference to an *existing* object
 * that is not allowed by a ReferenceGrant, the controller must ensure the
 * "ResolvedRefs"  condition on the Route is set to `status: False`,
 * with the "RefNotPermitted" reason and not configure this backend in the
 * underlying implementation.
 *
 * In either error case, the Message of the `ResolvedRefs` Condition
 * should be used to provide more detail about the problem.
 *
 * Support: Extended for Kubernetes Service
 *
 * Support: Implementation-specific for any other resource
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_BackendRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
  };

/**
 * BackendRef references a resource where mirrored requests are sent.
 *
 * Mirrored requests must be sent only to a single destination endpoint
 * within this BackendRef, irrespective of how many endpoints are present
 * within this BackendRef.
 *
 * If the referent cannot be found, this BackendRef is invalid and must be
 * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
 * condition on the Route status is set to `status: False` and not configure
 * this backend in the underlying implementation.
 *
 * If there is a cross-namespace reference to an *existing* object
 * that is not allowed by a ReferenceGrant, the controller must ensure the
 * "ResolvedRefs"  condition on the Route is set to `status: False`,
 * with the "RefNotPermitted" reason and not configure this backend in the
 * underlying implementation.
 *
 * In either error case, the Message of the `ResolvedRefs` Condition
 * should be used to provide more detail about the problem.
 *
 * Support: Extended for Kubernetes Service
 *
 * Support: Implementation-specific for any other resource
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_BackendRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * Fraction represents the fraction of requests that should be
 * mirrored to BackendRef.
 *
 * Only one of Fraction or Percent may be specified. If neither field
 * is specified, 100% of requests will be mirrored.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Fraction =
  {
    denominator?: Maybe<Scalars['Int']['output']>;
    numerator: Scalars['Int']['output'];
  };

/**
 * Fraction represents the fraction of requests that should be
 * mirrored to BackendRef.
 *
 * Only one of Fraction or Percent may be specified. If neither field
 * is specified, 100% of requests will be mirrored.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Fraction_Input =
  {
    denominator?: InputMaybe<Scalars['Int']['input']>;
    numerator: Scalars['Int']['input'];
  };

/**
 * RequestRedirect defines a schema for a filter that responds to the
 * request with an HTTP redirection.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect =
  {
    hostname?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_hostname']['output']
    >;
    path?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path>;
    /**
     * Port is the port to be used in the value of the `Location`
     * header in the response.
     *
     * If no port is specified, the redirect port MUST be derived using the
     * following rules:
     *
     * * If redirect scheme is not-empty, the redirect port MUST be the well-known
     *   port associated with the redirect scheme. Specifically "http" to port 80
     *   and "https" to port 443. If the redirect scheme does not have a
     *   well-known port, the listener port of the Gateway SHOULD be used.
     * * If redirect scheme is empty, the redirect port MUST be the Gateway
     *   Listener port.
     *
     * Implementations SHOULD NOT add the port number in the 'Location'
     * header in the following cases:
     *
     * * A Location header that will use HTTP (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 80.
     * * A Location header that will use HTTPS (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 443.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    scheme?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Scheme>;
    statusCode?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_StatusCode>;
  };

/**
 * RequestRedirect defines a schema for a filter that responds to the
 * request with an HTTP redirection.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_hostname']['input']
    >;
    path?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Input>;
    /**
     * Port is the port to be used in the value of the `Location`
     * header in the response.
     *
     * If no port is specified, the redirect port MUST be derived using the
     * following rules:
     *
     * * If redirect scheme is not-empty, the redirect port MUST be the well-known
     *   port associated with the redirect scheme. Specifically "http" to port 80
     *   and "https" to port 443. If the redirect scheme does not have a
     *   well-known port, the listener port of the Gateway SHOULD be used.
     * * If redirect scheme is empty, the redirect port MUST be the Gateway
     *   Listener port.
     *
     * Implementations SHOULD NOT add the port number in the 'Location'
     * header in the following cases:
     *
     * * A Location header that will use HTTP (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 80.
     * * A Location header that will use HTTPS (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 443.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    scheme?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Scheme>;
    statusCode?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_StatusCode>;
  };

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replaceFullPath']['output']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replacePrefixMatch']['output']
    >;
    type: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Type;
  };

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Input =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replaceFullPath']['input']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replacePrefixMatch']['input']
    >;
    type: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Type;
  };

/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Type =
  'ReplaceFullPath' | 'ReplacePrefixMatch';

/**
 * Scheme is the scheme to be used in the value of the `Location` header in
 * the response. When empty, the scheme of the request is used.
 *
 * Scheme redirects can affect the port of the redirect, for more information,
 * refer to the documentation for the port field of this filter.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Scheme =
  'http' | 'https';

/**
 * StatusCode is the HTTP status code to be used in response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Core
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_StatusCode =
  '_301' | '_302';

/**
 * ResponseHeaderModifier defines a schema for a filter that modifies response
 * headers.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Add_Items>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Set_Items>
      >
    >;
  };

/**
 * ResponseHeaderModifier defines a schema for a filter that modifies response
 * headers.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Input =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Add_Items_Input>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Set_Items_Input>
      >
    >;
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Add_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Add_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_value']['input'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Set_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Set_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_value']['input'];
  };

/**
 * Type identifies the type of filter to apply. As with other API fields,
 * types are classified into three conformance levels:
 *
 * - Core: Filter types and their corresponding configuration defined by
 *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
 *   implementations must support core filters.
 *
 * - Extended: Filter types and their corresponding configuration defined by
 *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
 *   are encouraged to support extended filters.
 *
 * - Implementation-specific: Filters that are defined and supported by
 *   specific vendors.
 *   In the future, filters showing convergence in behavior across multiple
 *   implementations will be considered for inclusion in extended or core
 *   conformance levels. Filter-specific configuration for such filters
 *   is specified using the ExtensionRef field. `Type` should be set to
 *   "ExtensionRef" for custom filters.
 *
 * Implementers are encouraged to define custom implementation types to
 * extend the core API with implementation-specific behavior.
 *
 * If a reference to a custom filter type cannot be resolved, the filter
 * MUST NOT be skipped. Instead, requests that would have been processed by
 * that filter MUST receive a HTTP error response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Type =

    | 'ExtensionRef'
    | 'RequestHeaderModifier'
    | 'RequestMirror'
    | 'RequestRedirect'
    | 'ResponseHeaderModifier'
    | 'URLRewrite';

/**
 * URLRewrite defines a schema for a filter that modifies a request during forwarding.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite =
  {
    hostname?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_hostname']['output']
    >;
    path?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path>;
  };

/**
 * URLRewrite defines a schema for a filter that modifies a request during forwarding.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_hostname']['input']
    >;
    path?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Input>;
  };

/**
 * Path defines a path rewrite.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replaceFullPath']['output']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replacePrefixMatch']['output']
    >;
    type: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Type;
  };

/**
 * Path defines a path rewrite.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Input =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replaceFullPath']['input']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replacePrefixMatch']['input']
    >;
    type: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Type;
  };

/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Type =
  'ReplaceFullPath' | 'ReplacePrefixMatch';

/**
 * HTTPRouteMatch defines the predicate used to match requests to a given
 * action. Multiple match types are ANDed together, i.e. the match will
 * evaluate to true only if all conditions are satisfied.
 *
 * For example, the match below will match a HTTP request only if its path
 * starts with `/foo` AND it contains the `version: v1` header:
 *
 * ```
 * match:
 *
 * 	path:
 * 	  value: "/foo"
 * 	headers:
 * 	- name: "version"
 * 	  value "v1"
 *
 * ```
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items =
  {
    /**
     * Headers specifies HTTP request header matchers. Multiple match values are
     * ANDed together, meaning, a request must match all the specified headers
     * to select the route.
     */
    headers?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items>
      >
    >;
    method?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Method>;
    path?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path>;
    /**
     * QueryParams specifies HTTP query parameter matchers. Multiple match
     * values are ANDed together, meaning, a request must match all the
     * specified query parameters to select the route.
     *
     * Support: Extended
     */
    queryParams?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items>
      >
    >;
  };

/**
 * HTTPRouteMatch defines the predicate used to match requests to a given
 * action. Multiple match types are ANDed together, i.e. the match will
 * evaluate to true only if all conditions are satisfied.
 *
 * For example, the match below will match a HTTP request only if its path
 * starts with `/foo` AND it contains the `version: v1` header:
 *
 * ```
 * match:
 *
 * 	path:
 * 	  value: "/foo"
 * 	headers:
 * 	- name: "version"
 * 	  value "v1"
 *
 * ```
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Input =
  {
    /**
     * Headers specifies HTTP request header matchers. Multiple match values are
     * ANDed together, meaning, a request must match all the specified headers
     * to select the route.
     */
    headers?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Input>
      >
    >;
    method?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Method>;
    path?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Input>;
    /**
     * QueryParams specifies HTTP query parameter matchers. Multiple match
     * values are ANDed together, meaning, a request must match all the
     * specified query parameters to select the route.
     *
     * Support: Extended
     */
    queryParams?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Input>
      >
    >;
  };

/**
 * HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
 * headers.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_name']['output'];
    type?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Type>;
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_value']['output'];
  };

/**
 * HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
 * headers.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_name']['input'];
    type?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Type>;
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_value']['input'];
  };

/**
 * Type specifies how to match against the value of the header.
 *
 * Support: Core (Exact)
 *
 * Support: Implementation-specific (RegularExpression)
 *
 * Since RegularExpression HeaderMatchType has implementation-specific
 * conformance, implementations can support POSIX, PCRE or any other dialects
 * of regular expressions. Please read the implementation's documentation to
 * determine the supported dialect.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Type =
  'Exact' | 'RegularExpression';

/**
 * Method specifies HTTP method matcher.
 * When specified, this route will be matched only if the request has the
 * specified method.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Method =
  'CONNECT' | 'DELETE' | 'GET' | 'HEAD' | 'OPTIONS' | 'PATCH' | 'POST' | 'PUT' | 'TRACE';

/**
 * Path specifies a HTTP request path matcher. If this field is not
 * specified, a default prefix match on the "/" path is provided.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path =
  {
    type?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Type>;
    /** Value of the HTTP path to match against. */
    value?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_path_value']['output']
    >;
  };

/**
 * Path specifies a HTTP request path matcher. If this field is not
 * specified, a default prefix match on the "/" path is provided.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Input =
  {
    type?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Type>;
    /** Value of the HTTP path to match against. */
    value?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_path_value']['input']
    >;
  };

/**
 * Type specifies how to match against the path Value.
 *
 * Support: Core (Exact, PathPrefix)
 *
 * Support: Implementation-specific (RegularExpression)
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Type =
  'Exact' | 'PathPrefix' | 'RegularExpression';

/**
 * HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
 * query parameters.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_name']['output'];
    type?: Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Type>;
    /** Value is the value of HTTP query param to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_value']['output'];
  };

/**
 * HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
 * query parameters.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Input =
  {
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_name']['input'];
    type?: InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Type>;
    /** Value is the value of HTTP query param to be matched. */
    value: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_value']['input'];
  };

/**
 * Type specifies how to match against the value of the query parameter.
 *
 * Support: Extended (Exact)
 *
 * Support: Implementation-specific (RegularExpression)
 *
 * Since RegularExpression QueryParamMatchType has Implementation-specific
 * conformance, implementations can support POSIX, PCRE or any other
 * dialects of regular expressions. Please read the implementation's
 * documentation to determine the supported dialect.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Type =
  'Exact' | 'RegularExpression';

/**
 * Timeouts defines the timeouts that can be configured for an HTTP request.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Timeouts =
  {
    backendRequest?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_timeouts_backendRequest']['output']
    >;
    request?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_timeouts_request']['output']
    >;
  };

/**
 * Timeouts defines the timeouts that can be configured for an HTTP request.
 *
 * Support: Extended
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Spec_Rules_Items_Timeouts_Input =
  {
    backendRequest?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_timeouts_backendRequest']['input']
    >;
    request?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_spec_rules_items_timeouts_request']['input']
    >;
  };

/** Status defines the current state of HTTPRoute. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status = {
  /**
   * Parents is a list of parent resources (usually Gateways) that are
   * associated with the route, and the status of the route with respect to
   * each parent. When this route attaches to a parent, the controller that
   * manages the parent must add an entry to this list when the controller
   * first sees the route and should update the entry as appropriate when the
   * route or gateway is modified.
   *
   * Note that parent references that cannot be resolved by an implementation
   * of this API will not be added to this list. Implementations of this API
   * can only populate Route status for the Gateways/parent resources they are
   * responsible for.
   *
   * A maximum of 32 Gateways will be represented in this list. An empty list
   * means the route has not been attached to any Gateway.
   */
  parents: Array<
    Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items>
  >;
};

/** Status defines the current state of HTTPRoute. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Input = {
  /**
   * Parents is a list of parent resources (usually Gateways) that are
   * associated with the route, and the status of the route with respect to
   * each parent. When this route attaches to a parent, the controller that
   * manages the parent must add an entry to this list when the controller
   * first sees the route and should update the entry as appropriate when the
   * route or gateway is modified.
   *
   * Note that parent references that cannot be resolved by an implementation
   * of this API will not be added to this list. Implementations of this API
   * can only populate Route status for the Gateways/parent resources they are
   * responsible for.
   *
   * A maximum of 32 Gateways will be represented in this list. An empty list
   * means the route has not been attached to any Gateway.
   */
  parents: Array<
    InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Input>
  >;
};

/**
 * RouteParentStatus describes the status of a route with respect to an
 * associated Parent.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items =
  {
    /**
     * Conditions describes the status of the route with respect to the Gateway.
     * Note that the route's availability is also subject to the Gateway's own
     * status conditions and listener status.
     *
     * If the Route's ParentRef specifies an existing Gateway that supports
     * Routes of this kind AND that Gateway's controller has sufficient access,
     * then that Gateway's controller MUST set the "Accepted" condition on the
     * Route, to indicate whether the route has been accepted or rejected by the
     * Gateway, and why.
     *
     * A Route MUST be considered "Accepted" if at least one of the Route's
     * rules is implemented by the Gateway.
     *
     * There are a number of cases where the "Accepted" condition may not be set
     * due to lack of controller visibility, that includes when:
     *
     * * The Route refers to a nonexistent parent.
     * * The Route is of a type that the controller does not support.
     * * The Route is in a namespace the controller does not have access to.
     */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Conditions_Items>
      >
    >;
    controllerName: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_controllerName']['output'];
    parentRef: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_ParentRef;
  };

/**
 * RouteParentStatus describes the status of a route with respect to an
 * associated Parent.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Input =
  {
    /**
     * Conditions describes the status of the route with respect to the Gateway.
     * Note that the route's availability is also subject to the Gateway's own
     * status conditions and listener status.
     *
     * If the Route's ParentRef specifies an existing Gateway that supports
     * Routes of this kind AND that Gateway's controller has sufficient access,
     * then that Gateway's controller MUST set the "Accepted" condition on the
     * Route, to indicate whether the route has been accepted or rejected by the
     * Gateway, and why.
     *
     * A Route MUST be considered "Accepted" if at least one of the Route's
     * rules is implemented by the Gateway.
     *
     * There are a number of cases where the "Accepted" condition may not be set
     * due to lack of controller visibility, that includes when:
     *
     * * The Route refers to a nonexistent parent.
     * * The Route is of a type that the controller does not support.
     * * The Route is in a namespace the controller does not have access to.
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Conditions_Items_Input>
      >
    >;
    controllerName: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_controllerName']['input'];
    parentRef: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_ParentRef_Input;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_reason']['output'];
    status: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_reason']['input'];
    status: Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Conditions_Items_Status;
    type: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * ParentRef corresponds with a ParentRef in the spec that this
 * RouteParentStatus struct describes the status of.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_ParentRef =
  {
    group?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_kind']['output']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_namespace']['output']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    sectionName?: Maybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_sectionName']['output']
    >;
  };

/**
 * ParentRef corresponds with a ParentRef in the spec that this
 * RouteParentStatus struct describes the status of.
 */
export type Query_ListGatewayNetworkingV1beta1HttpRouteForAllNamespaces_Items_Items_Status_Parents_Items_ParentRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_kind']['input']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_namespace']['input']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    sectionName?: InputMaybe<
      Scalars['query_listGatewayNetworkingV1beta1HTTPRouteForAllNamespaces_items_items_status_parents_items_parentRef_sectionName']['input']
    >;
  };

/** GroupStatus defines the observed state of Group */
export type Query_ListIamMiloapisComV1alpha1GroupForAllNamespaces_Items_Items_Status = {
  /** Conditions represent the latest available observations of an object's current state. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListIamMiloapisComV1alpha1GroupForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
};

/** GroupStatus defines the observed state of Group */
export type Query_ListIamMiloapisComV1alpha1GroupForAllNamespaces_Items_Items_Status_Input = {
  /** Conditions represent the latest available observations of an object's current state. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListIamMiloapisComV1alpha1GroupForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
    >
  >;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1GroupForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1GroupForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1GroupForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListIamMiloapisComV1alpha1GroupForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1GroupForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1GroupForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1GroupForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1GroupForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListIamMiloapisComV1alpha1GroupForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1GroupForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListIamMiloapisComV1alpha1GroupForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** GroupMembershipSpec defines the desired state of GroupMembership */
export type Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Spec = {
  groupRef: Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Spec_GroupRef;
  userRef: Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Spec_UserRef;
};

/** GroupMembershipSpec defines the desired state of GroupMembership */
export type Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Spec_Input =
  {
    groupRef: Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Spec_GroupRef_Input;
    userRef: Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Spec_UserRef_Input;
  };

/**
 * GroupRef is a reference to the Group.
 * Group is a namespaced resource.
 */
export type Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Spec_GroupRef =
  {
    /** Name is the name of the Group being referenced. */
    name: Scalars['String']['output'];
    /** Namespace of the referenced Group. */
    namespace: Scalars['String']['output'];
  };

/**
 * GroupRef is a reference to the Group.
 * Group is a namespaced resource.
 */
export type Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Spec_GroupRef_Input =
  {
    /** Name is the name of the Group being referenced. */
    name: Scalars['String']['input'];
    /** Namespace of the referenced Group. */
    namespace: Scalars['String']['input'];
  };

/**
 * UserRef is a reference to the User that is a member of the Group.
 * User is a cluster-scoped resource.
 */
export type Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Spec_UserRef =
  {
    /** Name is the name of the User being referenced. */
    name: Scalars['String']['output'];
  };

/**
 * UserRef is a reference to the User that is a member of the Group.
 * User is a cluster-scoped resource.
 */
export type Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Spec_UserRef_Input =
  {
    /** Name is the name of the User being referenced. */
    name: Scalars['String']['input'];
  };

/** GroupMembershipStatus defines the observed state of GroupMembership */
export type Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Status = {
  /** Conditions represent the latest available observations of an object's current state. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
};

/** GroupMembershipStatus defines the observed state of GroupMembership */
export type Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Status_Input =
  {
    /** Conditions represent the latest available observations of an object's current state. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListIamMiloapisComV1alpha1GroupMembershipForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** MachineAccountSpec defines the desired state of MachineAccount */
export type Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Spec = {
  state?: Maybe<Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Spec_State>;
};

/** MachineAccountSpec defines the desired state of MachineAccount */
export type Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Spec_Input =
  {
    state?: InputMaybe<Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Spec_State>;
  };

/**
 * The state of the machine account. This state can be safely changed as needed.
 * States:
 *   - Active: The machine account can be used to authenticate.
 *   - Inactive: The machine account is prohibited to be used to authenticate, and revokes all existing sessions.
 */
export type Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Spec_State =
  | 'Active'
  | 'Inactive';

/** MachineAccountStatus defines the observed state of MachineAccount */
export type Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Status = {
  /** Conditions provide conditions that represent the current status of the MachineAccount. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
  /**
   * The computed email of the machine account following the pattern:
   * {metadata.name}@{metadata.namespace}.{project.metadata.name}.{global-suffix}
   */
  email?: Maybe<Scalars['String']['output']>;
  state?: Maybe<Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Status_State>;
};

/** MachineAccountStatus defines the observed state of MachineAccount */
export type Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Status_Input =
  {
    /** Conditions provide conditions that represent the current status of the MachineAccount. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /**
     * The computed email of the machine account following the pattern:
     * {metadata.name}@{metadata.namespace}.{project.metadata.name}.{global-suffix}
     */
    email?: InputMaybe<Scalars['String']['input']>;
    state?: InputMaybe<Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Status_State>;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1MachineAccountForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1MachineAccountForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1MachineAccountForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1MachineAccountForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1MachineAccountForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1MachineAccountForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * State represents the current activation state of the machine account from the auth provider.
 * This field tracks the state from the previous generation and is updated when state changes
 * are successfully propagated to the auth provider. It helps optimize performance by only
 * updating the auth provider when a state change is detected.
 */
export type Query_ListIamMiloapisComV1alpha1MachineAccountForAllNamespaces_Items_Items_Status_State =
  'Active' | 'Inactive';

/** MachineAccountKeySpec defines the desired state of MachineAccountKey */
export type Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Spec = {
  /**
   * ExpirationDate is the date and time when the MachineAccountKey will expire.
   * If not specified, the MachineAccountKey will never expire.
   */
  expirationDate?: Maybe<Scalars['DateTime']['output']>;
  /** MachineAccountName is the name of the MachineAccount that owns this key. */
  machineAccountName: Scalars['String']['output'];
  /**
   * PublicKey is the public key of the MachineAccountKey.
   * If not specified, the MachineAccountKey will be created with an auto-generated public key.
   */
  publicKey?: Maybe<Scalars['String']['output']>;
};

/** MachineAccountKeySpec defines the desired state of MachineAccountKey */
export type Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Spec_Input =
  {
    /**
     * ExpirationDate is the date and time when the MachineAccountKey will expire.
     * If not specified, the MachineAccountKey will never expire.
     */
    expirationDate?: InputMaybe<Scalars['DateTime']['input']>;
    /** MachineAccountName is the name of the MachineAccount that owns this key. */
    machineAccountName: Scalars['String']['input'];
    /**
     * PublicKey is the public key of the MachineAccountKey.
     * If not specified, the MachineAccountKey will be created with an auto-generated public key.
     */
    publicKey?: InputMaybe<Scalars['String']['input']>;
  };

/** MachineAccountKeyStatus defines the observed state of MachineAccountKey */
export type Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Status = {
  /**
   * AuthProviderKeyID is the unique identifier for the key in the auth provider.
   * This field is populated by the controller after the key is created in the auth provider.
   * For example, when using Zitadel, a typical value might be: "326102453042806786"
   */
  authProviderKeyId?: Maybe<Scalars['String']['output']>;
  /** Conditions provide conditions that represent the current status of the MachineAccountKey. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
};

/** MachineAccountKeyStatus defines the observed state of MachineAccountKey */
export type Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * AuthProviderKeyID is the unique identifier for the key in the auth provider.
     * This field is populated by the controller after the key is created in the auth provider.
     * For example, when using Zitadel, a typical value might be: "326102453042806786"
     */
    authProviderKeyId?: InputMaybe<Scalars['String']['input']>;
    /** Conditions provide conditions that represent the current status of the MachineAccountKey. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListIamMiloapisComV1alpha1MachineAccountKeyForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** PolicyBindingSpec defines the desired state of PolicyBinding */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec = {
  resourceSelector: Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_ResourceSelector;
  roleRef: Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_RoleRef;
  /** Subjects holds references to the objects the role applies to. */
  subjects: Array<
    Maybe<Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_Subjects_Items>
  >;
};

/** PolicyBindingSpec defines the desired state of PolicyBinding */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_Input = {
  resourceSelector: Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_ResourceSelector_Input;
  roleRef: Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_RoleRef_Input;
  /** Subjects holds references to the objects the role applies to. */
  subjects: Array<
    InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_Subjects_Items_Input>
  >;
};

/**
 * ResourceSelector defines which resources the subjects in the policy binding
 * should have the role applied to. Options within this struct are mutually
 * exclusive.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_ResourceSelector =
  {
    resourceKind?: Maybe<Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_ResourceSelector_ResourceKind>;
    resourceRef?: Maybe<Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_ResourceSelector_ResourceRef>;
  };

/**
 * ResourceSelector defines which resources the subjects in the policy binding
 * should have the role applied to. Options within this struct are mutually
 * exclusive.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_ResourceSelector_Input =
  {
    resourceKind?: InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_ResourceSelector_ResourceKind_Input>;
    resourceRef?: InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_ResourceSelector_ResourceRef_Input>;
  };

/**
 * ResourceKind specifies that the policy binding should apply to all resources of a specific kind.
 * Mutually exclusive with resourceRef.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_ResourceSelector_ResourceKind =
  {
    /**
     * APIGroup is the group for the resource type being referenced. If APIGroup
     * is not specified, the specified Kind must be in the core API group.
     */
    apiGroup?: Maybe<Scalars['String']['output']>;
    /** Kind is the type of resource being referenced. */
    kind: Scalars['String']['output'];
  };

/**
 * ResourceKind specifies that the policy binding should apply to all resources of a specific kind.
 * Mutually exclusive with resourceRef.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_ResourceSelector_ResourceKind_Input =
  {
    /**
     * APIGroup is the group for the resource type being referenced. If APIGroup
     * is not specified, the specified Kind must be in the core API group.
     */
    apiGroup?: InputMaybe<Scalars['String']['input']>;
    /** Kind is the type of resource being referenced. */
    kind: Scalars['String']['input'];
  };

/**
 * ResourceRef provides a reference to a specific resource instance.
 * Mutually exclusive with resourceKind.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_ResourceSelector_ResourceRef =
  {
    /**
     * APIGroup is the group for the resource being referenced.
     * If APIGroup is not specified, the specified Kind must be in the core API group.
     * For any other third-party types, APIGroup is required.
     */
    apiGroup?: Maybe<Scalars['String']['output']>;
    /** Kind is the type of resource being referenced. */
    kind: Scalars['String']['output'];
    /** Name is the name of resource being referenced. */
    name: Scalars['String']['output'];
    /**
     * Namespace is the namespace of resource being referenced.
     * Required for namespace-scoped resources. Omitted for cluster-scoped resources.
     */
    namespace?: Maybe<Scalars['String']['output']>;
    /** UID is the unique identifier of the resource being referenced. */
    uid: Scalars['String']['output'];
  };

/**
 * ResourceRef provides a reference to a specific resource instance.
 * Mutually exclusive with resourceKind.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_ResourceSelector_ResourceRef_Input =
  {
    /**
     * APIGroup is the group for the resource being referenced.
     * If APIGroup is not specified, the specified Kind must be in the core API group.
     * For any other third-party types, APIGroup is required.
     */
    apiGroup?: InputMaybe<Scalars['String']['input']>;
    /** Kind is the type of resource being referenced. */
    kind: Scalars['String']['input'];
    /** Name is the name of resource being referenced. */
    name: Scalars['String']['input'];
    /**
     * Namespace is the namespace of resource being referenced.
     * Required for namespace-scoped resources. Omitted for cluster-scoped resources.
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
    /** UID is the unique identifier of the resource being referenced. */
    uid: Scalars['String']['input'];
  };

/**
 * RoleRef is a reference to the Role that is being bound.
 * This can be a reference to a Role custom resource.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_RoleRef = {
  /** Name is the name of resource being referenced */
  name: Scalars['String']['output'];
  /** Namespace of the referenced Role. If empty, it is assumed to be in the PolicyBinding's namespace. */
  namespace?: Maybe<Scalars['String']['output']>;
};

/**
 * RoleRef is a reference to the Role that is being bound.
 * This can be a reference to a Role custom resource.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_RoleRef_Input =
  {
    /** Name is the name of resource being referenced */
    name: Scalars['String']['input'];
    /** Namespace of the referenced Role. If empty, it is assumed to be in the PolicyBinding's namespace. */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * Subject contains a reference to the object or user identities a role binding applies to.
 * This can be a User or Group.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_Subjects_Items =
  {
    kind: Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_Subjects_Items_Kind;
    /**
     * Name of the object being referenced. A special group name of
     * "system:authenticated-users" can be used to refer to all authenticated
     * users.
     */
    name: Scalars['String']['output'];
    /**
     * Namespace of the referenced object. If DNE, then for an SA it refers to the PolicyBinding resource's namespace.
     * For a User or Group, it is ignored.
     */
    namespace?: Maybe<Scalars['String']['output']>;
    /** UID of the referenced object. Optional for system groups (groups with names starting with "system:"). */
    uid?: Maybe<Scalars['String']['output']>;
  };

/**
 * Subject contains a reference to the object or user identities a role binding applies to.
 * This can be a User or Group.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_Subjects_Items_Input =
  {
    kind: Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_Subjects_Items_Kind;
    /**
     * Name of the object being referenced. A special group name of
     * "system:authenticated-users" can be used to refer to all authenticated
     * users.
     */
    name: Scalars['String']['input'];
    /**
     * Namespace of the referenced object. If DNE, then for an SA it refers to the PolicyBinding resource's namespace.
     * For a User or Group, it is ignored.
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
    /** UID of the referenced object. Optional for system groups (groups with names starting with "system:"). */
    uid?: InputMaybe<Scalars['String']['input']>;
  };

/** Kind of object being referenced. Values defined in Kind constants. */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Spec_Subjects_Items_Kind =
  'Group' | 'User';

/** PolicyBindingStatus defines the observed state of PolicyBinding */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Status = {
  /** Conditions provide conditions that represent the current status of the PolicyBinding. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Status_Conditions_Items>
    >
  >;
  /** ObservedGeneration is the most recent generation observed for this PolicyBinding by the controller. */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
};

/** PolicyBindingStatus defines the observed state of PolicyBinding */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Status_Input = {
  /** Conditions provide conditions that represent the current status of the PolicyBinding. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /** ObservedGeneration is the most recent generation observed for this PolicyBinding by the controller. */
  observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1NamespacedPolicyBinding_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1NamespacedPolicyBinding_items_items_status_conditions_items_reason']['output'];
    status: Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1NamespacedPolicyBinding_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1NamespacedPolicyBinding_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1NamespacedPolicyBinding_items_items_status_conditions_items_reason']['input'];
    status: Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1NamespacedPolicyBinding_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListIamMiloapisComV1alpha1NamespacedPolicyBinding_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** RoleSpec defines the desired state of Role */
export type Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Spec = {
  /**
   * The names of the permissions this role grants when bound in an IAM policy.
   * All permissions must be in the format: `{service}.{resource}.{action}`
   * (e.g. compute.workloads.create).
   */
  includedPermissions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * The list of roles from which this role inherits permissions.
   * Each entry must be a valid role resource name.
   */
  inheritedRoles?: Maybe<
    Array<
      Maybe<Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Spec_InheritedRoles_Items>
    >
  >;
  /**
   * Defines the launch stage of the IAM Role. Must be one of: Early Access,
   * Alpha, Beta, Stable, Deprecated.
   */
  launchStage: Scalars['String']['output'];
};

/** RoleSpec defines the desired state of Role */
export type Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Spec_Input = {
  /**
   * The names of the permissions this role grants when bound in an IAM policy.
   * All permissions must be in the format: `{service}.{resource}.{action}`
   * (e.g. compute.workloads.create).
   */
  includedPermissions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /**
   * The list of roles from which this role inherits permissions.
   * Each entry must be a valid role resource name.
   */
  inheritedRoles?: InputMaybe<
    Array<
      InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Spec_InheritedRoles_Items_Input>
    >
  >;
  /**
   * Defines the launch stage of the IAM Role. Must be one of: Early Access,
   * Alpha, Beta, Stable, Deprecated.
   */
  launchStage: Scalars['String']['input'];
};

/**
 * ScopedRoleReference defines a reference to another Role, scoped by namespace.
 * This is used for purposes like role inheritance where a simple name and namespace
 * is sufficient to identify the target role.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Spec_InheritedRoles_Items = {
  /** Name of the referenced Role. */
  name: Scalars['String']['output'];
  /**
   * Namespace of the referenced Role.
   * If not specified, it defaults to the namespace of the resource containing this reference.
   */
  namespace?: Maybe<Scalars['String']['output']>;
};

/**
 * ScopedRoleReference defines a reference to another Role, scoped by namespace.
 * This is used for purposes like role inheritance where a simple name and namespace
 * is sufficient to identify the target role.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Spec_InheritedRoles_Items_Input =
  {
    /** Name of the referenced Role. */
    name: Scalars['String']['input'];
    /**
     * Namespace of the referenced Role.
     * If not specified, it defaults to the namespace of the resource containing this reference.
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/** RoleStatus defines the observed state of Role */
export type Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Status = {
  /** Conditions provide conditions that represent the current status of the Role. */
  conditions?: Maybe<
    Array<Maybe<Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Status_Conditions_Items>>
  >;
  /**
   * EffectivePermissions is the complete flattened list of all permissions
   * granted by this role, including permissions from inheritedRoles and
   * directly specified includedPermissions. This is computed by the controller
   * and provides a single source of truth for all permissions this role grants.
   */
  effectivePermissions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** ObservedGeneration is the most recent generation observed by the controller. */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
  /** The resource name of the parent the role was created under. */
  parent?: Maybe<Scalars['String']['output']>;
};

/** RoleStatus defines the observed state of Role */
export type Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Status_Input = {
  /** Conditions provide conditions that represent the current status of the Role. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /**
   * EffectivePermissions is the complete flattened list of all permissions
   * granted by this role, including permissions from inheritedRoles and
   * directly specified includedPermissions. This is computed by the controller
   * and provides a single source of truth for all permissions this role grants.
   */
  effectivePermissions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** ObservedGeneration is the most recent generation observed by the controller. */
  observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
  /** The resource name of the parent the role was created under. */
  parent?: InputMaybe<Scalars['String']['input']>;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Status_Conditions_Items = {
  /**
   * lastTransitionTime is the last time the condition transitioned from one status to another.
   * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
   */
  lastTransitionTime: Scalars['DateTime']['output'];
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  message: Scalars['query_listIamMiloapisComV1alpha1NamespacedRole_items_items_status_conditions_items_message']['output'];
  /**
   * observedGeneration represents the .metadata.generation that the condition was set based upon.
   * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
   * with respect to the current state of the instance.
   */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
  reason: Scalars['query_listIamMiloapisComV1alpha1NamespacedRole_items_items_status_conditions_items_reason']['output'];
  status: Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Status_Conditions_Items_Status;
  type: Scalars['query_listIamMiloapisComV1alpha1NamespacedRole_items_items_status_conditions_items_type']['output'];
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1NamespacedRole_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1NamespacedRole_items_items_status_conditions_items_reason']['input'];
    status: Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1NamespacedRole_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListIamMiloapisComV1alpha1NamespacedRole_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** UserInvitationSpec defines the desired state of UserInvitation */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec = {
  /** The email of the user being invited. */
  email: Scalars['String']['output'];
  /**
   * ExpirationDate is the date and time when the UserInvitation will expire.
   * If not specified, the UserInvitation will never expire.
   */
  expirationDate?: Maybe<Scalars['DateTime']['output']>;
  /** The last name of the user being invited. */
  familyName?: Maybe<Scalars['String']['output']>;
  /** The first name of the user being invited. */
  givenName?: Maybe<Scalars['String']['output']>;
  invitedBy?: Maybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_InvitedBy>;
  organizationRef: Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_OrganizationRef;
  /** The roles that will be assigned to the user when they accept the invitation. */
  roles: Array<
    Maybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_Roles_Items>
  >;
  state: Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_State;
};

/** UserInvitationSpec defines the desired state of UserInvitation */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_Input = {
  /** The email of the user being invited. */
  email: Scalars['String']['input'];
  /**
   * ExpirationDate is the date and time when the UserInvitation will expire.
   * If not specified, the UserInvitation will never expire.
   */
  expirationDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** The last name of the user being invited. */
  familyName?: InputMaybe<Scalars['String']['input']>;
  /** The first name of the user being invited. */
  givenName?: InputMaybe<Scalars['String']['input']>;
  invitedBy?: InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_InvitedBy_Input>;
  organizationRef: Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_OrganizationRef_Input;
  /** The roles that will be assigned to the user when they accept the invitation. */
  roles: Array<
    InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_Roles_Items_Input>
  >;
  state: Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_State;
};

/** InvitedBy is the user who invited the user. A mutation webhook will default this field to the user who made the request. */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_InvitedBy = {
  /** Name is the name of the User being referenced. */
  name: Scalars['String']['output'];
};

/** InvitedBy is the user who invited the user. A mutation webhook will default this field to the user who made the request. */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_InvitedBy_Input =
  {
    /** Name is the name of the User being referenced. */
    name: Scalars['String']['input'];
  };

/** OrganizationRef is a reference to the Organization that the user is invoted to. */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_OrganizationRef =
  {
    /** Name is the name of resource being referenced */
    name: Scalars['String']['output'];
  };

/** OrganizationRef is a reference to the Organization that the user is invoted to. */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_OrganizationRef_Input =
  {
    /** Name is the name of resource being referenced */
    name: Scalars['String']['input'];
  };

/** RoleReference contains information that points to the Role being used */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_Roles_Items =
  {
    /** Name is the name of resource being referenced */
    name: Scalars['String']['output'];
    /** Namespace of the referenced Role. If empty, it is assumed to be in the PolicyBinding's namespace. */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/** RoleReference contains information that points to the Role being used */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_Roles_Items_Input =
  {
    /** Name is the name of resource being referenced */
    name: Scalars['String']['input'];
    /** Namespace of the referenced Role. If empty, it is assumed to be in the PolicyBinding's namespace. */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * State is the state of the UserInvitation. In order to accept the invitation, the invited user
 * must set the state to Accepted.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Spec_State =
  | 'Accepted'
  | 'Declined'
  | 'Pending';

/** UserInvitationStatus defines the observed state of UserInvitation */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status = {
  /** Conditions provide conditions that represent the current status of the UserInvitation. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_Conditions_Items>
    >
  >;
  inviteeUser?: Maybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_InviteeUser>;
  inviterUser?: Maybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_InviterUser>;
  organization?: Maybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_Organization>;
};

/** UserInvitationStatus defines the observed state of UserInvitation */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_Input = {
  /** Conditions provide conditions that represent the current status of the UserInvitation. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  inviteeUser?: InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_InviteeUser_Input>;
  inviterUser?: InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_InviterUser_Input>;
  organization?: InputMaybe<Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_Organization_Input>;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1NamespacedUserInvitation_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1NamespacedUserInvitation_items_items_status_conditions_items_reason']['output'];
    status: Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1NamespacedUserInvitation_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1NamespacedUserInvitation_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1NamespacedUserInvitation_items_items_status_conditions_items_reason']['input'];
    status: Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1NamespacedUserInvitation_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * InviteeUser contains information about the invitee user in the invitation.
 * This value may be nil if the invitee user has not been created yet.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_InviteeUser =
  {
    /**
     * Name is the name of the invitee user in the invitation.
     * Name is a cluster-scoped resource, so Namespace is not needed.
     */
    name: Scalars['String']['output'];
  };

/**
 * InviteeUser contains information about the invitee user in the invitation.
 * This value may be nil if the invitee user has not been created yet.
 */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_InviteeUser_Input =
  {
    /**
     * Name is the name of the invitee user in the invitation.
     * Name is a cluster-scoped resource, so Namespace is not needed.
     */
    name: Scalars['String']['input'];
  };

/** InviterUser contains information about the user who invited the user in the invitation. */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_InviterUser =
  {
    /** DisplayName is the display name of the user who invited the user in the invitation. */
    displayName?: Maybe<Scalars['String']['output']>;
    /** EmailAddress is the email address of the user who invited the user in the invitation. */
    emailAddress?: Maybe<Scalars['String']['output']>;
  };

/** InviterUser contains information about the user who invited the user in the invitation. */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_InviterUser_Input =
  {
    /** DisplayName is the display name of the user who invited the user in the invitation. */
    displayName?: InputMaybe<Scalars['String']['input']>;
    /** EmailAddress is the email address of the user who invited the user in the invitation. */
    emailAddress?: InputMaybe<Scalars['String']['input']>;
  };

/** Organization contains information about the organization in the invitation. */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_Organization =
  {
    /** DisplayName is the display name of the organization in the invitation. */
    displayName?: Maybe<Scalars['String']['output']>;
  };

/** Organization contains information about the organization in the invitation. */
export type Query_ListIamMiloapisComV1alpha1NamespacedUserInvitation_Items_Items_Status_Organization_Input =
  {
    /** DisplayName is the display name of the organization in the invitation. */
    displayName?: InputMaybe<Scalars['String']['input']>;
  };

/** PlatformAccessApprovalSpec defines the desired state of PlatformAccessApproval. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec = {
  approverRef?: Maybe<Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec_ApproverRef>;
  subjectRef: Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec_SubjectRef;
};

/** PlatformAccessApprovalSpec defines the desired state of PlatformAccessApproval. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec_Input = {
  approverRef?: InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec_ApproverRef_Input>;
  subjectRef: Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec_SubjectRef_Input;
};

/**
 * ApproverRef is the reference to the approver being approved.
 * If not specified, the approval was made by the system.
 */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec_ApproverRef = {
  /** Name is the name of the User being referenced. */
  name: Scalars['String']['output'];
};

/**
 * ApproverRef is the reference to the approver being approved.
 * If not specified, the approval was made by the system.
 */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec_ApproverRef_Input =
  {
    /** Name is the name of the User being referenced. */
    name: Scalars['String']['input'];
  };

/** SubjectRef is the reference to the subject being approved. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec_SubjectRef = {
  /**
   * Email is the email of the user being approved.
   * Use Email to approve an email address that is not associated with a created user. (e.g. when using PlatformInvitation)
   * UserRef and Email are mutually exclusive. Exactly one of them must be specified.
   */
  email?: Maybe<Scalars['String']['output']>;
  userRef?: Maybe<Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec_SubjectRef_UserRef>;
};

/** SubjectRef is the reference to the subject being approved. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec_SubjectRef_Input =
  {
    /**
     * Email is the email of the user being approved.
     * Use Email to approve an email address that is not associated with a created user. (e.g. when using PlatformInvitation)
     * UserRef and Email are mutually exclusive. Exactly one of them must be specified.
     */
    email?: InputMaybe<Scalars['String']['input']>;
    userRef?: InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec_SubjectRef_UserRef_Input>;
  };

/**
 * UserRef is the reference to the user being approved.
 * UserRef and Email are mutually exclusive. Exactly one of them must be specified.
 */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec_SubjectRef_UserRef =
  {
    /** Name is the name of the User being referenced. */
    name: Scalars['String']['output'];
  };

/**
 * UserRef is the reference to the user being approved.
 * UserRef and Email are mutually exclusive. Exactly one of them must be specified.
 */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessApproval_Items_Items_Spec_SubjectRef_UserRef_Input =
  {
    /** Name is the name of the User being referenced. */
    name: Scalars['String']['input'];
  };

/** PlatformAccessDenialSpec defines the desired state of PlatformAccessDenial. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec = {
  approverRef?: Maybe<Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec_ApproverRef>;
  subjectRef: Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec_SubjectRef;
};

/** PlatformAccessDenialSpec defines the desired state of PlatformAccessDenial. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec_Input = {
  approverRef?: InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec_ApproverRef_Input>;
  subjectRef: Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec_SubjectRef_Input;
};

/**
 * ApproverRef is the reference to the approver being approved.
 * If not specified, the approval was made by the system.
 */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec_ApproverRef = {
  /** Name is the name of the User being referenced. */
  name: Scalars['String']['output'];
};

/**
 * ApproverRef is the reference to the approver being approved.
 * If not specified, the approval was made by the system.
 */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec_ApproverRef_Input =
  {
    /** Name is the name of the User being referenced. */
    name: Scalars['String']['input'];
  };

/** SubjectRef is the reference to the subject being approved. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec_SubjectRef = {
  /**
   * Email is the email of the user being approved.
   * Use Email to approve an email address that is not associated with a created user. (e.g. when using PlatformInvitation)
   * UserRef and Email are mutually exclusive. Exactly one of them must be specified.
   */
  email?: Maybe<Scalars['String']['output']>;
  userRef?: Maybe<Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec_SubjectRef_UserRef>;
};

/** SubjectRef is the reference to the subject being approved. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec_SubjectRef_Input =
  {
    /**
     * Email is the email of the user being approved.
     * Use Email to approve an email address that is not associated with a created user. (e.g. when using PlatformInvitation)
     * UserRef and Email are mutually exclusive. Exactly one of them must be specified.
     */
    email?: InputMaybe<Scalars['String']['input']>;
    userRef?: InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec_SubjectRef_UserRef_Input>;
  };

/**
 * UserRef is the reference to the user being approved.
 * UserRef and Email are mutually exclusive. Exactly one of them must be specified.
 */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec_SubjectRef_UserRef =
  {
    /** Name is the name of the User being referenced. */
    name: Scalars['String']['output'];
  };

/**
 * UserRef is the reference to the user being approved.
 * UserRef and Email are mutually exclusive. Exactly one of them must be specified.
 */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Spec_SubjectRef_UserRef_Input =
  {
    /** Name is the name of the User being referenced. */
    name: Scalars['String']['input'];
  };

export type Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Status = {
  /** Conditions provide conditions that represent the current status of the PlatformAccessDenial. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Status_Conditions_Items>
    >
  >;
};

export type Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Status_Input = {
  /** Conditions provide conditions that represent the current status of the PlatformAccessDenial. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Status_Conditions_Items_Input>
    >
  >;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1PlatformAccessDenial_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1PlatformAccessDenial_items_items_status_conditions_items_reason']['output'];
    status: Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1PlatformAccessDenial_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1PlatformAccessDenial_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1PlatformAccessDenial_items_items_status_conditions_items_reason']['input'];
    status: Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1PlatformAccessDenial_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessDenial_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** PlatformAccessRejectionSpec defines the desired state of PlatformAccessRejection. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessRejection_Items_Items_Spec = {
  /** Reason is the reason for the rejection. */
  reason: Scalars['String']['output'];
  rejecterRef?: Maybe<Query_ListIamMiloapisComV1alpha1PlatformAccessRejection_Items_Items_Spec_RejecterRef>;
  subjectRef: Query_ListIamMiloapisComV1alpha1PlatformAccessRejection_Items_Items_Spec_SubjectRef;
};

/** PlatformAccessRejectionSpec defines the desired state of PlatformAccessRejection. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessRejection_Items_Items_Spec_Input = {
  /** Reason is the reason for the rejection. */
  reason: Scalars['String']['input'];
  rejecterRef?: InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformAccessRejection_Items_Items_Spec_RejecterRef_Input>;
  subjectRef: Query_ListIamMiloapisComV1alpha1PlatformAccessRejection_Items_Items_Spec_SubjectRef_Input;
};

/**
 * RejecterRef is the reference to the actor who issued the rejection.
 * If not specified, the rejection was made by the system.
 */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessRejection_Items_Items_Spec_RejecterRef = {
  /** Name is the name of the User being referenced. */
  name: Scalars['String']['output'];
};

/**
 * RejecterRef is the reference to the actor who issued the rejection.
 * If not specified, the rejection was made by the system.
 */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessRejection_Items_Items_Spec_RejecterRef_Input =
  {
    /** Name is the name of the User being referenced. */
    name: Scalars['String']['input'];
  };

/** UserRef is the reference to the user being rejected. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessRejection_Items_Items_Spec_SubjectRef = {
  /** Name is the name of the User being referenced. */
  name: Scalars['String']['output'];
};

/** UserRef is the reference to the user being rejected. */
export type Query_ListIamMiloapisComV1alpha1PlatformAccessRejection_Items_Items_Spec_SubjectRef_Input =
  {
    /** Name is the name of the User being referenced. */
    name: Scalars['String']['input'];
  };

/** PlatformInvitationSpec defines the desired state of PlatformInvitation. */
export type Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Spec = {
  /** The email of the user being invited. */
  email: Scalars['String']['output'];
  /** The family name of the user being invited. */
  familyName?: Maybe<Scalars['String']['output']>;
  /** The given name of the user being invited. */
  givenName?: Maybe<Scalars['String']['output']>;
  invitedBy?: Maybe<Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Spec_InvitedBy>;
  /**
   * The schedule at which the platform invitation will be sent.
   * It can only be updated before the platform invitation is sent.
   */
  scheduleAt?: Maybe<Scalars['DateTime']['output']>;
};

/** PlatformInvitationSpec defines the desired state of PlatformInvitation. */
export type Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Spec_Input = {
  /** The email of the user being invited. */
  email: Scalars['String']['input'];
  /** The family name of the user being invited. */
  familyName?: InputMaybe<Scalars['String']['input']>;
  /** The given name of the user being invited. */
  givenName?: InputMaybe<Scalars['String']['input']>;
  invitedBy?: InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Spec_InvitedBy_Input>;
  /**
   * The schedule at which the platform invitation will be sent.
   * It can only be updated before the platform invitation is sent.
   */
  scheduleAt?: InputMaybe<Scalars['DateTime']['input']>;
};

/** The user who created the platform invitation. A mutation webhook will default this field to the user who made the request. */
export type Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Spec_InvitedBy = {
  /** Name is the name of the User being referenced. */
  name: Scalars['String']['output'];
};

/** The user who created the platform invitation. A mutation webhook will default this field to the user who made the request. */
export type Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Spec_InvitedBy_Input = {
  /** Name is the name of the User being referenced. */
  name: Scalars['String']['input'];
};

/** PlatformInvitationStatus defines the observed state of PlatformInvitation. */
export type Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status = {
  /** Conditions provide conditions that represent the current status of the PlatformInvitation. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status_Conditions_Items>
    >
  >;
  email?: Maybe<Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status_Email>;
};

/** PlatformInvitationStatus defines the observed state of PlatformInvitation. */
export type Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status_Input = {
  /** Conditions provide conditions that represent the current status of the PlatformInvitation. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  email?: InputMaybe<Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status_Email_Input>;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1PlatformInvitation_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1PlatformInvitation_items_items_status_conditions_items_reason']['output'];
    status: Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1PlatformInvitation_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1PlatformInvitation_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1PlatformInvitation_items_items_status_conditions_items_reason']['input'];
    status: Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1PlatformInvitation_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** The email resource that was created for the platform invitation. */
export type Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status_Email = {
  /** The name of the email resource that was created for the platform invitation. */
  name?: Maybe<Scalars['String']['output']>;
  /** The namespace of the email resource that was created for the platform invitation. */
  namespace?: Maybe<Scalars['String']['output']>;
};

/** The email resource that was created for the platform invitation. */
export type Query_ListIamMiloapisComV1alpha1PlatformInvitation_Items_Items_Status_Email_Input = {
  /** The name of the email resource that was created for the platform invitation. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The namespace of the email resource that was created for the platform invitation. */
  namespace?: InputMaybe<Scalars['String']['input']>;
};

/** ProtectedResourceSpec defines the desired state of ProtectedResource */
export type Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Spec = {
  /**
   * The kind of the resource.
   * This will be in the format `Workload`.
   */
  kind: Scalars['String']['output'];
  /**
   * A list of resources that are registered with the platform that may be a
   * parent to the resource. Permissions may be bound to a parent resource so
   * they can be inherited down the resource hierarchy.
   */
  parentResources?: Maybe<
    Array<
      Maybe<Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Spec_ParentResources_Items>
    >
  >;
  /** A list of permissions that are associated with the resource. */
  permissions: Array<Maybe<Scalars['String']['output']>>;
  /**
   * The plural form for the resource type, e.g. 'workloads'. Must follow
   * camelCase format.
   */
  plural: Scalars['String']['output'];
  serviceRef: Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Spec_ServiceRef;
  /**
   * The singular form for the resource type, e.g. 'workload'. Must follow
   * camelCase format.
   */
  singular: Scalars['String']['output'];
};

/** ProtectedResourceSpec defines the desired state of ProtectedResource */
export type Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Spec_Input = {
  /**
   * The kind of the resource.
   * This will be in the format `Workload`.
   */
  kind: Scalars['String']['input'];
  /**
   * A list of resources that are registered with the platform that may be a
   * parent to the resource. Permissions may be bound to a parent resource so
   * they can be inherited down the resource hierarchy.
   */
  parentResources?: InputMaybe<
    Array<
      InputMaybe<Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Spec_ParentResources_Items_Input>
    >
  >;
  /** A list of permissions that are associated with the resource. */
  permissions: Array<InputMaybe<Scalars['String']['input']>>;
  /**
   * The plural form for the resource type, e.g. 'workloads'. Must follow
   * camelCase format.
   */
  plural: Scalars['String']['input'];
  serviceRef: Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Spec_ServiceRef_Input;
  /**
   * The singular form for the resource type, e.g. 'workload'. Must follow
   * camelCase format.
   */
  singular: Scalars['String']['input'];
};

/** ParentResourceRef defines the reference to a parent resource */
export type Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Spec_ParentResources_Items =
  {
    /**
     * APIGroup is the group for the resource being referenced.
     * If APIGroup is not specified, the specified Kind must be in the core API group.
     * For any other third-party types, APIGroup is required.
     */
    apiGroup?: Maybe<Scalars['String']['output']>;
    /** Kind is the type of resource being referenced. */
    kind: Scalars['String']['output'];
  };

/** ParentResourceRef defines the reference to a parent resource */
export type Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Spec_ParentResources_Items_Input =
  {
    /**
     * APIGroup is the group for the resource being referenced.
     * If APIGroup is not specified, the specified Kind must be in the core API group.
     * For any other third-party types, APIGroup is required.
     */
    apiGroup?: InputMaybe<Scalars['String']['input']>;
    /** Kind is the type of resource being referenced. */
    kind: Scalars['String']['input'];
  };

/** ServiceRef references the service definition this protected resource belongs to. */
export type Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Spec_ServiceRef = {
  /** Name is the resource name of the service definition. */
  name: Scalars['String']['output'];
};

/** ServiceRef references the service definition this protected resource belongs to. */
export type Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Spec_ServiceRef_Input = {
  /** Name is the resource name of the service definition. */
  name: Scalars['String']['input'];
};

/** ProtectedResourceStatus defines the observed state of ProtectedResource */
export type Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Status = {
  /** Conditions provide conditions that represent the current status of the ProtectedResource. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Status_Conditions_Items>
    >
  >;
  /**
   * ObservedGeneration is the most recent generation observed for this ProtectedResource. It corresponds to the
   * ProtectedResource's generation, which is updated on mutation by the API Server.
   */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
};

/** ProtectedResourceStatus defines the observed state of ProtectedResource */
export type Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Status_Input = {
  /** Conditions provide conditions that represent the current status of the ProtectedResource. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /**
   * ObservedGeneration is the most recent generation observed for this ProtectedResource. It corresponds to the
   * ProtectedResource's generation, which is updated on mutation by the API Server.
   */
  observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1ProtectedResource_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1ProtectedResource_items_items_status_conditions_items_reason']['output'];
    status: Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1ProtectedResource_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1ProtectedResource_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1ProtectedResource_items_items_status_conditions_items_reason']['input'];
    status: Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1ProtectedResource_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListIamMiloapisComV1alpha1ProtectedResource_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** UserDeactivationSpec defines the desired state of UserDeactivation */
export type Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Spec = {
  /** DeactivatedBy indicates who initiated the deactivation. */
  deactivatedBy: Scalars['String']['output'];
  /** Description provides detailed internal description for the deactivation. */
  description?: Maybe<Scalars['String']['output']>;
  /** Reason is the internal reason for deactivation. */
  reason: Scalars['String']['output'];
  userRef: Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Spec_UserRef;
};

/** UserDeactivationSpec defines the desired state of UserDeactivation */
export type Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Spec_Input = {
  /** DeactivatedBy indicates who initiated the deactivation. */
  deactivatedBy: Scalars['String']['input'];
  /** Description provides detailed internal description for the deactivation. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Reason is the internal reason for deactivation. */
  reason: Scalars['String']['input'];
  userRef: Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Spec_UserRef_Input;
};

/**
 * UserRef is a reference to the User being deactivated.
 * User is a cluster-scoped resource.
 */
export type Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Spec_UserRef = {
  /** Name is the name of the User being referenced. */
  name: Scalars['String']['output'];
};

/**
 * UserRef is a reference to the User being deactivated.
 * User is a cluster-scoped resource.
 */
export type Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Spec_UserRef_Input = {
  /** Name is the name of the User being referenced. */
  name: Scalars['String']['input'];
};

/** UserDeactivationStatus defines the observed state of UserDeactivation */
export type Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Status = {
  /** Conditions represent the latest available observations of an object's current state. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Status_Conditions_Items>
    >
  >;
};

/** UserDeactivationStatus defines the observed state of UserDeactivation */
export type Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Status_Input = {
  /** Conditions represent the latest available observations of an object's current state. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Status_Conditions_Items_Input>
    >
  >;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Status_Conditions_Items = {
  /**
   * lastTransitionTime is the last time the condition transitioned from one status to another.
   * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
   */
  lastTransitionTime: Scalars['DateTime']['output'];
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  message: Scalars['query_listIamMiloapisComV1alpha1UserDeactivation_items_items_status_conditions_items_message']['output'];
  /**
   * observedGeneration represents the .metadata.generation that the condition was set based upon.
   * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
   * with respect to the current state of the instance.
   */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
  reason: Scalars['query_listIamMiloapisComV1alpha1UserDeactivation_items_items_status_conditions_items_reason']['output'];
  status: Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Status_Conditions_Items_Status;
  type: Scalars['query_listIamMiloapisComV1alpha1UserDeactivation_items_items_status_conditions_items_type']['output'];
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1UserDeactivation_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1UserDeactivation_items_items_status_conditions_items_reason']['input'];
    status: Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1UserDeactivation_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListIamMiloapisComV1alpha1UserDeactivation_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** UserPreferenceSpec defines the desired state of UserPreference */
export type Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Spec = {
  theme?: Maybe<Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Spec_Theme>;
  userRef: Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Spec_UserRef;
};

/** UserPreferenceSpec defines the desired state of UserPreference */
export type Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Spec_Input = {
  theme?: InputMaybe<Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Spec_Theme>;
  userRef: Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Spec_UserRef_Input;
};

/** The user's theme preference. */
export type Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Spec_Theme =
  | 'dark'
  | 'light'
  | 'system';

/** Reference to the user these preferences belong to. */
export type Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Spec_UserRef = {
  /** Name is the name of the User being referenced. */
  name: Scalars['String']['output'];
};

/** Reference to the user these preferences belong to. */
export type Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Spec_UserRef_Input = {
  /** Name is the name of the User being referenced. */
  name: Scalars['String']['input'];
};

/** UserPreferenceStatus defines the observed state of UserPreference */
export type Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Status = {
  /** Conditions provide conditions that represent the current status of the UserPreference. */
  conditions?: Maybe<
    Array<Maybe<Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Status_Conditions_Items>>
  >;
};

/** UserPreferenceStatus defines the observed state of UserPreference */
export type Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Status_Input = {
  /** Conditions provide conditions that represent the current status of the UserPreference. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Status_Conditions_Items_Input>
    >
  >;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Status_Conditions_Items = {
  /**
   * lastTransitionTime is the last time the condition transitioned from one status to another.
   * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
   */
  lastTransitionTime: Scalars['DateTime']['output'];
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  message: Scalars['query_listIamMiloapisComV1alpha1UserPreference_items_items_status_conditions_items_message']['output'];
  /**
   * observedGeneration represents the .metadata.generation that the condition was set based upon.
   * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
   * with respect to the current state of the instance.
   */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
  reason: Scalars['query_listIamMiloapisComV1alpha1UserPreference_items_items_status_conditions_items_reason']['output'];
  status: Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Status_Conditions_Items_Status;
  type: Scalars['query_listIamMiloapisComV1alpha1UserPreference_items_items_status_conditions_items_type']['output'];
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listIamMiloapisComV1alpha1UserPreference_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listIamMiloapisComV1alpha1UserPreference_items_items_status_conditions_items_reason']['input'];
    status: Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listIamMiloapisComV1alpha1UserPreference_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListIamMiloapisComV1alpha1UserPreference_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** UserSpec defines the desired state of User */
export type Query_ListIamMiloapisComV1alpha1User_Items_Items_Spec = {
  /** The email of the user. */
  email: Scalars['String']['output'];
  /** The last name of the user. */
  familyName?: Maybe<Scalars['String']['output']>;
  /** The first name of the user. */
  givenName?: Maybe<Scalars['String']['output']>;
};

/** UserSpec defines the desired state of User */
export type Query_ListIamMiloapisComV1alpha1User_Items_Items_Spec_Input = {
  /** The email of the user. */
  email: Scalars['String']['input'];
  /** The last name of the user. */
  familyName?: InputMaybe<Scalars['String']['input']>;
  /** The first name of the user. */
  givenName?: InputMaybe<Scalars['String']['input']>;
};

/** UserStatus defines the observed state of User */
export type Query_ListIamMiloapisComV1alpha1User_Items_Items_Status = {
  /**
   * AvatarURL points to the avatar image associated with the user. This value is
   * populated by the auth provider or any service that provides a user avatar URL.
   */
  avatarUrl?: Maybe<Scalars['URL']['output']>;
  /** Conditions provide conditions that represent the current status of the User. */
  conditions?: Maybe<
    Array<Maybe<Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_Conditions_Items>>
  >;
  /**
   * LastLoginProvider records the identity provider that was most recently used by the
   * user to log in (e.g., "github" or "google"). This field is set by the auth provider
   * based on authentication events.
   */
  lastLoginProvider?: Maybe<Scalars['String']['output']>;
  registrationApproval?: Maybe<Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_RegistrationApproval>;
  state?: Maybe<Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_State>;
};

/** UserStatus defines the observed state of User */
export type Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_Input = {
  /**
   * AvatarURL points to the avatar image associated with the user. This value is
   * populated by the auth provider or any service that provides a user avatar URL.
   */
  avatarUrl?: InputMaybe<Scalars['URL']['input']>;
  /** Conditions provide conditions that represent the current status of the User. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /**
   * LastLoginProvider records the identity provider that was most recently used by the
   * user to log in (e.g., "github" or "google"). This field is set by the auth provider
   * based on authentication events.
   */
  lastLoginProvider?: InputMaybe<Scalars['String']['input']>;
  registrationApproval?: InputMaybe<Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_RegistrationApproval>;
  state?: InputMaybe<Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_State>;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_Conditions_Items = {
  /**
   * lastTransitionTime is the last time the condition transitioned from one status to another.
   * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
   */
  lastTransitionTime: Scalars['DateTime']['output'];
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  message: Scalars['query_listIamMiloapisComV1alpha1User_items_items_status_conditions_items_message']['output'];
  /**
   * observedGeneration represents the .metadata.generation that the condition was set based upon.
   * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
   * with respect to the current state of the instance.
   */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
  reason: Scalars['query_listIamMiloapisComV1alpha1User_items_items_status_conditions_items_reason']['output'];
  status: Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_Conditions_Items_Status;
  type: Scalars['query_listIamMiloapisComV1alpha1User_items_items_status_conditions_items_type']['output'];
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_Conditions_Items_Input = {
  /**
   * lastTransitionTime is the last time the condition transitioned from one status to another.
   * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
   */
  lastTransitionTime: Scalars['DateTime']['input'];
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   */
  message: Scalars['query_listIamMiloapisComV1alpha1User_items_items_status_conditions_items_message']['input'];
  /**
   * observedGeneration represents the .metadata.generation that the condition was set based upon.
   * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
   * with respect to the current state of the instance.
   */
  observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
  reason: Scalars['query_listIamMiloapisComV1alpha1User_items_items_status_conditions_items_reason']['input'];
  status: Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_Conditions_Items_Status;
  type: Scalars['query_listIamMiloapisComV1alpha1User_items_items_status_conditions_items_type']['input'];
};

/** status of the condition, one of True, False, Unknown. */
export type Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_Conditions_Items_Status =
  | 'False'
  | 'True'
  | 'Unknown';

/**
 * RegistrationApproval represents the administrators decision on the users registration request.
 * States:
 *   - Pending:  The user is awaiting review by an administrator.
 *   - Approved: The user registration has been approved.
 *   - Rejected: The user registration has been rejected.
 * The User resource is always created regardless of this value, but the
 * ability for the person to sign into the platform and access resources is
 * governed by this status: only *Approved* users are granted access, while
 * *Pending* and *Rejected* users are prevented for interacting with resources.
 */
export type Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_RegistrationApproval =
  | 'Approved'
  | 'Pending'
  | 'Rejected';

/**
 * State represents the current activation state of the user account from the
 * auth provider. This field is managed exclusively by the UserDeactivation CRD
 * and cannot be changed directly by the user. When a UserDeactivation resource
 * is created for the user, the user is deactivated in the auth provider; when
 * the UserDeactivation is deleted, the user is reactivated.
 * States:
 *   - Active: The user can be used to authenticate.
 *   - Inactive: The user is prohibited to be used to authenticate, and revokes all existing sessions.
 */
export type Query_ListIamMiloapisComV1alpha1User_Items_Items_Status_State = 'Active' | 'Inactive';

/** Spec defines the desired state of a ConnectorAdvertisement */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec =
  {
    connectorRef: Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_ConnectorRef;
    /** Layer 4 services being advertised. */
    layer4?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_Layer4_Items>
      >
    >;
  };

/** Spec defines the desired state of a ConnectorAdvertisement */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_Input =
  {
    connectorRef: Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_ConnectorRef_Input;
    /** Layer 4 services being advertised. */
    layer4?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_Layer4_Items_Input>
      >
    >;
  };

/** ConnectorRef references the Connector being advertised. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_ConnectorRef =
  {
    /** Name of the referenced Connector. */
    name: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_spec_connectorRef_name']['output'];
  };

/** ConnectorRef references the Connector being advertised. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_ConnectorRef_Input =
  {
    /** Name of the referenced Connector. */
    name: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_spec_connectorRef_name']['input'];
  };

export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_Layer4_Items =
  {
    /** Name of the advertisement. */
    name: Scalars['String']['output'];
    /** Layer 4 services being advertised. */
    services: Array<
      Maybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_Layer4_Items_Services_Items>
    >;
  };

export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_Layer4_Items_Input =
  {
    /** Name of the advertisement. */
    name: Scalars['String']['input'];
    /** Layer 4 services being advertised. */
    services: Array<
      InputMaybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_Layer4_Items_Services_Items_Input>
    >;
  };

export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_Layer4_Items_Services_Items =
  {
    /**
     * Address of the service.
     *
     * Can be an IPv4, IPv6, or a DNS address. A DNS address may contain
     * wildcards. A DNS address acts as an allow list for what addresses the
     * connector will allow to be requested through it.
     *
     * DNS resolution is the responsibility of the connector.
     */
    address: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_spec_layer4_items_services_items_address']['output'];
    /** Ports of the service. */
    ports: Array<
      Maybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_Layer4_Items_Services_Items_Ports_Items>
    >;
  };

export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_Layer4_Items_Services_Items_Input =
  {
    /**
     * Address of the service.
     *
     * Can be an IPv4, IPv6, or a DNS address. A DNS address may contain
     * wildcards. A DNS address acts as an allow list for what addresses the
     * connector will allow to be requested through it.
     *
     * DNS resolution is the responsibility of the connector.
     */
    address: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_spec_layer4_items_services_items_address']['input'];
    /** Ports of the service. */
    ports: Array<
      InputMaybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_Layer4_Items_Services_Items_Ports_Items_Input>
    >;
  };

/** Layer4ServicePort represents a port for a Layer 4 service. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_Layer4_Items_Services_Items_Ports_Items =
  {
    /** Named port for the service. */
    name: Scalars['String']['output'];
    /** Port number for the service. */
    port: Scalars['Int']['output'];
    /** Protocol for port. Must be TCP or UDP, defaults to "TCP". */
    protocol: Scalars['String']['output'];
  };

/** Layer4ServicePort represents a port for a Layer 4 service. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Spec_Layer4_Items_Services_Items_Ports_Items_Input =
  {
    /** Named port for the service. */
    name: Scalars['String']['input'];
    /** Port number for the service. */
    port: Scalars['Int']['input'];
    /** Protocol for port. Must be TCP or UDP, defaults to "TCP". */
    protocol?: Scalars['String']['input'];
  };

/** Status defines the observed state of a ConnectorAdvertisement */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Status =
  {
    /**
     * Conditions describe the current conditions of the ConnectorAdvertisement.
     *
     * Known conditions:
     * - Accepted: indicates whether the referenced Connector has been resolved.
     *   When Accepted is False, the reason will explain why the reference
     *   could not be resolved (for example, ConnectorNotFound).
     */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Status_Conditions_Items>
      >
    >;
  };

/** Status defines the observed state of a ConnectorAdvertisement */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * Conditions describe the current conditions of the ConnectorAdvertisement.
     *
     * Known conditions:
     * - Accepted: indicates whether the referenced Connector has been resolved.
     *   When Accepted is False, the reason will explain why the reference
     *   could not be resolved (for example, ConnectorNotFound).
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorAdvertisementForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** Spec defines the desired state of a ConnectorClass */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorClassForAllNamespaces_Items_Items_Spec =
  {
    /** ControllerName is the name of the controller responsible for this ConnectorClass. */
    controllerName: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorClassForAllNamespaces_items_items_spec_controllerName']['output'];
  };

/** Spec defines the desired state of a ConnectorClass */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorClassForAllNamespaces_Items_Items_Spec_Input =
  {
    /** ControllerName is the name of the controller responsible for this ConnectorClass. */
    controllerName?: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorClassForAllNamespaces_items_items_spec_controllerName']['input'];
  };

/** Spec defines the desired state of a Connector */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Spec = {
  /**
   * Capabilities desired to be supported by the connector.
   *
   * A connector may choose to not support all requested capabilities, and may
   * also choose to support additional capabilities not requested here. The
   * condition of each capability will reflect whether the capability is supported
   * or not in the ConnectorStatus.
   */
  capabilities?: Maybe<
    Array<
      Maybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Spec_Capabilities_Items>
    >
  >;
  connectorClassName: Scalars['NonEmptyString']['output'];
};

/** Spec defines the desired state of a Connector */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Spec_Input =
  {
    /**
     * Capabilities desired to be supported by the connector.
     *
     * A connector may choose to not support all requested capabilities, and may
     * also choose to support additional capabilities not requested here. The
     * condition of each capability will reflect whether the capability is supported
     * or not in the ConnectorStatus.
     */
    capabilities?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Spec_Capabilities_Items_Input>
      >
    >;
    connectorClassName: Scalars['NonEmptyString']['input'];
  };

export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Spec_Capabilities_Items =
  {
    connectTCP?: Maybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Spec_Capabilities_Items_ConnectTcp>;
    /** Type of capability */
    type: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_spec_capabilities_items_type']['output'];
  };

export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Spec_Capabilities_Items_Input =
  {
    connectTCP?: InputMaybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Spec_Capabilities_Items_ConnectTcp_Input>;
    /** Type of capability */
    type: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_spec_capabilities_items_type']['input'];
  };

export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Spec_Capabilities_Items_ConnectTcp =
  {
    disabled?: Maybe<Scalars['Boolean']['output']>;
  };

export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Spec_Capabilities_Items_ConnectTcp_Input =
  {
    disabled?: InputMaybe<Scalars['Boolean']['input']>;
  };

/** Status defines the observed state of a Connector */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status = {
  /** Capabilities describe the status of each capability of the connector. */
  capabilities?: Maybe<
    Array<
      Maybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Capabilities_Items>
    >
  >;
  /** Conditions describe the current conditions of the HTTPProxy. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
  connectionDetails?: Maybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_ConnectionDetails>;
  leaseRef?: Maybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_LeaseRef>;
};

/** Status defines the observed state of a Connector */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Input =
  {
    /** Capabilities describe the status of each capability of the connector. */
    capabilities?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Capabilities_Items_Input>
      >
    >;
    /** Conditions describe the current conditions of the HTTPProxy. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    connectionDetails?: InputMaybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_ConnectionDetails_Input>;
    leaseRef?: InputMaybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_LeaseRef_Input>;
  };

export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Capabilities_Items =
  {
    /** Conditions describe the current conditions of the capability. */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Capabilities_Items_Conditions_Items>
      >
    >;
    /** Type of capability */
    type: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_capabilities_items_type']['output'];
  };

export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Capabilities_Items_Input =
  {
    /** Conditions describe the current conditions of the capability. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Capabilities_Items_Conditions_Items_Input>
      >
    >;
    /** Type of capability */
    type: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_capabilities_items_type']['input'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Capabilities_Items_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_capabilities_items_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_capabilities_items_conditions_items_reason']['output'];
    status: Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Capabilities_Items_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_capabilities_items_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Capabilities_Items_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_capabilities_items_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_capabilities_items_conditions_items_reason']['input'];
    status: Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Capabilities_Items_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_capabilities_items_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Capabilities_Items_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** ConnectionDetails provide details on how to connect to the connector. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_ConnectionDetails =
  {
    publicKey?: Maybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_ConnectionDetails_PublicKey>;
    type: PublicKey_Const;
  };

/** ConnectionDetails provide details on how to connect to the connector. */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_ConnectionDetails_Input =
  {
    publicKey?: InputMaybe<Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_ConnectionDetails_PublicKey_Input>;
    type: PublicKey_Const;
  };

/** PublicKey connection details */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_ConnectionDetails_PublicKey =
  {
    /** Addresses where the connector can be reached */
    addresses: Array<
      Maybe<
        Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_connectionDetails_publicKey_addresses_items']['output']
      >
    >;
    discoveryMode?: Maybe<Dns_Const>;
    /**
     * Home Relay server of the connector
     *
     * Must be a valid URL
     */
    homeRelay: Scalars['String']['output'];
    /** The public key to dial and connect to */
    id?: Maybe<Scalars['String']['output']>;
  };

/** PublicKey connection details */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_ConnectionDetails_PublicKey_Input =
  {
    /** Addresses where the connector can be reached */
    addresses: Array<
      InputMaybe<
        Scalars['query_listNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_items_items_status_connectionDetails_publicKey_addresses_items']['input']
      >
    >;
    discoveryMode?: InputMaybe<Dns_Const>;
    /**
     * Home Relay server of the connector
     *
     * Must be a valid URL
     */
    homeRelay: Scalars['String']['input'];
    /** The public key to dial and connect to */
    id?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * LeaseRef references the Lease used to report connector liveness.
 *
 * The connector controller creates the Lease when a Connector is created
 * and records it here. Connector implementations (agents) are expected to
 * periodically renew the Lease to indicate liveness.
 */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_LeaseRef =
  {
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: Maybe<Scalars['String']['output']>;
  };

/**
 * LeaseRef references the Lease used to report connector liveness.
 *
 * The connector controller creates the Lease when a Connector is created
 * and records it here. Connector implementations (agents) are expected to
 * periodically renew the Lease to indicate liveness.
 */
export type Query_ListNetworkingDatumapisComV1alpha1ConnectorForAllNamespaces_Items_Items_Status_LeaseRef_Input =
  {
    /**
     * Name of the referent.
     * This field is effectively required, but due to backwards compatibility is
     * allowed to be empty. Instances of this type with an empty value here are
     * almost certainly wrong.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
     */
    name?: InputMaybe<Scalars['String']['input']>;
  };

/** DomainSpec defines the desired state of Domain */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Spec = {
  /** DesiredRegistrationRefreshAttempt is the desired time of the next registration refresh attempt. */
  desiredRegistrationRefreshAttempt?: Maybe<Scalars['DateTime']['output']>;
  domainName: Scalars['query_listNetworkingDatumapisComV1alphaDomainForAllNamespaces_items_items_spec_domainName']['output'];
};

/** DomainSpec defines the desired state of Domain */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Spec_Input = {
  /** DesiredRegistrationRefreshAttempt is the desired time of the next registration refresh attempt. */
  desiredRegistrationRefreshAttempt?: InputMaybe<Scalars['DateTime']['input']>;
  domainName: Scalars['query_listNetworkingDatumapisComV1alphaDomainForAllNamespaces_items_items_spec_domainName']['input'];
};

/** DomainStatus defines the observed state of Domain */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status = {
  /** Apex is true when spec.domainName is the registered domain (eTLD+1). */
  apex?: Maybe<Scalars['Boolean']['output']>;
  conditions?: Maybe<
    Array<
      Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
  /**
   * Nameservers lists the authoritative NS for the *effective* domain name:
   * - If Apex == true: taken from RDAP for the registered domain (eTLD+1)
   * - If Apex == false: taken from DNS delegation for the subdomain; falls back to apex NS if no cut
   */
  nameservers?: Maybe<
    Array<
      Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Nameservers_Items>
    >
  >;
  registration?: Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration>;
  verification?: Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Verification>;
};

/** DomainStatus defines the observed state of Domain */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Input =
  {
    /** Apex is true when spec.domainName is the registered domain (eTLD+1). */
    apex?: InputMaybe<Scalars['Boolean']['input']>;
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /**
     * Nameservers lists the authoritative NS for the *effective* domain name:
     * - If Apex == true: taken from RDAP for the registered domain (eTLD+1)
     * - If Apex == false: taken from DNS delegation for the subdomain; falls back to apex NS if no cut
     */
    nameservers?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Nameservers_Items_Input>
      >
    >;
    registration?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Input>;
    verification?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Verification_Input>;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaDomainForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaDomainForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaDomainForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaDomainForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaDomainForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaDomainForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Nameservers_Items =
  {
    hostname: Scalars['String']['output'];
    ips?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Nameservers_Items_Ips_Items>
      >
    >;
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Nameservers_Items_Input =
  {
    hostname: Scalars['String']['input'];
    ips?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Nameservers_Items_Ips_Items_Input>
      >
    >;
  };

/** NameserverIP captures per-address provenance for a nameserver. */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Nameservers_Items_Ips_Items =
  {
    address: Scalars['String']['output'];
    registrantName?: Maybe<Scalars['String']['output']>;
  };

/** NameserverIP captures per-address provenance for a nameserver. */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Nameservers_Items_Ips_Items_Input =
  {
    address: Scalars['String']['input'];
    registrantName?: InputMaybe<Scalars['String']['input']>;
  };

/** Registration represents the registration information for a domain */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration =
  {
    abuse?: Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Abuse>;
    contacts?: Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts>;
    /** Lifecycle */
    createdAt?: Maybe<Scalars['DateTime']['output']>;
    dnssec?: Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Dnssec>;
    /** Identity & provenance */
    domain?: Maybe<Scalars['String']['output']>;
    expiresAt?: Maybe<Scalars['DateTime']['output']>;
    handle?: Maybe<Scalars['String']['output']>;
    lastRefreshAttempt?: Maybe<Scalars['DateTime']['output']>;
    nextRefreshAttempt?: Maybe<Scalars['DateTime']['output']>;
    registrar?: Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Registrar>;
    registry?: Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Registry>;
    registryDomainID?: Maybe<Scalars['String']['output']>;
    source?: Maybe<Scalars['String']['output']>;
    /** Raw statuses that will either be rdap rfc8056 or whois EPP status strings */
    statuses?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    updatedAt?: Maybe<Scalars['DateTime']['output']>;
  };

/** Registration represents the registration information for a domain */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Input =
  {
    abuse?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Abuse_Input>;
    contacts?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts_Input>;
    /** Lifecycle */
    createdAt?: InputMaybe<Scalars['DateTime']['input']>;
    dnssec?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Dnssec_Input>;
    /** Identity & provenance */
    domain?: InputMaybe<Scalars['String']['input']>;
    expiresAt?: InputMaybe<Scalars['DateTime']['input']>;
    handle?: InputMaybe<Scalars['String']['input']>;
    lastRefreshAttempt?: InputMaybe<Scalars['DateTime']['input']>;
    nextRefreshAttempt?: InputMaybe<Scalars['DateTime']['input']>;
    registrar?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Registrar_Input>;
    registry?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Registry_Input>;
    registryDomainID?: InputMaybe<Scalars['String']['input']>;
    source?: InputMaybe<Scalars['String']['input']>;
    /** Raw statuses that will either be rdap rfc8056 or whois EPP status strings */
    statuses?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  };

/** Abuse / support contacts (registrar/registry) */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Abuse =
  {
    email?: Maybe<Scalars['String']['output']>;
    phone?: Maybe<Scalars['String']['output']>;
  };

/** Abuse / support contacts (registrar/registry) */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Abuse_Input =
  {
    email?: InputMaybe<Scalars['String']['input']>;
    phone?: InputMaybe<Scalars['String']['input']>;
  };

/** Contacts (minimal, non-PII summary if available) */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts =
  {
    admin?: Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts_Admin>;
    registrant?: Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts_Registrant>;
    tech?: Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts_Tech>;
  };

/** Contacts (minimal, non-PII summary if available) */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts_Input =
  {
    admin?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts_Admin_Input>;
    registrant?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts_Registrant_Input>;
    tech?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts_Tech_Input>;
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts_Admin =
  {
    email?: Maybe<Scalars['String']['output']>;
    organization?: Maybe<Scalars['String']['output']>;
    phone?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts_Admin_Input =
  {
    email?: InputMaybe<Scalars['String']['input']>;
    organization?: InputMaybe<Scalars['String']['input']>;
    phone?: InputMaybe<Scalars['String']['input']>;
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts_Registrant =
  {
    email?: Maybe<Scalars['String']['output']>;
    organization?: Maybe<Scalars['String']['output']>;
    phone?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts_Registrant_Input =
  {
    email?: InputMaybe<Scalars['String']['input']>;
    organization?: InputMaybe<Scalars['String']['input']>;
    phone?: InputMaybe<Scalars['String']['input']>;
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts_Tech =
  {
    email?: Maybe<Scalars['String']['output']>;
    organization?: Maybe<Scalars['String']['output']>;
    phone?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Contacts_Tech_Input =
  {
    email?: InputMaybe<Scalars['String']['input']>;
    organization?: InputMaybe<Scalars['String']['input']>;
    phone?: InputMaybe<Scalars['String']['input']>;
  };

/** DNSSEC (from RDAP secureDNS, with WHOIS fallback when parsable) */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Dnssec =
  {
    ds?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Dnssec_Ds_Items>
      >
    >;
    enabled?: Maybe<Scalars['Boolean']['output']>;
  };

/** DNSSEC (from RDAP secureDNS, with WHOIS fallback when parsable) */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Dnssec_Input =
  {
    ds?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Dnssec_Ds_Items_Input>
      >
    >;
    enabled?: InputMaybe<Scalars['Boolean']['input']>;
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Dnssec_Ds_Items =
  {
    algorithm: Scalars['Int']['output'];
    digest: Scalars['String']['output'];
    digestType: Scalars['Int']['output'];
    keyTag: Scalars['Int']['output'];
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Dnssec_Ds_Items_Input =
  {
    algorithm: Scalars['Int']['input'];
    digest: Scalars['String']['input'];
    digestType: Scalars['Int']['input'];
    keyTag: Scalars['Int']['input'];
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Registrar =
  {
    ianaID?: Maybe<Scalars['String']['output']>;
    name?: Maybe<Scalars['String']['output']>;
    url?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Registrar_Input =
  {
    ianaID?: InputMaybe<Scalars['String']['input']>;
    name?: InputMaybe<Scalars['String']['input']>;
    url?: InputMaybe<Scalars['String']['input']>;
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Registry =
  {
    name?: Maybe<Scalars['String']['output']>;
    url?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Registration_Registry_Input =
  {
    name?: InputMaybe<Scalars['String']['input']>;
    url?: InputMaybe<Scalars['String']['input']>;
  };

/** DomainVerificationStatus represents the verification status of a domain */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Verification =
  {
    dnsRecord?: Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Verification_DnsRecord>;
    httpToken?: Maybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Verification_HttpToken>;
    nextVerificationAttempt?: Maybe<Scalars['DateTime']['output']>;
  };

/** DomainVerificationStatus represents the verification status of a domain */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Verification_Input =
  {
    dnsRecord?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Verification_DnsRecord_Input>;
    httpToken?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Verification_HttpToken_Input>;
    nextVerificationAttempt?: InputMaybe<Scalars['DateTime']['input']>;
  };

/** DNSVerificationRecord represents a DNS record required for verification */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Verification_DnsRecord =
  {
    content: Scalars['String']['output'];
    name: Scalars['String']['output'];
    type: Scalars['String']['output'];
  };

/** DNSVerificationRecord represents a DNS record required for verification */
export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Verification_DnsRecord_Input =
  {
    content: Scalars['String']['input'];
    name: Scalars['String']['input'];
    type: Scalars['String']['input'];
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Verification_HttpToken =
  {
    body: Scalars['String']['output'];
    url: Scalars['String']['output'];
  };

export type Query_ListNetworkingDatumapisComV1alphaDomainForAllNamespaces_Items_Items_Status_Verification_HttpToken_Input =
  {
    body: Scalars['String']['input'];
    url: Scalars['String']['input'];
  };

/** Spec defines the desired state of an HTTPProxy. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec = {
  /**
   * Hostnames defines a set of hostnames that should match against the HTTP
   * Host header to select a HTTPProxy used to process the request.
   *
   * Valid values for Hostnames are determined by RFC 1123 definition of a
   * hostname with 1 notable exception:
   *
   * 1. IPs are not allowed.
   *
   * Hostnames must be verified before being programmed. This is accomplished
   * via the use of `Domain` resources. A hostname is considered verified if any
   * verified `Domain` resource exists in the same namespace where the
   * `spec.domainName` of the resource either exactly matches the hostname, or
   * is a suffix match of the hostname. That means that a Domain with a
   * `spec.domainName` of `example.com` will match a hostname of
   * `test.example.com`, `foo.test.example.com`, and exactly `example.com`, but
   * not a hostname of `test-example.com`. If a `Domain` resource does not exist
   * that matches a hostname, one will automatically be created when the system
   * attempts to program the HTTPProxy.
   *
   * In addition to verifying ownership, hostnames must be unique across the
   * platform. If a hostname is already programmed on another resource, a
   * conflict will be encountered and communicated in the `HostnamesVerified`
   * condition.
   *
   * Hostnames which have been programmed will be listed in the
   * `status.hostnames` field. Any hostname which has not been programmed will
   * be listed in the `message` field of the `HostnamesVerified` condition with
   * an indication as to why it was not programmed.
   *
   * The system may automatically generate and associate hostnames with the
   * HTTPProxy. In such cases, these will be listed in the `status.hostnames`
   * field and do not require additional configuration by the user.
   *
   * Wildcard hostnames are not supported at this time.
   */
  hostnames?: Maybe<
    Array<
      Maybe<
        Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_hostnames_items']['output']
      >
    >
  >;
  /** Rules are a list of HTTP matchers, filters and actions. */
  rules: Array<
    Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items>
  >;
};

/** Spec defines the desired state of an HTTPProxy. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Input =
  {
    /**
     * Hostnames defines a set of hostnames that should match against the HTTP
     * Host header to select a HTTPProxy used to process the request.
     *
     * Valid values for Hostnames are determined by RFC 1123 definition of a
     * hostname with 1 notable exception:
     *
     * 1. IPs are not allowed.
     *
     * Hostnames must be verified before being programmed. This is accomplished
     * via the use of `Domain` resources. A hostname is considered verified if any
     * verified `Domain` resource exists in the same namespace where the
     * `spec.domainName` of the resource either exactly matches the hostname, or
     * is a suffix match of the hostname. That means that a Domain with a
     * `spec.domainName` of `example.com` will match a hostname of
     * `test.example.com`, `foo.test.example.com`, and exactly `example.com`, but
     * not a hostname of `test-example.com`. If a `Domain` resource does not exist
     * that matches a hostname, one will automatically be created when the system
     * attempts to program the HTTPProxy.
     *
     * In addition to verifying ownership, hostnames must be unique across the
     * platform. If a hostname is already programmed on another resource, a
     * conflict will be encountered and communicated in the `HostnamesVerified`
     * condition.
     *
     * Hostnames which have been programmed will be listed in the
     * `status.hostnames` field. Any hostname which has not been programmed will
     * be listed in the `message` field of the `HostnamesVerified` condition with
     * an indication as to why it was not programmed.
     *
     * The system may automatically generate and associate hostnames with the
     * HTTPProxy. In such cases, these will be listed in the `status.hostnames`
     * field and do not require additional configuration by the user.
     *
     * Wildcard hostnames are not supported at this time.
     */
    hostnames?: InputMaybe<
      Array<
        InputMaybe<
          Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_hostnames_items']['input']
        >
      >
    >;
    /** Rules are a list of HTTP matchers, filters and actions. */
    rules: Array<
      InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Input>
    >;
  };

/**
 * HTTPProxyRule defines semantics for matching an HTTP request based on
 * conditions (matches), processing it (filters), and forwarding the request to
 * backends.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items =
  {
    /**
     * Backends defines the backend(s) where matching requests should be
     * sent.
     *
     * Note: While this field is a list, only a single element is permitted at
     * this time due to underlying Gateway limitations. Once addressed, MaxItems
     * will be increased to allow for multiple backends on any given route.
     */
    backends?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items>
      >
    >;
    /**
     * Filters define the filters that are applied to requests that match
     * this rule.
     *
     * See documentation for the `filters` field in the `HTTPRouteRule` type at
     * https://gateway-api.sigs.k8s.io/reference/spec/#httprouterule
     */
    filters?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items>
      >
    >;
    /**
     * Matches define conditions used for matching the rule against incoming
     * HTTP requests. Each match is independent, i.e. this rule will be matched
     * if **any** one of the matches is satisfied.
     *
     * See documentation for the `matches` field in the `HTTPRouteRule` type at
     * https://gateway-api.sigs.k8s.io/reference/spec/#httprouterule
     */
    matches?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items>
      >
    >;
    name?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_name']['output']
    >;
  };

/**
 * HTTPProxyRule defines semantics for matching an HTTP request based on
 * conditions (matches), processing it (filters), and forwarding the request to
 * backends.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Input =
  {
    /**
     * Backends defines the backend(s) where matching requests should be
     * sent.
     *
     * Note: While this field is a list, only a single element is permitted at
     * this time due to underlying Gateway limitations. Once addressed, MaxItems
     * will be increased to allow for multiple backends on any given route.
     */
    backends?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Input>
      >
    >;
    /**
     * Filters define the filters that are applied to requests that match
     * this rule.
     *
     * See documentation for the `filters` field in the `HTTPRouteRule` type at
     * https://gateway-api.sigs.k8s.io/reference/spec/#httprouterule
     */
    filters?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Input>
      >
    >;
    /**
     * Matches define conditions used for matching the rule against incoming
     * HTTP requests. Each match is independent, i.e. this rule will be matched
     * if **any** one of the matches is satisfied.
     *
     * See documentation for the `matches` field in the `HTTPRouteRule` type at
     * https://gateway-api.sigs.k8s.io/reference/spec/#httprouterule
     */
    matches?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Input>
      >
    >;
    name?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_name']['input']
    >;
  };

export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items =
  {
    connector?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Connector>;
    /**
     * Endpoint for the backend. Must be a valid URL.
     *
     * Supports http and https protocols, IPs or DNS addresses in the host, custom
     * ports, and paths.
     */
    endpoint: Scalars['String']['output'];
    /**
     * Filters defined at this level should be executed if and only if the
     * request is being forwarded to the backend defined here.
     */
    filters?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items>
      >
    >;
  };

export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Input =
  {
    connector?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Connector_Input>;
    /**
     * Endpoint for the backend. Must be a valid URL.
     *
     * Supports http and https protocols, IPs or DNS addresses in the host, custom
     * ports, and paths.
     */
    endpoint: Scalars['String']['input'];
    /**
     * Filters defined at this level should be executed if and only if the
     * request is being forwarded to the backend defined here.
     */
    filters?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_Input>
      >
    >;
  };

/**
 * Connector references the Connector that should be used for this backend.
 *
 * For now, only a name reference is supported. In the future this can be
 * extended to selector-based matching to allow multiple connectors.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Connector =
  {
    /** Name of the referenced Connector. */
    name: Scalars['String']['output'];
  };

/**
 * Connector references the Connector that should be used for this backend.
 *
 * For now, only a name reference is supported. In the future this can be
 * extended to selector-based matching to allow multiple connectors.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Connector_Input =
  {
    /** Name of the referenced Connector. */
    name: Scalars['String']['input'];
  };

/**
 * HTTPRouteFilter defines processing steps that must be completed during the
 * request or response lifecycle. HTTPRouteFilters are meant as an extension
 * point to express processing that may be done in Gateway implementations. Some
 * examples include request or response modification, implementing
 * authentication strategies, rate-limiting, and traffic shaping. API
 * guarantee/conformance is defined based on the type of the filter.
 *
 * <gateway:experimental:validation:XValidation:message="filter.cors must be nil if the filter.type is not CORS",rule="!(has(self.cors) && self.type != 'CORS')">
 * <gateway:experimental:validation:XValidation:message="filter.cors must be specified for CORS filter.type",rule="!(!has(self.cors) && self.type == 'CORS')">
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items =
  {
    cors?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_Cors>;
    extensionRef?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ExtensionRef>;
    requestHeaderModifier?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestHeaderModifier>;
    requestMirror?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestMirror>;
    requestRedirect?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect>;
    responseHeaderModifier?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ResponseHeaderModifier>;
    type: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_Type;
    urlRewrite?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_UrlRewrite>;
  };

/**
 * HTTPRouteFilter defines processing steps that must be completed during the
 * request or response lifecycle. HTTPRouteFilters are meant as an extension
 * point to express processing that may be done in Gateway implementations. Some
 * examples include request or response modification, implementing
 * authentication strategies, rate-limiting, and traffic shaping. API
 * guarantee/conformance is defined based on the type of the filter.
 *
 * <gateway:experimental:validation:XValidation:message="filter.cors must be nil if the filter.type is not CORS",rule="!(has(self.cors) && self.type != 'CORS')">
 * <gateway:experimental:validation:XValidation:message="filter.cors must be specified for CORS filter.type",rule="!(!has(self.cors) && self.type == 'CORS')">
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_Input =
  {
    cors?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_Cors_Input>;
    extensionRef?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ExtensionRef_Input>;
    requestHeaderModifier?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestHeaderModifier_Input>;
    requestMirror?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestMirror_Input>;
    requestRedirect?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_Input>;
    responseHeaderModifier?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ResponseHeaderModifier_Input>;
    type: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_Type;
    urlRewrite?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_UrlRewrite_Input>;
  };

/**
 * CORS defines a schema for a filter that responds to the
 * cross-origin request based on HTTP response header.
 *
 * Support: Extended
 *
 * <gateway:experimental>
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_Cors =
  {
    /**
     * AllowCredentials indicates whether the actual cross-origin request allows
     * to include credentials.
     *
     * The only valid value for the `Access-Control-Allow-Credentials` response
     * header is true (case-sensitive).
     *
     * If the credentials are not allowed in cross-origin requests, the gateway
     * will omit the header `Access-Control-Allow-Credentials` entirely rather
     * than setting its value to false.
     *
     * Support: Extended
     */
    allowCredentials?: Maybe<Scalars['Boolean']['output']>;
    /**
     * AllowHeaders indicates which HTTP request headers are supported for
     * accessing the requested resource.
     *
     * Header names are not case sensitive.
     *
     * Multiple header names in the value of the `Access-Control-Allow-Headers`
     * response header are separated by a comma (",").
     *
     * When the `AllowHeaders` field is configured with one or more headers, the
     * gateway must return the `Access-Control-Allow-Headers` response header
     * which value is present in the `AllowHeaders` field.
     *
     * If any header name in the `Access-Control-Request-Headers` request header
     * is not included in the list of header names specified by the response
     * header `Access-Control-Allow-Headers`, it will present an error on the
     * client side.
     *
     * If any header name in the `Access-Control-Allow-Headers` response header
     * does not recognize by the client, it will also occur an error on the
     * client side.
     *
     * A wildcard indicates that the requests with all HTTP headers are allowed.
     * The `Access-Control-Allow-Headers` response header can only use `*`
     * wildcard as value when the `AllowCredentials` field is unspecified.
     *
     * When the `AllowCredentials` field is specified and `AllowHeaders` field
     * specified with the `*` wildcard, the gateway must specify one or more
     * HTTP headers in the value of the `Access-Control-Allow-Headers` response
     * header. The value of the header `Access-Control-Allow-Headers` is same as
     * the `Access-Control-Request-Headers` header provided by the client. If
     * the header `Access-Control-Request-Headers` is not included in the
     * request, the gateway will omit the `Access-Control-Allow-Headers`
     * response header, instead of specifying the `*` wildcard. A Gateway
     * implementation may choose to add implementation-specific default headers.
     *
     * Support: Extended
     */
    allowHeaders?: Maybe<
      Array<
        Maybe<
          Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_cors_allowHeaders_items']['output']
        >
      >
    >;
    /**
     * AllowMethods indicates which HTTP methods are supported for accessing the
     * requested resource.
     *
     * Valid values are any method defined by RFC9110, along with the special
     * value `*`, which represents all HTTP methods are allowed.
     *
     * Method names are case sensitive, so these values are also case-sensitive.
     * (See https://www.rfc-editor.org/rfc/rfc2616#section-5.1.1)
     *
     * Multiple method names in the value of the `Access-Control-Allow-Methods`
     * response header are separated by a comma (",").
     *
     * A CORS-safelisted method is a method that is `GET`, `HEAD`, or `POST`.
     * (See https://fetch.spec.whatwg.org/#cors-safelisted-method) The
     * CORS-safelisted methods are always allowed, regardless of whether they
     * are specified in the `AllowMethods` field.
     *
     * When the `AllowMethods` field is configured with one or more methods, the
     * gateway must return the `Access-Control-Allow-Methods` response header
     * which value is present in the `AllowMethods` field.
     *
     * If the HTTP method of the `Access-Control-Request-Method` request header
     * is not included in the list of methods specified by the response header
     * `Access-Control-Allow-Methods`, it will present an error on the client
     * side.
     *
     * The `Access-Control-Allow-Methods` response header can only use `*`
     * wildcard as value when the `AllowCredentials` field is unspecified.
     *
     * When the `AllowCredentials` field is specified and `AllowMethods` field
     * specified with the `*` wildcard, the gateway must specify one HTTP method
     * in the value of the Access-Control-Allow-Methods response header. The
     * value of the header `Access-Control-Allow-Methods` is same as the
     * `Access-Control-Request-Method` header provided by the client. If the
     * header `Access-Control-Request-Method` is not included in the request,
     * the gateway will omit the `Access-Control-Allow-Methods` response header,
     * instead of specifying the `*` wildcard. A Gateway implementation may
     * choose to add implementation-specific default methods.
     *
     * Support: Extended
     */
    allowMethods?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_Cors_AllowMethods_Items>
      >
    >;
    /**
     * AllowOrigins indicates whether the response can be shared with requested
     * resource from the given `Origin`.
     *
     * The `Origin` consists of a scheme and a host, with an optional port, and
     * takes the form `<scheme>://<host>(:<port>)`.
     *
     * Valid values for scheme are: `http` and `https`.
     *
     * Valid values for port are any integer between 1 and 65535 (the list of
     * available TCP/UDP ports). Note that, if not included, port `80` is
     * assumed for `http` scheme origins, and port `443` is assumed for `https`
     * origins. This may affect origin matching.
     *
     * The host part of the origin may contain the wildcard character `*`. These
     * wildcard characters behave as follows:
     *
     * * `*` is a greedy match to the _left_, including any number of
     *   DNS labels to the left of its position. This also means that
     *   `*` will include any number of period `.` characters to the
     *   left of its position.
     * * A wildcard by itself matches all hosts.
     *
     * An origin value that includes _only_ the `*` character indicates requests
     * from all `Origin`s are allowed.
     *
     * When the `AllowOrigins` field is configured with multiple origins, it
     * means the server supports clients from multiple origins. If the request
     * `Origin` matches the configured allowed origins, the gateway must return
     * the given `Origin` and sets value of the header
     * `Access-Control-Allow-Origin` same as the `Origin` header provided by the
     * client.
     *
     * The status code of a successful response to a "preflight" request is
     * always an OK status (i.e., 204 or 200).
     *
     * If the request `Origin` does not match the configured allowed origins,
     * the gateway returns 204/200 response but doesn't set the relevant
     * cross-origin response headers. Alternatively, the gateway responds with
     * 403 status to the "preflight" request is denied, coupled with omitting
     * the CORS headers. The cross-origin request fails on the client side.
     * Therefore, the client doesn't attempt the actual cross-origin request.
     *
     * The `Access-Control-Allow-Origin` response header can only use `*`
     * wildcard as value when the `AllowCredentials` field is unspecified.
     *
     * When the `AllowCredentials` field is specified and `AllowOrigins` field
     * specified with the `*` wildcard, the gateway must return a single origin
     * in the value of the `Access-Control-Allow-Origin` response header,
     * instead of specifying the `*` wildcard. The value of the header
     * `Access-Control-Allow-Origin` is same as the `Origin` header provided by
     * the client.
     *
     * Support: Extended
     */
    allowOrigins?: Maybe<
      Array<
        Maybe<
          Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_cors_allowOrigins_items']['output']
        >
      >
    >;
    /**
     * ExposeHeaders indicates which HTTP response headers can be exposed
     * to client-side scripts in response to a cross-origin request.
     *
     * A CORS-safelisted response header is an HTTP header in a CORS response
     * that it is considered safe to expose to the client scripts.
     * The CORS-safelisted response headers include the following headers:
     * `Cache-Control`
     * `Content-Language`
     * `Content-Length`
     * `Content-Type`
     * `Expires`
     * `Last-Modified`
     * `Pragma`
     * (See https://fetch.spec.whatwg.org/#cors-safelisted-response-header-name)
     * The CORS-safelisted response headers are exposed to client by default.
     *
     * When an HTTP header name is specified using the `ExposeHeaders` field,
     * this additional header will be exposed as part of the response to the
     * client.
     *
     * Header names are not case sensitive.
     *
     * Multiple header names in the value of the `Access-Control-Expose-Headers`
     * response header are separated by a comma (",").
     *
     * A wildcard indicates that the responses with all HTTP headers are exposed
     * to clients. The `Access-Control-Expose-Headers` response header can only
     * use `*` wildcard as value when the `AllowCredentials` field is
     * unspecified.
     *
     * Support: Extended
     */
    exposeHeaders?: Maybe<
      Array<
        Maybe<
          Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_cors_exposeHeaders_items']['output']
        >
      >
    >;
    /**
     * MaxAge indicates the duration (in seconds) for the client to cache the
     * results of a "preflight" request.
     *
     * The information provided by the `Access-Control-Allow-Methods` and
     * `Access-Control-Allow-Headers` response headers can be cached by the
     * client until the time specified by `Access-Control-Max-Age` elapses.
     *
     * The default value of `Access-Control-Max-Age` response header is 5
     * (seconds).
     */
    maxAge?: Maybe<Scalars['Int']['output']>;
  };

/**
 * CORS defines a schema for a filter that responds to the
 * cross-origin request based on HTTP response header.
 *
 * Support: Extended
 *
 * <gateway:experimental>
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_Cors_Input =
  {
    /**
     * AllowCredentials indicates whether the actual cross-origin request allows
     * to include credentials.
     *
     * The only valid value for the `Access-Control-Allow-Credentials` response
     * header is true (case-sensitive).
     *
     * If the credentials are not allowed in cross-origin requests, the gateway
     * will omit the header `Access-Control-Allow-Credentials` entirely rather
     * than setting its value to false.
     *
     * Support: Extended
     */
    allowCredentials?: InputMaybe<Scalars['Boolean']['input']>;
    /**
     * AllowHeaders indicates which HTTP request headers are supported for
     * accessing the requested resource.
     *
     * Header names are not case sensitive.
     *
     * Multiple header names in the value of the `Access-Control-Allow-Headers`
     * response header are separated by a comma (",").
     *
     * When the `AllowHeaders` field is configured with one or more headers, the
     * gateway must return the `Access-Control-Allow-Headers` response header
     * which value is present in the `AllowHeaders` field.
     *
     * If any header name in the `Access-Control-Request-Headers` request header
     * is not included in the list of header names specified by the response
     * header `Access-Control-Allow-Headers`, it will present an error on the
     * client side.
     *
     * If any header name in the `Access-Control-Allow-Headers` response header
     * does not recognize by the client, it will also occur an error on the
     * client side.
     *
     * A wildcard indicates that the requests with all HTTP headers are allowed.
     * The `Access-Control-Allow-Headers` response header can only use `*`
     * wildcard as value when the `AllowCredentials` field is unspecified.
     *
     * When the `AllowCredentials` field is specified and `AllowHeaders` field
     * specified with the `*` wildcard, the gateway must specify one or more
     * HTTP headers in the value of the `Access-Control-Allow-Headers` response
     * header. The value of the header `Access-Control-Allow-Headers` is same as
     * the `Access-Control-Request-Headers` header provided by the client. If
     * the header `Access-Control-Request-Headers` is not included in the
     * request, the gateway will omit the `Access-Control-Allow-Headers`
     * response header, instead of specifying the `*` wildcard. A Gateway
     * implementation may choose to add implementation-specific default headers.
     *
     * Support: Extended
     */
    allowHeaders?: InputMaybe<
      Array<
        InputMaybe<
          Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_cors_allowHeaders_items']['input']
        >
      >
    >;
    /**
     * AllowMethods indicates which HTTP methods are supported for accessing the
     * requested resource.
     *
     * Valid values are any method defined by RFC9110, along with the special
     * value `*`, which represents all HTTP methods are allowed.
     *
     * Method names are case sensitive, so these values are also case-sensitive.
     * (See https://www.rfc-editor.org/rfc/rfc2616#section-5.1.1)
     *
     * Multiple method names in the value of the `Access-Control-Allow-Methods`
     * response header are separated by a comma (",").
     *
     * A CORS-safelisted method is a method that is `GET`, `HEAD`, or `POST`.
     * (See https://fetch.spec.whatwg.org/#cors-safelisted-method) The
     * CORS-safelisted methods are always allowed, regardless of whether they
     * are specified in the `AllowMethods` field.
     *
     * When the `AllowMethods` field is configured with one or more methods, the
     * gateway must return the `Access-Control-Allow-Methods` response header
     * which value is present in the `AllowMethods` field.
     *
     * If the HTTP method of the `Access-Control-Request-Method` request header
     * is not included in the list of methods specified by the response header
     * `Access-Control-Allow-Methods`, it will present an error on the client
     * side.
     *
     * The `Access-Control-Allow-Methods` response header can only use `*`
     * wildcard as value when the `AllowCredentials` field is unspecified.
     *
     * When the `AllowCredentials` field is specified and `AllowMethods` field
     * specified with the `*` wildcard, the gateway must specify one HTTP method
     * in the value of the Access-Control-Allow-Methods response header. The
     * value of the header `Access-Control-Allow-Methods` is same as the
     * `Access-Control-Request-Method` header provided by the client. If the
     * header `Access-Control-Request-Method` is not included in the request,
     * the gateway will omit the `Access-Control-Allow-Methods` response header,
     * instead of specifying the `*` wildcard. A Gateway implementation may
     * choose to add implementation-specific default methods.
     *
     * Support: Extended
     */
    allowMethods?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_Cors_AllowMethods_Items>
      >
    >;
    /**
     * AllowOrigins indicates whether the response can be shared with requested
     * resource from the given `Origin`.
     *
     * The `Origin` consists of a scheme and a host, with an optional port, and
     * takes the form `<scheme>://<host>(:<port>)`.
     *
     * Valid values for scheme are: `http` and `https`.
     *
     * Valid values for port are any integer between 1 and 65535 (the list of
     * available TCP/UDP ports). Note that, if not included, port `80` is
     * assumed for `http` scheme origins, and port `443` is assumed for `https`
     * origins. This may affect origin matching.
     *
     * The host part of the origin may contain the wildcard character `*`. These
     * wildcard characters behave as follows:
     *
     * * `*` is a greedy match to the _left_, including any number of
     *   DNS labels to the left of its position. This also means that
     *   `*` will include any number of period `.` characters to the
     *   left of its position.
     * * A wildcard by itself matches all hosts.
     *
     * An origin value that includes _only_ the `*` character indicates requests
     * from all `Origin`s are allowed.
     *
     * When the `AllowOrigins` field is configured with multiple origins, it
     * means the server supports clients from multiple origins. If the request
     * `Origin` matches the configured allowed origins, the gateway must return
     * the given `Origin` and sets value of the header
     * `Access-Control-Allow-Origin` same as the `Origin` header provided by the
     * client.
     *
     * The status code of a successful response to a "preflight" request is
     * always an OK status (i.e., 204 or 200).
     *
     * If the request `Origin` does not match the configured allowed origins,
     * the gateway returns 204/200 response but doesn't set the relevant
     * cross-origin response headers. Alternatively, the gateway responds with
     * 403 status to the "preflight" request is denied, coupled with omitting
     * the CORS headers. The cross-origin request fails on the client side.
     * Therefore, the client doesn't attempt the actual cross-origin request.
     *
     * The `Access-Control-Allow-Origin` response header can only use `*`
     * wildcard as value when the `AllowCredentials` field is unspecified.
     *
     * When the `AllowCredentials` field is specified and `AllowOrigins` field
     * specified with the `*` wildcard, the gateway must return a single origin
     * in the value of the `Access-Control-Allow-Origin` response header,
     * instead of specifying the `*` wildcard. The value of the header
     * `Access-Control-Allow-Origin` is same as the `Origin` header provided by
     * the client.
     *
     * Support: Extended
     */
    allowOrigins?: InputMaybe<
      Array<
        InputMaybe<
          Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_cors_allowOrigins_items']['input']
        >
      >
    >;
    /**
     * ExposeHeaders indicates which HTTP response headers can be exposed
     * to client-side scripts in response to a cross-origin request.
     *
     * A CORS-safelisted response header is an HTTP header in a CORS response
     * that it is considered safe to expose to the client scripts.
     * The CORS-safelisted response headers include the following headers:
     * `Cache-Control`
     * `Content-Language`
     * `Content-Length`
     * `Content-Type`
     * `Expires`
     * `Last-Modified`
     * `Pragma`
     * (See https://fetch.spec.whatwg.org/#cors-safelisted-response-header-name)
     * The CORS-safelisted response headers are exposed to client by default.
     *
     * When an HTTP header name is specified using the `ExposeHeaders` field,
     * this additional header will be exposed as part of the response to the
     * client.
     *
     * Header names are not case sensitive.
     *
     * Multiple header names in the value of the `Access-Control-Expose-Headers`
     * response header are separated by a comma (",").
     *
     * A wildcard indicates that the responses with all HTTP headers are exposed
     * to clients. The `Access-Control-Expose-Headers` response header can only
     * use `*` wildcard as value when the `AllowCredentials` field is
     * unspecified.
     *
     * Support: Extended
     */
    exposeHeaders?: InputMaybe<
      Array<
        InputMaybe<
          Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_cors_exposeHeaders_items']['input']
        >
      >
    >;
    /**
     * MaxAge indicates the duration (in seconds) for the client to cache the
     * results of a "preflight" request.
     *
     * The information provided by the `Access-Control-Allow-Methods` and
     * `Access-Control-Allow-Headers` response headers can be cached by the
     * client until the time specified by `Access-Control-Max-Age` elapses.
     *
     * The default value of `Access-Control-Max-Age` response header is 5
     * (seconds).
     */
    maxAge?: InputMaybe<Scalars['Int']['input']>;
  };

export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_Cors_AllowMethods_Items =
  'CONNECT' | 'DELETE' | 'GET' | 'HEAD' | 'OPTIONS' | 'PATCH' | 'POST' | 'PUT' | 'TRACE' | '_STAR_';

/**
 * ExtensionRef is an optional, implementation-specific extension to the
 * "filter" behavior.  For example, resource "myroutefilter" in group
 * "networking.example.net"). ExtensionRef MUST NOT be used for core and
 * extended filters.
 *
 * This filter can be used multiple times within the same rule.
 *
 * Support: Implementation-specific
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ExtensionRef =
  {
    group: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_extensionRef_group']['output'];
    kind: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_extensionRef_kind']['output'];
    /** Name is the name of the referent. */
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_extensionRef_name']['output'];
  };

/**
 * ExtensionRef is an optional, implementation-specific extension to the
 * "filter" behavior.  For example, resource "myroutefilter" in group
 * "networking.example.net"). ExtensionRef MUST NOT be used for core and
 * extended filters.
 *
 * This filter can be used multiple times within the same rule.
 *
 * Support: Implementation-specific
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ExtensionRef_Input =
  {
    group: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_extensionRef_group']['input'];
    kind: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_extensionRef_kind']['input'];
    /** Name is the name of the referent. */
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_extensionRef_name']['input'];
  };

/**
 * RequestHeaderModifier defines a schema for a filter that modifies request
 * headers.
 *
 * Support: Core
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestHeaderModifier =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestHeaderModifier_Add_Items>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestHeaderModifier_Set_Items>
      >
    >;
  };

/**
 * RequestHeaderModifier defines a schema for a filter that modifies request
 * headers.
 *
 * Support: Core
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestHeaderModifier_Input =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestHeaderModifier_Add_Items_Input>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestHeaderModifier_Set_Items_Input>
      >
    >;
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestHeaderModifier_Add_Items =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestHeaderModifier_add_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestHeaderModifier_add_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestHeaderModifier_Add_Items_Input =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestHeaderModifier_add_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestHeaderModifier_add_items_value']['input'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestHeaderModifier_Set_Items =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestHeaderModifier_set_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestHeaderModifier_set_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestHeaderModifier_Set_Items_Input =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestHeaderModifier_set_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestHeaderModifier_set_items_value']['input'];
  };

/**
 * RequestMirror defines a schema for a filter that mirrors requests.
 * Requests are sent to the specified destination, but responses from
 * that destination are ignored.
 *
 * This filter can be used multiple times within the same rule. Note that
 * not all implementations will be able to support mirroring to multiple
 * backends.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestMirror =
  {
    backendRef: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestMirror_BackendRef;
    fraction?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestMirror_Fraction>;
    /**
     * Percent represents the percentage of requests that should be
     * mirrored to BackendRef. Its minimum value is 0 (indicating 0% of
     * requests) and its maximum value is 100 (indicating 100% of requests).
     *
     * Only one of Fraction or Percent may be specified. If neither field
     * is specified, 100% of requests will be mirrored.
     */
    percent?: Maybe<Scalars['Int']['output']>;
  };

/**
 * RequestMirror defines a schema for a filter that mirrors requests.
 * Requests are sent to the specified destination, but responses from
 * that destination are ignored.
 *
 * This filter can be used multiple times within the same rule. Note that
 * not all implementations will be able to support mirroring to multiple
 * backends.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestMirror_Input =
  {
    backendRef: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestMirror_BackendRef_Input;
    fraction?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestMirror_Fraction_Input>;
    /**
     * Percent represents the percentage of requests that should be
     * mirrored to BackendRef. Its minimum value is 0 (indicating 0% of
     * requests) and its maximum value is 100 (indicating 100% of requests).
     *
     * Only one of Fraction or Percent may be specified. If neither field
     * is specified, 100% of requests will be mirrored.
     */
    percent?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * BackendRef references a resource where mirrored requests are sent.
 *
 * Mirrored requests must be sent only to a single destination endpoint
 * within this BackendRef, irrespective of how many endpoints are present
 * within this BackendRef.
 *
 * If the referent cannot be found, this BackendRef is invalid and must be
 * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
 * condition on the Route status is set to `status: False` and not configure
 * this backend in the underlying implementation.
 *
 * If there is a cross-namespace reference to an *existing* object
 * that is not allowed by a ReferenceGrant, the controller must ensure the
 * "ResolvedRefs"  condition on the Route is set to `status: False`,
 * with the "RefNotPermitted" reason and not configure this backend in the
 * underlying implementation.
 *
 * In either error case, the Message of the `ResolvedRefs` Condition
 * should be used to provide more detail about the problem.
 *
 * Support: Extended for Kubernetes Service
 *
 * Support: Implementation-specific for any other resource
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestMirror_BackendRef =
  {
    group?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestMirror_backendRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestMirror_backendRef_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestMirror_backendRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestMirror_backendRef_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
  };

/**
 * BackendRef references a resource where mirrored requests are sent.
 *
 * Mirrored requests must be sent only to a single destination endpoint
 * within this BackendRef, irrespective of how many endpoints are present
 * within this BackendRef.
 *
 * If the referent cannot be found, this BackendRef is invalid and must be
 * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
 * condition on the Route status is set to `status: False` and not configure
 * this backend in the underlying implementation.
 *
 * If there is a cross-namespace reference to an *existing* object
 * that is not allowed by a ReferenceGrant, the controller must ensure the
 * "ResolvedRefs"  condition on the Route is set to `status: False`,
 * with the "RefNotPermitted" reason and not configure this backend in the
 * underlying implementation.
 *
 * In either error case, the Message of the `ResolvedRefs` Condition
 * should be used to provide more detail about the problem.
 *
 * Support: Extended for Kubernetes Service
 *
 * Support: Implementation-specific for any other resource
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestMirror_BackendRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestMirror_backendRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestMirror_backendRef_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestMirror_backendRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestMirror_backendRef_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * Fraction represents the fraction of requests that should be
 * mirrored to BackendRef.
 *
 * Only one of Fraction or Percent may be specified. If neither field
 * is specified, 100% of requests will be mirrored.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestMirror_Fraction =
  {
    denominator?: Maybe<Scalars['Int']['output']>;
    numerator: Scalars['Int']['output'];
  };

/**
 * Fraction represents the fraction of requests that should be
 * mirrored to BackendRef.
 *
 * Only one of Fraction or Percent may be specified. If neither field
 * is specified, 100% of requests will be mirrored.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestMirror_Fraction_Input =
  {
    denominator?: InputMaybe<Scalars['Int']['input']>;
    numerator: Scalars['Int']['input'];
  };

/**
 * RequestRedirect defines a schema for a filter that responds to the
 * request with an HTTP redirection.
 *
 * Support: Core
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect =
  {
    hostname?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestRedirect_hostname']['output']
    >;
    path?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_Path>;
    /**
     * Port is the port to be used in the value of the `Location`
     * header in the response.
     *
     * If no port is specified, the redirect port MUST be derived using the
     * following rules:
     *
     * * If redirect scheme is not-empty, the redirect port MUST be the well-known
     *   port associated with the redirect scheme. Specifically "http" to port 80
     *   and "https" to port 443. If the redirect scheme does not have a
     *   well-known port, the listener port of the Gateway SHOULD be used.
     * * If redirect scheme is empty, the redirect port MUST be the Gateway
     *   Listener port.
     *
     * Implementations SHOULD NOT add the port number in the 'Location'
     * header in the following cases:
     *
     * * A Location header that will use HTTP (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 80.
     * * A Location header that will use HTTPS (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 443.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    scheme?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_Scheme>;
    statusCode?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_StatusCode>;
  };

/**
 * RequestRedirect defines a schema for a filter that responds to the
 * request with an HTTP redirection.
 *
 * Support: Core
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestRedirect_hostname']['input']
    >;
    path?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_Path_Input>;
    /**
     * Port is the port to be used in the value of the `Location`
     * header in the response.
     *
     * If no port is specified, the redirect port MUST be derived using the
     * following rules:
     *
     * * If redirect scheme is not-empty, the redirect port MUST be the well-known
     *   port associated with the redirect scheme. Specifically "http" to port 80
     *   and "https" to port 443. If the redirect scheme does not have a
     *   well-known port, the listener port of the Gateway SHOULD be used.
     * * If redirect scheme is empty, the redirect port MUST be the Gateway
     *   Listener port.
     *
     * Implementations SHOULD NOT add the port number in the 'Location'
     * header in the following cases:
     *
     * * A Location header that will use HTTP (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 80.
     * * A Location header that will use HTTPS (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 443.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    scheme?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_Scheme>;
    statusCode?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_StatusCode>;
  };

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_Path =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestRedirect_path_replaceFullPath']['output']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestRedirect_path_replacePrefixMatch']['output']
    >;
    type: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_Path_Type;
  };

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_Path_Input =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestRedirect_path_replaceFullPath']['input']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_requestRedirect_path_replacePrefixMatch']['input']
    >;
    type: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_Path_Type;
  };

/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_Path_Type =
  'ReplaceFullPath' | 'ReplacePrefixMatch';

/**
 * Scheme is the scheme to be used in the value of the `Location` header in
 * the response. When empty, the scheme of the request is used.
 *
 * Scheme redirects can affect the port of the redirect, for more information,
 * refer to the documentation for the port field of this filter.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_Scheme =
  'http' | 'https';

/**
 * StatusCode is the HTTP status code to be used in response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Core
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_RequestRedirect_StatusCode =
  '_301' | '_302';

/**
 * ResponseHeaderModifier defines a schema for a filter that modifies response
 * headers.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ResponseHeaderModifier =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ResponseHeaderModifier_Add_Items>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ResponseHeaderModifier_Set_Items>
      >
    >;
  };

/**
 * ResponseHeaderModifier defines a schema for a filter that modifies response
 * headers.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ResponseHeaderModifier_Input =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ResponseHeaderModifier_Add_Items_Input>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ResponseHeaderModifier_Set_Items_Input>
      >
    >;
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ResponseHeaderModifier_Add_Items =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_responseHeaderModifier_add_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_responseHeaderModifier_add_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ResponseHeaderModifier_Add_Items_Input =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_responseHeaderModifier_add_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_responseHeaderModifier_add_items_value']['input'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ResponseHeaderModifier_Set_Items =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_responseHeaderModifier_set_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_responseHeaderModifier_set_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_ResponseHeaderModifier_Set_Items_Input =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_responseHeaderModifier_set_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_responseHeaderModifier_set_items_value']['input'];
  };

/**
 * Type identifies the type of filter to apply. As with other API fields,
 * types are classified into three conformance levels:
 *
 * - Core: Filter types and their corresponding configuration defined by
 *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
 *   implementations must support core filters.
 *
 * - Extended: Filter types and their corresponding configuration defined by
 *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
 *   are encouraged to support extended filters.
 *
 * - Implementation-specific: Filters that are defined and supported by
 *   specific vendors.
 *   In the future, filters showing convergence in behavior across multiple
 *   implementations will be considered for inclusion in extended or core
 *   conformance levels. Filter-specific configuration for such filters
 *   is specified using the ExtensionRef field. `Type` should be set to
 *   "ExtensionRef" for custom filters.
 *
 * Implementers are encouraged to define custom implementation types to
 * extend the core API with implementation-specific behavior.
 *
 * If a reference to a custom filter type cannot be resolved, the filter
 * MUST NOT be skipped. Instead, requests that would have been processed by
 * that filter MUST receive a HTTP error response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * <gateway:experimental:validation:Enum=RequestHeaderModifier;ResponseHeaderModifier;RequestMirror;RequestRedirect;URLRewrite;ExtensionRef;CORS>
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_Type =

    | 'ExtensionRef'
    | 'RequestHeaderModifier'
    | 'RequestMirror'
    | 'RequestRedirect'
    | 'ResponseHeaderModifier'
    | 'URLRewrite';

/**
 * URLRewrite defines a schema for a filter that modifies a request during forwarding.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_UrlRewrite =
  {
    hostname?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_urlRewrite_hostname']['output']
    >;
    path?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_UrlRewrite_Path>;
  };

/**
 * URLRewrite defines a schema for a filter that modifies a request during forwarding.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_UrlRewrite_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_urlRewrite_hostname']['input']
    >;
    path?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_UrlRewrite_Path_Input>;
  };

/**
 * Path defines a path rewrite.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_UrlRewrite_Path =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_urlRewrite_path_replaceFullPath']['output']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_urlRewrite_path_replacePrefixMatch']['output']
    >;
    type: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_UrlRewrite_Path_Type;
  };

/**
 * Path defines a path rewrite.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_UrlRewrite_Path_Input =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_urlRewrite_path_replaceFullPath']['input']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_backends_items_filters_items_urlRewrite_path_replacePrefixMatch']['input']
    >;
    type: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_UrlRewrite_Path_Type;
  };

/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Backends_Items_Filters_Items_UrlRewrite_Path_Type =
  'ReplaceFullPath' | 'ReplacePrefixMatch';

/**
 * HTTPRouteFilter defines processing steps that must be completed during the
 * request or response lifecycle. HTTPRouteFilters are meant as an extension
 * point to express processing that may be done in Gateway implementations. Some
 * examples include request or response modification, implementing
 * authentication strategies, rate-limiting, and traffic shaping. API
 * guarantee/conformance is defined based on the type of the filter.
 *
 * <gateway:experimental:validation:XValidation:message="filter.cors must be nil if the filter.type is not CORS",rule="!(has(self.cors) && self.type != 'CORS')">
 * <gateway:experimental:validation:XValidation:message="filter.cors must be specified for CORS filter.type",rule="!(!has(self.cors) && self.type == 'CORS')">
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items =
  {
    cors?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Cors>;
    extensionRef?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ExtensionRef>;
    requestHeaderModifier?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier>;
    requestMirror?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror>;
    requestRedirect?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect>;
    responseHeaderModifier?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier>;
    type: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Type;
    urlRewrite?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite>;
  };

/**
 * HTTPRouteFilter defines processing steps that must be completed during the
 * request or response lifecycle. HTTPRouteFilters are meant as an extension
 * point to express processing that may be done in Gateway implementations. Some
 * examples include request or response modification, implementing
 * authentication strategies, rate-limiting, and traffic shaping. API
 * guarantee/conformance is defined based on the type of the filter.
 *
 * <gateway:experimental:validation:XValidation:message="filter.cors must be nil if the filter.type is not CORS",rule="!(has(self.cors) && self.type != 'CORS')">
 * <gateway:experimental:validation:XValidation:message="filter.cors must be specified for CORS filter.type",rule="!(!has(self.cors) && self.type == 'CORS')">
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Input =
  {
    cors?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Cors_Input>;
    extensionRef?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ExtensionRef_Input>;
    requestHeaderModifier?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Input>;
    requestMirror?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Input>;
    requestRedirect?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Input>;
    responseHeaderModifier?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Input>;
    type: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Type;
    urlRewrite?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Input>;
  };

/**
 * CORS defines a schema for a filter that responds to the
 * cross-origin request based on HTTP response header.
 *
 * Support: Extended
 *
 * <gateway:experimental>
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Cors =
  {
    /**
     * AllowCredentials indicates whether the actual cross-origin request allows
     * to include credentials.
     *
     * The only valid value for the `Access-Control-Allow-Credentials` response
     * header is true (case-sensitive).
     *
     * If the credentials are not allowed in cross-origin requests, the gateway
     * will omit the header `Access-Control-Allow-Credentials` entirely rather
     * than setting its value to false.
     *
     * Support: Extended
     */
    allowCredentials?: Maybe<Scalars['Boolean']['output']>;
    /**
     * AllowHeaders indicates which HTTP request headers are supported for
     * accessing the requested resource.
     *
     * Header names are not case sensitive.
     *
     * Multiple header names in the value of the `Access-Control-Allow-Headers`
     * response header are separated by a comma (",").
     *
     * When the `AllowHeaders` field is configured with one or more headers, the
     * gateway must return the `Access-Control-Allow-Headers` response header
     * which value is present in the `AllowHeaders` field.
     *
     * If any header name in the `Access-Control-Request-Headers` request header
     * is not included in the list of header names specified by the response
     * header `Access-Control-Allow-Headers`, it will present an error on the
     * client side.
     *
     * If any header name in the `Access-Control-Allow-Headers` response header
     * does not recognize by the client, it will also occur an error on the
     * client side.
     *
     * A wildcard indicates that the requests with all HTTP headers are allowed.
     * The `Access-Control-Allow-Headers` response header can only use `*`
     * wildcard as value when the `AllowCredentials` field is unspecified.
     *
     * When the `AllowCredentials` field is specified and `AllowHeaders` field
     * specified with the `*` wildcard, the gateway must specify one or more
     * HTTP headers in the value of the `Access-Control-Allow-Headers` response
     * header. The value of the header `Access-Control-Allow-Headers` is same as
     * the `Access-Control-Request-Headers` header provided by the client. If
     * the header `Access-Control-Request-Headers` is not included in the
     * request, the gateway will omit the `Access-Control-Allow-Headers`
     * response header, instead of specifying the `*` wildcard. A Gateway
     * implementation may choose to add implementation-specific default headers.
     *
     * Support: Extended
     */
    allowHeaders?: Maybe<
      Array<
        Maybe<
          Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_cors_allowHeaders_items']['output']
        >
      >
    >;
    /**
     * AllowMethods indicates which HTTP methods are supported for accessing the
     * requested resource.
     *
     * Valid values are any method defined by RFC9110, along with the special
     * value `*`, which represents all HTTP methods are allowed.
     *
     * Method names are case sensitive, so these values are also case-sensitive.
     * (See https://www.rfc-editor.org/rfc/rfc2616#section-5.1.1)
     *
     * Multiple method names in the value of the `Access-Control-Allow-Methods`
     * response header are separated by a comma (",").
     *
     * A CORS-safelisted method is a method that is `GET`, `HEAD`, or `POST`.
     * (See https://fetch.spec.whatwg.org/#cors-safelisted-method) The
     * CORS-safelisted methods are always allowed, regardless of whether they
     * are specified in the `AllowMethods` field.
     *
     * When the `AllowMethods` field is configured with one or more methods, the
     * gateway must return the `Access-Control-Allow-Methods` response header
     * which value is present in the `AllowMethods` field.
     *
     * If the HTTP method of the `Access-Control-Request-Method` request header
     * is not included in the list of methods specified by the response header
     * `Access-Control-Allow-Methods`, it will present an error on the client
     * side.
     *
     * The `Access-Control-Allow-Methods` response header can only use `*`
     * wildcard as value when the `AllowCredentials` field is unspecified.
     *
     * When the `AllowCredentials` field is specified and `AllowMethods` field
     * specified with the `*` wildcard, the gateway must specify one HTTP method
     * in the value of the Access-Control-Allow-Methods response header. The
     * value of the header `Access-Control-Allow-Methods` is same as the
     * `Access-Control-Request-Method` header provided by the client. If the
     * header `Access-Control-Request-Method` is not included in the request,
     * the gateway will omit the `Access-Control-Allow-Methods` response header,
     * instead of specifying the `*` wildcard. A Gateway implementation may
     * choose to add implementation-specific default methods.
     *
     * Support: Extended
     */
    allowMethods?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Cors_AllowMethods_Items>
      >
    >;
    /**
     * AllowOrigins indicates whether the response can be shared with requested
     * resource from the given `Origin`.
     *
     * The `Origin` consists of a scheme and a host, with an optional port, and
     * takes the form `<scheme>://<host>(:<port>)`.
     *
     * Valid values for scheme are: `http` and `https`.
     *
     * Valid values for port are any integer between 1 and 65535 (the list of
     * available TCP/UDP ports). Note that, if not included, port `80` is
     * assumed for `http` scheme origins, and port `443` is assumed for `https`
     * origins. This may affect origin matching.
     *
     * The host part of the origin may contain the wildcard character `*`. These
     * wildcard characters behave as follows:
     *
     * * `*` is a greedy match to the _left_, including any number of
     *   DNS labels to the left of its position. This also means that
     *   `*` will include any number of period `.` characters to the
     *   left of its position.
     * * A wildcard by itself matches all hosts.
     *
     * An origin value that includes _only_ the `*` character indicates requests
     * from all `Origin`s are allowed.
     *
     * When the `AllowOrigins` field is configured with multiple origins, it
     * means the server supports clients from multiple origins. If the request
     * `Origin` matches the configured allowed origins, the gateway must return
     * the given `Origin` and sets value of the header
     * `Access-Control-Allow-Origin` same as the `Origin` header provided by the
     * client.
     *
     * The status code of a successful response to a "preflight" request is
     * always an OK status (i.e., 204 or 200).
     *
     * If the request `Origin` does not match the configured allowed origins,
     * the gateway returns 204/200 response but doesn't set the relevant
     * cross-origin response headers. Alternatively, the gateway responds with
     * 403 status to the "preflight" request is denied, coupled with omitting
     * the CORS headers. The cross-origin request fails on the client side.
     * Therefore, the client doesn't attempt the actual cross-origin request.
     *
     * The `Access-Control-Allow-Origin` response header can only use `*`
     * wildcard as value when the `AllowCredentials` field is unspecified.
     *
     * When the `AllowCredentials` field is specified and `AllowOrigins` field
     * specified with the `*` wildcard, the gateway must return a single origin
     * in the value of the `Access-Control-Allow-Origin` response header,
     * instead of specifying the `*` wildcard. The value of the header
     * `Access-Control-Allow-Origin` is same as the `Origin` header provided by
     * the client.
     *
     * Support: Extended
     */
    allowOrigins?: Maybe<
      Array<
        Maybe<
          Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_cors_allowOrigins_items']['output']
        >
      >
    >;
    /**
     * ExposeHeaders indicates which HTTP response headers can be exposed
     * to client-side scripts in response to a cross-origin request.
     *
     * A CORS-safelisted response header is an HTTP header in a CORS response
     * that it is considered safe to expose to the client scripts.
     * The CORS-safelisted response headers include the following headers:
     * `Cache-Control`
     * `Content-Language`
     * `Content-Length`
     * `Content-Type`
     * `Expires`
     * `Last-Modified`
     * `Pragma`
     * (See https://fetch.spec.whatwg.org/#cors-safelisted-response-header-name)
     * The CORS-safelisted response headers are exposed to client by default.
     *
     * When an HTTP header name is specified using the `ExposeHeaders` field,
     * this additional header will be exposed as part of the response to the
     * client.
     *
     * Header names are not case sensitive.
     *
     * Multiple header names in the value of the `Access-Control-Expose-Headers`
     * response header are separated by a comma (",").
     *
     * A wildcard indicates that the responses with all HTTP headers are exposed
     * to clients. The `Access-Control-Expose-Headers` response header can only
     * use `*` wildcard as value when the `AllowCredentials` field is
     * unspecified.
     *
     * Support: Extended
     */
    exposeHeaders?: Maybe<
      Array<
        Maybe<
          Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_cors_exposeHeaders_items']['output']
        >
      >
    >;
    /**
     * MaxAge indicates the duration (in seconds) for the client to cache the
     * results of a "preflight" request.
     *
     * The information provided by the `Access-Control-Allow-Methods` and
     * `Access-Control-Allow-Headers` response headers can be cached by the
     * client until the time specified by `Access-Control-Max-Age` elapses.
     *
     * The default value of `Access-Control-Max-Age` response header is 5
     * (seconds).
     */
    maxAge?: Maybe<Scalars['Int']['output']>;
  };

/**
 * CORS defines a schema for a filter that responds to the
 * cross-origin request based on HTTP response header.
 *
 * Support: Extended
 *
 * <gateway:experimental>
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Cors_Input =
  {
    /**
     * AllowCredentials indicates whether the actual cross-origin request allows
     * to include credentials.
     *
     * The only valid value for the `Access-Control-Allow-Credentials` response
     * header is true (case-sensitive).
     *
     * If the credentials are not allowed in cross-origin requests, the gateway
     * will omit the header `Access-Control-Allow-Credentials` entirely rather
     * than setting its value to false.
     *
     * Support: Extended
     */
    allowCredentials?: InputMaybe<Scalars['Boolean']['input']>;
    /**
     * AllowHeaders indicates which HTTP request headers are supported for
     * accessing the requested resource.
     *
     * Header names are not case sensitive.
     *
     * Multiple header names in the value of the `Access-Control-Allow-Headers`
     * response header are separated by a comma (",").
     *
     * When the `AllowHeaders` field is configured with one or more headers, the
     * gateway must return the `Access-Control-Allow-Headers` response header
     * which value is present in the `AllowHeaders` field.
     *
     * If any header name in the `Access-Control-Request-Headers` request header
     * is not included in the list of header names specified by the response
     * header `Access-Control-Allow-Headers`, it will present an error on the
     * client side.
     *
     * If any header name in the `Access-Control-Allow-Headers` response header
     * does not recognize by the client, it will also occur an error on the
     * client side.
     *
     * A wildcard indicates that the requests with all HTTP headers are allowed.
     * The `Access-Control-Allow-Headers` response header can only use `*`
     * wildcard as value when the `AllowCredentials` field is unspecified.
     *
     * When the `AllowCredentials` field is specified and `AllowHeaders` field
     * specified with the `*` wildcard, the gateway must specify one or more
     * HTTP headers in the value of the `Access-Control-Allow-Headers` response
     * header. The value of the header `Access-Control-Allow-Headers` is same as
     * the `Access-Control-Request-Headers` header provided by the client. If
     * the header `Access-Control-Request-Headers` is not included in the
     * request, the gateway will omit the `Access-Control-Allow-Headers`
     * response header, instead of specifying the `*` wildcard. A Gateway
     * implementation may choose to add implementation-specific default headers.
     *
     * Support: Extended
     */
    allowHeaders?: InputMaybe<
      Array<
        InputMaybe<
          Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_cors_allowHeaders_items']['input']
        >
      >
    >;
    /**
     * AllowMethods indicates which HTTP methods are supported for accessing the
     * requested resource.
     *
     * Valid values are any method defined by RFC9110, along with the special
     * value `*`, which represents all HTTP methods are allowed.
     *
     * Method names are case sensitive, so these values are also case-sensitive.
     * (See https://www.rfc-editor.org/rfc/rfc2616#section-5.1.1)
     *
     * Multiple method names in the value of the `Access-Control-Allow-Methods`
     * response header are separated by a comma (",").
     *
     * A CORS-safelisted method is a method that is `GET`, `HEAD`, or `POST`.
     * (See https://fetch.spec.whatwg.org/#cors-safelisted-method) The
     * CORS-safelisted methods are always allowed, regardless of whether they
     * are specified in the `AllowMethods` field.
     *
     * When the `AllowMethods` field is configured with one or more methods, the
     * gateway must return the `Access-Control-Allow-Methods` response header
     * which value is present in the `AllowMethods` field.
     *
     * If the HTTP method of the `Access-Control-Request-Method` request header
     * is not included in the list of methods specified by the response header
     * `Access-Control-Allow-Methods`, it will present an error on the client
     * side.
     *
     * The `Access-Control-Allow-Methods` response header can only use `*`
     * wildcard as value when the `AllowCredentials` field is unspecified.
     *
     * When the `AllowCredentials` field is specified and `AllowMethods` field
     * specified with the `*` wildcard, the gateway must specify one HTTP method
     * in the value of the Access-Control-Allow-Methods response header. The
     * value of the header `Access-Control-Allow-Methods` is same as the
     * `Access-Control-Request-Method` header provided by the client. If the
     * header `Access-Control-Request-Method` is not included in the request,
     * the gateway will omit the `Access-Control-Allow-Methods` response header,
     * instead of specifying the `*` wildcard. A Gateway implementation may
     * choose to add implementation-specific default methods.
     *
     * Support: Extended
     */
    allowMethods?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Cors_AllowMethods_Items>
      >
    >;
    /**
     * AllowOrigins indicates whether the response can be shared with requested
     * resource from the given `Origin`.
     *
     * The `Origin` consists of a scheme and a host, with an optional port, and
     * takes the form `<scheme>://<host>(:<port>)`.
     *
     * Valid values for scheme are: `http` and `https`.
     *
     * Valid values for port are any integer between 1 and 65535 (the list of
     * available TCP/UDP ports). Note that, if not included, port `80` is
     * assumed for `http` scheme origins, and port `443` is assumed for `https`
     * origins. This may affect origin matching.
     *
     * The host part of the origin may contain the wildcard character `*`. These
     * wildcard characters behave as follows:
     *
     * * `*` is a greedy match to the _left_, including any number of
     *   DNS labels to the left of its position. This also means that
     *   `*` will include any number of period `.` characters to the
     *   left of its position.
     * * A wildcard by itself matches all hosts.
     *
     * An origin value that includes _only_ the `*` character indicates requests
     * from all `Origin`s are allowed.
     *
     * When the `AllowOrigins` field is configured with multiple origins, it
     * means the server supports clients from multiple origins. If the request
     * `Origin` matches the configured allowed origins, the gateway must return
     * the given `Origin` and sets value of the header
     * `Access-Control-Allow-Origin` same as the `Origin` header provided by the
     * client.
     *
     * The status code of a successful response to a "preflight" request is
     * always an OK status (i.e., 204 or 200).
     *
     * If the request `Origin` does not match the configured allowed origins,
     * the gateway returns 204/200 response but doesn't set the relevant
     * cross-origin response headers. Alternatively, the gateway responds with
     * 403 status to the "preflight" request is denied, coupled with omitting
     * the CORS headers. The cross-origin request fails on the client side.
     * Therefore, the client doesn't attempt the actual cross-origin request.
     *
     * The `Access-Control-Allow-Origin` response header can only use `*`
     * wildcard as value when the `AllowCredentials` field is unspecified.
     *
     * When the `AllowCredentials` field is specified and `AllowOrigins` field
     * specified with the `*` wildcard, the gateway must return a single origin
     * in the value of the `Access-Control-Allow-Origin` response header,
     * instead of specifying the `*` wildcard. The value of the header
     * `Access-Control-Allow-Origin` is same as the `Origin` header provided by
     * the client.
     *
     * Support: Extended
     */
    allowOrigins?: InputMaybe<
      Array<
        InputMaybe<
          Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_cors_allowOrigins_items']['input']
        >
      >
    >;
    /**
     * ExposeHeaders indicates which HTTP response headers can be exposed
     * to client-side scripts in response to a cross-origin request.
     *
     * A CORS-safelisted response header is an HTTP header in a CORS response
     * that it is considered safe to expose to the client scripts.
     * The CORS-safelisted response headers include the following headers:
     * `Cache-Control`
     * `Content-Language`
     * `Content-Length`
     * `Content-Type`
     * `Expires`
     * `Last-Modified`
     * `Pragma`
     * (See https://fetch.spec.whatwg.org/#cors-safelisted-response-header-name)
     * The CORS-safelisted response headers are exposed to client by default.
     *
     * When an HTTP header name is specified using the `ExposeHeaders` field,
     * this additional header will be exposed as part of the response to the
     * client.
     *
     * Header names are not case sensitive.
     *
     * Multiple header names in the value of the `Access-Control-Expose-Headers`
     * response header are separated by a comma (",").
     *
     * A wildcard indicates that the responses with all HTTP headers are exposed
     * to clients. The `Access-Control-Expose-Headers` response header can only
     * use `*` wildcard as value when the `AllowCredentials` field is
     * unspecified.
     *
     * Support: Extended
     */
    exposeHeaders?: InputMaybe<
      Array<
        InputMaybe<
          Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_cors_exposeHeaders_items']['input']
        >
      >
    >;
    /**
     * MaxAge indicates the duration (in seconds) for the client to cache the
     * results of a "preflight" request.
     *
     * The information provided by the `Access-Control-Allow-Methods` and
     * `Access-Control-Allow-Headers` response headers can be cached by the
     * client until the time specified by `Access-Control-Max-Age` elapses.
     *
     * The default value of `Access-Control-Max-Age` response header is 5
     * (seconds).
     */
    maxAge?: InputMaybe<Scalars['Int']['input']>;
  };

export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Cors_AllowMethods_Items =
  'CONNECT' | 'DELETE' | 'GET' | 'HEAD' | 'OPTIONS' | 'PATCH' | 'POST' | 'PUT' | 'TRACE' | '_STAR_';

/**
 * ExtensionRef is an optional, implementation-specific extension to the
 * "filter" behavior.  For example, resource "myroutefilter" in group
 * "networking.example.net"). ExtensionRef MUST NOT be used for core and
 * extended filters.
 *
 * This filter can be used multiple times within the same rule.
 *
 * Support: Implementation-specific
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ExtensionRef =
  {
    group: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_group']['output'];
    kind: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_kind']['output'];
    /** Name is the name of the referent. */
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_name']['output'];
  };

/**
 * ExtensionRef is an optional, implementation-specific extension to the
 * "filter" behavior.  For example, resource "myroutefilter" in group
 * "networking.example.net"). ExtensionRef MUST NOT be used for core and
 * extended filters.
 *
 * This filter can be used multiple times within the same rule.
 *
 * Support: Implementation-specific
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ExtensionRef_Input =
  {
    group: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_group']['input'];
    kind: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_kind']['input'];
    /** Name is the name of the referent. */
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_extensionRef_name']['input'];
  };

/**
 * RequestHeaderModifier defines a schema for a filter that modifies request
 * headers.
 *
 * Support: Core
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Add_Items>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Set_Items>
      >
    >;
  };

/**
 * RequestHeaderModifier defines a schema for a filter that modifies request
 * headers.
 *
 * Support: Core
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Input =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Add_Items_Input>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Set_Items_Input>
      >
    >;
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Add_Items =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Add_Items_Input =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_add_items_value']['input'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Set_Items =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestHeaderModifier_Set_Items_Input =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestHeaderModifier_set_items_value']['input'];
  };

/**
 * RequestMirror defines a schema for a filter that mirrors requests.
 * Requests are sent to the specified destination, but responses from
 * that destination are ignored.
 *
 * This filter can be used multiple times within the same rule. Note that
 * not all implementations will be able to support mirroring to multiple
 * backends.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror =
  {
    backendRef: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_BackendRef;
    fraction?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Fraction>;
    /**
     * Percent represents the percentage of requests that should be
     * mirrored to BackendRef. Its minimum value is 0 (indicating 0% of
     * requests) and its maximum value is 100 (indicating 100% of requests).
     *
     * Only one of Fraction or Percent may be specified. If neither field
     * is specified, 100% of requests will be mirrored.
     */
    percent?: Maybe<Scalars['Int']['output']>;
  };

/**
 * RequestMirror defines a schema for a filter that mirrors requests.
 * Requests are sent to the specified destination, but responses from
 * that destination are ignored.
 *
 * This filter can be used multiple times within the same rule. Note that
 * not all implementations will be able to support mirroring to multiple
 * backends.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Input =
  {
    backendRef: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_BackendRef_Input;
    fraction?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Fraction_Input>;
    /**
     * Percent represents the percentage of requests that should be
     * mirrored to BackendRef. Its minimum value is 0 (indicating 0% of
     * requests) and its maximum value is 100 (indicating 100% of requests).
     *
     * Only one of Fraction or Percent may be specified. If neither field
     * is specified, 100% of requests will be mirrored.
     */
    percent?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * BackendRef references a resource where mirrored requests are sent.
 *
 * Mirrored requests must be sent only to a single destination endpoint
 * within this BackendRef, irrespective of how many endpoints are present
 * within this BackendRef.
 *
 * If the referent cannot be found, this BackendRef is invalid and must be
 * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
 * condition on the Route status is set to `status: False` and not configure
 * this backend in the underlying implementation.
 *
 * If there is a cross-namespace reference to an *existing* object
 * that is not allowed by a ReferenceGrant, the controller must ensure the
 * "ResolvedRefs"  condition on the Route is set to `status: False`,
 * with the "RefNotPermitted" reason and not configure this backend in the
 * underlying implementation.
 *
 * In either error case, the Message of the `ResolvedRefs` Condition
 * should be used to provide more detail about the problem.
 *
 * Support: Extended for Kubernetes Service
 *
 * Support: Implementation-specific for any other resource
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_BackendRef =
  {
    group?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_kind']['output']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_namespace']['output']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: Maybe<Scalars['Int']['output']>;
  };

/**
 * BackendRef references a resource where mirrored requests are sent.
 *
 * Mirrored requests must be sent only to a single destination endpoint
 * within this BackendRef, irrespective of how many endpoints are present
 * within this BackendRef.
 *
 * If the referent cannot be found, this BackendRef is invalid and must be
 * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
 * condition on the Route status is set to `status: False` and not configure
 * this backend in the underlying implementation.
 *
 * If there is a cross-namespace reference to an *existing* object
 * that is not allowed by a ReferenceGrant, the controller must ensure the
 * "ResolvedRefs"  condition on the Route is set to `status: False`,
 * with the "RefNotPermitted" reason and not configure this backend in the
 * underlying implementation.
 *
 * In either error case, the Message of the `ResolvedRefs` Condition
 * should be used to provide more detail about the problem.
 *
 * Support: Extended for Kubernetes Service
 *
 * Support: Implementation-specific for any other resource
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_BackendRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_kind']['input']
    >;
    /** Name is the name of the referent. */
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestMirror_backendRef_namespace']['input']
    >;
    /**
     * Port specifies the destination port number to use for this resource.
     * Port is required when the referent is a Kubernetes Service. In this
     * case, the port number is the service port number, not the target port.
     * For other resources, destination port might be derived from the referent
     * resource or this field.
     */
    port?: InputMaybe<Scalars['Int']['input']>;
  };

/**
 * Fraction represents the fraction of requests that should be
 * mirrored to BackendRef.
 *
 * Only one of Fraction or Percent may be specified. If neither field
 * is specified, 100% of requests will be mirrored.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Fraction =
  {
    denominator?: Maybe<Scalars['Int']['output']>;
    numerator: Scalars['Int']['output'];
  };

/**
 * Fraction represents the fraction of requests that should be
 * mirrored to BackendRef.
 *
 * Only one of Fraction or Percent may be specified. If neither field
 * is specified, 100% of requests will be mirrored.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestMirror_Fraction_Input =
  {
    denominator?: InputMaybe<Scalars['Int']['input']>;
    numerator: Scalars['Int']['input'];
  };

/**
 * RequestRedirect defines a schema for a filter that responds to the
 * request with an HTTP redirection.
 *
 * Support: Core
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect =
  {
    hostname?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_hostname']['output']
    >;
    path?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path>;
    /**
     * Port is the port to be used in the value of the `Location`
     * header in the response.
     *
     * If no port is specified, the redirect port MUST be derived using the
     * following rules:
     *
     * * If redirect scheme is not-empty, the redirect port MUST be the well-known
     *   port associated with the redirect scheme. Specifically "http" to port 80
     *   and "https" to port 443. If the redirect scheme does not have a
     *   well-known port, the listener port of the Gateway SHOULD be used.
     * * If redirect scheme is empty, the redirect port MUST be the Gateway
     *   Listener port.
     *
     * Implementations SHOULD NOT add the port number in the 'Location'
     * header in the following cases:
     *
     * * A Location header that will use HTTP (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 80.
     * * A Location header that will use HTTPS (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 443.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    scheme?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Scheme>;
    statusCode?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_StatusCode>;
  };

/**
 * RequestRedirect defines a schema for a filter that responds to the
 * request with an HTTP redirection.
 *
 * Support: Core
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_hostname']['input']
    >;
    path?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Input>;
    /**
     * Port is the port to be used in the value of the `Location`
     * header in the response.
     *
     * If no port is specified, the redirect port MUST be derived using the
     * following rules:
     *
     * * If redirect scheme is not-empty, the redirect port MUST be the well-known
     *   port associated with the redirect scheme. Specifically "http" to port 80
     *   and "https" to port 443. If the redirect scheme does not have a
     *   well-known port, the listener port of the Gateway SHOULD be used.
     * * If redirect scheme is empty, the redirect port MUST be the Gateway
     *   Listener port.
     *
     * Implementations SHOULD NOT add the port number in the 'Location'
     * header in the following cases:
     *
     * * A Location header that will use HTTP (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 80.
     * * A Location header that will use HTTPS (whether that is determined via
     *   the Listener protocol or the Scheme field) _and_ use port 443.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    scheme?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Scheme>;
    statusCode?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_StatusCode>;
  };

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replaceFullPath']['output']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replacePrefixMatch']['output']
    >;
    type: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Type;
  };

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Input =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replaceFullPath']['input']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_requestRedirect_path_replacePrefixMatch']['input']
    >;
    type: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Type;
  };

/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Path_Type =
  'ReplaceFullPath' | 'ReplacePrefixMatch';

/**
 * Scheme is the scheme to be used in the value of the `Location` header in
 * the response. When empty, the scheme of the request is used.
 *
 * Scheme redirects can affect the port of the redirect, for more information,
 * refer to the documentation for the port field of this filter.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_Scheme =
  'http' | 'https';

/**
 * StatusCode is the HTTP status code to be used in response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Core
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_RequestRedirect_StatusCode =
  '_301' | '_302';

/**
 * ResponseHeaderModifier defines a schema for a filter that modifies response
 * headers.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Add_Items>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Set_Items>
      >
    >;
  };

/**
 * ResponseHeaderModifier defines a schema for a filter that modifies response
 * headers.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Input =
  {
    /**
     * Add adds the given header(s) (name, value) to the request
     * before the action. It appends to any existing values associated
     * with the header name.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   add:
     *   - name: "my-header"
     *     value: "bar,baz"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: foo,bar,baz
     */
    add?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Add_Items_Input>
      >
    >;
    /**
     * Remove the given header(s) from the HTTP request before the action. The
     * value of Remove is a list of HTTP header names. Note that the header
     * names are case-insensitive (see
     * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header1: foo
     *   my-header2: bar
     *   my-header3: baz
     *
     * Config:
     *   remove: ["my-header1", "my-header3"]
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header2: bar
     */
    remove?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * Set overwrites the request with the given header (name, value)
     * before the action.
     *
     * Input:
     *   GET /foo HTTP/1.1
     *   my-header: foo
     *
     * Config:
     *   set:
     *   - name: "my-header"
     *     value: "bar"
     *
     * Output:
     *   GET /foo HTTP/1.1
     *   my-header: bar
     */
    set?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Set_Items_Input>
      >
    >;
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Add_Items =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Add_Items_Input =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_add_items_value']['input'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Set_Items =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_name']['output'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_value']['output'];
  };

/** HTTPHeader represents an HTTP Header name and value as defined by RFC 7230. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_ResponseHeaderModifier_Set_Items_Input =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_name']['input'];
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_responseHeaderModifier_set_items_value']['input'];
  };

/**
 * Type identifies the type of filter to apply. As with other API fields,
 * types are classified into three conformance levels:
 *
 * - Core: Filter types and their corresponding configuration defined by
 *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
 *   implementations must support core filters.
 *
 * - Extended: Filter types and their corresponding configuration defined by
 *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
 *   are encouraged to support extended filters.
 *
 * - Implementation-specific: Filters that are defined and supported by
 *   specific vendors.
 *   In the future, filters showing convergence in behavior across multiple
 *   implementations will be considered for inclusion in extended or core
 *   conformance levels. Filter-specific configuration for such filters
 *   is specified using the ExtensionRef field. `Type` should be set to
 *   "ExtensionRef" for custom filters.
 *
 * Implementers are encouraged to define custom implementation types to
 * extend the core API with implementation-specific behavior.
 *
 * If a reference to a custom filter type cannot be resolved, the filter
 * MUST NOT be skipped. Instead, requests that would have been processed by
 * that filter MUST receive a HTTP error response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * <gateway:experimental:validation:Enum=RequestHeaderModifier;ResponseHeaderModifier;RequestMirror;RequestRedirect;URLRewrite;ExtensionRef;CORS>
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_Type =

    | 'ExtensionRef'
    | 'RequestHeaderModifier'
    | 'RequestMirror'
    | 'RequestRedirect'
    | 'ResponseHeaderModifier'
    | 'URLRewrite';

/**
 * URLRewrite defines a schema for a filter that modifies a request during forwarding.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite =
  {
    hostname?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_hostname']['output']
    >;
    path?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path>;
  };

/**
 * URLRewrite defines a schema for a filter that modifies a request during forwarding.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Input =
  {
    hostname?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_hostname']['input']
    >;
    path?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Input>;
  };

/**
 * Path defines a path rewrite.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replaceFullPath']['output']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replacePrefixMatch']['output']
    >;
    type: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Type;
  };

/**
 * Path defines a path rewrite.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Input =
  {
    /**
     * ReplaceFullPath specifies the value with which to replace the full path
     * of a request during a rewrite or redirect.
     */
    replaceFullPath?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replaceFullPath']['input']
    >;
    /**
     * ReplacePrefixMatch specifies the value with which to replace the prefix
     * match of a request during a rewrite or redirect. For example, a request
     * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
     * of "/xyz" would be modified to "/xyz/bar".
     *
     * Note that this matches the behavior of the PathPrefix match type. This
     * matches full path elements. A path element refers to the list of labels
     * in the path split by the `/` separator. When specified, a trailing `/` is
     * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
     * match the prefix `/abc`, but the path `/abcd` would not.
     *
     * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
     * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
     * the implementation setting the Accepted Condition for the Route to `status: False`.
     *
     * Request Path | Prefix Match | Replace Prefix | Modified Path
     */
    replacePrefixMatch?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_filters_items_urlRewrite_path_replacePrefixMatch']['input']
    >;
    type: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Type;
  };

/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Filters_Items_UrlRewrite_Path_Type =
  'ReplaceFullPath' | 'ReplacePrefixMatch';

/**
 * HTTPRouteMatch defines the predicate used to match requests to a given
 * action. Multiple match types are ANDed together, i.e. the match will
 * evaluate to true only if all conditions are satisfied.
 *
 * For example, the match below will match a HTTP request only if its path
 * starts with `/foo` AND it contains the `version: v1` header:
 *
 * ```
 * match:
 *
 * 	path:
 * 	  value: "/foo"
 * 	headers:
 * 	- name: "version"
 * 	  value "v1"
 *
 * ```
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items =
  {
    /**
     * Headers specifies HTTP request header matchers. Multiple match values are
     * ANDed together, meaning, a request must match all the specified headers
     * to select the route.
     */
    headers?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items>
      >
    >;
    method?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Method>;
    path?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path>;
    /**
     * QueryParams specifies HTTP query parameter matchers. Multiple match
     * values are ANDed together, meaning, a request must match all the
     * specified query parameters to select the route.
     *
     * Support: Extended
     */
    queryParams?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items>
      >
    >;
  };

/**
 * HTTPRouteMatch defines the predicate used to match requests to a given
 * action. Multiple match types are ANDed together, i.e. the match will
 * evaluate to true only if all conditions are satisfied.
 *
 * For example, the match below will match a HTTP request only if its path
 * starts with `/foo` AND it contains the `version: v1` header:
 *
 * ```
 * match:
 *
 * 	path:
 * 	  value: "/foo"
 * 	headers:
 * 	- name: "version"
 * 	  value "v1"
 *
 * ```
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Input =
  {
    /**
     * Headers specifies HTTP request header matchers. Multiple match values are
     * ANDed together, meaning, a request must match all the specified headers
     * to select the route.
     */
    headers?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Input>
      >
    >;
    method?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Method>;
    path?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Input>;
    /**
     * QueryParams specifies HTTP query parameter matchers. Multiple match
     * values are ANDed together, meaning, a request must match all the
     * specified query parameters to select the route.
     *
     * Support: Extended
     */
    queryParams?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Input>
      >
    >;
  };

/**
 * HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
 * headers.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_name']['output'];
    type?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Type>;
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_value']['output'];
  };

/**
 * HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
 * headers.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Input =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_name']['input'];
    type?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Type>;
    /** Value is the value of HTTP Header to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_headers_items_value']['input'];
  };

/**
 * Type specifies how to match against the value of the header.
 *
 * Support: Core (Exact)
 *
 * Support: Implementation-specific (RegularExpression)
 *
 * Since RegularExpression HeaderMatchType has implementation-specific
 * conformance, implementations can support POSIX, PCRE or any other dialects
 * of regular expressions. Please read the implementation's documentation to
 * determine the supported dialect.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Headers_Items_Type =
  'Exact' | 'RegularExpression';

/**
 * Method specifies HTTP method matcher.
 * When specified, this route will be matched only if the request has the
 * specified method.
 *
 * Support: Extended
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Method =
  'CONNECT' | 'DELETE' | 'GET' | 'HEAD' | 'OPTIONS' | 'PATCH' | 'POST' | 'PUT' | 'TRACE';

/**
 * Path specifies a HTTP request path matcher. If this field is not
 * specified, a default prefix match on the "/" path is provided.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path =
  {
    type?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Type>;
    /** Value of the HTTP path to match against. */
    value?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_path_value']['output']
    >;
  };

/**
 * Path specifies a HTTP request path matcher. If this field is not
 * specified, a default prefix match on the "/" path is provided.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Input =
  {
    type?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Type>;
    /** Value of the HTTP path to match against. */
    value?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_path_value']['input']
    >;
  };

/**
 * Type specifies how to match against the path Value.
 *
 * Support: Core (Exact, PathPrefix)
 *
 * Support: Implementation-specific (RegularExpression)
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_Path_Type =
  'Exact' | 'PathPrefix' | 'RegularExpression';

/**
 * HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
 * query parameters.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_name']['output'];
    type?: Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Type>;
    /** Value is the value of HTTP query param to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_value']['output'];
  };

/**
 * HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
 * query parameters.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Input =
  {
    name: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_name']['input'];
    type?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Type>;
    /** Value is the value of HTTP query param to be matched. */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_spec_rules_items_matches_items_queryParams_items_value']['input'];
  };

/**
 * Type specifies how to match against the value of the query parameter.
 *
 * Support: Extended (Exact)
 *
 * Support: Implementation-specific (RegularExpression)
 *
 * Since RegularExpression QueryParamMatchType has Implementation-specific
 * conformance, implementations can support POSIX, PCRE or any other
 * dialects of regular expressions. Please read the implementation's
 * documentation to determine the supported dialect.
 */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Spec_Rules_Items_Matches_Items_QueryParams_Items_Type =
  'Exact' | 'RegularExpression';

/** Status defines the current state of an HTTPProxy. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status = {
  /**
   * Addresses lists the network addresses that have been bound to the
   * HTTPProxy.
   *
   * This field will not contain custom hostnames defined in the HTTPProxy. See
   * the `hostnames` field
   */
  addresses?: Maybe<
    Array<
      Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status_Addresses_Items>
    >
  >;
  /** Conditions describe the current conditions of the HTTPProxy. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
  /**
   * Hostnames lists the hostnames that have been bound to the HTTPProxy.
   *
   * If this list does not match that defined in the HTTPProxy, see the
   * `HostnamesVerified` condition message for details.
   */
  hostnames?: Maybe<
    Array<
      Maybe<
        Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_hostnames_items']['output']
      >
    >
  >;
};

/** Status defines the current state of an HTTPProxy. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * Addresses lists the network addresses that have been bound to the
     * HTTPProxy.
     *
     * This field will not contain custom hostnames defined in the HTTPProxy. See
     * the `hostnames` field
     */
    addresses?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status_Addresses_Items_Input>
      >
    >;
    /** Conditions describe the current conditions of the HTTPProxy. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /**
     * Hostnames lists the hostnames that have been bound to the HTTPProxy.
     *
     * If this list does not match that defined in the HTTPProxy, see the
     * `HostnamesVerified` condition message for details.
     */
    hostnames?: InputMaybe<
      Array<
        InputMaybe<
          Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_hostnames_items']['input']
        >
      >
    >;
  };

/** GatewayStatusAddress describes a network address that is bound to a Gateway. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status_Addresses_Items =
  {
    type?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_addresses_items_type']['output']
    >;
    /**
     * Value of the address. The validity of the values will depend
     * on the type and support by the controller.
     *
     * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
     */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_addresses_items_value']['output'];
  };

/** GatewayStatusAddress describes a network address that is bound to a Gateway. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status_Addresses_Items_Input =
  {
    type?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_addresses_items_type']['input']
    >;
    /**
     * Value of the address. The validity of the values will depend
     * on the type and support by the controller.
     *
     * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
     */
    value: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_addresses_items_value']['input'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaHTTPProxyForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNetworkingDatumapisComV1alphaHttpProxyForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** LocationSpec defines the desired state of Location. */
export type Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Spec = {
  /**
   * The location class that indicates control plane behavior of entities
   * associated with the location.
   *
   * Valid values are:
   * 	- datum-managed
   * 	- self-managed
   */
  locationClassName: Scalars['String']['output'];
  provider: Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Spec_Provider;
  /**
   * The topology of the location
   *
   * This may contain arbitrary topology keys. Some keys may be well known, such
   * as:
   * 	- topology.datum.net/city-code
   */
  topology: Scalars['JSON']['output'];
};

/** LocationSpec defines the desired state of Location. */
export type Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Spec_Input =
  {
    /**
     * The location class that indicates control plane behavior of entities
     * associated with the location.
     *
     * Valid values are:
     * 	- datum-managed
     * 	- self-managed
     */
    locationClassName: Scalars['String']['input'];
    provider: Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Spec_Provider_Input;
    /**
     * The topology of the location
     *
     * This may contain arbitrary topology keys. Some keys may be well known, such
     * as:
     * 	- topology.datum.net/city-code
     */
    topology: Scalars['JSON']['input'];
  };

/** The location provider */
export type Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Spec_Provider =
  {
    gcp?: Maybe<Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Spec_Provider_Gcp>;
  };

/** The location provider */
export type Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Spec_Provider_Input =
  {
    gcp?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Spec_Provider_Gcp_Input>;
  };

export type Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Spec_Provider_Gcp =
  {
    /**
     * The GCP project servicing the location
     *
     * For locations with the class of `datum-managed`, a service account will be
     * required for each unique GCP project ID across all locations registered in a
     * namespace.
     */
    projectId: Scalars['String']['output'];
    /** The GCP region servicing the location */
    region: Scalars['String']['output'];
    /** The GCP zone servicing the location */
    zone: Scalars['String']['output'];
  };

export type Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Spec_Provider_Gcp_Input =
  {
    /**
     * The GCP project servicing the location
     *
     * For locations with the class of `datum-managed`, a service account will be
     * required for each unique GCP project ID across all locations registered in a
     * namespace.
     */
    projectId: Scalars['String']['input'];
    /** The GCP region servicing the location */
    region: Scalars['String']['input'];
    /** The GCP zone servicing the location */
    zone: Scalars['String']['input'];
  };

/** LocationStatus defines the observed state of Location. */
export type Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Status = {
  /** Represents the observations of a location's current state. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
};

/** LocationStatus defines the observed state of Location. */
export type Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Status_Input =
  {
    /** Represents the observations of a location's current state. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaLocationForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaLocationForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaLocationForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaLocationForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaLocationForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaLocationForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNetworkingDatumapisComV1alphaLocationForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** NetworkBindingSpec defines the desired state of NetworkBinding */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Spec = {
  location: Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Spec_Location;
  network: Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Spec_Network;
};

/** NetworkBindingSpec defines the desired state of NetworkBinding */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Spec_Input =
  {
    location: Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Spec_Location_Input;
    network: Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Spec_Network_Input;
  };

/** The location of where a network binding exists. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Spec_Location =
  {
    /** Name of a datum location */
    name: Scalars['String']['output'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['output'];
  };

/** The location of where a network binding exists. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Spec_Location_Input =
  {
    /** Name of a datum location */
    name: Scalars['String']['input'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['input'];
  };

/** The network that the binding is for. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Spec_Network =
  {
    /** The network name */
    name: Scalars['String']['output'];
    /**
     * The network namespace.
     *
     * Defaults to the namespace for the type the reference is embedded in.
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/** The network that the binding is for. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Spec_Network_Input =
  {
    /** The network name */
    name: Scalars['String']['input'];
    /**
     * The network namespace.
     *
     * Defaults to the namespace for the type the reference is embedded in.
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/** NetworkBindingStatus defines the observed state of NetworkBinding */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status = {
  /** Represents the observations of a network binding's current state. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status_Conditions_Items>
    >
  >;
  networkContextRef?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status_NetworkContextRef>;
};

/** NetworkBindingStatus defines the observed state of NetworkBinding */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status_Input =
  {
    /** Represents the observations of a network binding's current state. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    networkContextRef?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status_NetworkContextRef_Input>;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetworkBinding_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetworkBinding_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetworkBinding_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetworkBinding_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetworkBinding_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetworkBinding_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status_NetworkContextRef =
  {
    /** The network context name */
    name: Scalars['String']['output'];
    /** The network context namespace */
    namespace: Scalars['String']['output'];
  };

export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkBinding_Items_Items_Status_NetworkContextRef_Input =
  {
    /** The network context name */
    name: Scalars['String']['input'];
    /** The network context namespace */
    namespace: Scalars['String']['input'];
  };

/** NetworkContextSpec defines the desired state of NetworkContext */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Spec = {
  location: Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Spec_Location;
  network: Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Spec_Network;
};

/** NetworkContextSpec defines the desired state of NetworkContext */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Spec_Input =
  {
    location: Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Spec_Location_Input;
    network: Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Spec_Network_Input;
  };

/** The location of where a network context exists. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Spec_Location =
  {
    /** Name of a datum location */
    name: Scalars['String']['output'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['output'];
  };

/** The location of where a network context exists. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Spec_Location_Input =
  {
    /** Name of a datum location */
    name: Scalars['String']['input'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['input'];
  };

/** The attached network */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Spec_Network =
  {
    /** The network name */
    name: Scalars['String']['output'];
  };

/** The attached network */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Spec_Network_Input =
  {
    /** The network name */
    name: Scalars['String']['input'];
  };

/** NetworkContextStatus defines the observed state of NetworkContext */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Status = {
  /** Represents the observations of a network context's current state. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Status_Conditions_Items>
    >
  >;
};

/** NetworkContextStatus defines the observed state of NetworkContext */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Status_Input =
  {
    /** Represents the observations of a network context's current state. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Status_Conditions_Items_Input>
      >
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetworkContext_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetworkContext_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetworkContext_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetworkContext_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetworkContext_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetworkContext_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetworkContext_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** NetworkSpec defines the desired state of a Network */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Spec = {
  /** IP Families to permit on a network. Defaults to IPv4. */
  ipFamilies?: Maybe<
    Array<
      Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Spec_IpFamilies_Items>
    >
  >;
  ipam: Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Spec_Ipam;
  /** Network MTU. May be between 1300 and 8856. */
  mtu?: Maybe<Scalars['Int']['output']>;
};

/** NetworkSpec defines the desired state of a Network */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Spec_Input = {
  /** IP Families to permit on a network. Defaults to IPv4. */
  ipFamilies?: InputMaybe<
    Array<
      InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Spec_IpFamilies_Items>
    >
  >;
  ipam: Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Spec_Ipam_Input;
  /** Network MTU. May be between 1300 and 8856. */
  mtu?: InputMaybe<Scalars['Int']['input']>;
};

export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Spec_IpFamilies_Items =
  'IPv4' | 'IPv6';

/** IPAM settings for the network. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Spec_Ipam = {
  /** IPv4 range to use in auto mode networks. Defaults to 10.128.0.0/9. */
  ipv4Range?: Maybe<Scalars['String']['output']>;
  /** IPv6 range to use in auto mode networks. Defaults to a /48 allocated from `fd20::/20`. */
  ipv6Range?: Maybe<Scalars['String']['output']>;
  mode: Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Spec_Ipam_Mode;
};

/** IPAM settings for the network. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Spec_Ipam_Input = {
  /** IPv4 range to use in auto mode networks. Defaults to 10.128.0.0/9. */
  ipv4Range?: InputMaybe<Scalars['String']['input']>;
  /** IPv6 range to use in auto mode networks. Defaults to a /48 allocated from `fd20::/20`. */
  ipv6Range?: InputMaybe<Scalars['String']['input']>;
  mode: Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Spec_Ipam_Mode;
};

/** IPAM mode */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Spec_Ipam_Mode =
  | 'Auto'
  | 'Policy';

/** NetworkStatus defines the observed state of Network */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Status = {
  /** Represents the observations of a network's current state. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Status_Conditions_Items>
    >
  >;
};

/** NetworkStatus defines the observed state of Network */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Status_Input = {
  /** Represents the observations of a network's current state. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Status_Conditions_Items_Input>
    >
  >;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetwork_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetwork_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetwork_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetwork_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetwork_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedNetwork_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedNetwork_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** SubnetClaimSpec defines the desired state of SubnetClaim */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec = {
  ipFamily: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec_IpFamily;
  location: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec_Location;
  networkContext: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec_NetworkContext;
  /** The prefix length of a subnet claim */
  prefixLength?: Maybe<Scalars['Int']['output']>;
  /** The start address of a subnet claim */
  startAddress?: Maybe<Scalars['String']['output']>;
  /** The class of subnet required */
  subnetClass: Scalars['String']['output'];
};

/** SubnetClaimSpec defines the desired state of SubnetClaim */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec_Input = {
  ipFamily: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec_IpFamily;
  location: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec_Location_Input;
  networkContext: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec_NetworkContext_Input;
  /** The prefix length of a subnet claim */
  prefixLength?: InputMaybe<Scalars['Int']['input']>;
  /** The start address of a subnet claim */
  startAddress?: InputMaybe<Scalars['String']['input']>;
  /** The class of subnet required */
  subnetClass: Scalars['String']['input'];
};

/** The IP family of a subnet claim */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec_IpFamily =
  | 'IPv4'
  | 'IPv6';

/** The location which a subnet claim is associated with */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec_Location =
  {
    /** Name of a datum location */
    name: Scalars['String']['output'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['output'];
  };

/** The location which a subnet claim is associated with */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec_Location_Input =
  {
    /** Name of a datum location */
    name: Scalars['String']['input'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['input'];
  };

/** The network context to claim a subnet in */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec_NetworkContext =
  {
    /** The network context name */
    name: Scalars['String']['output'];
  };

/** The network context to claim a subnet in */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Spec_NetworkContext_Input =
  {
    /** The network context name */
    name: Scalars['String']['input'];
  };

/** SubnetClaimStatus defines the observed state of SubnetClaim */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status = {
  /** Represents the observations of a subnet claim's current state. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status_Conditions_Items>
    >
  >;
  /** The prefix length of a subnet claim */
  prefixLength?: Maybe<Scalars['Int']['output']>;
  /** The start address of a subnet claim */
  startAddress?: Maybe<Scalars['String']['output']>;
  subnetRef?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status_SubnetRef>;
};

/** SubnetClaimStatus defines the observed state of SubnetClaim */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status_Input =
  {
    /** Represents the observations of a subnet claim's current state. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /** The prefix length of a subnet claim */
    prefixLength?: InputMaybe<Scalars['Int']['input']>;
    /** The start address of a subnet claim */
    startAddress?: InputMaybe<Scalars['String']['input']>;
    subnetRef?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status_SubnetRef_Input>;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedSubnetClaim_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedSubnetClaim_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedSubnetClaim_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedSubnetClaim_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedSubnetClaim_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedSubnetClaim_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** The subnet which has been claimed from */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status_SubnetRef =
  {
    name: Scalars['String']['output'];
  };

/** The subnet which has been claimed from */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnetClaim_Items_Items_Status_SubnetRef_Input =
  {
    name: Scalars['String']['input'];
  };

/** SubnetSpec defines the desired state of Subnet */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec = {
  ipFamily: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec_IpFamily;
  location: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec_Location;
  networkContext: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec_NetworkContext;
  /** The prefix length of a subnet */
  prefixLength: Scalars['Int']['output'];
  /** The start address of a subnet */
  startAddress: Scalars['String']['output'];
  /** The class of subnet */
  subnetClass: Scalars['String']['output'];
};

/** SubnetSpec defines the desired state of Subnet */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec_Input = {
  ipFamily: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec_IpFamily;
  location: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec_Location_Input;
  networkContext: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec_NetworkContext_Input;
  /** The prefix length of a subnet */
  prefixLength: Scalars['Int']['input'];
  /** The start address of a subnet */
  startAddress: Scalars['String']['input'];
  /** The class of subnet */
  subnetClass: Scalars['String']['input'];
};

/** The IP family of a subnet */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec_IpFamily =
  | 'IPv4'
  | 'IPv6';

/** The location which a subnet is associated with */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec_Location = {
  /** Name of a datum location */
  name: Scalars['String']['output'];
  /** Namespace for the datum location */
  namespace: Scalars['String']['output'];
};

/** The location which a subnet is associated with */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec_Location_Input =
  {
    /** Name of a datum location */
    name: Scalars['String']['input'];
    /** Namespace for the datum location */
    namespace: Scalars['String']['input'];
  };

/** A subnet's network context */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec_NetworkContext =
  {
    /** The network context name */
    name: Scalars['String']['output'];
  };

/** A subnet's network context */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Spec_NetworkContext_Input =
  {
    /** The network context name */
    name: Scalars['String']['input'];
  };

/** SubnetStatus defines the observed state of a Subnet */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Status = {
  /** Represents the observations of a subnet's current state. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Status_Conditions_Items>
    >
  >;
  /** The prefix length of a subnet */
  prefixLength?: Maybe<Scalars['Int']['output']>;
  /** The start address of a subnet */
  startAddress?: Maybe<Scalars['String']['output']>;
};

/** SubnetStatus defines the observed state of a Subnet */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Status_Input = {
  /** Represents the observations of a subnet's current state. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /** The prefix length of a subnet */
  prefixLength?: InputMaybe<Scalars['Int']['input']>;
  /** The start address of a subnet */
  startAddress?: InputMaybe<Scalars['String']['input']>;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedSubnet_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedSubnet_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedSubnet_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedSubnet_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedSubnet_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedSubnet_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedSubnet_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** TrafficProtectionPolicySpec defines the desired state of TrafficProtectionPolicy. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec =
  {
    mode?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_Mode>;
    /** RuleSets specifies the TrafficProtectionPolicy rulesets to apply. */
    ruleSets: Array<
      Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items>
    >;
    /**
     * SamplingPercentage controls the percentage of traffic that will be processed
     * by the TrafficProtectionPolicy.
     */
    samplingPercentage?: Maybe<Scalars['PositiveInt']['output']>;
    /**
     * TargetRefs are the names of the Gateway resources this policy
     * is being attached to.
     */
    targetRefs: Array<
      Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_TargetRefs_Items>
    >;
  };

/** TrafficProtectionPolicySpec defines the desired state of TrafficProtectionPolicy. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_Input =
  {
    mode?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_Mode>;
    /** RuleSets specifies the TrafficProtectionPolicy rulesets to apply. */
    ruleSets?: Array<
      InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_Input>
    >;
    /**
     * SamplingPercentage controls the percentage of traffic that will be processed
     * by the TrafficProtectionPolicy.
     */
    samplingPercentage?: InputMaybe<Scalars['PositiveInt']['input']>;
    /**
     * TargetRefs are the names of the Gateway resources this policy
     * is being attached to.
     */
    targetRefs: Array<
      InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_TargetRefs_Items_Input>
    >;
  };

/**
 * Mode specifies the mode of traffic protection to apply.
 * If not specified, defaults to "Observe".
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_Mode =
  'Disabled' | 'Enforce' | 'Observe';

export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items =
  {
    owaspCoreRuleSet?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet>;
    type: OwaspCoreRuleSet_Const;
  };

export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_Input =
  {
    owaspCoreRuleSet?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet_Input>;
    type: OwaspCoreRuleSet_Const;
  };

/**
 * OWASPCoreRuleSet defines configuration options for the OWASP ModSecurity
 * Core Rule Set (CRS).
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet =
  {
    paranoiaLevels?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet_ParanoiaLevels>;
    ruleExclusions?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet_RuleExclusions>;
    scoreThresholds?: Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet_ScoreThresholds>;
  };

/**
 * OWASPCoreRuleSet defines configuration options for the OWASP ModSecurity
 * Core Rule Set (CRS).
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet_Input =
  {
    paranoiaLevels?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet_ParanoiaLevels_Input>;
    ruleExclusions?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet_RuleExclusions_Input>;
    scoreThresholds?: InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet_ScoreThresholds_Input>;
  };

/**
 * ParanoiaLevels specifies the OWASP ModSecurity Core Rule Set (CRS)
 * paranoia levels to use.
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet_ParanoiaLevels =
  {
    /** Blocking specifies the paranoia level for blocking requests or responses. */
    blocking?: Maybe<Scalars['PositiveInt']['output']>;
    /**
     * Detection specifies the paranoia level for detection only. This allows
     * setting a higher paranoia level for detection while keeping blocking at a
     * lower level.
     */
    detection?: Maybe<Scalars['PositiveInt']['output']>;
  };

/**
 * ParanoiaLevels specifies the OWASP ModSecurity Core Rule Set (CRS)
 * paranoia levels to use.
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet_ParanoiaLevels_Input =
  {
    /** Blocking specifies the paranoia level for blocking requests or responses. */
    blocking?: InputMaybe<Scalars['PositiveInt']['input']>;
    /**
     * Detection specifies the paranoia level for detection only. This allows
     * setting a higher paranoia level for detection while keeping blocking at a
     * lower level.
     */
    detection?: InputMaybe<Scalars['PositiveInt']['input']>;
  };

/**
 * RuleExclusions can be used to disable specific OWASP ModSecurity Rules.
 * This allows operators to disable specific rules that may be causing false
 * positives.
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet_RuleExclusions =
  {
    /** IDRanges is a list of specific rule ID ranges to disable. */
    idRanges?: Maybe<
      Array<
        Maybe<
          Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_ruleSets_items_owaspCoreRuleSet_ruleExclusions_idRanges_items']['output']
        >
      >
    >;
    /** IDs is a list of specific rule IDs to disable */
    ids?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
    /** Tags is a list of rule tags to disable. */
    tags?: Maybe<
      Array<
        Maybe<
          Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_ruleSets_items_owaspCoreRuleSet_ruleExclusions_tags_items']['output']
        >
      >
    >;
  };

/**
 * RuleExclusions can be used to disable specific OWASP ModSecurity Rules.
 * This allows operators to disable specific rules that may be causing false
 * positives.
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet_RuleExclusions_Input =
  {
    /** IDRanges is a list of specific rule ID ranges to disable. */
    idRanges?: InputMaybe<
      Array<
        InputMaybe<
          Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_ruleSets_items_owaspCoreRuleSet_ruleExclusions_idRanges_items']['input']
        >
      >
    >;
    /** IDs is a list of specific rule IDs to disable */
    ids?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
    /** Tags is a list of rule tags to disable. */
    tags?: InputMaybe<
      Array<
        InputMaybe<
          Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_ruleSets_items_owaspCoreRuleSet_ruleExclusions_tags_items']['input']
        >
      >
    >;
  };

/**
 * ScoreThresholds specifies the OWASP ModSecurity Core Rule Set (CRS)
 * score thresholds to block a request or response.
 *
 * See: https://coreruleset.org/docs/2-how-crs-works/2-1-anomaly_scoring/
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet_ScoreThresholds =
  {
    /** Inbound is the score threshold for blocking inbound (request) traffic. */
    inbound?: Maybe<Scalars['PositiveInt']['output']>;
    /** Outbound is the score threshold for blocking outbound (response) traffic. */
    outbound?: Maybe<Scalars['PositiveInt']['output']>;
  };

/**
 * ScoreThresholds specifies the OWASP ModSecurity Core Rule Set (CRS)
 * score thresholds to block a request or response.
 *
 * See: https://coreruleset.org/docs/2-how-crs-works/2-1-anomaly_scoring/
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_RuleSets_Items_OwaspCoreRuleSet_ScoreThresholds_Input =
  {
    /** Inbound is the score threshold for blocking inbound (request) traffic. */
    inbound?: InputMaybe<Scalars['PositiveInt']['input']>;
    /** Outbound is the score threshold for blocking outbound (response) traffic. */
    outbound?: InputMaybe<Scalars['PositiveInt']['input']>;
  };

/**
 * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
 * direct policy to. This should be used as part of Policy resources that can
 * target single resources. For more information on how this policy attachment
 * mode works, and a sample Policy resource, refer to the policy attachment
 * documentation for Gateway API.
 *
 * Note: This should only be used for direct policy attachment when references
 * to SectionName are actually needed. In all other cases,
 * LocalPolicyTargetReference should be used.
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_TargetRefs_Items =
  {
    group: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_targetRefs_items_group']['output'];
    kind: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_targetRefs_items_kind']['output'];
    /** Name is the name of the target resource. */
    name: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_targetRefs_items_name']['output'];
    sectionName?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_targetRefs_items_sectionName']['output']
    >;
  };

/**
 * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
 * direct policy to. This should be used as part of Policy resources that can
 * target single resources. For more information on how this policy attachment
 * mode works, and a sample Policy resource, refer to the policy attachment
 * documentation for Gateway API.
 *
 * Note: This should only be used for direct policy attachment when references
 * to SectionName are actually needed. In all other cases,
 * LocalPolicyTargetReference should be used.
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Spec_TargetRefs_Items_Input =
  {
    group: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_targetRefs_items_group']['input'];
    kind: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_targetRefs_items_kind']['input'];
    /** Name is the name of the target resource. */
    name: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_targetRefs_items_name']['input'];
    sectionName?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_spec_targetRefs_items_sectionName']['input']
    >;
  };

/** TrafficProtectionPolicyStatus defines the observed state of TrafficProtectionPolicy. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status =
  {
    /**
     * Ancestors is a list of ancestor resources (usually Gateways) that are
     * associated with the policy, and the status of the policy with respect to
     * each ancestor. When this policy attaches to a parent, the controller that
     * manages the parent and the ancestors MUST add an entry to this list when
     * the controller first sees the policy and SHOULD update the entry as
     * appropriate when the relevant ancestor is modified.
     *
     * Note that choosing the relevant ancestor is left to the Policy designers;
     * an important part of Policy design is designing the right object level at
     * which to namespace this status.
     *
     * Note also that implementations MUST ONLY populate ancestor status for
     * the Ancestor resources they are responsible for. Implementations MUST
     * use the ControllerName field to uniquely identify the entries in this list
     * that they are responsible for.
     *
     * Note that to achieve this, the list of PolicyAncestorStatus structs
     * MUST be treated as a map with a composite key, made up of the AncestorRef
     * and ControllerName fields combined.
     *
     * A maximum of 16 ancestors will be represented in this list. An empty list
     * means the Policy is not relevant for any ancestors.
     *
     * If this slice is full, implementations MUST NOT add further entries.
     * Instead they MUST consider the policy unimplementable and signal that
     * on any related resources such as the ancestor that would be referenced
     * here. For example, if this list was full on BackendTLSPolicy, no
     * additional Gateways would be able to reference the Service targeted by
     * the BackendTLSPolicy.
     */
    ancestors: Array<
      Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items>
    >;
  };

/** TrafficProtectionPolicyStatus defines the observed state of TrafficProtectionPolicy. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Input =
  {
    /**
     * Ancestors is a list of ancestor resources (usually Gateways) that are
     * associated with the policy, and the status of the policy with respect to
     * each ancestor. When this policy attaches to a parent, the controller that
     * manages the parent and the ancestors MUST add an entry to this list when
     * the controller first sees the policy and SHOULD update the entry as
     * appropriate when the relevant ancestor is modified.
     *
     * Note that choosing the relevant ancestor is left to the Policy designers;
     * an important part of Policy design is designing the right object level at
     * which to namespace this status.
     *
     * Note also that implementations MUST ONLY populate ancestor status for
     * the Ancestor resources they are responsible for. Implementations MUST
     * use the ControllerName field to uniquely identify the entries in this list
     * that they are responsible for.
     *
     * Note that to achieve this, the list of PolicyAncestorStatus structs
     * MUST be treated as a map with a composite key, made up of the AncestorRef
     * and ControllerName fields combined.
     *
     * A maximum of 16 ancestors will be represented in this list. An empty list
     * means the Policy is not relevant for any ancestors.
     *
     * If this slice is full, implementations MUST NOT add further entries.
     * Instead they MUST consider the policy unimplementable and signal that
     * on any related resources such as the ancestor that would be referenced
     * here. For example, if this list was full on BackendTLSPolicy, no
     * additional Gateways would be able to reference the Service targeted by
     * the BackendTLSPolicy.
     */
    ancestors: Array<
      InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items_Input>
    >;
  };

/**
 * PolicyAncestorStatus describes the status of a route with respect to an
 * associated Ancestor.
 *
 * Ancestors refer to objects that are either the Target of a policy or above it
 * in terms of object hierarchy. For example, if a policy targets a Service, the
 * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
 * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
 * useful object to place Policy status on, so we recommend that implementations
 * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
 * have a _very_ good reason otherwise.
 *
 * In the context of policy attachment, the Ancestor is used to distinguish which
 * resource results in a distinct application of this policy. For example, if a policy
 * targets a Service, it may have a distinct result per attached Gateway.
 *
 * Policies targeting the same resource may have different effects depending on the
 * ancestors of those resources. For example, different Gateways targeting the same
 * Service may have different capabilities, especially if they have different underlying
 * implementations.
 *
 * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
 * used as a backend in a HTTPRoute that is itself attached to a Gateway.
 * In this case, the relevant object for status is the Gateway, and that is the
 * ancestor object referred to in this status.
 *
 * Note that a parent is also an ancestor, so for objects where the parent is the
 * relevant object for status, this struct SHOULD still be used.
 *
 * This struct is intended to be used in a slice that's effectively a map,
 * with a composite key made up of the AncestorRef and the ControllerName.
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items =
  {
    ancestorRef: Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items_AncestorRef;
    /** Conditions describes the status of the Policy with respect to the given Ancestor. */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items_Conditions_Items>
      >
    >;
    controllerName: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_controllerName']['output'];
  };

/**
 * PolicyAncestorStatus describes the status of a route with respect to an
 * associated Ancestor.
 *
 * Ancestors refer to objects that are either the Target of a policy or above it
 * in terms of object hierarchy. For example, if a policy targets a Service, the
 * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
 * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
 * useful object to place Policy status on, so we recommend that implementations
 * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
 * have a _very_ good reason otherwise.
 *
 * In the context of policy attachment, the Ancestor is used to distinguish which
 * resource results in a distinct application of this policy. For example, if a policy
 * targets a Service, it may have a distinct result per attached Gateway.
 *
 * Policies targeting the same resource may have different effects depending on the
 * ancestors of those resources. For example, different Gateways targeting the same
 * Service may have different capabilities, especially if they have different underlying
 * implementations.
 *
 * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
 * used as a backend in a HTTPRoute that is itself attached to a Gateway.
 * In this case, the relevant object for status is the Gateway, and that is the
 * ancestor object referred to in this status.
 *
 * Note that a parent is also an ancestor, so for objects where the parent is the
 * relevant object for status, this struct SHOULD still be used.
 *
 * This struct is intended to be used in a slice that's effectively a map,
 * with a composite key made up of the AncestorRef and the ControllerName.
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items_Input =
  {
    ancestorRef: Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items_AncestorRef_Input;
    /** Conditions describes the status of the Policy with respect to the given Ancestor. */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items_Conditions_Items_Input>
      >
    >;
    controllerName: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_controllerName']['input'];
  };

/**
 * AncestorRef corresponds with a ParentRef in the spec that this
 * PolicyAncestorStatus struct describes the status of.
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items_AncestorRef =
  {
    group?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_group']['output']
    >;
    kind?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_kind']['output']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_name']['output'];
    namespace?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_namespace']['output']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     * <gateway:experimental:description>
     * When the parent resource is a Service, this targets a specific port in the
     * Service spec. When both Port (experimental) and SectionName are specified,
     * the name and port of the selected port must match both specified values.
     * </gateway:experimental:description>
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: Maybe<Scalars['Int']['output']>;
    sectionName?: Maybe<
      Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_sectionName']['output']
    >;
  };

/**
 * AncestorRef corresponds with a ParentRef in the spec that this
 * PolicyAncestorStatus struct describes the status of.
 */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items_AncestorRef_Input =
  {
    group?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_group']['input']
    >;
    kind?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_kind']['input']
    >;
    /**
     * Name is the name of the referent.
     *
     * Support: Core
     */
    name: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_name']['input'];
    namespace?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_namespace']['input']
    >;
    /**
     * Port is the network port this Route targets. It can be interpreted
     * differently based on the type of parent resource.
     *
     * When the parent resource is a Gateway, this targets all listeners
     * listening on the specified port that also support this kind of Route(and
     * select this Route). It's not recommended to set `Port` unless the
     * networking behaviors specified in a Route must apply to a specific port
     * as opposed to a listener(s) whose port(s) may be changed. When both Port
     * and SectionName are specified, the name and port of the selected listener
     * must match both specified values.
     *
     * <gateway:experimental:description>
     * When the parent resource is a Service, this targets a specific port in the
     * Service spec. When both Port (experimental) and SectionName are specified,
     * the name and port of the selected port must match both specified values.
     * </gateway:experimental:description>
     *
     * Implementations MAY choose to support other parent resources.
     * Implementations supporting other types of parent resources MUST clearly
     * document how/if Port is interpreted.
     *
     * For the purpose of status, an attachment is considered successful as
     * long as the parent resource accepts it partially. For example, Gateway
     * listeners can restrict which Routes can attach to them by Route kind,
     * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
     * from the referencing Route, the Route MUST be considered successfully
     * attached. If no Gateway listeners accept attachment from this Route,
     * the Route MUST be considered detached from the Gateway.
     *
     * Support: Extended
     */
    port?: InputMaybe<Scalars['Int']['input']>;
    sectionName?: InputMaybe<
      Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_ancestorRef_sectionName']['input']
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_conditions_items_reason']['output'];
    status: Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_conditions_items_reason']['input'];
    status: Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items_Conditions_Items_Status;
    type: Scalars['query_listNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_items_items_status_ancestors_items_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNetworkingDatumapisComV1alphaNamespacedTrafficProtectionPolicy_Items_Items_Status_Ancestors_Items_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** ContactSpec defines the desired state of Contact. */
export type Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Spec = {
  email: Scalars['String']['output'];
  familyName?: Maybe<Scalars['String']['output']>;
  givenName?: Maybe<Scalars['String']['output']>;
  subject?: Maybe<Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Spec_Subject>;
};

/** ContactSpec defines the desired state of Contact. */
export type Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Spec_Input =
  {
    email: Scalars['String']['input'];
    familyName?: InputMaybe<Scalars['String']['input']>;
    givenName?: InputMaybe<Scalars['String']['input']>;
    subject?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Spec_Subject_Input>;
  };

/** Subject is a reference to the subject of the contact. */
export type Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Spec_Subject =
  {
    apiGroup: Iam_Miloapis_Com_Const;
    kind: User_Const;
    /** Name is the name of resource being referenced. */
    name: Scalars['String']['output'];
    /**
     * Namespace is the namespace of resource being referenced.
     * Required for namespace-scoped resources. Omitted for cluster-scoped resources.
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/** Subject is a reference to the subject of the contact. */
export type Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Spec_Subject_Input =
  {
    apiGroup: Iam_Miloapis_Com_Const;
    kind: User_Const;
    /** Name is the name of resource being referenced. */
    name: Scalars['String']['input'];
    /**
     * Namespace is the namespace of resource being referenced.
     * Required for namespace-scoped resources. Omitted for cluster-scoped resources.
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

export type Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status = {
  /**
   * Conditions represent the latest available observations of an object's current state.
   * Standard condition is "Ready" which tracks contact creation status and sync to the contact provider.
   */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
  /**
   * ProviderID is the identifier returned by the underlying contact provider
   * (e.g. Resend) when the contact is created. It is usually
   * used to track the contact creation status (e.g. provider webhooks).
   * Deprecated: Use Providers instead.
   */
  providerID?: Maybe<Scalars['String']['output']>;
  /**
   * Providers contains the per-provider status for this contact.
   * This enables tracking multiple provider backends simultaneously.
   */
  providers?: Maybe<
    Array<
      Maybe<Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Providers_Items>
    >
  >;
};

export type Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * Conditions represent the latest available observations of an object's current state.
     * Standard condition is "Ready" which tracks contact creation status and sync to the contact provider.
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /**
     * ProviderID is the identifier returned by the underlying contact provider
     * (e.g. Resend) when the contact is created. It is usually
     * used to track the contact creation status (e.g. provider webhooks).
     * Deprecated: Use Providers instead.
     */
    providerID?: InputMaybe<Scalars['String']['input']>;
    /**
     * Providers contains the per-provider status for this contact.
     * This enables tracking multiple provider backends simultaneously.
     */
    providers?: InputMaybe<
      Array<
        InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Providers_Items_Input>
      >
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1ContactForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1ContactForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1ContactForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1ContactForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1ContactForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1ContactForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * ContactProviderStatus represents status information for a single contact provider.
 * It allows tracking the provider name and the provider-specific identifier.
 */
export type Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Providers_Items =
  {
    /** ID is the identifier returned by the specific contact provider for this contact. */
    id: Scalars['String']['output'];
    name: Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Providers_Items_Name;
  };

/**
 * ContactProviderStatus represents status information for a single contact provider.
 * It allows tracking the provider name and the provider-specific identifier.
 */
export type Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Providers_Items_Input =
  {
    /** ID is the identifier returned by the specific contact provider for this contact. */
    id: Scalars['String']['input'];
    name: Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Providers_Items_Name;
  };

/**
 * Name is the provider handling this contact.
 * Allowed values are Resend and Loops.
 */
export type Query_ListNotificationMiloapisComV1alpha1ContactForAllNamespaces_Items_Items_Status_Providers_Items_Name =
  'Loops' | 'Resend';

/** ContactGroupSpec defines the desired state of ContactGroup. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Spec =
  {
    /** DisplayName is the display name of the contact group. */
    displayName: Scalars['String']['output'];
    /** Providers defines the providers this group should be synced to. */
    providers?: Maybe<
      Array<
        Maybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Spec_Providers_Items>
      >
    >;
    visibility: Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Spec_Visibility;
  };

/** ContactGroupSpec defines the desired state of ContactGroup. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Spec_Input =
  {
    /** DisplayName is the display name of the contact group. */
    displayName: Scalars['String']['input'];
    /** Providers defines the providers this group should be synced to. */
    providers?: InputMaybe<
      Array<
        InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Spec_Providers_Items_Input>
      >
    >;
    visibility: Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Spec_Visibility;
  };

/** ContactGroupProviderSpec defines the desired state of a contact group in a specific provider. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Spec_Providers_Items =
  {
    /**
     * ID is the identifier of the contact group in the external provider.
     * This field is used when a provider does not expose an API for creating mailing lists,
     * requiring an existing ContactList ID to be provided for synchronization purposes (e.g. Loops).
     * If not provided, a new group will be created if supported by the provider.
     */
    id: Scalars['String']['output'];
    name: Loops_Const;
  };

/** ContactGroupProviderSpec defines the desired state of a contact group in a specific provider. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Spec_Providers_Items_Input =
  {
    /**
     * ID is the identifier of the contact group in the external provider.
     * This field is used when a provider does not expose an API for creating mailing lists,
     * requiring an existing ContactList ID to be provided for synchronization purposes (e.g. Loops).
     * If not provided, a new group will be created if supported by the provider.
     */
    id: Scalars['String']['input'];
    name: Loops_Const;
  };

/**
 * Visibility determines whether members are allowed opt-in or opt-out of the contactgroup.
 *    "public"   members may leave via ContactGroupMembershipRemoval.
 *    "private"  membership is enforced; opt-out requests are rejected.
 */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Spec_Visibility =
  'private' | 'public';

export type Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status =
  {
    /**
     * Conditions represent the latest available observations of an object's current state.
     * Standard condition is "Ready" which tracks contact group creation status and sync to the contact group provider.
     */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Conditions_Items>
      >
    >;
    /**
     * ProviderID is the identifier returned by the underlying contact groupprovider
     * (e.g. Resend) when the contact groupis created. It is usually
     * used to track the contact creation status (e.g. provider webhooks).
     * Deprecated: Use Providers instead.
     */
    providerID?: Maybe<Scalars['String']['output']>;
    /**
     * Providers contains the per-provider status for this contact group.
     * This enables tracking multiple provider backends simultaneously.
     */
    providers?: Maybe<
      Array<
        Maybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Providers_Items>
      >
    >;
  };

export type Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * Conditions represent the latest available observations of an object's current state.
     * Standard condition is "Ready" which tracks contact group creation status and sync to the contact group provider.
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /**
     * ProviderID is the identifier returned by the underlying contact groupprovider
     * (e.g. Resend) when the contact groupis created. It is usually
     * used to track the contact creation status (e.g. provider webhooks).
     * Deprecated: Use Providers instead.
     */
    providerID?: InputMaybe<Scalars['String']['input']>;
    /**
     * Providers contains the per-provider status for this contact group.
     * This enables tracking multiple provider backends simultaneously.
     */
    providers?: InputMaybe<
      Array<
        InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Providers_Items_Input>
      >
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * ContactProviderStatus represents status information for a single contact provider.
 * It allows tracking the provider name and the provider-specific identifier.
 */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Providers_Items =
  {
    /** ID is the identifier returned by the specific contact provider for this contact. */
    id: Scalars['String']['output'];
    name: Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Providers_Items_Name;
  };

/**
 * ContactProviderStatus represents status information for a single contact provider.
 * It allows tracking the provider name and the provider-specific identifier.
 */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Providers_Items_Input =
  {
    /** ID is the identifier returned by the specific contact provider for this contact. */
    id: Scalars['String']['input'];
    name: Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Providers_Items_Name;
  };

/**
 * Name is the provider handling this contact.
 * Allowed values are Resend and Loops.
 */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupForAllNamespaces_Items_Items_Status_Providers_Items_Name =
  'Loops' | 'Resend';

/** ContactGroupMembershipSpec defines the desired state of ContactGroupMembership. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Spec =
  {
    contactGroupRef: Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Spec_ContactGroupRef;
    contactRef: Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Spec_ContactRef;
  };

/** ContactGroupMembershipSpec defines the desired state of ContactGroupMembership. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Spec_Input =
  {
    contactGroupRef: Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Spec_ContactGroupRef_Input;
    contactRef: Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Spec_ContactRef_Input;
  };

/** ContactGroupRef is a reference to the ContactGroup that the Contact is a member of. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Spec_ContactGroupRef =
  {
    /** Name is the name of the ContactGroup being referenced. */
    name: Scalars['String']['output'];
    /** Namespace is the namespace of the ContactGroup being referenced. */
    namespace: Scalars['String']['output'];
  };

/** ContactGroupRef is a reference to the ContactGroup that the Contact is a member of. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Spec_ContactGroupRef_Input =
  {
    /** Name is the name of the ContactGroup being referenced. */
    name: Scalars['String']['input'];
    /** Namespace is the namespace of the ContactGroup being referenced. */
    namespace: Scalars['String']['input'];
  };

/** ContactRef is a reference to the Contact that is a member of the ContactGroup. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Spec_ContactRef =
  {
    /** Name is the name of the Contact being referenced. */
    name: Scalars['String']['output'];
    /** Namespace is the namespace of the Contact being referenced. */
    namespace: Scalars['String']['output'];
  };

/** ContactRef is a reference to the Contact that is a member of the ContactGroup. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Spec_ContactRef_Input =
  {
    /** Name is the name of the Contact being referenced. */
    name: Scalars['String']['input'];
    /** Namespace is the namespace of the Contact being referenced. */
    namespace: Scalars['String']['input'];
  };

export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status =
  {
    /**
     * Conditions represent the latest available observations of an object's current state.
     * Standard condition is "Ready" which tracks contact group membership creation status and sync to the contact group membership provider.
     */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Conditions_Items>
      >
    >;
    /**
     * ProviderID is the identifier returned by the underlying contact provider
     * (e.g. Resend) when the membership is created in the associated audience. It is usually
     * used to track the contact-group membership creation status (e.g. provider webhooks).
     * Deprecated: Use Providers instead.
     */
    providerID?: Maybe<Scalars['String']['output']>;
    /**
     * Providers contains the per-provider status for this contact group membership.
     * This enables tracking multiple provider backends simultaneously.
     */
    providers?: Maybe<
      Array<
        Maybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Providers_Items>
      >
    >;
    /**
     * Username is the username of the user that owns the ContactGroupMembership.
     * This is populated by the controller based on the referenced Contact's subject.
     */
    username?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * Conditions represent the latest available observations of an object's current state.
     * Standard condition is "Ready" which tracks contact group membership creation status and sync to the contact group membership provider.
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /**
     * ProviderID is the identifier returned by the underlying contact provider
     * (e.g. Resend) when the membership is created in the associated audience. It is usually
     * used to track the contact-group membership creation status (e.g. provider webhooks).
     * Deprecated: Use Providers instead.
     */
    providerID?: InputMaybe<Scalars['String']['input']>;
    /**
     * Providers contains the per-provider status for this contact group membership.
     * This enables tracking multiple provider backends simultaneously.
     */
    providers?: InputMaybe<
      Array<
        InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Providers_Items_Input>
      >
    >;
    /**
     * Username is the username of the user that owns the ContactGroupMembership.
     * This is populated by the controller based on the referenced Contact's subject.
     */
    username?: InputMaybe<Scalars['String']['input']>;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * ContactProviderStatus represents status information for a single contact provider.
 * It allows tracking the provider name and the provider-specific identifier.
 */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Providers_Items =
  {
    /** ID is the identifier returned by the specific contact provider for this contact. */
    id: Scalars['String']['output'];
    name: Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Providers_Items_Name;
  };

/**
 * ContactProviderStatus represents status information for a single contact provider.
 * It allows tracking the provider name and the provider-specific identifier.
 */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Providers_Items_Input =
  {
    /** ID is the identifier returned by the specific contact provider for this contact. */
    id: Scalars['String']['input'];
    name: Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Providers_Items_Name;
  };

/**
 * Name is the provider handling this contact.
 * Allowed values are Resend and Loops.
 */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipForAllNamespaces_Items_Items_Status_Providers_Items_Name =
  'Loops' | 'Resend';

export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Spec =
  {
    contactGroupRef: Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Spec_ContactGroupRef;
    contactRef: Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Spec_ContactRef;
  };

export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Spec_Input =
  {
    contactGroupRef: Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Spec_ContactGroupRef_Input;
    contactRef: Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Spec_ContactRef_Input;
  };

/** ContactGroupRef is a reference to the ContactGroup that the Contact does not want to be a member of. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Spec_ContactGroupRef =
  {
    /** Name is the name of the ContactGroup being referenced. */
    name: Scalars['String']['output'];
    /** Namespace is the namespace of the ContactGroup being referenced. */
    namespace: Scalars['String']['output'];
  };

/** ContactGroupRef is a reference to the ContactGroup that the Contact does not want to be a member of. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Spec_ContactGroupRef_Input =
  {
    /** Name is the name of the ContactGroup being referenced. */
    name: Scalars['String']['input'];
    /** Namespace is the namespace of the ContactGroup being referenced. */
    namespace: Scalars['String']['input'];
  };

/** ContactRef is a reference to the Contact that prevents the Contact from being part of the ContactGroup. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Spec_ContactRef =
  {
    /** Name is the name of the Contact being referenced. */
    name: Scalars['String']['output'];
    /** Namespace is the namespace of the Contact being referenced. */
    namespace: Scalars['String']['output'];
  };

/** ContactRef is a reference to the Contact that prevents the Contact from being part of the ContactGroup. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Spec_ContactRef_Input =
  {
    /** Name is the name of the Contact being referenced. */
    name: Scalars['String']['input'];
    /** Namespace is the namespace of the Contact being referenced. */
    namespace: Scalars['String']['input'];
  };

export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Status =
  {
    /**
     * Conditions represent the latest available observations of an object's current state.
     * Standard condition is "Ready" which tracks contact group membership removal creation status.
     */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Status_Conditions_Items>
      >
    >;
    /**
     * Username is the username of the user that owns the ContactGroupMembershipRemoval.
     * This is populated by the controller based on the referenced Contact's subject.
     */
    username?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * Conditions represent the latest available observations of an object's current state.
     * Standard condition is "Ready" which tracks contact group membership removal creation status.
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /**
     * Username is the username of the user that owns the ContactGroupMembershipRemoval.
     * This is populated by the controller based on the referenced Contact's subject.
     */
    username?: InputMaybe<Scalars['String']['input']>;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNotificationMiloapisComV1alpha1ContactGroupMembershipRemovalForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** EmailBroadcastSpec defines the desired state of EmailBroadcast. */
export type Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Spec =
  {
    contactGroupRef: Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Spec_ContactGroupRef;
    /** DisplayName is the display name of the email broadcast. */
    displayName?: Maybe<Scalars['String']['output']>;
    /**
     * ScheduledAt optionally specifies the time at which the broadcast should be executed.
     * If omitted, the message is sent as soon as the controller reconciles the resource.
     * Example: "2024-08-05T11:52:01.858Z"
     */
    scheduledAt?: Maybe<Scalars['DateTime']['output']>;
    templateRef: Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Spec_TemplateRef;
  };

/** EmailBroadcastSpec defines the desired state of EmailBroadcast. */
export type Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Spec_Input =
  {
    contactGroupRef: Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Spec_ContactGroupRef_Input;
    /** DisplayName is the display name of the email broadcast. */
    displayName?: InputMaybe<Scalars['String']['input']>;
    /**
     * ScheduledAt optionally specifies the time at which the broadcast should be executed.
     * If omitted, the message is sent as soon as the controller reconciles the resource.
     * Example: "2024-08-05T11:52:01.858Z"
     */
    scheduledAt?: InputMaybe<Scalars['DateTime']['input']>;
    templateRef: Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Spec_TemplateRef_Input;
  };

/** ContactGroupRef is a reference to the ContactGroup that the email broadcast is for. */
export type Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Spec_ContactGroupRef =
  {
    /** Name is the name of the ContactGroup being referenced. */
    name: Scalars['String']['output'];
    /** Namespace is the namespace of the ContactGroup being referenced. */
    namespace: Scalars['String']['output'];
  };

/** ContactGroupRef is a reference to the ContactGroup that the email broadcast is for. */
export type Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Spec_ContactGroupRef_Input =
  {
    /** Name is the name of the ContactGroup being referenced. */
    name: Scalars['String']['input'];
    /** Namespace is the namespace of the ContactGroup being referenced. */
    namespace: Scalars['String']['input'];
  };

/**
 * TemplateRef references the EmailTemplate to render the broadcast message.
 * When using the Resend provider you can include the following placeholders
 * in HTMLBody or TextBody; they will be substituted by the provider at send time:
 *   {{{FIRST_NAME}}} {{{LAST_NAME}}} {{{EMAIL}}}
 */
export type Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Spec_TemplateRef =
  {
    /** Name is the name of the EmailTemplate being referenced. */
    name: Scalars['String']['output'];
  };

/**
 * TemplateRef references the EmailTemplate to render the broadcast message.
 * When using the Resend provider you can include the following placeholders
 * in HTMLBody or TextBody; they will be substituted by the provider at send time:
 *   {{{FIRST_NAME}}} {{{LAST_NAME}}} {{{EMAIL}}}
 */
export type Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Spec_TemplateRef_Input =
  {
    /** Name is the name of the EmailTemplate being referenced. */
    name: Scalars['String']['input'];
  };

export type Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Status =
  {
    /**
     * Conditions represent the latest available observations of an object's current state.
     * Standard condition is "Ready" which tracks email broadcast status and sync to the email broadcast provider.
     */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Status_Conditions_Items>
      >
    >;
    /**
     * ProviderID is the identifier returned by the underlying email broadcast provider
     * (e.g. Resend) when the email broadcast is created. It is usually
     * used to track the email broadcast creation status (e.g. provider webhooks).
     */
    providerID?: Maybe<Scalars['String']['output']>;
  };

export type Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * Conditions represent the latest available observations of an object's current state.
     * Standard condition is "Ready" which tracks email broadcast status and sync to the email broadcast provider.
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /**
     * ProviderID is the identifier returned by the underlying email broadcast provider
     * (e.g. Resend) when the email broadcast is created. It is usually
     * used to track the email broadcast creation status (e.g. provider webhooks).
     */
    providerID?: InputMaybe<Scalars['String']['input']>;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNotificationMiloapisComV1alpha1EmailBroadcastForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * EmailSpec defines the desired state of Email.
 * It references a template, recipients, and any variables required to render the final message.
 */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec = {
  /**
   * BCC contains e-mail addresses that will receive a blind-carbon copy of the message.
   * Maximum 10 addresses.
   */
  bcc?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /**
   * CC contains additional e-mail addresses that will receive a carbon copy of the message.
   * Maximum 10 addresses.
   */
  cc?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  priority?: Maybe<Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Priority>;
  recipient: Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Recipient;
  templateRef: Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_TemplateRef;
  /** Variables supplies the values that will be substituted in the template. */
  variables?: Maybe<
    Array<
      Maybe<Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Variables_Items>
    >
  >;
};

/**
 * EmailSpec defines the desired state of Email.
 * It references a template, recipients, and any variables required to render the final message.
 */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Input =
  {
    /**
     * BCC contains e-mail addresses that will receive a blind-carbon copy of the message.
     * Maximum 10 addresses.
     */
    bcc?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    /**
     * CC contains additional e-mail addresses that will receive a carbon copy of the message.
     * Maximum 10 addresses.
     */
    cc?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    priority?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Priority>;
    recipient: Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Recipient_Input;
    templateRef: Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_TemplateRef_Input;
    /** Variables supplies the values that will be substituted in the template. */
    variables?: InputMaybe<
      Array<
        InputMaybe<Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Variables_Items_Input>
      >
    >;
  };

/** Priority influences the order in which pending e-mails are processed. */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Priority =
  'high' | 'low' | 'normal';

/** Recipient contain the recipient of the email. */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Recipient =
  {
    /**
     * EmailAddress allows specifying a literal e-mail address for the recipient instead of referencing a User resource.
     * It is mutually exclusive with UserRef: exactly one of them must be specified.
     */
    emailAddress?: Maybe<Scalars['String']['output']>;
    userRef?: Maybe<Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Recipient_UserRef>;
  };

/** Recipient contain the recipient of the email. */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Recipient_Input =
  {
    /**
     * EmailAddress allows specifying a literal e-mail address for the recipient instead of referencing a User resource.
     * It is mutually exclusive with UserRef: exactly one of them must be specified.
     */
    emailAddress?: InputMaybe<Scalars['String']['input']>;
    userRef?: InputMaybe<Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Recipient_UserRef_Input>;
  };

/**
 * UserRef references the User resource that will receive the message.
 * It is mutually exclusive with EmailAddress: exactly one of them must be specified.
 */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Recipient_UserRef =
  {
    /** Name contain the name of the User resource that will receive the email. */
    name: Scalars['String']['output'];
  };

/**
 * UserRef references the User resource that will receive the message.
 * It is mutually exclusive with EmailAddress: exactly one of them must be specified.
 */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Recipient_UserRef_Input =
  {
    /** Name contain the name of the User resource that will receive the email. */
    name: Scalars['String']['input'];
  };

/** TemplateRef references the EmailTemplate that should be rendered. */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_TemplateRef =
  {
    /** Name is the name of the EmailTemplate being referenced. */
    name: Scalars['String']['output'];
  };

/** TemplateRef references the EmailTemplate that should be rendered. */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_TemplateRef_Input =
  {
    /** Name is the name of the EmailTemplate being referenced. */
    name: Scalars['String']['input'];
  };

/** EmailVariable represents a name/value pair that will be injected into the template. */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Variables_Items =
  {
    /** Name of the variable as declared in the associated EmailTemplate. */
    name: Scalars['String']['output'];
    /** Value provided for this variable. */
    value: Scalars['String']['output'];
  };

/** EmailVariable represents a name/value pair that will be injected into the template. */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Spec_Variables_Items_Input =
  {
    /** Name of the variable as declared in the associated EmailTemplate. */
    name: Scalars['String']['input'];
    /** Value provided for this variable. */
    value: Scalars['String']['input'];
  };

/**
 * EmailStatus captures the observed state of an Email.
 * Uses standard Kubernetes conditions to track both processing and delivery state.
 */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Status = {
  /**
   * Conditions represent the latest available observations of an object's current state.
   * Standard condition is "Delivered" which tracks email delivery status.
   */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Status_Conditions_Items>
    >
  >;
  /**
   * EmailAddress stores the final recipient address used for delivery,
   * after resolving any referenced User.
   */
  emailAddress?: Maybe<Scalars['String']['output']>;
  /** HTMLBody stores the rendered HTML content of the e-mail. */
  htmlBody?: Maybe<Scalars['String']['output']>;
  /**
   * ProviderID is the identifier returned by the underlying email provider
   * (e.g. Resend) when the e-mail is accepted for delivery. It is usually
   * used to track the email delivery status (e.g. provider webhooks).
   */
  providerID?: Maybe<Scalars['String']['output']>;
  /** Subject stores the subject line used for the e-mail. */
  subject?: Maybe<Scalars['String']['output']>;
  /** TextBody stores the rendered plain-text content of the e-mail. */
  textBody?: Maybe<Scalars['String']['output']>;
};

/**
 * EmailStatus captures the observed state of an Email.
 * Uses standard Kubernetes conditions to track both processing and delivery state.
 */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * Conditions represent the latest available observations of an object's current state.
     * Standard condition is "Delivered" which tracks email delivery status.
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /**
     * EmailAddress stores the final recipient address used for delivery,
     * after resolving any referenced User.
     */
    emailAddress?: InputMaybe<Scalars['String']['input']>;
    /** HTMLBody stores the rendered HTML content of the e-mail. */
    htmlBody?: InputMaybe<Scalars['String']['input']>;
    /**
     * ProviderID is the identifier returned by the underlying email provider
     * (e.g. Resend) when the e-mail is accepted for delivery. It is usually
     * used to track the email delivery status (e.g. provider webhooks).
     */
    providerID?: InputMaybe<Scalars['String']['input']>;
    /** Subject stores the subject line used for the e-mail. */
    subject?: InputMaybe<Scalars['String']['input']>;
    /** TextBody stores the rendered plain-text content of the e-mail. */
    textBody?: InputMaybe<Scalars['String']['input']>;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1EmailForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1EmailForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1EmailForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1EmailForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1EmailForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1EmailForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNotificationMiloapisComV1alpha1EmailForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * EmailTemplateSpec defines the desired state of EmailTemplate.
 * It contains the subject, content, and declared variables.
 */
export type Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Spec = {
  /** HTMLBody is the string for the HTML representation of the message. */
  htmlBody: Scalars['String']['output'];
  /** Subject is the string that composes the email subject line. */
  subject: Scalars['String']['output'];
  /** TextBody is the Go template string for the plain-text representation of the message. */
  textBody: Scalars['String']['output'];
  /** Variables enumerates all variables that can be referenced inside the template expressions. */
  variables?: Maybe<
    Array<
      Maybe<Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Spec_Variables_Items>
    >
  >;
};

/**
 * EmailTemplateSpec defines the desired state of EmailTemplate.
 * It contains the subject, content, and declared variables.
 */
export type Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Spec_Input = {
  /** HTMLBody is the string for the HTML representation of the message. */
  htmlBody: Scalars['String']['input'];
  /** Subject is the string that composes the email subject line. */
  subject: Scalars['String']['input'];
  /** TextBody is the Go template string for the plain-text representation of the message. */
  textBody: Scalars['String']['input'];
  /** Variables enumerates all variables that can be referenced inside the template expressions. */
  variables?: InputMaybe<
    Array<
      InputMaybe<Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Spec_Variables_Items_Input>
    >
  >;
};

/**
 * TemplateVariable declares a variable that can be referenced in the template body or subject.
 * Each variable must be listed here so that callers know which parameters are expected.
 */
export type Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Spec_Variables_Items =
  {
    /** Name is the identifier of the variable as it appears inside the Go template (e.g. {{.UserName}}). */
    name: Scalars['String']['output'];
    /** Required indicates whether the variable must be provided when rendering the template. */
    required: Scalars['Boolean']['output'];
    type: Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Spec_Variables_Items_Type;
  };

/**
 * TemplateVariable declares a variable that can be referenced in the template body or subject.
 * Each variable must be listed here so that callers know which parameters are expected.
 */
export type Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Spec_Variables_Items_Input =
  {
    /** Name is the identifier of the variable as it appears inside the Go template (e.g. {{.UserName}}). */
    name: Scalars['String']['input'];
    /** Required indicates whether the variable must be provided when rendering the template. */
    required: Scalars['Boolean']['input'];
    type: Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Spec_Variables_Items_Type;
  };

/** Type provides a hint about the expected value of this variable (e.g. plain string or URL). */
export type Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Spec_Variables_Items_Type =
  'string' | 'url';

/**
 * EmailTemplateStatus captures the observed state of an EmailTemplate.
 * Right now we only expose standard Kubernetes conditions so callers can
 * determine whether the template is ready for use.
 */
export type Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Status = {
  /** Conditions represent the latest available observations of an object's current state. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Status_Conditions_Items>
    >
  >;
};

/**
 * EmailTemplateStatus captures the observed state of an EmailTemplate.
 * Right now we only expose standard Kubernetes conditions so callers can
 * determine whether the template is ready for use.
 */
export type Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Status_Input = {
  /** Conditions represent the latest available observations of an object's current state. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Status_Conditions_Items_Input>
    >
  >;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1EmailTemplate_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1EmailTemplate_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1EmailTemplate_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1EmailTemplate_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1EmailTemplate_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1EmailTemplate_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNotificationMiloapisComV1alpha1EmailTemplate_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** NoteSpec defines the desired state of Note. */
export type Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Spec = {
  /** Action is an optional follow-up action. */
  action?: Maybe<Scalars['String']['output']>;
  /** ActionTime is the timestamp for the follow-up action. */
  actionTime?: Maybe<Scalars['DateTime']['output']>;
  /** ContactRef is the name of the Contact this note is attached to. */
  contactRef: Scalars['String']['output'];
  /** Content is the text content of the note. */
  content: Scalars['query_listNotificationMiloapisComV1alpha1NamespacedNote_items_items_spec_content']['output'];
  /**
   * InteractionTime is the timestamp of the interaction.
   * If not specified, it defaults to the creation timestamp of the note.
   */
  interactionTime?: Maybe<Scalars['DateTime']['output']>;
};

/** NoteSpec defines the desired state of Note. */
export type Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Spec_Input = {
  /** Action is an optional follow-up action. */
  action?: InputMaybe<Scalars['String']['input']>;
  /** ActionTime is the timestamp for the follow-up action. */
  actionTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** ContactRef is the name of the Contact this note is attached to. */
  contactRef: Scalars['String']['input'];
  /** Content is the text content of the note. */
  content: Scalars['query_listNotificationMiloapisComV1alpha1NamespacedNote_items_items_spec_content']['input'];
  /**
   * InteractionTime is the timestamp of the interaction.
   * If not specified, it defaults to the creation timestamp of the note.
   */
  interactionTime?: InputMaybe<Scalars['DateTime']['input']>;
};

/** NoteStatus defines the observed state of Note. */
export type Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Status = {
  /** Conditions represent the latest available observations of an object's state */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Status_Conditions_Items>
    >
  >;
};

/** NoteStatus defines the observed state of Note. */
export type Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Status_Input = {
  /** Conditions represent the latest available observations of an object's state */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Status_Conditions_Items_Input>
    >
  >;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1NamespacedNote_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1NamespacedNote_items_items_status_conditions_items_reason']['output'];
    status: Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1NamespacedNote_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listNotificationMiloapisComV1alpha1NamespacedNote_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listNotificationMiloapisComV1alpha1NamespacedNote_items_items_status_conditions_items_reason']['input'];
    status: Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listNotificationMiloapisComV1alpha1NamespacedNote_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListNotificationMiloapisComV1alpha1NamespacedNote_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * AllowanceBucketSpec defines the desired state of AllowanceBucket.
 * The system automatically creates buckets for each unique (consumer, resourceType) combination
 * found in active ResourceGrants.
 */
export type Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Spec = {
  consumerRef: Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Spec_ConsumerRef;
  /**
   * ResourceType specifies which resource type this bucket aggregates quota for.
   * Must exactly match a ResourceRegistration.spec.resourceType that is currently active.
   * The quota system validates this reference and only creates buckets for registered types.
   *
   * The identifier format is flexible, as defined by platform administrators
   * in their ResourceRegistrations.
   *
   * Examples:
   * - "resourcemanager.miloapis.com/projects"
   * - "compute_cpu"
   * - "storage.volumes"
   * - "custom-service-quota"
   */
  resourceType: Scalars['query_listQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_items_items_spec_resourceType']['output'];
};

/**
 * AllowanceBucketSpec defines the desired state of AllowanceBucket.
 * The system automatically creates buckets for each unique (consumer, resourceType) combination
 * found in active ResourceGrants.
 */
export type Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Spec_Input =
  {
    consumerRef: Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Spec_ConsumerRef_Input;
    /**
     * ResourceType specifies which resource type this bucket aggregates quota for.
     * Must exactly match a ResourceRegistration.spec.resourceType that is currently active.
     * The quota system validates this reference and only creates buckets for registered types.
     *
     * The identifier format is flexible, as defined by platform administrators
     * in their ResourceRegistrations.
     *
     * Examples:
     * - "resourcemanager.miloapis.com/projects"
     * - "compute_cpu"
     * - "storage.volumes"
     * - "custom-service-quota"
     */
    resourceType: Scalars['query_listQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_items_items_spec_resourceType']['input'];
  };

/**
 * ConsumerRef identifies the quota consumer tracked by this bucket.
 * Must match the ConsumerRef from ResourceGrants that contribute to this bucket.
 * Only one bucket exists per unique (ConsumerRef, ResourceType) combination.
 *
 * Examples:
 * - Organization "acme-corp" consuming Project quota
 * - Project "web-app" consuming User quota
 * - Organization "enterprise-corp" consuming storage quota
 */
export type Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Spec_ConsumerRef =
  {
    /**
     * APIGroup specifies the API group of the consumer resource.
     * Use full group name for Milo resources.
     *
     * Examples:
     * - "resourcemanager.miloapis.com" (Organization/Project resources)
     * - "iam.miloapis.com" (User/Group resources)
     * - "infrastructure.miloapis.com" (infrastructure resources)
     */
    apiGroup?: Maybe<Scalars['String']['output']>;
    /**
     * Kind specifies the type of consumer resource.
     * Must match an existing Kubernetes resource type that can receive quota grants.
     *
     * Common consumer types:
     * - "Organization" (top-level quota consumer)
     * - "Project" (project-level quota consumer)
     * - "User" (user-level quota consumer)
     */
    kind: Scalars['String']['output'];
    /**
     * Name identifies the specific consumer resource instance.
     * Must match the name of an existing consumer resource in the cluster.
     *
     * Examples:
     * - "acme-corp" (Organization name)
     * - "web-application" (Project name)
     * - "john.doe" (User name)
     */
    name: Scalars['String']['output'];
    /**
     * Namespace identifies the namespace of the consumer resource.
     * Required for namespaced consumer resources (e.g., Projects).
     * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
     *
     * Examples:
     * - "" (empty for cluster-scoped Organizations)
     * - "organization-acme-corp" (namespace for Projects within an organization)
     * - "project-web-app" (namespace for resources within a project)
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/**
 * ConsumerRef identifies the quota consumer tracked by this bucket.
 * Must match the ConsumerRef from ResourceGrants that contribute to this bucket.
 * Only one bucket exists per unique (ConsumerRef, ResourceType) combination.
 *
 * Examples:
 * - Organization "acme-corp" consuming Project quota
 * - Project "web-app" consuming User quota
 * - Organization "enterprise-corp" consuming storage quota
 */
export type Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Spec_ConsumerRef_Input =
  {
    /**
     * APIGroup specifies the API group of the consumer resource.
     * Use full group name for Milo resources.
     *
     * Examples:
     * - "resourcemanager.miloapis.com" (Organization/Project resources)
     * - "iam.miloapis.com" (User/Group resources)
     * - "infrastructure.miloapis.com" (infrastructure resources)
     */
    apiGroup?: InputMaybe<Scalars['String']['input']>;
    /**
     * Kind specifies the type of consumer resource.
     * Must match an existing Kubernetes resource type that can receive quota grants.
     *
     * Common consumer types:
     * - "Organization" (top-level quota consumer)
     * - "Project" (project-level quota consumer)
     * - "User" (user-level quota consumer)
     */
    kind: Scalars['String']['input'];
    /**
     * Name identifies the specific consumer resource instance.
     * Must match the name of an existing consumer resource in the cluster.
     *
     * Examples:
     * - "acme-corp" (Organization name)
     * - "web-application" (Project name)
     * - "john.doe" (User name)
     */
    name: Scalars['String']['input'];
    /**
     * Namespace identifies the namespace of the consumer resource.
     * Required for namespaced consumer resources (e.g., Projects).
     * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
     *
     * Examples:
     * - "" (empty for cluster-scoped Organizations)
     * - "organization-acme-corp" (namespace for Projects within an organization)
     * - "project-web-app" (namespace for resources within a project)
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * AllowanceBucketStatus contains the quota system-computed quota aggregation for a specific
 * (consumer, resourceType) combination. The quota system continuously updates this status
 * by aggregating capacity from active ResourceGrants and consumption from granted ResourceClaims.
 */
export type Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Status = {
  /**
   * Allocated represents the total quota currently consumed by granted ResourceClaims.
   * Calculated by summing all allocation amounts from ResourceClaims with status.conditions[type=Granted]=True
   * that match the bucket's spec.consumerRef and have requests for spec.resourceType.
   *
   * Aggregation logic:
   * - Only ResourceClaims with Granted=True contribute to allocated amount
   * - Only requests matching spec.resourceType are included
   * - All allocated amounts from matching requests are summed
   */
  allocated: Scalars['BigInt']['output'];
  /**
   * Available represents the quota capacity remaining for new ResourceClaims.
   * Always calculated as: Available = Limit - Allocated (never negative).
   * The system uses this value to determine whether new ResourceClaims can be granted.
   *
   * Decision logic:
   * - ResourceClaim is granted if requested amount <= Available
   * - ResourceClaim is denied if requested amount > Available
   * - Multiple concurrent claims may race; first to be processed wins
   */
  available: Scalars['BigInt']['output'];
  /**
   * ClaimCount indicates the total number of granted ResourceClaims consuming quota from this bucket.
   * Includes all ResourceClaims with status.conditions[type=Granted]=True that have requests
   * matching spec.resourceType and spec.consumerRef.
   *
   * Used for monitoring quota usage patterns and identifying potential issues.
   */
  claimCount: Scalars['Int']['output'];
  /**
   * ContributingGrantRefs provides detailed information about each ResourceGrant that contributes
   * to this bucket's limit. Includes grant names, amounts, and last observed generations for
   * tracking and debugging quota sources.
   *
   * This field provides visibility into:
   * - Which grants are providing quota capacity
   * - How much each grant contributes
   * - Whether grants have been updated since last bucket calculation
   *
   * Grants are tracked individually because they are typically few in number compared to claims.
   */
  contributingGrantRefs?: Maybe<
    Array<
      Maybe<Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Status_ContributingGrantRefs_Items>
    >
  >;
  /**
   * GrantCount indicates the total number of active ResourceGrants contributing to this bucket's limit.
   * Includes all ResourceGrants with status.conditions[type=Active]=True that have allowances
   * matching spec.resourceType and spec.consumerRef.
   *
   * Used for understanding quota source distribution and debugging capacity issues.
   */
  grantCount: Scalars['Int']['output'];
  /**
   * LastReconciliation records when the quota system last recalculated this status.
   * Used for monitoring quota system health and understanding how fresh the aggregated data is.
   *
   * The quota system updates this timestamp every time it processes the bucket, regardless of
   * whether the aggregated values changed.
   */
  lastReconciliation?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Limit represents the total quota capacity available for this (consumer, resourceType) combination.
   * Calculated by summing all bucket amounts from active ResourceGrants that match the bucket's
   * spec.consumerRef and spec.resourceType. Measured in BaseUnit from the ResourceRegistration.
   *
   * Aggregation logic:
   * - Only ResourceGrants with status.conditions[type=Active]=True contribute to the limit
   * - All allowances matching spec.resourceType are included from contributing grants
   * - All bucket amounts within matching allowances are summed
   */
  limit: Scalars['BigInt']['output'];
  /**
   * ObservedGeneration indicates the most recent spec generation the quota system has processed.
   * When ObservedGeneration matches metadata.generation, the status reflects the current spec.
   * When ObservedGeneration is lower, the quota system is still processing recent changes.
   */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
};

/**
 * AllowanceBucketStatus contains the quota system-computed quota aggregation for a specific
 * (consumer, resourceType) combination. The quota system continuously updates this status
 * by aggregating capacity from active ResourceGrants and consumption from granted ResourceClaims.
 */
export type Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * Allocated represents the total quota currently consumed by granted ResourceClaims.
     * Calculated by summing all allocation amounts from ResourceClaims with status.conditions[type=Granted]=True
     * that match the bucket's spec.consumerRef and have requests for spec.resourceType.
     *
     * Aggregation logic:
     * - Only ResourceClaims with Granted=True contribute to allocated amount
     * - Only requests matching spec.resourceType are included
     * - All allocated amounts from matching requests are summed
     */
    allocated: Scalars['BigInt']['input'];
    /**
     * Available represents the quota capacity remaining for new ResourceClaims.
     * Always calculated as: Available = Limit - Allocated (never negative).
     * The system uses this value to determine whether new ResourceClaims can be granted.
     *
     * Decision logic:
     * - ResourceClaim is granted if requested amount <= Available
     * - ResourceClaim is denied if requested amount > Available
     * - Multiple concurrent claims may race; first to be processed wins
     */
    available: Scalars['BigInt']['input'];
    /**
     * ClaimCount indicates the total number of granted ResourceClaims consuming quota from this bucket.
     * Includes all ResourceClaims with status.conditions[type=Granted]=True that have requests
     * matching spec.resourceType and spec.consumerRef.
     *
     * Used for monitoring quota usage patterns and identifying potential issues.
     */
    claimCount: Scalars['Int']['input'];
    /**
     * ContributingGrantRefs provides detailed information about each ResourceGrant that contributes
     * to this bucket's limit. Includes grant names, amounts, and last observed generations for
     * tracking and debugging quota sources.
     *
     * This field provides visibility into:
     * - Which grants are providing quota capacity
     * - How much each grant contributes
     * - Whether grants have been updated since last bucket calculation
     *
     * Grants are tracked individually because they are typically few in number compared to claims.
     */
    contributingGrantRefs?: InputMaybe<
      Array<
        InputMaybe<Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Status_ContributingGrantRefs_Items_Input>
      >
    >;
    /**
     * GrantCount indicates the total number of active ResourceGrants contributing to this bucket's limit.
     * Includes all ResourceGrants with status.conditions[type=Active]=True that have allowances
     * matching spec.resourceType and spec.consumerRef.
     *
     * Used for understanding quota source distribution and debugging capacity issues.
     */
    grantCount: Scalars['Int']['input'];
    /**
     * LastReconciliation records when the quota system last recalculated this status.
     * Used for monitoring quota system health and understanding how fresh the aggregated data is.
     *
     * The quota system updates this timestamp every time it processes the bucket, regardless of
     * whether the aggregated values changed.
     */
    lastReconciliation?: InputMaybe<Scalars['DateTime']['input']>;
    /**
     * Limit represents the total quota capacity available for this (consumer, resourceType) combination.
     * Calculated by summing all bucket amounts from active ResourceGrants that match the bucket's
     * spec.consumerRef and spec.resourceType. Measured in BaseUnit from the ResourceRegistration.
     *
     * Aggregation logic:
     * - Only ResourceGrants with status.conditions[type=Active]=True contribute to the limit
     * - All allowances matching spec.resourceType are included from contributing grants
     * - All bucket amounts within matching allowances are summed
     */
    limit: Scalars['BigInt']['input'];
    /**
     * ObservedGeneration indicates the most recent spec generation the quota system has processed.
     * When ObservedGeneration matches metadata.generation, the status reflects the current spec.
     * When ObservedGeneration is lower, the quota system is still processing recent changes.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
  };

/**
 * ContributingGrantRef tracks a ResourceGrant that contributes capacity to this bucket.
 * The quota system maintains these references to provide visibility into quota sources
 * and to detect when grants change.
 */
export type Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Status_ContributingGrantRefs_Items =
  {
    /**
     * Amount specifies how much quota capacity this grant contributes to the bucket.
     * Represents the sum of all buckets within all allowances for the matching
     * resource type in the referenced grant. Measured in BaseUnit.
     */
    amount: Scalars['BigInt']['output'];
    /**
     * LastObservedGeneration records the ResourceGrant's generation when the bucket
     * quota system last processed it. Used to detect when grants have been updated
     * and the bucket needs to recalculate its aggregated limit.
     */
    lastObservedGeneration: Scalars['BigInt']['output'];
    /**
     * Name identifies the ResourceGrant that contributes to this bucket's limit.
     * Used for tracking quota sources and debugging allocation issues.
     */
    name: Scalars['String']['output'];
  };

/**
 * ContributingGrantRef tracks a ResourceGrant that contributes capacity to this bucket.
 * The quota system maintains these references to provide visibility into quota sources
 * and to detect when grants change.
 */
export type Query_ListQuotaMiloapisComV1alpha1AllowanceBucketForAllNamespaces_Items_Items_Status_ContributingGrantRefs_Items_Input =
  {
    /**
     * Amount specifies how much quota capacity this grant contributes to the bucket.
     * Represents the sum of all buckets within all allowances for the matching
     * resource type in the referenced grant. Measured in BaseUnit.
     */
    amount: Scalars['BigInt']['input'];
    /**
     * LastObservedGeneration records the ResourceGrant's generation when the bucket
     * quota system last processed it. Used to detect when grants have been updated
     * and the bucket needs to recalculate its aggregated limit.
     */
    lastObservedGeneration: Scalars['BigInt']['input'];
    /**
     * Name identifies the ResourceGrant that contributes to this bucket's limit.
     * Used for tracking quota sources and debugging allocation issues.
     */
    name: Scalars['String']['input'];
  };

/** ClaimCreationPolicySpec defines the desired state of ClaimCreationPolicy. */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec = {
  /**
   * Disabled determines if this policy is inactive.
   * If true, no **ResourceClaims** will be created for matching resources.
   */
  disabled?: Maybe<Scalars['Boolean']['output']>;
  target: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target;
  trigger: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Trigger;
};

/** ClaimCreationPolicySpec defines the desired state of ClaimCreationPolicy. */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Input = {
  /**
   * Disabled determines if this policy is inactive.
   * If true, no **ResourceClaims** will be created for matching resources.
   */
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  target: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_Input;
  trigger: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Trigger_Input;
};

/** Target defines how and where **ResourceClaims** should be created. */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target = {
  resourceClaimTemplate: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate;
};

/** Target defines how and where **ResourceClaims** should be created. */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_Input = {
  resourceClaimTemplate: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Input;
};

/**
 * ResourceClaimTemplate defines how to create **ResourceClaims**.
 * String fields support CEL expressions for dynamic content.
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate =
  {
    metadata: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Metadata;
    spec: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec;
  };

/**
 * ResourceClaimTemplate defines how to create **ResourceClaims**.
 * String fields support CEL expressions for dynamic content.
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Input =
  {
    metadata: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Metadata_Input;
    spec: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec_Input;
  };

/**
 * Metadata for the created **ResourceClaim**.
 * String fields support CEL expressions.
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Metadata =
  {
    /**
     * Annotations specifies annotations to apply to the created ResourceClaim.
     * Values support CEL expressions wrapped in {{ }} delimiters for dynamic content.
     * The system automatically adds standard annotations for tracking.
     *
     * Template variables available:
     * - trigger: The resource triggering claim creation
     * - requestInfo: Request details
     * - user: User information
     *
     * Examples:
     * - created-for: "{{trigger.metadata.name}}" (CEL expression)
     * - requested-by: "{{user.name}}" (CEL expression)
     * - environment: "production" (literal string)
     */
    annotations?: Maybe<Scalars['JSON']['output']>;
    /**
     * GenerateName specifies a prefix for auto-generated names when Name is empty.
     * Kubernetes appends random characters to create unique names.
     * Supports CEL expressions wrapped in {{ }} delimiters.
     *
     * Examples:
     * - "{{trigger.spec.type + '-claim-'}}" (CEL expression)
     * - "{{trigger.spec.type}}-claim-" (CEL + literal)
     * - "quota-claim-" (literal string)
     */
    generateName?: Maybe<Scalars['String']['output']>;
    /**
     * Labels specifies static labels to apply to the created ResourceClaim.
     * Values are literal strings (no template processing).
     * The system automatically adds standard labels for policy tracking.
     *
     * Useful for:
     * - Organizing claims by policy or resource type
     * - Adding environment or tier indicators
     * - Enabling label-based queries and monitoring
     */
    labels?: Maybe<Scalars['JSON']['output']>;
    /**
     * Name specifies the exact name for the created ResourceClaim.
     * Supports CEL expressions wrapped in {{ }} delimiters with access to template variables.
     * Leave empty to use GenerateName for auto-generated names.
     *
     * CEL Expression Syntax: CEL expressions must be enclosed in double curly braces {{ }}.
     * Plain strings without {{ }} are treated as literal values.
     *
     * Template variables available:
     * - trigger: The resource triggering claim creation
     * - requestInfo: Request details (verb, resource, name, etc.)
     * - user: User information (name, uid, groups, extra)
     *
     * Examples:
     * - "{{trigger.metadata.name + '-quota-claim'}}" (CEL expression)
     * - "{{trigger.metadata.name}}-claim" (CEL + literal)
     * - "fixed-claim-name" (literal string)
     */
    name?: Maybe<Scalars['String']['output']>;
    /**
     * Namespace specifies where the ResourceClaim will be created.
     * Supports CEL expressions wrapped in {{ }} delimiters to derive namespace from trigger resource.
     * Leave empty to create in the same namespace as the trigger resource.
     *
     * Examples:
     * - "{{trigger.metadata.namespace}}" (CEL: same namespace as trigger)
     * - "milo-system" (literal: fixed system namespace)
     * - "{{trigger.spec.organization + '-claims'}}" (CEL: derived namespace)
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/**
 * Metadata for the created **ResourceClaim**.
 * String fields support CEL expressions.
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Metadata_Input =
  {
    /**
     * Annotations specifies annotations to apply to the created ResourceClaim.
     * Values support CEL expressions wrapped in {{ }} delimiters for dynamic content.
     * The system automatically adds standard annotations for tracking.
     *
     * Template variables available:
     * - trigger: The resource triggering claim creation
     * - requestInfo: Request details
     * - user: User information
     *
     * Examples:
     * - created-for: "{{trigger.metadata.name}}" (CEL expression)
     * - requested-by: "{{user.name}}" (CEL expression)
     * - environment: "production" (literal string)
     */
    annotations?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * GenerateName specifies a prefix for auto-generated names when Name is empty.
     * Kubernetes appends random characters to create unique names.
     * Supports CEL expressions wrapped in {{ }} delimiters.
     *
     * Examples:
     * - "{{trigger.spec.type + '-claim-'}}" (CEL expression)
     * - "{{trigger.spec.type}}-claim-" (CEL + literal)
     * - "quota-claim-" (literal string)
     */
    generateName?: InputMaybe<Scalars['String']['input']>;
    /**
     * Labels specifies static labels to apply to the created ResourceClaim.
     * Values are literal strings (no template processing).
     * The system automatically adds standard labels for policy tracking.
     *
     * Useful for:
     * - Organizing claims by policy or resource type
     * - Adding environment or tier indicators
     * - Enabling label-based queries and monitoring
     */
    labels?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * Name specifies the exact name for the created ResourceClaim.
     * Supports CEL expressions wrapped in {{ }} delimiters with access to template variables.
     * Leave empty to use GenerateName for auto-generated names.
     *
     * CEL Expression Syntax: CEL expressions must be enclosed in double curly braces {{ }}.
     * Plain strings without {{ }} are treated as literal values.
     *
     * Template variables available:
     * - trigger: The resource triggering claim creation
     * - requestInfo: Request details (verb, resource, name, etc.)
     * - user: User information (name, uid, groups, extra)
     *
     * Examples:
     * - "{{trigger.metadata.name + '-quota-claim'}}" (CEL expression)
     * - "{{trigger.metadata.name}}-claim" (CEL + literal)
     * - "fixed-claim-name" (literal string)
     */
    name?: InputMaybe<Scalars['String']['input']>;
    /**
     * Namespace specifies where the ResourceClaim will be created.
     * Supports CEL expressions wrapped in {{ }} delimiters to derive namespace from trigger resource.
     * Leave empty to create in the same namespace as the trigger resource.
     *
     * Examples:
     * - "{{trigger.metadata.namespace}}" (CEL: same namespace as trigger)
     * - "milo-system" (literal: fixed system namespace)
     * - "{{trigger.spec.organization + '-claims'}}" (CEL: derived namespace)
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * Spec for the created ResourceClaim.
 * String fields support CEL expressions.
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec =
  {
    consumerRef?: Maybe<Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec_ConsumerRef>;
    /**
     * Requests specifies the resource types and amounts being claimed from quota.
     * Each resource type can appear only once in the requests array. Minimum 1
     * request, maximum 20 requests per claim.
     *
     * The system processes all requests as a single atomic operation: either all
     * requests are granted or all are denied.
     */
    requests: Array<
      Maybe<Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec_Requests_Items>
    >;
    resourceRef?: Maybe<Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec_ResourceRef>;
  };

/**
 * Spec for the created ResourceClaim.
 * String fields support CEL expressions.
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec_Input =
  {
    consumerRef?: InputMaybe<Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec_ConsumerRef_Input>;
    /**
     * Requests specifies the resource types and amounts being claimed from quota.
     * Each resource type can appear only once in the requests array. Minimum 1
     * request, maximum 20 requests per claim.
     *
     * The system processes all requests as a single atomic operation: either all
     * requests are granted or all are denied.
     */
    requests: Array<
      InputMaybe<Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec_Requests_Items_Input>
    >;
    resourceRef?: InputMaybe<Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec_ResourceRef_Input>;
  };

/**
 * ConsumerRef identifies the quota consumer making this claim. The consumer
 * must match the ConsumerType defined in the ResourceRegistration for each
 * requested resource type. The system validates this relationship during
 * claim processing.
 *
 * When creating ResourceClaims via ClaimCreationPolicy, this field can be
 * omitted and the admission plugin will automatically fill it based on the
 * authenticated user's context (organization or project).
 *
 * Examples:
 *
 *   - Organization consuming Project quota
 *   - Project consuming User quota
 *   - Organization consuming storage quota
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec_ConsumerRef =
  {
    /**
     * APIGroup specifies the API group of the consumer resource.
     * Use full group name for Milo resources.
     *
     * Examples:
     * - "resourcemanager.miloapis.com" (Organization/Project resources)
     * - "iam.miloapis.com" (User/Group resources)
     * - "infrastructure.miloapis.com" (infrastructure resources)
     */
    apiGroup?: Maybe<Scalars['String']['output']>;
    /**
     * Kind specifies the type of consumer resource.
     * Must match an existing Kubernetes resource type that can receive quota grants.
     *
     * Common consumer types:
     * - "Organization" (top-level quota consumer)
     * - "Project" (project-level quota consumer)
     * - "User" (user-level quota consumer)
     */
    kind: Scalars['String']['output'];
    /**
     * Name identifies the specific consumer resource instance.
     * Must match the name of an existing consumer resource in the cluster.
     *
     * Examples:
     * - "acme-corp" (Organization name)
     * - "web-application" (Project name)
     * - "john.doe" (User name)
     */
    name: Scalars['String']['output'];
    /**
     * Namespace identifies the namespace of the consumer resource.
     * Required for namespaced consumer resources (e.g., Projects).
     * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
     *
     * Examples:
     * - "" (empty for cluster-scoped Organizations)
     * - "organization-acme-corp" (namespace for Projects within an organization)
     * - "project-web-app" (namespace for resources within a project)
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/**
 * ConsumerRef identifies the quota consumer making this claim. The consumer
 * must match the ConsumerType defined in the ResourceRegistration for each
 * requested resource type. The system validates this relationship during
 * claim processing.
 *
 * When creating ResourceClaims via ClaimCreationPolicy, this field can be
 * omitted and the admission plugin will automatically fill it based on the
 * authenticated user's context (organization or project).
 *
 * Examples:
 *
 *   - Organization consuming Project quota
 *   - Project consuming User quota
 *   - Organization consuming storage quota
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec_ConsumerRef_Input =
  {
    /**
     * APIGroup specifies the API group of the consumer resource.
     * Use full group name for Milo resources.
     *
     * Examples:
     * - "resourcemanager.miloapis.com" (Organization/Project resources)
     * - "iam.miloapis.com" (User/Group resources)
     * - "infrastructure.miloapis.com" (infrastructure resources)
     */
    apiGroup?: InputMaybe<Scalars['String']['input']>;
    /**
     * Kind specifies the type of consumer resource.
     * Must match an existing Kubernetes resource type that can receive quota grants.
     *
     * Common consumer types:
     * - "Organization" (top-level quota consumer)
     * - "Project" (project-level quota consumer)
     * - "User" (user-level quota consumer)
     */
    kind: Scalars['String']['input'];
    /**
     * Name identifies the specific consumer resource instance.
     * Must match the name of an existing consumer resource in the cluster.
     *
     * Examples:
     * - "acme-corp" (Organization name)
     * - "web-application" (Project name)
     * - "john.doe" (User name)
     */
    name: Scalars['String']['input'];
    /**
     * Namespace identifies the namespace of the consumer resource.
     * Required for namespaced consumer resources (e.g., Projects).
     * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
     *
     * Examples:
     * - "" (empty for cluster-scoped Organizations)
     * - "organization-acme-corp" (namespace for Projects within an organization)
     * - "project-web-app" (namespace for resources within a project)
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * ResourceRequest defines a single resource request within a ResourceClaim.
 * Each request specifies a resource type and the amount of quota being claimed.
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec_Requests_Items =
  {
    /**
     * Amount specifies how much quota to claim for this resource type. Must be
     * measured in the BaseUnit defined by the corresponding ResourceRegistration.
     * Must be a positive integer (minimum value is 0, but 0 means no quota
     * requested).
     *
     * For Entity registrations: Use 1 for single resource instances (1 Project, 1
     * User) For Allocation registrations: Use actual capacity amounts (2048 for
     * 2048 MB, 1000 for 1000 millicores)
     *
     * Examples:
     *
     *   - 1 (claiming 1 Project)
     *   - 2048 (claiming 2048 bytes of storage)
     *   - 1000 (claiming 1000 CPU millicores)
     */
    amount: Scalars['BigInt']['output'];
    /**
     * ResourceType identifies the specific resource type being claimed. Must
     * exactly match a ResourceRegistration.spec.resourceType that is currently
     * active. The quota system validates this reference during claim processing.
     *
     * The format is defined by platform administrators when creating ResourceRegistrations.
     * Service providers can use any identifier that makes sense for their quota system usage.
     *
     * Examples:
     *
     *   - "resourcemanager.miloapis.com/projects"
     *   - "compute_cpu"
     *   - "storage.volumes"
     *   - "custom-service-quota"
     */
    resourceType: Scalars['String']['output'];
  };

/**
 * ResourceRequest defines a single resource request within a ResourceClaim.
 * Each request specifies a resource type and the amount of quota being claimed.
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec_Requests_Items_Input =
  {
    /**
     * Amount specifies how much quota to claim for this resource type. Must be
     * measured in the BaseUnit defined by the corresponding ResourceRegistration.
     * Must be a positive integer (minimum value is 0, but 0 means no quota
     * requested).
     *
     * For Entity registrations: Use 1 for single resource instances (1 Project, 1
     * User) For Allocation registrations: Use actual capacity amounts (2048 for
     * 2048 MB, 1000 for 1000 millicores)
     *
     * Examples:
     *
     *   - 1 (claiming 1 Project)
     *   - 2048 (claiming 2048 bytes of storage)
     *   - 1000 (claiming 1000 CPU millicores)
     */
    amount: Scalars['BigInt']['input'];
    /**
     * ResourceType identifies the specific resource type being claimed. Must
     * exactly match a ResourceRegistration.spec.resourceType that is currently
     * active. The quota system validates this reference during claim processing.
     *
     * The format is defined by platform administrators when creating ResourceRegistrations.
     * Service providers can use any identifier that makes sense for their quota system usage.
     *
     * Examples:
     *
     *   - "resourcemanager.miloapis.com/projects"
     *   - "compute_cpu"
     *   - "storage.volumes"
     *   - "custom-service-quota"
     */
    resourceType: Scalars['String']['input'];
  };

/**
 * ResourceRef identifies the actual Kubernetes resource that triggered this
 * claim. ClaimCreationPolicy automatically populates this field during
 * admission. Uses unversioned reference (apiGroup + kind + name + namespace)
 * to remain valid across API version changes.
 *
 * The referenced resource's kind must be listed in the ResourceRegistration's
 * spec.claimingResources for the claim to be valid.
 *
 * Examples:
 *
 *   - Project resource triggering Project quota claim
 *   - User resource triggering User quota claim
 *   - Organization resource triggering storage quota claim
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec_ResourceRef =
  {
    /**
     * APIGroup specifies the API group of the referenced resource.
     * Use full group name for Milo resources.
     *
     * Examples:
     * - "resourcemanager.miloapis.com" (Project, Organization)
     * - "iam.miloapis.com" (User, Group)
     * - "infrastructure.miloapis.com" (infrastructure resources)
     */
    apiGroup?: Maybe<Scalars['String']['output']>;
    /**
     * Kind specifies the type of the referenced resource.
     * Must match an existing Kubernetes resource type.
     *
     * Examples:
     * - "Project" (Project resource that triggered quota claim)
     * - "User" (User resource that triggered quota claim)
     * - "Organization" (Organization resource that triggered quota claim)
     */
    kind: Scalars['String']['output'];
    /**
     * Name identifies the specific resource instance that triggered the quota claim.
     * Used for linking claims back to their triggering resources.
     *
     * Examples:
     * - "web-app-project" (Project that triggered Project quota claim)
     * - "john.doe" (User that triggered User quota claim)
     */
    name: Scalars['String']['output'];
    /**
     * Namespace specifies the namespace containing the referenced resource.
     * Required for namespaced resources, omitted for cluster-scoped resources.
     *
     * Examples:
     * - "acme-corp" (organization namespace containing Project)
     * - "team-alpha" (project namespace containing User)
     * - "" or omitted (for cluster-scoped resources like Organization)
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/**
 * ResourceRef identifies the actual Kubernetes resource that triggered this
 * claim. ClaimCreationPolicy automatically populates this field during
 * admission. Uses unversioned reference (apiGroup + kind + name + namespace)
 * to remain valid across API version changes.
 *
 * The referenced resource's kind must be listed in the ResourceRegistration's
 * spec.claimingResources for the claim to be valid.
 *
 * Examples:
 *
 *   - Project resource triggering Project quota claim
 *   - User resource triggering User quota claim
 *   - Organization resource triggering storage quota claim
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Target_ResourceClaimTemplate_Spec_ResourceRef_Input =
  {
    /**
     * APIGroup specifies the API group of the referenced resource.
     * Use full group name for Milo resources.
     *
     * Examples:
     * - "resourcemanager.miloapis.com" (Project, Organization)
     * - "iam.miloapis.com" (User, Group)
     * - "infrastructure.miloapis.com" (infrastructure resources)
     */
    apiGroup?: InputMaybe<Scalars['String']['input']>;
    /**
     * Kind specifies the type of the referenced resource.
     * Must match an existing Kubernetes resource type.
     *
     * Examples:
     * - "Project" (Project resource that triggered quota claim)
     * - "User" (User resource that triggered quota claim)
     * - "Organization" (Organization resource that triggered quota claim)
     */
    kind: Scalars['String']['input'];
    /**
     * Name identifies the specific resource instance that triggered the quota claim.
     * Used for linking claims back to their triggering resources.
     *
     * Examples:
     * - "web-app-project" (Project that triggered Project quota claim)
     * - "john.doe" (User that triggered User quota claim)
     */
    name: Scalars['String']['input'];
    /**
     * Namespace specifies the namespace containing the referenced resource.
     * Required for namespaced resources, omitted for cluster-scoped resources.
     *
     * Examples:
     * - "acme-corp" (organization namespace containing Project)
     * - "team-alpha" (project namespace containing User)
     * - "" or omitted (for cluster-scoped resources like Organization)
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/** Trigger defines what resource changes should trigger claim creation. */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Trigger = {
  /**
   * Constraints are CEL expressions that must evaluate to true for claim creation to occur.
   * These are pure CEL expressions WITHOUT {{ }} delimiters (unlike template fields).
   * Evaluated in the admission context.
   */
  constraints?: Maybe<
    Array<
      Maybe<Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Trigger_Constraints_Items>
    >
  >;
  resource: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Trigger_Resource;
};

/** Trigger defines what resource changes should trigger claim creation. */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Trigger_Input = {
  /**
   * Constraints are CEL expressions that must evaluate to true for claim creation to occur.
   * These are pure CEL expressions WITHOUT {{ }} delimiters (unlike template fields).
   * Evaluated in the admission context.
   */
  constraints?: InputMaybe<
    Array<
      InputMaybe<Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Trigger_Constraints_Items_Input>
    >
  >;
  resource: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Trigger_Resource_Input;
};

/**
 * ConditionExpression defines a CEL expression that determines when the policy should trigger.
 * All expressions in a policy's trigger conditions must evaluate to true for the policy to activate.
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Trigger_Constraints_Items =
  {
    /**
     * Expression specifies the CEL expression to evaluate against the trigger resource.
     * This is a pure CEL expression WITHOUT {{ }} delimiters (unlike template fields).
     * Must return a boolean value (true to match, false to skip).
     * Maximum 1024 characters.
     *
     * Available variables in GrantCreationPolicy context:
     * - trigger: The complete resource being watched (map[string]any)
     *   - trigger.metadata.name, trigger.spec.*, trigger.status.*, etc.
     *
     * Common expression patterns:
     * - trigger.spec.tier == "premium" (check resource field)
     * - trigger.metadata.labels["environment"] == "prod" (check labels)
     * - trigger.status.phase == "Active" (check status)
     * - trigger.metadata.namespace == "production" (check namespace)
     * - has(trigger.spec.quotaProfile) (check field existence)
     */
    expression: Scalars['query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_spec_trigger_constraints_items_expression']['output'];
    /**
     * Message provides a human-readable description explaining when this condition applies.
     * Used for documentation and debugging. Maximum 256 characters.
     *
     * Examples:
     * - "Applies only to premium tier organizations"
     * - "Matches organizations in production environment"
     * - "Triggers when quota profile is specified"
     */
    message?: Maybe<
      Scalars['query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_spec_trigger_constraints_items_message']['output']
    >;
  };

/**
 * ConditionExpression defines a CEL expression that determines when the policy should trigger.
 * All expressions in a policy's trigger conditions must evaluate to true for the policy to activate.
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Trigger_Constraints_Items_Input =
  {
    /**
     * Expression specifies the CEL expression to evaluate against the trigger resource.
     * This is a pure CEL expression WITHOUT {{ }} delimiters (unlike template fields).
     * Must return a boolean value (true to match, false to skip).
     * Maximum 1024 characters.
     *
     * Available variables in GrantCreationPolicy context:
     * - trigger: The complete resource being watched (map[string]any)
     *   - trigger.metadata.name, trigger.spec.*, trigger.status.*, etc.
     *
     * Common expression patterns:
     * - trigger.spec.tier == "premium" (check resource field)
     * - trigger.metadata.labels["environment"] == "prod" (check labels)
     * - trigger.status.phase == "Active" (check status)
     * - trigger.metadata.namespace == "production" (check namespace)
     * - has(trigger.spec.quotaProfile) (check field existence)
     */
    expression: Scalars['query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_spec_trigger_constraints_items_expression']['input'];
    /**
     * Message provides a human-readable description explaining when this condition applies.
     * Used for documentation and debugging. Maximum 256 characters.
     *
     * Examples:
     * - "Applies only to premium tier organizations"
     * - "Matches organizations in production environment"
     * - "Triggers when quota profile is specified"
     */
    message?: InputMaybe<
      Scalars['query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_spec_trigger_constraints_items_message']['input']
    >;
  };

/** Resource specifies which resource type triggers this policy. */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Trigger_Resource =
  {
    apiVersion: Scalars['query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_spec_trigger_resource_apiVersion']['output'];
    /** Kind is the kind of the trigger resource. */
    kind: Scalars['NonEmptyString']['output'];
  };

/** Resource specifies which resource type triggers this policy. */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Spec_Trigger_Resource_Input =
  {
    apiVersion: Scalars['query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_spec_trigger_resource_apiVersion']['input'];
    /** Kind is the kind of the trigger resource. */
    kind: Scalars['NonEmptyString']['input'];
  };

/**
 * ClaimCreationPolicyStatus defines the observed state of ClaimCreationPolicy.
 *
 * Status fields
 * - conditions[type=Ready]: True when the policy is validated and active.
 *
 * See also
 * - [ResourceClaim](#resourceclaim): The object created by this policy.
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Status = {
  /** Conditions represent the latest available observations of the policy's current state. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Status_Conditions_Items>
    >
  >;
  /** ObservedGeneration is the most recent generation observed. */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
};

/**
 * ClaimCreationPolicyStatus defines the observed state of ClaimCreationPolicy.
 *
 * Status fields
 * - conditions[type=Ready]: True when the policy is validated and active.
 *
 * See also
 * - [ResourceClaim](#resourceclaim): The object created by this policy.
 */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Status_Input = {
  /** Conditions represent the latest available observations of the policy's current state. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /** ObservedGeneration is the most recent generation observed. */
  observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_status_conditions_items_reason']['output'];
    status: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_status_conditions_items_reason']['input'];
    status: Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listQuotaMiloapisComV1alpha1ClaimCreationPolicy_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListQuotaMiloapisComV1alpha1ClaimCreationPolicy_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** GrantCreationPolicySpec defines the desired state of GrantCreationPolicy. */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec = {
  /**
   * Disabled determines if this policy is inactive.
   * If true, no **ResourceGrants** will be created for matching resources.
   */
  disabled?: Maybe<Scalars['Boolean']['output']>;
  target: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target;
  trigger: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Trigger;
};

/** GrantCreationPolicySpec defines the desired state of GrantCreationPolicy. */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Input = {
  /**
   * Disabled determines if this policy is inactive.
   * If true, no **ResourceGrants** will be created for matching resources.
   */
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  target: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_Input;
  trigger: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Trigger_Input;
};

/** Target defines where and how grants should be created. */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target = {
  parentContext?: Maybe<Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ParentContext>;
  resourceGrantTemplate: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate;
};

/** Target defines where and how grants should be created. */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_Input = {
  parentContext?: InputMaybe<Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ParentContext_Input>;
  resourceGrantTemplate: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Input;
};

/**
 * ParentContext defines cross-control-plane targeting.
 * If specified, grants will be created in the target parent context
 * instead of the current control plane.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ParentContext =
  {
    apiGroup: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_target_parentContext_apiGroup']['output'];
    kind: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_target_parentContext_kind']['output'];
    /**
     * NameExpression is a CEL expression that resolves the name of the parent context resource.
     * Must return a string value that identifies the specific parent context instance.
     * Maximum 512 characters.
     *
     * Available variables:
     * - object: The trigger resource being evaluated (complete object)
     *
     * Common expression patterns:
     * - object.spec.organization (direct field reference)
     * - object.metadata.labels["parent-org"] (label-based resolution)
     * - object.metadata.namespace.split("-")[0] (derived from namespace naming)
     *
     * Examples:
     * - "acme-corp" (literal parent name)
     * - object.spec.parentOrganization (field from trigger resource)
     * - object.metadata.labels["quota.miloapis.com/organization"] (label value)
     */
    nameExpression: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_target_parentContext_nameExpression']['output'];
  };

/**
 * ParentContext defines cross-control-plane targeting.
 * If specified, grants will be created in the target parent context
 * instead of the current control plane.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ParentContext_Input =
  {
    apiGroup: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_target_parentContext_apiGroup']['input'];
    kind: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_target_parentContext_kind']['input'];
    /**
     * NameExpression is a CEL expression that resolves the name of the parent context resource.
     * Must return a string value that identifies the specific parent context instance.
     * Maximum 512 characters.
     *
     * Available variables:
     * - object: The trigger resource being evaluated (complete object)
     *
     * Common expression patterns:
     * - object.spec.organization (direct field reference)
     * - object.metadata.labels["parent-org"] (label-based resolution)
     * - object.metadata.namespace.split("-")[0] (derived from namespace naming)
     *
     * Examples:
     * - "acme-corp" (literal parent name)
     * - object.spec.parentOrganization (field from trigger resource)
     * - object.metadata.labels["quota.miloapis.com/organization"] (label value)
     */
    nameExpression: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_target_parentContext_nameExpression']['input'];
  };

/**
 * ResourceGrantTemplate defines how to create **ResourceGrants**.
 * String fields support CEL expressions wrapped in {{ }} delimiters for dynamic content.
 * Plain strings without {{ }} are treated as literal values.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate =
  {
    metadata: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Metadata;
    spec: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec;
  };

/**
 * ResourceGrantTemplate defines how to create **ResourceGrants**.
 * String fields support CEL expressions wrapped in {{ }} delimiters for dynamic content.
 * Plain strings without {{ }} are treated as literal values.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Input =
  {
    metadata: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Metadata_Input;
    spec: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec_Input;
  };

/**
 * Metadata for the created ResourceGrant.
 * String fields support CEL expressions wrapped in {{ }} delimiters.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Metadata =
  {
    /**
     * Annotations specifies annotations to apply to the created ResourceClaim.
     * Values support CEL expressions wrapped in {{ }} delimiters for dynamic content.
     * The system automatically adds standard annotations for tracking.
     *
     * Template variables available:
     * - trigger: The resource triggering claim creation
     * - requestInfo: Request details
     * - user: User information
     *
     * Examples:
     * - created-for: "{{trigger.metadata.name}}" (CEL expression)
     * - requested-by: "{{user.name}}" (CEL expression)
     * - environment: "production" (literal string)
     */
    annotations?: Maybe<Scalars['JSON']['output']>;
    /**
     * GenerateName specifies a prefix for auto-generated names when Name is empty.
     * Kubernetes appends random characters to create unique names.
     * Supports CEL expressions wrapped in {{ }} delimiters.
     *
     * Examples:
     * - "{{trigger.spec.type + '-claim-'}}" (CEL expression)
     * - "{{trigger.spec.type}}-claim-" (CEL + literal)
     * - "quota-claim-" (literal string)
     */
    generateName?: Maybe<Scalars['String']['output']>;
    /**
     * Labels specifies static labels to apply to the created ResourceClaim.
     * Values are literal strings (no template processing).
     * The system automatically adds standard labels for policy tracking.
     *
     * Useful for:
     * - Organizing claims by policy or resource type
     * - Adding environment or tier indicators
     * - Enabling label-based queries and monitoring
     */
    labels?: Maybe<Scalars['JSON']['output']>;
    /**
     * Name specifies the exact name for the created ResourceClaim.
     * Supports CEL expressions wrapped in {{ }} delimiters with access to template variables.
     * Leave empty to use GenerateName for auto-generated names.
     *
     * CEL Expression Syntax: CEL expressions must be enclosed in double curly braces {{ }}.
     * Plain strings without {{ }} are treated as literal values.
     *
     * Template variables available:
     * - trigger: The resource triggering claim creation
     * - requestInfo: Request details (verb, resource, name, etc.)
     * - user: User information (name, uid, groups, extra)
     *
     * Examples:
     * - "{{trigger.metadata.name + '-quota-claim'}}" (CEL expression)
     * - "{{trigger.metadata.name}}-claim" (CEL + literal)
     * - "fixed-claim-name" (literal string)
     */
    name?: Maybe<Scalars['String']['output']>;
    /**
     * Namespace specifies where the ResourceClaim will be created.
     * Supports CEL expressions wrapped in {{ }} delimiters to derive namespace from trigger resource.
     * Leave empty to create in the same namespace as the trigger resource.
     *
     * Examples:
     * - "{{trigger.metadata.namespace}}" (CEL: same namespace as trigger)
     * - "milo-system" (literal: fixed system namespace)
     * - "{{trigger.spec.organization + '-claims'}}" (CEL: derived namespace)
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/**
 * Metadata for the created ResourceGrant.
 * String fields support CEL expressions wrapped in {{ }} delimiters.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Metadata_Input =
  {
    /**
     * Annotations specifies annotations to apply to the created ResourceClaim.
     * Values support CEL expressions wrapped in {{ }} delimiters for dynamic content.
     * The system automatically adds standard annotations for tracking.
     *
     * Template variables available:
     * - trigger: The resource triggering claim creation
     * - requestInfo: Request details
     * - user: User information
     *
     * Examples:
     * - created-for: "{{trigger.metadata.name}}" (CEL expression)
     * - requested-by: "{{user.name}}" (CEL expression)
     * - environment: "production" (literal string)
     */
    annotations?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * GenerateName specifies a prefix for auto-generated names when Name is empty.
     * Kubernetes appends random characters to create unique names.
     * Supports CEL expressions wrapped in {{ }} delimiters.
     *
     * Examples:
     * - "{{trigger.spec.type + '-claim-'}}" (CEL expression)
     * - "{{trigger.spec.type}}-claim-" (CEL + literal)
     * - "quota-claim-" (literal string)
     */
    generateName?: InputMaybe<Scalars['String']['input']>;
    /**
     * Labels specifies static labels to apply to the created ResourceClaim.
     * Values are literal strings (no template processing).
     * The system automatically adds standard labels for policy tracking.
     *
     * Useful for:
     * - Organizing claims by policy or resource type
     * - Adding environment or tier indicators
     * - Enabling label-based queries and monitoring
     */
    labels?: InputMaybe<Scalars['JSON']['input']>;
    /**
     * Name specifies the exact name for the created ResourceClaim.
     * Supports CEL expressions wrapped in {{ }} delimiters with access to template variables.
     * Leave empty to use GenerateName for auto-generated names.
     *
     * CEL Expression Syntax: CEL expressions must be enclosed in double curly braces {{ }}.
     * Plain strings without {{ }} are treated as literal values.
     *
     * Template variables available:
     * - trigger: The resource triggering claim creation
     * - requestInfo: Request details (verb, resource, name, etc.)
     * - user: User information (name, uid, groups, extra)
     *
     * Examples:
     * - "{{trigger.metadata.name + '-quota-claim'}}" (CEL expression)
     * - "{{trigger.metadata.name}}-claim" (CEL + literal)
     * - "fixed-claim-name" (literal string)
     */
    name?: InputMaybe<Scalars['String']['input']>;
    /**
     * Namespace specifies where the ResourceClaim will be created.
     * Supports CEL expressions wrapped in {{ }} delimiters to derive namespace from trigger resource.
     * Leave empty to create in the same namespace as the trigger resource.
     *
     * Examples:
     * - "{{trigger.metadata.namespace}}" (CEL: same namespace as trigger)
     * - "milo-system" (literal: fixed system namespace)
     * - "{{trigger.spec.organization + '-claims'}}" (CEL: derived namespace)
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * Spec for the created ResourceGrant.
 * String fields support CEL expressions wrapped in {{ }} delimiters.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec =
  {
    /**
     * Allowances specifies the quota allocations provided by this grant.
     * Each allowance grants capacity for a specific resource type.
     * Minimum 1 allowance required, maximum 20 allowances per grant.
     *
     * All allowances in a single grant:
     * - Apply to the same consumer (spec.consumerRef)
     * - Contribute to the same AllowanceBucket for each resource type
     * - Activate and deactivate together based on the grant's status
     */
    allowances: Array<
      Maybe<Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec_Allowances_Items>
    >;
    consumerRef: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec_ConsumerRef;
  };

/**
 * Spec for the created ResourceGrant.
 * String fields support CEL expressions wrapped in {{ }} delimiters.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec_Input =
  {
    /**
     * Allowances specifies the quota allocations provided by this grant.
     * Each allowance grants capacity for a specific resource type.
     * Minimum 1 allowance required, maximum 20 allowances per grant.
     *
     * All allowances in a single grant:
     * - Apply to the same consumer (spec.consumerRef)
     * - Contribute to the same AllowanceBucket for each resource type
     * - Activate and deactivate together based on the grant's status
     */
    allowances: Array<
      InputMaybe<Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec_Allowances_Items_Input>
    >;
    consumerRef: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec_ConsumerRef_Input;
  };

/**
 * Allowance defines quota allocation for a specific resource type within a ResourceGrant.
 * Each allowance can contain multiple buckets that sum to provide total capacity.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec_Allowances_Items =
  {
    /**
     * Buckets contains the quota allocations for this resource type.
     * All bucket amounts are summed to determine the total allowance.
     * Minimum 1 bucket required per allowance.
     *
     * Multiple buckets can be used for:
     * - Separating quota from different sources or tiers
     * - Managing incremental quota increases over time
     * - Tracking quota attribution for billing or reporting
     */
    buckets: Array<
      Maybe<Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec_Allowances_Items_Buckets_Items>
    >;
    /**
     * ResourceType identifies the specific resource type receiving quota allocation.
     * Must exactly match a ResourceRegistration.spec.resourceType that is currently active.
     * The quota system validates this reference when processing the grant.
     *
     * The identifier format is flexible, as defined by platform administrators
     * in their ResourceRegistrations.
     *
     * Examples:
     * - "resourcemanager.miloapis.com/projects"
     * - "compute_cpu"
     * - "storage.volumes"
     * - "custom-service-quota"
     */
    resourceType: Scalars['String']['output'];
  };

/**
 * Allowance defines quota allocation for a specific resource type within a ResourceGrant.
 * Each allowance can contain multiple buckets that sum to provide total capacity.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec_Allowances_Items_Input =
  {
    /**
     * Buckets contains the quota allocations for this resource type.
     * All bucket amounts are summed to determine the total allowance.
     * Minimum 1 bucket required per allowance.
     *
     * Multiple buckets can be used for:
     * - Separating quota from different sources or tiers
     * - Managing incremental quota increases over time
     * - Tracking quota attribution for billing or reporting
     */
    buckets: Array<
      InputMaybe<Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec_Allowances_Items_Buckets_Items_Input>
    >;
    /**
     * ResourceType identifies the specific resource type receiving quota allocation.
     * Must exactly match a ResourceRegistration.spec.resourceType that is currently active.
     * The quota system validates this reference when processing the grant.
     *
     * The identifier format is flexible, as defined by platform administrators
     * in their ResourceRegistrations.
     *
     * Examples:
     * - "resourcemanager.miloapis.com/projects"
     * - "compute_cpu"
     * - "storage.volumes"
     * - "custom-service-quota"
     */
    resourceType: Scalars['String']['input'];
  };

/**
 * Bucket represents a single allocation of quota capacity within an allowance.
 * Each bucket contributes its amount to the total allowance for a resource type.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec_Allowances_Items_Buckets_Items =
  {
    /**
     * Amount specifies the quota capacity provided by this bucket.
     * Must be measured in the BaseUnit defined by the corresponding ResourceRegistration.
     * Must be a non-negative integer (0 is valid but provides no quota).
     *
     * Examples:
     * - 100 (providing 100 projects)
     * - 2048000 (providing 2048000 bytes = 2GB)
     * - 5000 (providing 5000 CPU millicores = 5 cores)
     */
    amount: Scalars['BigInt']['output'];
  };

/**
 * Bucket represents a single allocation of quota capacity within an allowance.
 * Each bucket contributes its amount to the total allowance for a resource type.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec_Allowances_Items_Buckets_Items_Input =
  {
    /**
     * Amount specifies the quota capacity provided by this bucket.
     * Must be measured in the BaseUnit defined by the corresponding ResourceRegistration.
     * Must be a non-negative integer (0 is valid but provides no quota).
     *
     * Examples:
     * - 100 (providing 100 projects)
     * - 2048000 (providing 2048000 bytes = 2GB)
     * - 5000 (providing 5000 CPU millicores = 5 cores)
     */
    amount: Scalars['BigInt']['input'];
  };

/**
 * ConsumerRef identifies the quota consumer that receives these allowances.
 * The consumer type must match the ConsumerType defined in the ResourceRegistration
 * for each allowance resource type. The system validates this relationship.
 *
 * Examples:
 * - Organization receiving Project quota allowances
 * - Project receiving User quota allowances
 * - Organization receiving storage quota allowances
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec_ConsumerRef =
  {
    /**
     * APIGroup specifies the API group of the consumer resource.
     * Use full group name for Milo resources.
     *
     * Examples:
     * - "resourcemanager.miloapis.com" (Organization/Project resources)
     * - "iam.miloapis.com" (User/Group resources)
     * - "infrastructure.miloapis.com" (infrastructure resources)
     */
    apiGroup?: Maybe<Scalars['String']['output']>;
    /**
     * Kind specifies the type of consumer resource.
     * Must match an existing Kubernetes resource type that can receive quota grants.
     *
     * Common consumer types:
     * - "Organization" (top-level quota consumer)
     * - "Project" (project-level quota consumer)
     * - "User" (user-level quota consumer)
     */
    kind: Scalars['String']['output'];
    /**
     * Name identifies the specific consumer resource instance.
     * Must match the name of an existing consumer resource in the cluster.
     *
     * Examples:
     * - "acme-corp" (Organization name)
     * - "web-application" (Project name)
     * - "john.doe" (User name)
     */
    name: Scalars['String']['output'];
    /**
     * Namespace identifies the namespace of the consumer resource.
     * Required for namespaced consumer resources (e.g., Projects).
     * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
     *
     * Examples:
     * - "" (empty for cluster-scoped Organizations)
     * - "organization-acme-corp" (namespace for Projects within an organization)
     * - "project-web-app" (namespace for resources within a project)
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/**
 * ConsumerRef identifies the quota consumer that receives these allowances.
 * The consumer type must match the ConsumerType defined in the ResourceRegistration
 * for each allowance resource type. The system validates this relationship.
 *
 * Examples:
 * - Organization receiving Project quota allowances
 * - Project receiving User quota allowances
 * - Organization receiving storage quota allowances
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Target_ResourceGrantTemplate_Spec_ConsumerRef_Input =
  {
    /**
     * APIGroup specifies the API group of the consumer resource.
     * Use full group name for Milo resources.
     *
     * Examples:
     * - "resourcemanager.miloapis.com" (Organization/Project resources)
     * - "iam.miloapis.com" (User/Group resources)
     * - "infrastructure.miloapis.com" (infrastructure resources)
     */
    apiGroup?: InputMaybe<Scalars['String']['input']>;
    /**
     * Kind specifies the type of consumer resource.
     * Must match an existing Kubernetes resource type that can receive quota grants.
     *
     * Common consumer types:
     * - "Organization" (top-level quota consumer)
     * - "Project" (project-level quota consumer)
     * - "User" (user-level quota consumer)
     */
    kind: Scalars['String']['input'];
    /**
     * Name identifies the specific consumer resource instance.
     * Must match the name of an existing consumer resource in the cluster.
     *
     * Examples:
     * - "acme-corp" (Organization name)
     * - "web-application" (Project name)
     * - "john.doe" (User name)
     */
    name: Scalars['String']['input'];
    /**
     * Namespace identifies the namespace of the consumer resource.
     * Required for namespaced consumer resources (e.g., Projects).
     * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
     *
     * Examples:
     * - "" (empty for cluster-scoped Organizations)
     * - "organization-acme-corp" (namespace for Projects within an organization)
     * - "project-web-app" (namespace for resources within a project)
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/** Trigger defines what resource changes should trigger grant creation. */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Trigger = {
  /**
   * Constraints are CEL expressions that must evaluate to true for grant creation.
   * These are pure CEL expressions WITHOUT {{ }} delimiters (unlike template fields).
   * All constraints must pass for the policy to trigger.
   * The 'object' variable contains the trigger resource being evaluated.
   */
  constraints?: Maybe<
    Array<
      Maybe<Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Trigger_Constraints_Items>
    >
  >;
  resource: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Trigger_Resource;
};

/** Trigger defines what resource changes should trigger grant creation. */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Trigger_Input = {
  /**
   * Constraints are CEL expressions that must evaluate to true for grant creation.
   * These are pure CEL expressions WITHOUT {{ }} delimiters (unlike template fields).
   * All constraints must pass for the policy to trigger.
   * The 'object' variable contains the trigger resource being evaluated.
   */
  constraints?: InputMaybe<
    Array<
      InputMaybe<Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Trigger_Constraints_Items_Input>
    >
  >;
  resource: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Trigger_Resource_Input;
};

/**
 * ConditionExpression defines a CEL expression that determines when the policy should trigger.
 * All expressions in a policy's trigger conditions must evaluate to true for the policy to activate.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Trigger_Constraints_Items =
  {
    /**
     * Expression specifies the CEL expression to evaluate against the trigger resource.
     * This is a pure CEL expression WITHOUT {{ }} delimiters (unlike template fields).
     * Must return a boolean value (true to match, false to skip).
     * Maximum 1024 characters.
     *
     * Available variables in GrantCreationPolicy context:
     * - trigger: The complete resource being watched (map[string]any)
     *   - trigger.metadata.name, trigger.spec.*, trigger.status.*, etc.
     *
     * Common expression patterns:
     * - trigger.spec.tier == "premium" (check resource field)
     * - trigger.metadata.labels["environment"] == "prod" (check labels)
     * - trigger.status.phase == "Active" (check status)
     * - trigger.metadata.namespace == "production" (check namespace)
     * - has(trigger.spec.quotaProfile) (check field existence)
     */
    expression: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_trigger_constraints_items_expression']['output'];
    /**
     * Message provides a human-readable description explaining when this condition applies.
     * Used for documentation and debugging. Maximum 256 characters.
     *
     * Examples:
     * - "Applies only to premium tier organizations"
     * - "Matches organizations in production environment"
     * - "Triggers when quota profile is specified"
     */
    message?: Maybe<
      Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_trigger_constraints_items_message']['output']
    >;
  };

/**
 * ConditionExpression defines a CEL expression that determines when the policy should trigger.
 * All expressions in a policy's trigger conditions must evaluate to true for the policy to activate.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Trigger_Constraints_Items_Input =
  {
    /**
     * Expression specifies the CEL expression to evaluate against the trigger resource.
     * This is a pure CEL expression WITHOUT {{ }} delimiters (unlike template fields).
     * Must return a boolean value (true to match, false to skip).
     * Maximum 1024 characters.
     *
     * Available variables in GrantCreationPolicy context:
     * - trigger: The complete resource being watched (map[string]any)
     *   - trigger.metadata.name, trigger.spec.*, trigger.status.*, etc.
     *
     * Common expression patterns:
     * - trigger.spec.tier == "premium" (check resource field)
     * - trigger.metadata.labels["environment"] == "prod" (check labels)
     * - trigger.status.phase == "Active" (check status)
     * - trigger.metadata.namespace == "production" (check namespace)
     * - has(trigger.spec.quotaProfile) (check field existence)
     */
    expression: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_trigger_constraints_items_expression']['input'];
    /**
     * Message provides a human-readable description explaining when this condition applies.
     * Used for documentation and debugging. Maximum 256 characters.
     *
     * Examples:
     * - "Applies only to premium tier organizations"
     * - "Matches organizations in production environment"
     * - "Triggers when quota profile is specified"
     */
    message?: InputMaybe<
      Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_trigger_constraints_items_message']['input']
    >;
  };

/** Resource specifies which resource type triggers this policy. */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Trigger_Resource =
  {
    apiVersion: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_trigger_resource_apiVersion']['output'];
    kind: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_trigger_resource_kind']['output'];
  };

/** Resource specifies which resource type triggers this policy. */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Spec_Trigger_Resource_Input =
  {
    apiVersion: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_trigger_resource_apiVersion']['input'];
    kind: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_spec_trigger_resource_kind']['input'];
  };

/**
 * GrantCreationPolicyStatus defines the observed state of GrantCreationPolicy.
 *
 * Status fields
 * - conditions[type=Ready]: True when the policy is validated and active.
 * - conditions[type=ParentContextReady]: True when crosscluster targeting is resolvable.
 * - observedGeneration: Latest spec generation processed by the quota system.
 *
 * See also
 * - [ResourceGrant](#resourcegrant): The object created by this policy.
 * - [ResourceRegistration](#resourceregistration): Resource types for which grants are issued.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Status = {
  /** Conditions represent the latest available observations of the policy's current state. */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Status_Conditions_Items>
    >
  >;
  /** ObservedGeneration is the most recent generation observed. */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
};

/**
 * GrantCreationPolicyStatus defines the observed state of GrantCreationPolicy.
 *
 * Status fields
 * - conditions[type=Ready]: True when the policy is validated and active.
 * - conditions[type=ParentContextReady]: True when crosscluster targeting is resolvable.
 * - observedGeneration: Latest spec generation processed by the quota system.
 *
 * See also
 * - [ResourceGrant](#resourcegrant): The object created by this policy.
 * - [ResourceRegistration](#resourceregistration): Resource types for which grants are issued.
 */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Status_Input = {
  /** Conditions represent the latest available observations of the policy's current state. */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /** ObservedGeneration is the most recent generation observed. */
  observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_status_conditions_items_reason']['output'];
    status: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_status_conditions_items_reason']['input'];
    status: Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listQuotaMiloapisComV1alpha1GrantCreationPolicy_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListQuotaMiloapisComV1alpha1GrantCreationPolicy_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** ResourceClaimSpec defines the desired state of ResourceClaim. */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec = {
  consumerRef?: Maybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec_ConsumerRef>;
  /**
   * Requests specifies the resource types and amounts being claimed from quota.
   * Each resource type can appear only once in the requests array. Minimum 1
   * request, maximum 20 requests per claim.
   *
   * The system processes all requests as a single atomic operation: either all
   * requests are granted or all are denied.
   */
  requests: Array<
    Maybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec_Requests_Items>
  >;
  resourceRef?: Maybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec_ResourceRef>;
};

/** ResourceClaimSpec defines the desired state of ResourceClaim. */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec_Input = {
  consumerRef?: InputMaybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec_ConsumerRef_Input>;
  /**
   * Requests specifies the resource types and amounts being claimed from quota.
   * Each resource type can appear only once in the requests array. Minimum 1
   * request, maximum 20 requests per claim.
   *
   * The system processes all requests as a single atomic operation: either all
   * requests are granted or all are denied.
   */
  requests: Array<
    InputMaybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec_Requests_Items_Input>
  >;
  resourceRef?: InputMaybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec_ResourceRef_Input>;
};

/**
 * ConsumerRef identifies the quota consumer making this claim. The consumer
 * must match the ConsumerType defined in the ResourceRegistration for each
 * requested resource type. The system validates this relationship during
 * claim processing.
 *
 * When creating ResourceClaims via ClaimCreationPolicy, this field can be
 * omitted and the admission plugin will automatically fill it based on the
 * authenticated user's context (organization or project).
 *
 * Examples:
 *
 *   - Organization consuming Project quota
 *   - Project consuming User quota
 *   - Organization consuming storage quota
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec_ConsumerRef =
  {
    /**
     * APIGroup specifies the API group of the consumer resource.
     * Use full group name for Milo resources.
     *
     * Examples:
     * - "resourcemanager.miloapis.com" (Organization/Project resources)
     * - "iam.miloapis.com" (User/Group resources)
     * - "infrastructure.miloapis.com" (infrastructure resources)
     */
    apiGroup?: Maybe<Scalars['String']['output']>;
    /**
     * Kind specifies the type of consumer resource.
     * Must match an existing Kubernetes resource type that can receive quota grants.
     *
     * Common consumer types:
     * - "Organization" (top-level quota consumer)
     * - "Project" (project-level quota consumer)
     * - "User" (user-level quota consumer)
     */
    kind: Scalars['String']['output'];
    /**
     * Name identifies the specific consumer resource instance.
     * Must match the name of an existing consumer resource in the cluster.
     *
     * Examples:
     * - "acme-corp" (Organization name)
     * - "web-application" (Project name)
     * - "john.doe" (User name)
     */
    name: Scalars['String']['output'];
    /**
     * Namespace identifies the namespace of the consumer resource.
     * Required for namespaced consumer resources (e.g., Projects).
     * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
     *
     * Examples:
     * - "" (empty for cluster-scoped Organizations)
     * - "organization-acme-corp" (namespace for Projects within an organization)
     * - "project-web-app" (namespace for resources within a project)
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/**
 * ConsumerRef identifies the quota consumer making this claim. The consumer
 * must match the ConsumerType defined in the ResourceRegistration for each
 * requested resource type. The system validates this relationship during
 * claim processing.
 *
 * When creating ResourceClaims via ClaimCreationPolicy, this field can be
 * omitted and the admission plugin will automatically fill it based on the
 * authenticated user's context (organization or project).
 *
 * Examples:
 *
 *   - Organization consuming Project quota
 *   - Project consuming User quota
 *   - Organization consuming storage quota
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec_ConsumerRef_Input =
  {
    /**
     * APIGroup specifies the API group of the consumer resource.
     * Use full group name for Milo resources.
     *
     * Examples:
     * - "resourcemanager.miloapis.com" (Organization/Project resources)
     * - "iam.miloapis.com" (User/Group resources)
     * - "infrastructure.miloapis.com" (infrastructure resources)
     */
    apiGroup?: InputMaybe<Scalars['String']['input']>;
    /**
     * Kind specifies the type of consumer resource.
     * Must match an existing Kubernetes resource type that can receive quota grants.
     *
     * Common consumer types:
     * - "Organization" (top-level quota consumer)
     * - "Project" (project-level quota consumer)
     * - "User" (user-level quota consumer)
     */
    kind: Scalars['String']['input'];
    /**
     * Name identifies the specific consumer resource instance.
     * Must match the name of an existing consumer resource in the cluster.
     *
     * Examples:
     * - "acme-corp" (Organization name)
     * - "web-application" (Project name)
     * - "john.doe" (User name)
     */
    name: Scalars['String']['input'];
    /**
     * Namespace identifies the namespace of the consumer resource.
     * Required for namespaced consumer resources (e.g., Projects).
     * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
     *
     * Examples:
     * - "" (empty for cluster-scoped Organizations)
     * - "organization-acme-corp" (namespace for Projects within an organization)
     * - "project-web-app" (namespace for resources within a project)
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * ResourceRequest defines a single resource request within a ResourceClaim.
 * Each request specifies a resource type and the amount of quota being claimed.
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec_Requests_Items =
  {
    /**
     * Amount specifies how much quota to claim for this resource type. Must be
     * measured in the BaseUnit defined by the corresponding ResourceRegistration.
     * Must be a positive integer (minimum value is 0, but 0 means no quota
     * requested).
     *
     * For Entity registrations: Use 1 for single resource instances (1 Project, 1
     * User) For Allocation registrations: Use actual capacity amounts (2048 for
     * 2048 MB, 1000 for 1000 millicores)
     *
     * Examples:
     *
     *   - 1 (claiming 1 Project)
     *   - 2048 (claiming 2048 bytes of storage)
     *   - 1000 (claiming 1000 CPU millicores)
     */
    amount: Scalars['BigInt']['output'];
    /**
     * ResourceType identifies the specific resource type being claimed. Must
     * exactly match a ResourceRegistration.spec.resourceType that is currently
     * active. The quota system validates this reference during claim processing.
     *
     * The format is defined by platform administrators when creating ResourceRegistrations.
     * Service providers can use any identifier that makes sense for their quota system usage.
     *
     * Examples:
     *
     *   - "resourcemanager.miloapis.com/projects"
     *   - "compute_cpu"
     *   - "storage.volumes"
     *   - "custom-service-quota"
     */
    resourceType: Scalars['String']['output'];
  };

/**
 * ResourceRequest defines a single resource request within a ResourceClaim.
 * Each request specifies a resource type and the amount of quota being claimed.
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec_Requests_Items_Input =
  {
    /**
     * Amount specifies how much quota to claim for this resource type. Must be
     * measured in the BaseUnit defined by the corresponding ResourceRegistration.
     * Must be a positive integer (minimum value is 0, but 0 means no quota
     * requested).
     *
     * For Entity registrations: Use 1 for single resource instances (1 Project, 1
     * User) For Allocation registrations: Use actual capacity amounts (2048 for
     * 2048 MB, 1000 for 1000 millicores)
     *
     * Examples:
     *
     *   - 1 (claiming 1 Project)
     *   - 2048 (claiming 2048 bytes of storage)
     *   - 1000 (claiming 1000 CPU millicores)
     */
    amount: Scalars['BigInt']['input'];
    /**
     * ResourceType identifies the specific resource type being claimed. Must
     * exactly match a ResourceRegistration.spec.resourceType that is currently
     * active. The quota system validates this reference during claim processing.
     *
     * The format is defined by platform administrators when creating ResourceRegistrations.
     * Service providers can use any identifier that makes sense for their quota system usage.
     *
     * Examples:
     *
     *   - "resourcemanager.miloapis.com/projects"
     *   - "compute_cpu"
     *   - "storage.volumes"
     *   - "custom-service-quota"
     */
    resourceType: Scalars['String']['input'];
  };

/**
 * ResourceRef identifies the actual Kubernetes resource that triggered this
 * claim. ClaimCreationPolicy automatically populates this field during
 * admission. Uses unversioned reference (apiGroup + kind + name + namespace)
 * to remain valid across API version changes.
 *
 * The referenced resource's kind must be listed in the ResourceRegistration's
 * spec.claimingResources for the claim to be valid.
 *
 * Examples:
 *
 *   - Project resource triggering Project quota claim
 *   - User resource triggering User quota claim
 *   - Organization resource triggering storage quota claim
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec_ResourceRef =
  {
    /**
     * APIGroup specifies the API group of the referenced resource.
     * Use full group name for Milo resources.
     *
     * Examples:
     * - "resourcemanager.miloapis.com" (Project, Organization)
     * - "iam.miloapis.com" (User, Group)
     * - "infrastructure.miloapis.com" (infrastructure resources)
     */
    apiGroup?: Maybe<Scalars['String']['output']>;
    /**
     * Kind specifies the type of the referenced resource.
     * Must match an existing Kubernetes resource type.
     *
     * Examples:
     * - "Project" (Project resource that triggered quota claim)
     * - "User" (User resource that triggered quota claim)
     * - "Organization" (Organization resource that triggered quota claim)
     */
    kind: Scalars['String']['output'];
    /**
     * Name identifies the specific resource instance that triggered the quota claim.
     * Used for linking claims back to their triggering resources.
     *
     * Examples:
     * - "web-app-project" (Project that triggered Project quota claim)
     * - "john.doe" (User that triggered User quota claim)
     */
    name: Scalars['String']['output'];
    /**
     * Namespace specifies the namespace containing the referenced resource.
     * Required for namespaced resources, omitted for cluster-scoped resources.
     *
     * Examples:
     * - "acme-corp" (organization namespace containing Project)
     * - "team-alpha" (project namespace containing User)
     * - "" or omitted (for cluster-scoped resources like Organization)
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/**
 * ResourceRef identifies the actual Kubernetes resource that triggered this
 * claim. ClaimCreationPolicy automatically populates this field during
 * admission. Uses unversioned reference (apiGroup + kind + name + namespace)
 * to remain valid across API version changes.
 *
 * The referenced resource's kind must be listed in the ResourceRegistration's
 * spec.claimingResources for the claim to be valid.
 *
 * Examples:
 *
 *   - Project resource triggering Project quota claim
 *   - User resource triggering User quota claim
 *   - Organization resource triggering storage quota claim
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Spec_ResourceRef_Input =
  {
    /**
     * APIGroup specifies the API group of the referenced resource.
     * Use full group name for Milo resources.
     *
     * Examples:
     * - "resourcemanager.miloapis.com" (Project, Organization)
     * - "iam.miloapis.com" (User, Group)
     * - "infrastructure.miloapis.com" (infrastructure resources)
     */
    apiGroup?: InputMaybe<Scalars['String']['input']>;
    /**
     * Kind specifies the type of the referenced resource.
     * Must match an existing Kubernetes resource type.
     *
     * Examples:
     * - "Project" (Project resource that triggered quota claim)
     * - "User" (User resource that triggered quota claim)
     * - "Organization" (Organization resource that triggered quota claim)
     */
    kind: Scalars['String']['input'];
    /**
     * Name identifies the specific resource instance that triggered the quota claim.
     * Used for linking claims back to their triggering resources.
     *
     * Examples:
     * - "web-app-project" (Project that triggered Project quota claim)
     * - "john.doe" (User that triggered User quota claim)
     */
    name: Scalars['String']['input'];
    /**
     * Namespace specifies the namespace containing the referenced resource.
     * Required for namespaced resources, omitted for cluster-scoped resources.
     *
     * Examples:
     * - "acme-corp" (organization namespace containing Project)
     * - "team-alpha" (project namespace containing User)
     * - "" or omitted (for cluster-scoped resources like Organization)
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * ResourceClaimStatus reports the claim's processing state and allocation
 * results. The system updates this status to communicate whether quota was
 * granted and provide detailed allocation information for each requested
 * resource type.
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status = {
  /**
   * Allocations provides detailed status for each resource request in the
   * claim. The system creates one allocation entry for each request in
   * spec.requests. Use this field to understand which specific requests were
   * granted or denied.
   *
   * List is indexed by ResourceType for efficient lookups.
   */
  allocations?: Maybe<
    Array<
      Maybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Allocations_Items>
    >
  >;
  /**
   * Conditions represents the overall status of the claim evaluation.
   * Controllers set these conditions to provide a high-level view of claim
   * processing.
   *
   * Standard condition types:
   *
   *   - "Granted": Indicates whether the claim was approved and quota allocated
   *
   * Standard condition reasons for "Granted":
   *
   *   - "QuotaAvailable": All requested quota was available and allocated
   *   - "QuotaExceeded": Insufficient quota prevented allocation (claim denied)
   *   - "ValidationFailed": Configuration errors prevented evaluation (claim denied)
   *   - "PendingEvaluation": Claim is still being processed (initial state)
   *
   * Claim Lifecycle:
   *
   *   1. Created: Granted=False, reason=PendingEvaluation
   *   2. Processed: Granted=True/False based on quota availability and validation
   *   3. Updated: Granted condition changes only when allocation results change
   */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Conditions_Items>
    >
  >;
  /**
   * ObservedGeneration indicates the most recent spec generation the system has
   * processed. When ObservedGeneration matches metadata.generation, the status
   * reflects the current spec. When ObservedGeneration is lower, the system is
   * still processing recent changes.
   */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
};

/**
 * ResourceClaimStatus reports the claim's processing state and allocation
 * results. The system updates this status to communicate whether quota was
 * granted and provide detailed allocation information for each requested
 * resource type.
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Input = {
  /**
   * Allocations provides detailed status for each resource request in the
   * claim. The system creates one allocation entry for each request in
   * spec.requests. Use this field to understand which specific requests were
   * granted or denied.
   *
   * List is indexed by ResourceType for efficient lookups.
   */
  allocations?: InputMaybe<
    Array<
      InputMaybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Allocations_Items_Input>
    >
  >;
  /**
   * Conditions represents the overall status of the claim evaluation.
   * Controllers set these conditions to provide a high-level view of claim
   * processing.
   *
   * Standard condition types:
   *
   *   - "Granted": Indicates whether the claim was approved and quota allocated
   *
   * Standard condition reasons for "Granted":
   *
   *   - "QuotaAvailable": All requested quota was available and allocated
   *   - "QuotaExceeded": Insufficient quota prevented allocation (claim denied)
   *   - "ValidationFailed": Configuration errors prevented evaluation (claim denied)
   *   - "PendingEvaluation": Claim is still being processed (initial state)
   *
   * Claim Lifecycle:
   *
   *   1. Created: Granted=False, reason=PendingEvaluation
   *   2. Processed: Granted=True/False based on quota availability and validation
   *   3. Updated: Granted condition changes only when allocation results change
   */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /**
   * ObservedGeneration indicates the most recent spec generation the system has
   * processed. When ObservedGeneration matches metadata.generation, the status
   * reflects the current spec. When ObservedGeneration is lower, the system is
   * still processing recent changes.
   */
  observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
};

/**
 * ResourceClaimAllocationStatus tracks the allocation status for a specific resource
 * request within a claim. The system creates one allocation entry for each
 * request in the claim specification.
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Allocations_Items =
  {
    /**
     * AllocatedAmount specifies how much quota was actually allocated for this
     * request. Measured in the BaseUnit defined by the ResourceRegistration.
     * Currently always equals the requested amount or 0 (partial allocations not
     * supported).
     *
     * Set to the requested amount when Status=Granted, 0 when Status=Denied or
     * Pending.
     */
    allocatedAmount?: Maybe<Scalars['BigInt']['output']>;
    /**
     * AllocatingBucket identifies the AllowanceBucket that provided the quota for
     * this request. Set only when Status=Granted. Used for tracking and debugging
     * quota consumption.
     *
     * Format: bucket name (generated as:
     * consumer-kind-consumer-name-resource-type-hash)
     */
    allocatingBucket?: Maybe<Scalars['String']['output']>;
    /**
     * LastTransitionTime records when this allocation status last changed.
     * Updates whenever Status, Reason, or Message changes.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * Message provides a human-readable explanation of the allocation result.
     * Includes specific details about quota availability or validation errors.
     *
     * Examples:
     *
     *   - "Allocated 1 project from bucket organization-acme-projects"
     *   - "Insufficient quota: need 2048 bytes, only 1024 available"
     *   - "ResourceRegistration not found for resourceType"
     */
    message?: Maybe<Scalars['String']['output']>;
    /**
     * Reason provides a machine-readable explanation for the current status.
     * Standard reasons include "QuotaAvailable", "QuotaExceeded",
     * "ValidationFailed".
     */
    reason?: Maybe<Scalars['String']['output']>;
    /**
     * ResourceType identifies which resource request this allocation status
     * describes. Must exactly match one of the resourceType values in
     * spec.requests.
     */
    resourceType: Scalars['NonEmptyString']['output'];
    status: Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Allocations_Items_Status;
  };

/**
 * ResourceClaimAllocationStatus tracks the allocation status for a specific resource
 * request within a claim. The system creates one allocation entry for each
 * request in the claim specification.
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Allocations_Items_Input =
  {
    /**
     * AllocatedAmount specifies how much quota was actually allocated for this
     * request. Measured in the BaseUnit defined by the ResourceRegistration.
     * Currently always equals the requested amount or 0 (partial allocations not
     * supported).
     *
     * Set to the requested amount when Status=Granted, 0 when Status=Denied or
     * Pending.
     */
    allocatedAmount?: InputMaybe<Scalars['BigInt']['input']>;
    /**
     * AllocatingBucket identifies the AllowanceBucket that provided the quota for
     * this request. Set only when Status=Granted. Used for tracking and debugging
     * quota consumption.
     *
     * Format: bucket name (generated as:
     * consumer-kind-consumer-name-resource-type-hash)
     */
    allocatingBucket?: InputMaybe<Scalars['String']['input']>;
    /**
     * LastTransitionTime records when this allocation status last changed.
     * Updates whenever Status, Reason, or Message changes.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * Message provides a human-readable explanation of the allocation result.
     * Includes specific details about quota availability or validation errors.
     *
     * Examples:
     *
     *   - "Allocated 1 project from bucket organization-acme-projects"
     *   - "Insufficient quota: need 2048 bytes, only 1024 available"
     *   - "ResourceRegistration not found for resourceType"
     */
    message?: InputMaybe<Scalars['String']['input']>;
    /**
     * Reason provides a machine-readable explanation for the current status.
     * Standard reasons include "QuotaAvailable", "QuotaExceeded",
     * "ValidationFailed".
     */
    reason?: InputMaybe<Scalars['String']['input']>;
    /**
     * ResourceType identifies which resource request this allocation status
     * describes. Must exactly match one of the resourceType values in
     * spec.requests.
     */
    resourceType: Scalars['NonEmptyString']['input'];
    status: Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Allocations_Items_Status;
  };

/**
 * Status indicates the allocation result for this specific resource request.
 *
 * Valid values:
 *
 *   - "Granted": Quota was available and the request was approved
 *   - "Denied": Insufficient quota or validation failure prevented allocation
 *   - "Pending": Request is being evaluated (initial state)
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Allocations_Items_Status =
  'Denied' | 'Granted' | 'Pending';

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listQuotaMiloapisComV1alpha1NamespacedResourceClaim_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listQuotaMiloapisComV1alpha1NamespacedResourceClaim_items_items_status_conditions_items_reason']['output'];
    status: Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listQuotaMiloapisComV1alpha1NamespacedResourceClaim_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listQuotaMiloapisComV1alpha1NamespacedResourceClaim_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listQuotaMiloapisComV1alpha1NamespacedResourceClaim_items_items_status_conditions_items_reason']['input'];
    status: Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listQuotaMiloapisComV1alpha1NamespacedResourceClaim_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceClaim_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** ResourceGrantSpec defines the desired state of ResourceGrant. */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec = {
  /**
   * Allowances specifies the quota allocations provided by this grant.
   * Each allowance grants capacity for a specific resource type.
   * Minimum 1 allowance required, maximum 20 allowances per grant.
   *
   * All allowances in a single grant:
   * - Apply to the same consumer (spec.consumerRef)
   * - Contribute to the same AllowanceBucket for each resource type
   * - Activate and deactivate together based on the grant's status
   */
  allowances: Array<
    Maybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec_Allowances_Items>
  >;
  consumerRef: Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec_ConsumerRef;
};

/** ResourceGrantSpec defines the desired state of ResourceGrant. */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec_Input = {
  /**
   * Allowances specifies the quota allocations provided by this grant.
   * Each allowance grants capacity for a specific resource type.
   * Minimum 1 allowance required, maximum 20 allowances per grant.
   *
   * All allowances in a single grant:
   * - Apply to the same consumer (spec.consumerRef)
   * - Contribute to the same AllowanceBucket for each resource type
   * - Activate and deactivate together based on the grant's status
   */
  allowances: Array<
    InputMaybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec_Allowances_Items_Input>
  >;
  consumerRef: Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec_ConsumerRef_Input;
};

/**
 * Allowance defines quota allocation for a specific resource type within a ResourceGrant.
 * Each allowance can contain multiple buckets that sum to provide total capacity.
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec_Allowances_Items =
  {
    /**
     * Buckets contains the quota allocations for this resource type.
     * All bucket amounts are summed to determine the total allowance.
     * Minimum 1 bucket required per allowance.
     *
     * Multiple buckets can be used for:
     * - Separating quota from different sources or tiers
     * - Managing incremental quota increases over time
     * - Tracking quota attribution for billing or reporting
     */
    buckets: Array<
      Maybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec_Allowances_Items_Buckets_Items>
    >;
    /**
     * ResourceType identifies the specific resource type receiving quota allocation.
     * Must exactly match a ResourceRegistration.spec.resourceType that is currently active.
     * The quota system validates this reference when processing the grant.
     *
     * The identifier format is flexible, as defined by platform administrators
     * in their ResourceRegistrations.
     *
     * Examples:
     * - "resourcemanager.miloapis.com/projects"
     * - "compute_cpu"
     * - "storage.volumes"
     * - "custom-service-quota"
     */
    resourceType: Scalars['String']['output'];
  };

/**
 * Allowance defines quota allocation for a specific resource type within a ResourceGrant.
 * Each allowance can contain multiple buckets that sum to provide total capacity.
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec_Allowances_Items_Input =
  {
    /**
     * Buckets contains the quota allocations for this resource type.
     * All bucket amounts are summed to determine the total allowance.
     * Minimum 1 bucket required per allowance.
     *
     * Multiple buckets can be used for:
     * - Separating quota from different sources or tiers
     * - Managing incremental quota increases over time
     * - Tracking quota attribution for billing or reporting
     */
    buckets: Array<
      InputMaybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec_Allowances_Items_Buckets_Items_Input>
    >;
    /**
     * ResourceType identifies the specific resource type receiving quota allocation.
     * Must exactly match a ResourceRegistration.spec.resourceType that is currently active.
     * The quota system validates this reference when processing the grant.
     *
     * The identifier format is flexible, as defined by platform administrators
     * in their ResourceRegistrations.
     *
     * Examples:
     * - "resourcemanager.miloapis.com/projects"
     * - "compute_cpu"
     * - "storage.volumes"
     * - "custom-service-quota"
     */
    resourceType: Scalars['String']['input'];
  };

/**
 * Bucket represents a single allocation of quota capacity within an allowance.
 * Each bucket contributes its amount to the total allowance for a resource type.
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec_Allowances_Items_Buckets_Items =
  {
    /**
     * Amount specifies the quota capacity provided by this bucket.
     * Must be measured in the BaseUnit defined by the corresponding ResourceRegistration.
     * Must be a non-negative integer (0 is valid but provides no quota).
     *
     * Examples:
     * - 100 (providing 100 projects)
     * - 2048000 (providing 2048000 bytes = 2GB)
     * - 5000 (providing 5000 CPU millicores = 5 cores)
     */
    amount: Scalars['BigInt']['output'];
  };

/**
 * Bucket represents a single allocation of quota capacity within an allowance.
 * Each bucket contributes its amount to the total allowance for a resource type.
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec_Allowances_Items_Buckets_Items_Input =
  {
    /**
     * Amount specifies the quota capacity provided by this bucket.
     * Must be measured in the BaseUnit defined by the corresponding ResourceRegistration.
     * Must be a non-negative integer (0 is valid but provides no quota).
     *
     * Examples:
     * - 100 (providing 100 projects)
     * - 2048000 (providing 2048000 bytes = 2GB)
     * - 5000 (providing 5000 CPU millicores = 5 cores)
     */
    amount: Scalars['BigInt']['input'];
  };

/**
 * ConsumerRef identifies the quota consumer that receives these allowances.
 * The consumer type must match the ConsumerType defined in the ResourceRegistration
 * for each allowance resource type. The system validates this relationship.
 *
 * Examples:
 * - Organization receiving Project quota allowances
 * - Project receiving User quota allowances
 * - Organization receiving storage quota allowances
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec_ConsumerRef =
  {
    /**
     * APIGroup specifies the API group of the consumer resource.
     * Use full group name for Milo resources.
     *
     * Examples:
     * - "resourcemanager.miloapis.com" (Organization/Project resources)
     * - "iam.miloapis.com" (User/Group resources)
     * - "infrastructure.miloapis.com" (infrastructure resources)
     */
    apiGroup?: Maybe<Scalars['String']['output']>;
    /**
     * Kind specifies the type of consumer resource.
     * Must match an existing Kubernetes resource type that can receive quota grants.
     *
     * Common consumer types:
     * - "Organization" (top-level quota consumer)
     * - "Project" (project-level quota consumer)
     * - "User" (user-level quota consumer)
     */
    kind: Scalars['String']['output'];
    /**
     * Name identifies the specific consumer resource instance.
     * Must match the name of an existing consumer resource in the cluster.
     *
     * Examples:
     * - "acme-corp" (Organization name)
     * - "web-application" (Project name)
     * - "john.doe" (User name)
     */
    name: Scalars['String']['output'];
    /**
     * Namespace identifies the namespace of the consumer resource.
     * Required for namespaced consumer resources (e.g., Projects).
     * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
     *
     * Examples:
     * - "" (empty for cluster-scoped Organizations)
     * - "organization-acme-corp" (namespace for Projects within an organization)
     * - "project-web-app" (namespace for resources within a project)
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/**
 * ConsumerRef identifies the quota consumer that receives these allowances.
 * The consumer type must match the ConsumerType defined in the ResourceRegistration
 * for each allowance resource type. The system validates this relationship.
 *
 * Examples:
 * - Organization receiving Project quota allowances
 * - Project receiving User quota allowances
 * - Organization receiving storage quota allowances
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Spec_ConsumerRef_Input =
  {
    /**
     * APIGroup specifies the API group of the consumer resource.
     * Use full group name for Milo resources.
     *
     * Examples:
     * - "resourcemanager.miloapis.com" (Organization/Project resources)
     * - "iam.miloapis.com" (User/Group resources)
     * - "infrastructure.miloapis.com" (infrastructure resources)
     */
    apiGroup?: InputMaybe<Scalars['String']['input']>;
    /**
     * Kind specifies the type of consumer resource.
     * Must match an existing Kubernetes resource type that can receive quota grants.
     *
     * Common consumer types:
     * - "Organization" (top-level quota consumer)
     * - "Project" (project-level quota consumer)
     * - "User" (user-level quota consumer)
     */
    kind: Scalars['String']['input'];
    /**
     * Name identifies the specific consumer resource instance.
     * Must match the name of an existing consumer resource in the cluster.
     *
     * Examples:
     * - "acme-corp" (Organization name)
     * - "web-application" (Project name)
     * - "john.doe" (User name)
     */
    name: Scalars['String']['input'];
    /**
     * Namespace identifies the namespace of the consumer resource.
     * Required for namespaced consumer resources (e.g., Projects).
     * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
     *
     * Examples:
     * - "" (empty for cluster-scoped Organizations)
     * - "organization-acme-corp" (namespace for Projects within an organization)
     * - "project-web-app" (namespace for resources within a project)
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * ResourceGrantStatus reports the grant's operational state and processing status.
 * Controllers update status conditions to indicate whether the grant is active
 * and contributing capacity to AllowanceBuckets.
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Status = {
  /**
   * Conditions represents the latest available observations of the grant's state.
   * Controllers set these conditions to communicate operational status.
   *
   * Standard condition types:
   * - "Active": Indicates whether the grant is operational and contributing to quota buckets.
   *   When True, allowances are aggregated into AllowanceBuckets and available for claims.
   *   When False, allowances do not contribute to quota decisions.
   *
   * Standard condition reasons for "Active":
   * - "GrantActive": Grant is validated and contributing to quota buckets
   * - "ValidationFailed": Specification contains errors preventing activation (see message)
   * - "GrantPending": Grant is being processed by the quota system
   *
   * Grant Lifecycle:
   * 1. Created: Active=Unknown, reason=GrantPending
   * 2. Validated: Active=True, reason=GrantActive OR Active=False, reason=ValidationFailed
   * 3. Updated: Active condition changes only when validation results change
   */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Status_Conditions_Items>
    >
  >;
  /**
   * ObservedGeneration indicates the most recent spec generation the quota system has processed.
   * When ObservedGeneration matches metadata.generation, the status reflects the current spec.
   * When ObservedGeneration is lower, the quota system is still processing recent changes.
   */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
};

/**
 * ResourceGrantStatus reports the grant's operational state and processing status.
 * Controllers update status conditions to indicate whether the grant is active
 * and contributing capacity to AllowanceBuckets.
 */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Status_Input = {
  /**
   * Conditions represents the latest available observations of the grant's state.
   * Controllers set these conditions to communicate operational status.
   *
   * Standard condition types:
   * - "Active": Indicates whether the grant is operational and contributing to quota buckets.
   *   When True, allowances are aggregated into AllowanceBuckets and available for claims.
   *   When False, allowances do not contribute to quota decisions.
   *
   * Standard condition reasons for "Active":
   * - "GrantActive": Grant is validated and contributing to quota buckets
   * - "ValidationFailed": Specification contains errors preventing activation (see message)
   * - "GrantPending": Grant is being processed by the quota system
   *
   * Grant Lifecycle:
   * 1. Created: Active=Unknown, reason=GrantPending
   * 2. Validated: Active=True, reason=GrantActive OR Active=False, reason=ValidationFailed
   * 3. Updated: Active condition changes only when validation results change
   */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /**
   * ObservedGeneration indicates the most recent spec generation the quota system has processed.
   * When ObservedGeneration matches metadata.generation, the status reflects the current spec.
   * When ObservedGeneration is lower, the quota system is still processing recent changes.
   */
  observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listQuotaMiloapisComV1alpha1NamespacedResourceGrant_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listQuotaMiloapisComV1alpha1NamespacedResourceGrant_items_items_status_conditions_items_reason']['output'];
    status: Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listQuotaMiloapisComV1alpha1NamespacedResourceGrant_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listQuotaMiloapisComV1alpha1NamespacedResourceGrant_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listQuotaMiloapisComV1alpha1NamespacedResourceGrant_items_items_status_conditions_items_reason']['input'];
    status: Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listQuotaMiloapisComV1alpha1NamespacedResourceGrant_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListQuotaMiloapisComV1alpha1NamespacedResourceGrant_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** ResourceRegistrationSpec defines the desired state of ResourceRegistration. */
export type Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec = {
  /**
   * BaseUnit defines the internal measurement unit for all quota calculations.
   * The system stores and processes all quota amounts using this unit.
   * Use singular form with lowercase letters. Maximum 50 characters.
   *
   * Examples:
   * - "project" (for Entity type tracking Projects)
   * - "millicore" (for CPU allocation)
   * - "byte" (for storage or memory)
   * - "user" (for Entity type tracking Users)
   */
  baseUnit: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_baseUnit']['output'];
  /**
   * ClaimingResources specifies which resource types can create ResourceClaims for this registration.
   * Only resources listed here can trigger quota consumption for this resource type.
   * At least one claiming resource must be specified.
   * Maximum 20 entries.
   */
  claimingResources: Array<
    Maybe<Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec_ClaimingResources_Items>
  >;
  consumerType: Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec_ConsumerType;
  /**
   * Description provides human-readable context about what this registration tracks.
   * Use clear, specific language that explains the resource type and measurement approach.
   * Maximum 500 characters.
   *
   * Examples:
   * - "Projects created within Organizations"
   * - "CPU millicores allocated to workloads"
   * - "Storage bytes claimed by volume requests"
   */
  description?: Maybe<
    Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_description']['output']
  >;
  /**
   * DisplayUnit defines the unit shown in user interfaces and API responses.
   * Should be more human-readable than BaseUnit. Use singular form. Maximum 50 characters.
   *
   * Examples:
   * - "project" (same as BaseUnit when no conversion needed)
   * - "core" (for displaying CPU instead of millicores)
   * - "GiB" (for displaying memory/storage instead of bytes)
   * - "TB" (for large storage volumes)
   */
  displayUnit: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_displayUnit']['output'];
  /**
   * ResourceType identifies the resource to track with quota.
   * Platform administrators define resource type identifiers that make sense for their
   * quota system usage. This field is immutable after creation.
   *
   * The identifier format is flexible to accommodate various naming conventions
   * and organizational needs. Service providers can use any meaningful identifier.
   *
   * Examples:
   * - "resourcemanager.miloapis.com/projects"
   * - "iam.miloapis.com/users"
   * - "compute_cpu"
   * - "storage.volumes"
   * - "custom-service-quota"
   */
  resourceType: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_resourceType']['output'];
  type: Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec_Type;
  /**
   * UnitConversionFactor converts BaseUnit values to DisplayUnit values for presentation.
   * Must be a positive integer. Minimum value is 1 (no conversion).
   *
   * Formula: displayValue = baseValue / unitConversionFactor
   *
   * Examples:
   * - 1 (no conversion: "project" to "project")
   * - 1000 (millicores to cores: 2000 millicores displays as 2 cores)
   * - 1073741824 (bytes to GiB: 2147483648 bytes displays as 2 GiB)
   * - 1000000000000 (bytes to TB: 2000000000000 bytes displays as 2 TB)
   */
  unitConversionFactor: Scalars['BigInt']['output'];
};

/** ResourceRegistrationSpec defines the desired state of ResourceRegistration. */
export type Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec_Input = {
  /**
   * BaseUnit defines the internal measurement unit for all quota calculations.
   * The system stores and processes all quota amounts using this unit.
   * Use singular form with lowercase letters. Maximum 50 characters.
   *
   * Examples:
   * - "project" (for Entity type tracking Projects)
   * - "millicore" (for CPU allocation)
   * - "byte" (for storage or memory)
   * - "user" (for Entity type tracking Users)
   */
  baseUnit: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_baseUnit']['input'];
  /**
   * ClaimingResources specifies which resource types can create ResourceClaims for this registration.
   * Only resources listed here can trigger quota consumption for this resource type.
   * At least one claiming resource must be specified.
   * Maximum 20 entries.
   */
  claimingResources: Array<
    InputMaybe<Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec_ClaimingResources_Items_Input>
  >;
  consumerType: Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec_ConsumerType_Input;
  /**
   * Description provides human-readable context about what this registration tracks.
   * Use clear, specific language that explains the resource type and measurement approach.
   * Maximum 500 characters.
   *
   * Examples:
   * - "Projects created within Organizations"
   * - "CPU millicores allocated to workloads"
   * - "Storage bytes claimed by volume requests"
   */
  description?: InputMaybe<
    Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_description']['input']
  >;
  /**
   * DisplayUnit defines the unit shown in user interfaces and API responses.
   * Should be more human-readable than BaseUnit. Use singular form. Maximum 50 characters.
   *
   * Examples:
   * - "project" (same as BaseUnit when no conversion needed)
   * - "core" (for displaying CPU instead of millicores)
   * - "GiB" (for displaying memory/storage instead of bytes)
   * - "TB" (for large storage volumes)
   */
  displayUnit: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_displayUnit']['input'];
  /**
   * ResourceType identifies the resource to track with quota.
   * Platform administrators define resource type identifiers that make sense for their
   * quota system usage. This field is immutable after creation.
   *
   * The identifier format is flexible to accommodate various naming conventions
   * and organizational needs. Service providers can use any meaningful identifier.
   *
   * Examples:
   * - "resourcemanager.miloapis.com/projects"
   * - "iam.miloapis.com/users"
   * - "compute_cpu"
   * - "storage.volumes"
   * - "custom-service-quota"
   */
  resourceType: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_resourceType']['input'];
  type: Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec_Type;
  /**
   * UnitConversionFactor converts BaseUnit values to DisplayUnit values for presentation.
   * Must be a positive integer. Minimum value is 1 (no conversion).
   *
   * Formula: displayValue = baseValue / unitConversionFactor
   *
   * Examples:
   * - 1 (no conversion: "project" to "project")
   * - 1000 (millicores to cores: 2000 millicores displays as 2 cores)
   * - 1073741824 (bytes to GiB: 2147483648 bytes displays as 2 GiB)
   * - 1000000000000 (bytes to TB: 2000000000000 bytes displays as 2 TB)
   */
  unitConversionFactor: Scalars['BigInt']['input'];
};

/**
 * ClaimingResource identifies a resource type that can create **ResourceClaims**
 * for this registration. Uses unversioned references to remain valid across API version changes.
 */
export type Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec_ClaimingResources_Items =
  {
    apiGroup?: Maybe<
      Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_claimingResources_items_apiGroup']['output']
    >;
    /**
     * Kind specifies the resource type that can create **ResourceClaims** for this registration.
     * Must match an existing resource type. Maximum 63 characters.
     *
     * Examples:
     * - `Project` (**Project** resource creating claims for **Project** quota)
     * - `User` (**User** resource creating claims for **User** quota)
     * - `Organization` (**Organization** resource creating claims for **Organization** quota)
     */
    kind: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_claimingResources_items_kind']['output'];
  };

/**
 * ClaimingResource identifies a resource type that can create **ResourceClaims**
 * for this registration. Uses unversioned references to remain valid across API version changes.
 */
export type Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec_ClaimingResources_Items_Input =
  {
    apiGroup?: InputMaybe<
      Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_claimingResources_items_apiGroup']['input']
    >;
    /**
     * Kind specifies the resource type that can create **ResourceClaims** for this registration.
     * Must match an existing resource type. Maximum 63 characters.
     *
     * Examples:
     * - `Project` (**Project** resource creating claims for **Project** quota)
     * - `User` (**User** resource creating claims for **User** quota)
     * - `Organization` (**Organization** resource creating claims for **Organization** quota)
     */
    kind: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_claimingResources_items_kind']['input'];
  };

/**
 * ConsumerType specifies which resource type receives grants and creates claims for this registration.
 * The consumer type must exist in the cluster before creating the registration.
 *
 * Example: When registering "Projects per Organization", set `ConsumerType` to **Organization**
 * (apiGroup: `resourcemanager.miloapis.com`, kind: `Organization`). **Organizations** then
 * receive **ResourceGrants** allocating **Project** quota and create **ResourceClaims** when **Projects** are created.
 */
export type Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec_ConsumerType = {
  apiGroup: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_consumerType_apiGroup']['output'];
  /**
   * Kind specifies the resource type that receives quota grants and creates quota claims.
   * Must match an existing Kubernetes resource type (core or custom).
   * Use the exact Kind name as defined in the resource's schema.
   *
   * Examples:
   * - **Organization** (receives **Project** quotas)
   * - **Project** (receives **User** quotas)
   * - **User** (receives resource quotas within projects)
   */
  kind: Scalars['String']['output'];
};

/**
 * ConsumerType specifies which resource type receives grants and creates claims for this registration.
 * The consumer type must exist in the cluster before creating the registration.
 *
 * Example: When registering "Projects per Organization", set `ConsumerType` to **Organization**
 * (apiGroup: `resourcemanager.miloapis.com`, kind: `Organization`). **Organizations** then
 * receive **ResourceGrants** allocating **Project** quota and create **ResourceClaims** when **Projects** are created.
 */
export type Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec_ConsumerType_Input =
  {
    apiGroup: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_spec_consumerType_apiGroup']['input'];
    /**
     * Kind specifies the resource type that receives quota grants and creates quota claims.
     * Must match an existing Kubernetes resource type (core or custom).
     * Use the exact Kind name as defined in the resource's schema.
     *
     * Examples:
     * - **Organization** (receives **Project** quotas)
     * - **Project** (receives **User** quotas)
     * - **User** (receives resource quotas within projects)
     */
    kind: Scalars['String']['input'];
  };

/**
 * Type specifies the measurement method for quota tracking.
 * This field is immutable after creation.
 *
 * Valid values:
 * - `Entity`: Counts discrete resource instances. Use for resources where each instance
 *   consumes exactly 1 quota unit (for example, **Projects**, **Users**, **Databases**).
 *   Claims always request integer quantities.
 * - `Allocation`: Measures numeric capacity or resource amounts. Use for resources
 *   with variable consumption (for example, CPU millicores, memory bytes, storage capacity).
 *   Claims can request fractional amounts based on resource specifications.
 */
export type Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Spec_Type =
  | 'Allocation'
  | 'Entity';

/**
 * ResourceRegistrationStatus reports the registration's operational state and processing status.
 * The system updates status conditions to indicate whether the registration is active and
 * usable for quota operations.
 */
export type Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Status = {
  /**
   * Conditions represents the latest available observations of the registration's state.
   * The system sets these conditions to communicate operational status.
   *
   * Standard condition types:
   * - "Active": Indicates whether the registration is operational. When True, ResourceGrants
   *   and ResourceClaims can reference this registration. When False, quota operations are blocked.
   *
   * Standard condition reasons for "Active":
   * - "RegistrationActive": Registration is validated and operational
   * - "ValidationFailed": Specification contains errors (see message for details)
   * - "RegistrationPending": Registration is being processed
   */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Status_Conditions_Items>
    >
  >;
  /**
   * ObservedGeneration indicates the most recent spec generation that the system has processed.
   * When ObservedGeneration matches metadata.generation, the status reflects the current spec.
   * When ObservedGeneration is lower, the system is still processing recent changes.
   */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
};

/**
 * ResourceRegistrationStatus reports the registration's operational state and processing status.
 * The system updates status conditions to indicate whether the registration is active and
 * usable for quota operations.
 */
export type Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Status_Input = {
  /**
   * Conditions represents the latest available observations of the registration's state.
   * The system sets these conditions to communicate operational status.
   *
   * Standard condition types:
   * - "Active": Indicates whether the registration is operational. When True, ResourceGrants
   *   and ResourceClaims can reference this registration. When False, quota operations are blocked.
   *
   * Standard condition reasons for "Active":
   * - "RegistrationActive": Registration is validated and operational
   * - "ValidationFailed": Specification contains errors (see message for details)
   * - "RegistrationPending": Registration is being processed
   */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /**
   * ObservedGeneration indicates the most recent spec generation that the system has processed.
   * When ObservedGeneration matches metadata.generation, the status reflects the current spec.
   * When ObservedGeneration is lower, the system is still processing recent changes.
   */
  observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_status_conditions_items_reason']['output'];
    status: Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_status_conditions_items_reason']['input'];
    status: Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listQuotaMiloapisComV1alpha1ResourceRegistration_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListQuotaMiloapisComV1alpha1ResourceRegistration_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * OrganizationMembershipSpec defines the desired state of OrganizationMembership.
 * It specifies which user should be a member of which organization, and optionally
 * which roles should be assigned to grant permissions.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec =
  {
    organizationRef: Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec_OrganizationRef;
    /**
     * Roles specifies a list of roles to assign to the user within the organization.
     * The controller automatically creates and manages PolicyBinding resources for
     * each role. Roles can be added or removed after the membership is created.
     *
     * Optional field. When omitted or empty, the membership is established without
     * any role assignments. Roles can be added later via update operations.
     *
     * Each role reference must specify:
     *   - name: The role name (required)
     *   - namespace: The role namespace (optional, defaults to membership namespace)
     *
     * Duplicate roles are prevented by admission webhook validation.
     *
     * Example:
     *
     *   roles:
     *   - name: organization-admin
     *     namespace: organization-acme-corp
     *   - name: billing-manager
     *     namespace: organization-acme-corp
     *   - name: shared-developer
     *     namespace: milo-system
     */
    roles?: Maybe<
      Array<
        Maybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec_Roles_Items>
      >
    >;
    userRef: Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec_UserRef;
  };

/**
 * OrganizationMembershipSpec defines the desired state of OrganizationMembership.
 * It specifies which user should be a member of which organization, and optionally
 * which roles should be assigned to grant permissions.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec_Input =
  {
    organizationRef: Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec_OrganizationRef_Input;
    /**
     * Roles specifies a list of roles to assign to the user within the organization.
     * The controller automatically creates and manages PolicyBinding resources for
     * each role. Roles can be added or removed after the membership is created.
     *
     * Optional field. When omitted or empty, the membership is established without
     * any role assignments. Roles can be added later via update operations.
     *
     * Each role reference must specify:
     *   - name: The role name (required)
     *   - namespace: The role namespace (optional, defaults to membership namespace)
     *
     * Duplicate roles are prevented by admission webhook validation.
     *
     * Example:
     *
     *   roles:
     *   - name: organization-admin
     *     namespace: organization-acme-corp
     *   - name: billing-manager
     *     namespace: organization-acme-corp
     *   - name: shared-developer
     *     namespace: milo-system
     */
    roles?: InputMaybe<
      Array<
        InputMaybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec_Roles_Items_Input>
      >
    >;
    userRef: Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec_UserRef_Input;
  };

/**
 * OrganizationRef identifies the organization to grant membership in.
 * The organization must exist before creating the membership.
 *
 * Required field.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec_OrganizationRef =
  {
    /** Name is the name of resource being referenced */
    name: Scalars['String']['output'];
  };

/**
 * OrganizationRef identifies the organization to grant membership in.
 * The organization must exist before creating the membership.
 *
 * Required field.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec_OrganizationRef_Input =
  {
    /** Name is the name of resource being referenced */
    name: Scalars['String']['input'];
  };

/** RoleReference defines a reference to a Role resource for organization membership. */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec_Roles_Items =
  {
    /** Name of the referenced Role. */
    name: Scalars['String']['output'];
    /**
     * Namespace of the referenced Role.
     * If not specified, it defaults to the organization membership's namespace.
     */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/** RoleReference defines a reference to a Role resource for organization membership. */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec_Roles_Items_Input =
  {
    /** Name of the referenced Role. */
    name: Scalars['String']['input'];
    /**
     * Namespace of the referenced Role.
     * If not specified, it defaults to the organization membership's namespace.
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * UserRef identifies the user to grant organization membership.
 * The user must exist before creating the membership.
 *
 * Required field.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec_UserRef =
  {
    /** Name is the name of resource being referenced */
    name: Scalars['String']['output'];
  };

/**
 * UserRef identifies the user to grant organization membership.
 * The user must exist before creating the membership.
 *
 * Required field.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Spec_UserRef_Input =
  {
    /** Name is the name of resource being referenced */
    name: Scalars['String']['input'];
  };

/**
 * OrganizationMembershipStatus defines the observed state of OrganizationMembership.
 * The controller populates this status to reflect the current reconciliation state,
 * including whether the membership is ready and which roles have been successfully applied.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status =
  {
    /**
     * AppliedRoles tracks the reconciliation state of each role in spec.roles.
     * This array provides per-role status, making it easy to identify which
     * roles are applied and which failed.
     *
     * Each entry includes:
     *   - name and namespace: Identifies the role
     *   - status: "Applied", "Pending", or "Failed"
     *   - policyBindingRef: Reference to the created PolicyBinding (when Applied)
     *   - appliedAt: Timestamp when role was applied (when Applied)
     *   - message: Error details (when Failed)
     *
     * Use this to troubleshoot role assignment issues. Roles marked as "Failed"
     * include a message explaining why the PolicyBinding could not be created.
     *
     * Example:
     *
     *   appliedRoles:
     *   - name: org-admin
     *     namespace: organization-acme-corp
     *     status: Applied
     *     appliedAt: "2025-10-28T10:00:00Z"
     *     policyBindingRef:
     *       name: jane-acme-membership-a1b2c3d4
     *       namespace: organization-acme-corp
     *   - name: invalid-role
     *     namespace: organization-acme-corp
     *     status: Failed
     *     message: "role 'invalid-role' not found in namespace 'organization-acme-corp'"
     */
    appliedRoles?: Maybe<
      Array<
        Maybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_AppliedRoles_Items>
      >
    >;
    /**
     * Conditions represent the current status of the membership.
     *
     * Standard conditions:
     *   - Ready: Indicates membership has been established (user and org exist)
     *   - RolesApplied: Indicates whether all roles have been successfully applied
     *
     * Check the RolesApplied condition to determine overall role assignment status:
     *   - True with reason "AllRolesApplied": All roles successfully applied
     *   - True with reason "NoRolesSpecified": No roles in spec, membership only
     *   - False with reason "PartialRolesApplied": Some roles failed (check appliedRoles for details)
     */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_Conditions_Items>
      >
    >;
    /**
     * ObservedGeneration tracks the most recent membership spec that the
     * controller has processed. Use this to determine if status reflects
     * the latest changes.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    organization?: Maybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_Organization>;
    user?: Maybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_User>;
  };

/**
 * OrganizationMembershipStatus defines the observed state of OrganizationMembership.
 * The controller populates this status to reflect the current reconciliation state,
 * including whether the membership is ready and which roles have been successfully applied.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_Input =
  {
    /**
     * AppliedRoles tracks the reconciliation state of each role in spec.roles.
     * This array provides per-role status, making it easy to identify which
     * roles are applied and which failed.
     *
     * Each entry includes:
     *   - name and namespace: Identifies the role
     *   - status: "Applied", "Pending", or "Failed"
     *   - policyBindingRef: Reference to the created PolicyBinding (when Applied)
     *   - appliedAt: Timestamp when role was applied (when Applied)
     *   - message: Error details (when Failed)
     *
     * Use this to troubleshoot role assignment issues. Roles marked as "Failed"
     * include a message explaining why the PolicyBinding could not be created.
     *
     * Example:
     *
     *   appliedRoles:
     *   - name: org-admin
     *     namespace: organization-acme-corp
     *     status: Applied
     *     appliedAt: "2025-10-28T10:00:00Z"
     *     policyBindingRef:
     *       name: jane-acme-membership-a1b2c3d4
     *       namespace: organization-acme-corp
     *   - name: invalid-role
     *     namespace: organization-acme-corp
     *     status: Failed
     *     message: "role 'invalid-role' not found in namespace 'organization-acme-corp'"
     */
    appliedRoles?: InputMaybe<
      Array<
        InputMaybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_AppliedRoles_Items_Input>
      >
    >;
    /**
     * Conditions represent the current status of the membership.
     *
     * Standard conditions:
     *   - Ready: Indicates membership has been established (user and org exist)
     *   - RolesApplied: Indicates whether all roles have been successfully applied
     *
     * Check the RolesApplied condition to determine overall role assignment status:
     *   - True with reason "AllRolesApplied": All roles successfully applied
     *   - True with reason "NoRolesSpecified": No roles in spec, membership only
     *   - False with reason "PartialRolesApplied": Some roles failed (check appliedRoles for details)
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /**
     * ObservedGeneration tracks the most recent membership spec that the
     * controller has processed. Use this to determine if status reflects
     * the latest changes.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    organization?: InputMaybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_Organization_Input>;
    user?: InputMaybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_User_Input>;
  };

/**
 * AppliedRole tracks the reconciliation status of a single role assignment
 * within an organization membership. The controller maintains this status to
 * provide visibility into which roles are successfully applied and which failed.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_AppliedRoles_Items =
  {
    /**
     * AppliedAt records when this role was successfully applied.
     * Corresponds to the PolicyBinding creation time.
     *
     * Only populated when Status is "Applied".
     */
    appliedAt?: Maybe<Scalars['DateTime']['output']>;
    /**
     * Message provides additional context about the role status.
     * Contains error details when Status is "Failed", explaining why the
     * PolicyBinding could not be created.
     *
     * Common failure messages:
     *   - "role 'role-name' not found in namespace 'namespace'"
     *   - "Failed to create PolicyBinding: <error details>"
     *
     * Empty when Status is "Applied" or "Pending".
     */
    message?: Maybe<Scalars['String']['output']>;
    /**
     * Name identifies the Role resource.
     *
     * Required field.
     */
    name: Scalars['String']['output'];
    /**
     * Namespace identifies the namespace containing the Role resource.
     * Empty when the role is in the membership's namespace.
     */
    namespace?: Maybe<Scalars['String']['output']>;
    policyBindingRef?: Maybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_AppliedRoles_Items_PolicyBindingRef>;
    status: Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_AppliedRoles_Items_Status;
  };

/**
 * AppliedRole tracks the reconciliation status of a single role assignment
 * within an organization membership. The controller maintains this status to
 * provide visibility into which roles are successfully applied and which failed.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_AppliedRoles_Items_Input =
  {
    /**
     * AppliedAt records when this role was successfully applied.
     * Corresponds to the PolicyBinding creation time.
     *
     * Only populated when Status is "Applied".
     */
    appliedAt?: InputMaybe<Scalars['DateTime']['input']>;
    /**
     * Message provides additional context about the role status.
     * Contains error details when Status is "Failed", explaining why the
     * PolicyBinding could not be created.
     *
     * Common failure messages:
     *   - "role 'role-name' not found in namespace 'namespace'"
     *   - "Failed to create PolicyBinding: <error details>"
     *
     * Empty when Status is "Applied" or "Pending".
     */
    message?: InputMaybe<Scalars['String']['input']>;
    /**
     * Name identifies the Role resource.
     *
     * Required field.
     */
    name: Scalars['String']['input'];
    /**
     * Namespace identifies the namespace containing the Role resource.
     * Empty when the role is in the membership's namespace.
     */
    namespace?: InputMaybe<Scalars['String']['input']>;
    policyBindingRef?: InputMaybe<Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_AppliedRoles_Items_PolicyBindingRef_Input>;
    status: Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_AppliedRoles_Items_Status;
  };

/**
 * PolicyBindingRef references the PolicyBinding resource that was
 * automatically created for this role.
 *
 * Only populated when Status is "Applied". Use this reference to
 * inspect or troubleshoot the underlying PolicyBinding.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_AppliedRoles_Items_PolicyBindingRef =
  {
    /** Name of the PolicyBinding resource. */
    name: Scalars['String']['output'];
    /** Namespace of the PolicyBinding resource. */
    namespace?: Maybe<Scalars['String']['output']>;
  };

/**
 * PolicyBindingRef references the PolicyBinding resource that was
 * automatically created for this role.
 *
 * Only populated when Status is "Applied". Use this reference to
 * inspect or troubleshoot the underlying PolicyBinding.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_AppliedRoles_Items_PolicyBindingRef_Input =
  {
    /** Name of the PolicyBinding resource. */
    name: Scalars['String']['input'];
    /** Namespace of the PolicyBinding resource. */
    namespace?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * Status indicates the current state of this role assignment.
 *
 * Valid values:
 *   - "Applied": PolicyBinding successfully created and role is active
 *   - "Pending": Role is being reconciled (transitional state)
 *   - "Failed": PolicyBinding could not be created (see Message for details)
 *
 * Required field.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_AppliedRoles_Items_Status =
  'Applied' | 'Failed' | 'Pending';

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_items_items_status_conditions_items_reason']['output'];
    status: Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_items_items_status_conditions_items_reason']['input'];
    status: Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * Organization contains cached information about the organization in this membership.
 * This information is populated by the controller from the referenced organization.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_Organization =
  {
    /** DisplayName is the display name of the organization in the membership. */
    displayName?: Maybe<Scalars['String']['output']>;
    /** Type is the type of the organization in the membership. */
    type?: Maybe<Scalars['String']['output']>;
  };

/**
 * Organization contains cached information about the organization in this membership.
 * This information is populated by the controller from the referenced organization.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_Organization_Input =
  {
    /** DisplayName is the display name of the organization in the membership. */
    displayName?: InputMaybe<Scalars['String']['input']>;
    /** Type is the type of the organization in the membership. */
    type?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * User contains cached information about the user in this membership.
 * This information is populated by the controller from the referenced user.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_User =
  {
    /** AvatarURL is the avatar URL of the user in the membership. */
    avatarUrl?: Maybe<Scalars['String']['output']>;
    /** Email is the email of the user in the membership. */
    email?: Maybe<Scalars['String']['output']>;
    /** FamilyName is the family name of the user in the membership. */
    familyName?: Maybe<Scalars['String']['output']>;
    /** GivenName is the given name of the user in the membership. */
    givenName?: Maybe<Scalars['String']['output']>;
  };

/**
 * User contains cached information about the user in this membership.
 * This information is populated by the controller from the referenced user.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_User_Input =
  {
    /** AvatarURL is the avatar URL of the user in the membership. */
    avatarUrl?: InputMaybe<Scalars['String']['input']>;
    /** Email is the email of the user in the membership. */
    email?: InputMaybe<Scalars['String']['input']>;
    /** FamilyName is the family name of the user in the membership. */
    familyName?: InputMaybe<Scalars['String']['input']>;
    /** GivenName is the given name of the user in the membership. */
    givenName?: InputMaybe<Scalars['String']['input']>;
  };

/** OrganizationSpec defines the desired state of Organization */
export type Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Spec = {
  type: Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Spec_Type;
};

/** OrganizationSpec defines the desired state of Organization */
export type Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Spec_Input = {
  type: Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Spec_Type;
};

/** The type of organization. */
export type Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Spec_Type =
  | 'Personal'
  | 'Standard';

/** OrganizationStatus defines the observed state of Organization */
export type Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Status = {
  /**
   * Conditions represents the observations of an organization's current state.
   * Known condition types are: "Ready"
   */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Status_Conditions_Items>
    >
  >;
  /** ObservedGeneration is the most recent generation observed for this Organization by the controller. */
  observedGeneration?: Maybe<Scalars['BigInt']['output']>;
};

/** OrganizationStatus defines the observed state of Organization */
export type Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Status_Input = {
  /**
   * Conditions represents the observations of an organization's current state.
   * Known condition types are: "Ready"
   */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Status_Conditions_Items_Input>
    >
  >;
  /** ObservedGeneration is the most recent generation observed for this Organization by the controller. */
  observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listResourcemanagerMiloapisComV1alpha1Organization_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listResourcemanagerMiloapisComV1alpha1Organization_items_items_status_conditions_items_reason']['output'];
    status: Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listResourcemanagerMiloapisComV1alpha1Organization_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listResourcemanagerMiloapisComV1alpha1Organization_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listResourcemanagerMiloapisComV1alpha1Organization_items_items_status_conditions_items_reason']['input'];
    status: Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listResourcemanagerMiloapisComV1alpha1Organization_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListResourcemanagerMiloapisComV1alpha1Organization_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/** ProjectSpec defines the desired state of Project. */
export type Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Spec = {
  ownerRef: Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Spec_OwnerRef;
};

/** ProjectSpec defines the desired state of Project. */
export type Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Spec_Input = {
  ownerRef: Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Spec_OwnerRef_Input;
};

/**
 * OwnerRef is a reference to the owner of the project. Must be a valid
 * resource.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Spec_OwnerRef = {
  kind: Organization_Const;
  /** Name is the name of the resource. */
  name: Scalars['String']['output'];
};

/**
 * OwnerRef is a reference to the owner of the project. Must be a valid
 * resource.
 */
export type Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Spec_OwnerRef_Input = {
  kind: Organization_Const;
  /** Name is the name of the resource. */
  name: Scalars['String']['input'];
};

/** ProjectStatus defines the observed state of Project. */
export type Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Status = {
  /**
   * Represents the observations of a project's current state.
   * Known condition types are: "Ready"
   */
  conditions?: Maybe<
    Array<
      Maybe<Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Status_Conditions_Items>
    >
  >;
};

/** ProjectStatus defines the observed state of Project. */
export type Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Status_Input = {
  /**
   * Represents the observations of a project's current state.
   * Known condition types are: "Ready"
   */
  conditions?: InputMaybe<
    Array<
      InputMaybe<Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Status_Conditions_Items_Input>
    >
  >;
};

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listResourcemanagerMiloapisComV1alpha1Project_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listResourcemanagerMiloapisComV1alpha1Project_items_items_status_conditions_items_reason']['output'];
    status: Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listResourcemanagerMiloapisComV1alpha1Project_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listResourcemanagerMiloapisComV1alpha1Project_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listResourcemanagerMiloapisComV1alpha1Project_items_items_status_conditions_items_reason']['input'];
    status: Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listResourcemanagerMiloapisComV1alpha1Project_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListResourcemanagerMiloapisComV1alpha1Project_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * Describes the expected state of the ExportPolicy's configuration. The
 * control plane will constantly evaluate the current state of exporters that
 * are deployed and ensure it matches the expected configuration. This field
 * is required when configuring an export policy.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec = {
  /**
   * Configures how telemetry data should be sent to a third-party telemetry
   * platforms.
   */
  sinks: Array<
    Maybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items>
  >;
  /**
   * Defines how the export policy should source telemetry data to publish to
   * the configured sinks. An export policy can define multiple telemetry
   * sources. The export policy will **not** de-duplicate telemetry data that
   * matches multiple sources.
   */
  sources: Array<
    Maybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sources_Items>
  >;
};

/**
 * Describes the expected state of the ExportPolicy's configuration. The
 * control plane will constantly evaluate the current state of exporters that
 * are deployed and ensure it matches the expected configuration. This field
 * is required when configuring an export policy.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Input =
  {
    /**
     * Configures how telemetry data should be sent to a third-party telemetry
     * platforms.
     */
    sinks: Array<
      InputMaybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Input>
    >;
    /**
     * Defines how the export policy should source telemetry data to publish to
     * the configured sinks. An export policy can define multiple telemetry
     * sources. The export policy will **not** de-duplicate telemetry data that
     * matches multiple sources.
     */
    sources: Array<
      InputMaybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sources_Items_Input>
    >;
  };

/**
 * Configures how telemetry data should be sent to a third-party platform. As of
 * now there are no guarantees around delivery of telemetry data, especially if
 * the sink's endpoint is unavailable.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items =
  {
    name: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_spec_sinks_items_name']['output'];
    /** A list of sources that should be sent to the telemetry sink. */
    sources: Array<Maybe<Scalars['String']['output']>>;
    target: Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target;
  };

/**
 * Configures how telemetry data should be sent to a third-party platform. As of
 * now there are no guarantees around delivery of telemetry data, especially if
 * the sink's endpoint is unavailable.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Input =
  {
    name: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_spec_sinks_items_name']['input'];
    /** A list of sources that should be sent to the telemetry sink. */
    sources: Array<InputMaybe<Scalars['String']['input']>>;
    target: Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_Input;
  };

/** Configures the target of the telemetry sink. */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target =
  {
    prometheusRemoteWrite?: Maybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite>;
  };

/** Configures the target of the telemetry sink. */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_Input =
  {
    prometheusRemoteWrite?: InputMaybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Input>;
  };

/**
 * Configures the export policy to publish telemetry using the Prometheus
 * Remote Write protocol.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite =
  {
    authentication?: Maybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Authentication>;
    batch: Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Batch;
    /** Configure an HTTP endpoint to use for publishing telemetry data. */
    endpoint: Scalars['String']['output'];
    retry: Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Retry;
  };

/**
 * Configures the export policy to publish telemetry using the Prometheus
 * Remote Write protocol.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Input =
  {
    authentication?: InputMaybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Authentication_Input>;
    batch?: Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Batch_Input;
    /** Configure an HTTP endpoint to use for publishing telemetry data. */
    endpoint: Scalars['String']['input'];
    retry?: Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Retry_Input;
  };

/** Configures how the sink should authenticate with the HTTP endpoint. */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Authentication =
  {
    basicAuth?: Maybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Authentication_BasicAuth>;
  };

/** Configures how the sink should authenticate with the HTTP endpoint. */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Authentication_Input =
  {
    basicAuth?: InputMaybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Authentication_BasicAuth_Input>;
  };

/**
 * Configures the sink to use basic auth to authenticate with the configured
 * endpoint.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Authentication_BasicAuth =
  {
    secretRef: Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Authentication_BasicAuth_SecretRef;
  };

/**
 * Configures the sink to use basic auth to authenticate with the configured
 * endpoint.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Authentication_BasicAuth_Input =
  {
    secretRef: Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Authentication_BasicAuth_SecretRef_Input;
  };

/**
 * Configures which secret is used to retrieve the bearer token to add to the
 * authorization header. Secret must be a `kubernetes.io/basic-auth` type.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Authentication_BasicAuth_SecretRef =
  {
    /** The name of the secret */
    name: Scalars['String']['output'];
  };

/**
 * Configures which secret is used to retrieve the bearer token to add to the
 * authorization header. Secret must be a `kubernetes.io/basic-auth` type.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Authentication_BasicAuth_SecretRef_Input =
  {
    /** The name of the secret */
    name: Scalars['String']['input'];
  };

/**
 * Configures how telemetry data should be batched before sending to the sink.
 * By default, the sink will batch telemetry data every 5 seconds or when
 * the batch size reaches 500 entries, whichever comes first.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Batch =
  {
    /** Maximum number of telemetry entries per batch. */
    maxSize: Scalars['PositiveInt']['output'];
    /** Batch timeout before sending telemetry. Must be a duration (e.g. 5s). */
    timeout: Scalars['String']['output'];
  };

/**
 * Configures how telemetry data should be batched before sending to the sink.
 * By default, the sink will batch telemetry data every 5 seconds or when
 * the batch size reaches 500 entries, whichever comes first.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Batch_Input =
  {
    /** Maximum number of telemetry entries per batch. */
    maxSize: Scalars['PositiveInt']['input'];
    /** Batch timeout before sending telemetry. Must be a duration (e.g. 5s). */
    timeout: Scalars['String']['input'];
  };

/**
 * Configures the export policies' retry behavior when it fails to send
 * requests to the sink's endpoint. There's no guarantees that the export
 * policy will retry until success if the endpoint is not available or
 * configured incorrectly.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Retry =
  {
    /** Backoff duration that should be used to backoff when retrying requests. */
    backoffDuration: Scalars['String']['output'];
    /** Maximum number of attempts before telemetry data should be dropped. */
    maxAttempts: Scalars['PositiveInt']['output'];
  };

/**
 * Configures the export policies' retry behavior when it fails to send
 * requests to the sink's endpoint. There's no guarantees that the export
 * policy will retry until success if the endpoint is not available or
 * configured incorrectly.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sinks_Items_Target_PrometheusRemoteWrite_Retry_Input =
  {
    /** Backoff duration that should be used to backoff when retrying requests. */
    backoffDuration: Scalars['String']['input'];
    /** Maximum number of attempts before telemetry data should be dropped. */
    maxAttempts: Scalars['PositiveInt']['input'];
  };

/**
 * Defines how the export policy should source telemetry data from resources on
 * the platform.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sources_Items =
  {
    metrics?: Maybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sources_Items_Metrics>;
    name: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_spec_sources_items_name']['output'];
  };

/**
 * Defines how the export policy should source telemetry data from resources on
 * the platform.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sources_Items_Input =
  {
    metrics?: InputMaybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sources_Items_Metrics_Input>;
    name: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_spec_sources_items_name']['input'];
  };

/**
 * Configures how the telemetry source should retrieve metric data from the
 * Datum Cloud platform.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sources_Items_Metrics =
  {
    /**
     * The MetricSQL option allows to user to provide a metricsql query that can
     * be used to select and filter metric data that should be published by the
     * export policy.
     *
     * Here's an example of a metricsql query that will publish gateway metrics:
     *
     * ``` {service_name=networking.miloapis.com, resource_kind="Gateway"} ```
     *
     * See: https://docs.victoriametrics.com/metricsql/
     */
    metricsql?: Maybe<Scalars['String']['output']>;
  };

/**
 * Configures how the telemetry source should retrieve metric data from the
 * Datum Cloud platform.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Spec_Sources_Items_Metrics_Input =
  {
    /**
     * The MetricSQL option allows to user to provide a metricsql query that can
     * be used to select and filter metric data that should be published by the
     * export policy.
     *
     * Here's an example of a metricsql query that will publish gateway metrics:
     *
     * ``` {service_name=networking.miloapis.com, resource_kind="Gateway"} ```
     *
     * See: https://docs.victoriametrics.com/metricsql/
     */
    metricsql?: InputMaybe<Scalars['String']['input']>;
  };

/**
 * Provides information on the current state of the export policy that was
 * observed by the control plane. This will be continuously updated as the
 * control plane monitors exporters.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status =
  {
    /**
     * Provides summary status information on the export policy as a whole. Review
     * the sink status information for detailed information on each sink.
     *
     * Known condition types are: "Ready"
     */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Conditions_Items>
      >
    >;
    /** Provides status information on each sink that's configured. */
    sinks?: Maybe<
      Array<
        Maybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Sinks_Items>
      >
    >;
  };

/**
 * Provides information on the current state of the export policy that was
 * observed by the control plane. This will be continuously updated as the
 * control plane monitors exporters.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Input =
  {
    /**
     * Provides summary status information on the export policy as a whole. Review
     * the sink status information for detailed information on each sink.
     *
     * Known condition types are: "Ready"
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Conditions_Items_Input>
      >
    >;
    /** Provides status information on each sink that's configured. */
    sinks?: InputMaybe<
      Array<
        InputMaybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Sinks_Items_Input>
      >
    >;
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_conditions_items_reason']['output'];
    status: Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_conditions_items_reason']['input'];
    status: Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Conditions_Items_Status;
    type: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

/**
 * SinkStatus provides status information on the current status of a sink. This
 * can be used to determine whether a sink is configured correctly and is
 * exporting telemetry data.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Sinks_Items =
  {
    /**
     * Provides status information on the current status of the sink. This can be
     * used to determine whether a sink is configured correctly and is exporting
     * telemetry data.
     *
     * Known condition types are: "Ready"
     */
    conditions?: Maybe<
      Array<
        Maybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Sinks_Items_Conditions_Items>
      >
    >;
    /**
     * The name of the corresponding sink configuration in the spec of the export
     * policy.
     */
    name: Scalars['String']['output'];
  };

/**
 * SinkStatus provides status information on the current status of a sink. This
 * can be used to determine whether a sink is configured correctly and is
 * exporting telemetry data.
 */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Sinks_Items_Input =
  {
    /**
     * Provides status information on the current status of the sink. This can be
     * used to determine whether a sink is configured correctly and is exporting
     * telemetry data.
     *
     * Known condition types are: "Ready"
     */
    conditions?: InputMaybe<
      Array<
        InputMaybe<Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Sinks_Items_Conditions_Items_Input>
      >
    >;
    /**
     * The name of the corresponding sink configuration in the spec of the export
     * policy.
     */
    name: Scalars['String']['input'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Sinks_Items_Conditions_Items =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['output'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_sinks_items_conditions_items_message']['output'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: Maybe<Scalars['BigInt']['output']>;
    reason: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_sinks_items_conditions_items_reason']['output'];
    status: Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Sinks_Items_Conditions_Items_Status;
    type: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_sinks_items_conditions_items_type']['output'];
  };

/** Condition contains details for one aspect of the current state of this API Resource. */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Sinks_Items_Conditions_Items_Input =
  {
    /**
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     */
    lastTransitionTime: Scalars['DateTime']['input'];
    /**
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     */
    message: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_sinks_items_conditions_items_message']['input'];
    /**
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     */
    observedGeneration?: InputMaybe<Scalars['BigInt']['input']>;
    reason: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_sinks_items_conditions_items_reason']['input'];
    status: Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Sinks_Items_Conditions_Items_Status;
    type: Scalars['query_listTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_items_items_status_sinks_items_conditions_items_type']['input'];
  };

/** status of the condition, one of True, False, Unknown. */
export type Query_ListTelemetryMiloapisComV1alpha1ExportPolicyForAllNamespaces_Items_Items_Status_Sinks_Items_Conditions_Items_Status =
  'False' | 'True' | 'Unknown';

export type Resourcemanager_Miloapis_Com_Const = 'resourcemanager_miloapis_com';

export type ListOrganizationMembershipsQueryVariables = Exact<{ [key: string]: never }>;

export type ListOrganizationMembershipsQuery = {
  listResourcemanagerMiloapisComV1alpha1OrganizationMembershipForAllNamespaces?: {
    items: Array<{
      spec?: {
        organizationRef: { name: string };
        roles?: Array<{ name: string; namespace?: string | null } | null> | null;
        userRef: { name: string };
      } | null;
      metadata?: {
        annotations?: Record<string, any> | null;
        uid?: string | null;
        name?: string | null;
        namespace?: string | null;
        labels?: Record<string, any> | null;
        creationTimestamp?: string | null;
      } | null;
      status?: {
        organization?: { displayName?: string | null; type?: string | null } | null;
        conditions?: Array<{
          reason: any;
          status: Query_ListResourcemanagerMiloapisComV1alpha1NamespacedOrganizationMembership_Items_Items_Status_Conditions_Items_Status;
          type: any;
        } | null> | null;
      } | null;
    } | null>;
    metadata?: { continue?: string | null; remainingItemCount?: any | null } | null;
  } | null;
};

export class TypedDocumentString<TResult, TVariables>
  extends String
  implements DocumentTypeDecoration<TResult, TVariables>
{
  __apiType?: NonNullable<DocumentTypeDecoration<TResult, TVariables>['__apiType']>;
  private value: string;
  public __meta__?: Record<string, any> | undefined;

  constructor(value: string, __meta__?: Record<string, any> | undefined) {
    super(value);
    this.value = value;
    this.__meta__ = __meta__;
  }

  override toString(): string & DocumentTypeDecoration<TResult, TVariables> {
    return this.value;
  }
}

export const ListOrganizationMembershipsDocument = new TypedDocumentString(`
    query ListOrganizationMemberships {
  listResourcemanagerMiloapisComV1alpha1OrganizationMembershipForAllNamespaces {
    items {
      spec {
        organizationRef {
          name
        }
        roles {
          name
          namespace
        }
        userRef {
          name
        }
      }
      metadata {
        annotations
        uid
        name
        namespace
        labels
        creationTimestamp
      }
      status {
        organization {
          displayName
          type
        }
        conditions {
          reason
          status
          type
        }
      }
    }
    metadata {
      continue
      remainingItemCount
    }
  }
}
    `) as unknown as TypedDocumentString<
  ListOrganizationMembershipsQuery,
  ListOrganizationMembershipsQueryVariables
>;
