// This file is auto-generated by @hey-api/openapi-ts

export const com_miloapis_quota_v1alpha1_AllowanceBucketSchema = {
  description: `**AllowanceBucket** aggregates quota limits and usage for a single (consumer, resourceType) combination.
The system automatically creates buckets to provide real-time quota availability information
for **ResourceClaim** evaluation during admission.

### How It Works
1. **Auto-Creation**: Quota system creates buckets automatically for each unique (consumer, resourceType) pair found in active **ResourceGrants**
2. **Aggregation**: Quota system continuously aggregates capacity from active **ResourceGrants** and consumption from granted **ResourceClaims**
3. **Decision Support**: Quota system uses bucket \`status.available\` to determine if **ResourceClaims** can be granted
4. **Updates**: Quota system updates bucket status whenever contributing grants or claims change

### Aggregation Logic
**AllowanceBuckets** serve as the central aggregation point where quota capacity meets quota consumption.
The quota system continuously scans for **ResourceGrants** that match both the bucket's consumer
and resource type, but only considers grants with an \`Active\` status condition. For each qualifying
grant, the quota system examines all allowances targeting the bucket's resource type and sums the
amounts from every bucket within those allowances. This sum becomes the bucket's limit - the total
quota capacity available to the consumer for that specific resource type.

Simultaneously, the quota system tracks quota consumption by finding all **ResourceClaims** with matching
consumer and resource type specifications. However, only claims that have been successfully granted
contribute to the allocated total. The quota system sums the allocated amounts from all granted
requests, creating a running total of consumed quota capacity.

The available quota emerges from this simple relationship: Available = Limit - Allocated. The
system ensures this value never goes negative, treating any calculated negative as zero. This
available amount represents the quota capacity remaining for new **ResourceClaims** and drives
real-time admission decisions throughout the cluster.

### Real-Time Admission Decisions
When a **ResourceClaim** is created:
1. Quota system identifies the relevant bucket (matching consumer and resource type)
2. Compares requested amount with bucket's \`status.available\`
3. Grants claim if requested amount <= available capacity
4. Denies claim if requested amount > available capacity
5. Updates bucket status to reflect the new allocation (if granted)

### Bucket Lifecycle
1. **Auto-Created**: When first ResourceGrant creates allowance for (consumer, resourceType)
2. **Active**: Continuously aggregated while ResourceGrants or ResourceClaims exist
3. **Updated**: Status refreshed whenever contributing resources change
4. **Persistent**: Buckets remain even when limit drops to 0 (for monitoring)

### Consistency and Performance
**Eventual Consistency:**
- Status may lag briefly after ResourceGrant or ResourceClaim changes
- Controller processes updates asynchronously for performance
- LastReconciliation timestamp indicates data freshness

**Scale Optimization:**
- Stores aggregates (limit, allocated, available) rather than individual entries
- ContributingGrantRefs tracks grants (few) but not claims (many)
- Single bucket per (consumer, resourceType) regardless of claim count

### Status Information
- **Limit**: Total quota capacity from all contributing ResourceGrants
- **Allocated**: Total quota consumed by all granted ResourceClaims
- **Available**: Remaining quota capacity (Limit - Allocated)
- **ClaimCount**: Number of granted claims consuming from this bucket
- **GrantCount**: Number of active grants contributing to this bucket
- **ContributingGrantRefs**: Detailed information about contributing grants

### Monitoring and Troubleshooting
**Quota Monitoring:**
- Monitor status.available to track quota usage trends
- Check status.allocated vs status.limit for utilization ratios
- Use status.claimCount to understand resource creation patterns

**Troubleshooting Issues:**
When investigating quota problems, start with the bucket's limit value. A limit of zero typically
indicates that no ResourceGrants are contributing capacity for this consumer and resource type
combination. Verify that ResourceGrants exist with matching consumer and resource type specifications,
and confirm their status conditions show Active=True. Grants with validation failures or pending
states won't contribute to bucket limits.

High allocation values relative to limits suggest quota consumption issues. Review the ResourceClaims
that match this bucket's consumer and resource type to identify which resources are consuming large
amounts of quota. Check the claim allocation details to understand consumption patterns and identify
potential quota leaks where claims aren't being cleaned up properly.

Stale bucket data manifests as allocation or limit values that don't reflect recent changes to
grants or claims. Check the lastReconciliation timestamp to determine data freshness, then examine
quota system logs for aggregation errors or performance issues. The quota system should process
changes within seconds under normal conditions.

### System Architecture
- **Single Writer**: Only the quota system updates bucket status (prevents races)
- **Dedicated Processing**: Separate components focus solely on bucket aggregation
- **Event-Driven**: Responds to ResourceGrant and ResourceClaim changes
- **Efficient Queries**: Uses indexes and field selectors for fast aggregation

### Selectors and Filtering
- **Field selectors**: spec.consumerRef.kind, spec.consumerRef.name, spec.resourceType
- **System labels** (set automatically by quota system):
  - quota.miloapis.com/consumer-kind: Organization
  - quota.miloapis.com/consumer-name: acme-corp

### Common Queries
- All buckets for a consumer: label selector quota.miloapis.com/consumer-kind + quota.miloapis.com/consumer-name
- All buckets for a resource type: field selector spec.resourceType=<value>
- Specific bucket: field selector spec.consumerRef.name + spec.resourceType
- Overutilized buckets: filter by status.available < threshold
- Empty buckets: filter by status.limit = 0

### Performance Considerations
- Bucket status updates are asynchronous and may lag resource changes
- Large numbers of ResourceClaims can impact aggregation performance
- Controller uses efficient aggregation queries to handle scale
- Status updates are batched to reduce API server load`,
  type: 'object',
  required: ['spec'],
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
      type: 'string',
    },
    kind: {
      description:
        'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    metadata: {
      description:
        "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta',
        },
      ],
    },
    spec: {
      description: `AllowanceBucketSpec defines the desired state of AllowanceBucket.
The system automatically creates buckets for each unique (consumer, resourceType) combination
found in active ResourceGrants.`,
      type: 'object',
      required: ['consumerRef', 'resourceType'],
      properties: {
        consumerRef: {
          description: `ConsumerRef identifies the quota consumer tracked by this bucket.
Must match the ConsumerRef from ResourceGrants that contribute to this bucket.
Only one bucket exists per unique (ConsumerRef, ResourceType) combination.

Examples:
- Organization "acme-corp" consuming Project quota
- Project "web-app" consuming User quota
- Organization "enterprise-corp" consuming storage quota`,
          type: 'object',
          required: ['kind', 'name'],
          properties: {
            apiGroup: {
              description: `APIGroup specifies the API group of the consumer resource.
Use full group name for Milo resources.

Examples:
- "resourcemanager.miloapis.com" (Organization/Project resources)
- "iam.miloapis.com" (User/Group resources)
- "infrastructure.miloapis.com" (infrastructure resources)`,
              type: 'string',
            },
            kind: {
              description: `Kind specifies the type of consumer resource.
Must match an existing Kubernetes resource type that can receive quota grants.

Common consumer types:
- "Organization" (top-level quota consumer)
- "Project" (project-level quota consumer)
- "User" (user-level quota consumer)`,
              type: 'string',
            },
            name: {
              description: `Name identifies the specific consumer resource instance.
Must match the name of an existing consumer resource in the cluster.

Examples:
- "acme-corp" (Organization name)
- "web-application" (Project name)
- "john.doe" (User name)`,
              type: 'string',
            },
            namespace: {
              description: `Namespace identifies the namespace of the consumer resource.
Required for namespaced consumer resources (e.g., Projects).
Leave empty for cluster-scoped consumer resources (e.g., Organizations).

Examples:
- "" (empty for cluster-scoped Organizations)
- "organization-acme-corp" (namespace for Projects within an organization)
- "project-web-app" (namespace for resources within a project)`,
              type: 'string',
            },
          },
        },
        resourceType: {
          description: `ResourceType specifies which resource type this bucket aggregates quota for.
Must exactly match a ResourceRegistration.spec.resourceType that is currently active.
The quota system validates this reference and only creates buckets for registered types.

The identifier format is flexible, as defined by platform administrators
in their ResourceRegistrations.

Examples:
- "resourcemanager.miloapis.com/projects"
- "compute_cpu"
- "storage.volumes"
- "custom-service-quota"`,
          type: 'string',
          maxLength: 253,
          minLength: 1,
        },
      },
    },
    status: {
      description: `AllowanceBucketStatus contains the quota system-computed quota aggregation for a specific
(consumer, resourceType) combination. The quota system continuously updates this status
by aggregating capacity from active ResourceGrants and consumption from granted ResourceClaims.`,
      type: 'object',
      required: ['allocated', 'available', 'claimCount', 'grantCount', 'limit'],
      properties: {
        allocated: {
          description: `Allocated represents the total quota currently consumed by granted ResourceClaims.
Calculated by summing all allocation amounts from ResourceClaims with status.conditions[type=Granted]=True
that match the bucket's spec.consumerRef and have requests for spec.resourceType.

Aggregation logic:
- Only ResourceClaims with Granted=True contribute to allocated amount
- Only requests matching spec.resourceType are included
- All allocated amounts from matching requests are summed`,
          type: 'integer',
          format: 'int64',
          minimum: 0,
        },
        available: {
          description: `Available represents the quota capacity remaining for new ResourceClaims.
Always calculated as: Available = Limit - Allocated (never negative).
The system uses this value to determine whether new ResourceClaims can be granted.

Decision logic:
- ResourceClaim is granted if requested amount <= Available
- ResourceClaim is denied if requested amount > Available
- Multiple concurrent claims may race; first to be processed wins`,
          type: 'integer',
          format: 'int64',
          minimum: 0,
        },
        claimCount: {
          description: `ClaimCount indicates the total number of granted ResourceClaims consuming quota from this bucket.
Includes all ResourceClaims with status.conditions[type=Granted]=True that have requests
matching spec.resourceType and spec.consumerRef.

Used for monitoring quota usage patterns and identifying potential issues.`,
          type: 'integer',
          format: 'int32',
          minimum: 0,
        },
        contributingGrantRefs: {
          description: `ContributingGrantRefs provides detailed information about each ResourceGrant that contributes
to this bucket's limit. Includes grant names, amounts, and last observed generations for
tracking and debugging quota sources.

This field provides visibility into:
- Which grants are providing quota capacity
- How much each grant contributes
- Whether grants have been updated since last bucket calculation

Grants are tracked individually because they are typically few in number compared to claims.`,
          type: 'array',
          items: {
            description: `ContributingGrantRef tracks a ResourceGrant that contributes capacity to this bucket.
The quota system maintains these references to provide visibility into quota sources
and to detect when grants change.`,
            type: 'object',
            required: ['amount', 'lastObservedGeneration', 'name'],
            properties: {
              amount: {
                description: `Amount specifies how much quota capacity this grant contributes to the bucket.
Represents the sum of all buckets within all allowances for the matching
resource type in the referenced grant. Measured in BaseUnit.`,
                type: 'integer',
                format: 'int64',
                minimum: 0,
              },
              lastObservedGeneration: {
                description: `LastObservedGeneration records the ResourceGrant's generation when the bucket
quota system last processed it. Used to detect when grants have been updated
and the bucket needs to recalculate its aggregated limit.`,
                type: 'integer',
                format: 'int64',
              },
              name: {
                description: `Name identifies the ResourceGrant that contributes to this bucket's limit.
Used for tracking quota sources and debugging allocation issues.`,
                type: 'string',
              },
            },
          },
        },
        grantCount: {
          description: `GrantCount indicates the total number of active ResourceGrants contributing to this bucket's limit.
Includes all ResourceGrants with status.conditions[type=Active]=True that have allowances
matching spec.resourceType and spec.consumerRef.

Used for understanding quota source distribution and debugging capacity issues.`,
          type: 'integer',
          format: 'int32',
          minimum: 0,
        },
        lastReconciliation: {
          description: `LastReconciliation records when the quota system last recalculated this status.
Used for monitoring quota system health and understanding how fresh the aggregated data is.

The quota system updates this timestamp every time it processes the bucket, regardless of
whether the aggregated values changed.`,
          type: 'string',
          format: 'date-time',
        },
        limit: {
          description: `Limit represents the total quota capacity available for this (consumer, resourceType) combination.
Calculated by summing all bucket amounts from active ResourceGrants that match the bucket's
spec.consumerRef and spec.resourceType. Measured in BaseUnit from the ResourceRegistration.

Aggregation logic:
- Only ResourceGrants with status.conditions[type=Active]=True contribute to the limit
- All allowances matching spec.resourceType are included from contributing grants
- All bucket amounts within matching allowances are summed`,
          type: 'integer',
          format: 'int64',
          minimum: 0,
        },
        observedGeneration: {
          description: `ObservedGeneration indicates the most recent spec generation the quota system has processed.
When ObservedGeneration matches metadata.generation, the status reflects the current spec.
When ObservedGeneration is lower, the quota system is still processing recent changes.`,
          type: 'integer',
          format: 'int64',
        },
      },
    },
  },
  'x-kubernetes-group-version-kind': [
    {
      group: 'quota.miloapis.com',
      kind: 'AllowanceBucket',
      version: 'v1alpha1',
    },
  ],
  'x-kubernetes-selectable-fields': [
    {
      fieldPath: 'spec.consumerRef.kind',
    },
    {
      fieldPath: 'spec.consumerRef.name',
    },
    {
      fieldPath: 'spec.resourceType',
    },
  ],
} as const;

export const com_miloapis_quota_v1alpha1_AllowanceBucketListSchema = {
  description: 'AllowanceBucketList is a list of AllowanceBucket',
  type: 'object',
  required: ['items'],
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
      type: 'string',
    },
    items: {
      description:
        'List of allowancebuckets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md',
      type: 'array',
      items: {
        $ref: '#/components/schemas/com.miloapis.quota.v1alpha1.AllowanceBucket',
      },
    },
    kind: {
      description:
        'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    metadata: {
      description:
        'Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta',
        },
      ],
    },
  },
  'x-kubernetes-group-version-kind': [
    {
      group: 'quota.miloapis.com',
      kind: 'AllowanceBucketList',
      version: 'v1alpha1',
    },
  ],
  'x-kubernetes-selectable-fields': [
    {
      fieldPath: 'spec.consumerRef.kind',
    },
    {
      fieldPath: 'spec.consumerRef.name',
    },
    {
      fieldPath: 'spec.resourceType',
    },
  ],
} as const;

export const com_miloapis_quota_v1alpha1_ClaimCreationPolicySchema = {
  description: `ClaimCreationPolicy automatically creates ResourceClaims during admission to enforce quota in real-time.
Policies intercept resource creation requests, evaluate trigger conditions, and generate
quota claims that prevent resource creation when quota limits are exceeded.

### How It Works
1. **Trigger Matching**: Admission webhook matches incoming resource creates against spec.trigger.resource
2. **Condition Evaluation**: All CEL expressions in spec.trigger.conditions must evaluate to true
3. **Template Rendering**: Policy renders spec.target.resourceClaimTemplate using available template variables
4. **Claim Creation**: System creates the rendered ResourceClaim in the specified namespace
5. **Quota Evaluation**: Claim is immediately evaluated against AllowanceBucket capacity
6. **Admission Decision**: Original resource creation succeeds or fails based on claim result

### Policy Processing Flow
**Enabled Policies** (spec.enabled=true):
1. Admission webhook receives resource creation request
2. Finds all ClaimCreationPolicies matching the resource type
3. Evaluates trigger conditions for each matching policy
4. Creates ResourceClaim for each policy where all conditions are true
5. Evaluates all created claims against quota buckets
6. Allows resource creation only if all claims are granted

**Disabled Policies** (spec.enabled=false):
- Completely ignored during admission processing
- No conditions evaluated, no claims created
- Useful for temporarily disabling quota enforcement

### Template System
The template system transforms static ResourceClaim specifications into dynamic claims that reflect
the context of each admission request. When a policy triggers, the template engine receives rich
contextual information about the resource being created, the user making the request, and details
about the admission operation itself.

The most important template variable is \`.trigger\`, which contains the complete structure of the
resource that triggered the policy. This includes all metadata like labels and annotations, the
entire spec section, and any status information if the resource already exists. You can navigate
this structure using standard template dot notation: \`.trigger.metadata.name\` gives you the
resource's name, while \`.trigger.spec.replicas\` might tell you how many instances are requested.

Authentication context comes through the \`.user\` variable, providing access to the requester's
name, unique identifier, group memberships, and any additional attributes. This enables policies
to create claims that track who requested resources and potentially apply different quota rules
based on user attributes. The \`.requestInfo\` variable adds operational context like the specific
API verb being performed and which resource type is being manipulated.

Template functions help transform and manipulate these values. The \`default\` function proves
particularly useful for providing fallback values when template variables might be empty.
String manipulation functions like \`lower\`, \`upper\`, and \`trim\` help normalize names and values,
while \`replace\` enables pattern substitution for complex naming schemes. For example, you might
use \`{{default "milo-system" .trigger.metadata.namespace}}\` to place claims in a system namespace
when the triggering resource doesn't specify one.

### CEL Expression System
CEL expressions act as the gatekeepers that determine whether a policy should create a quota claim
for a particular resource. These expressions have access to the same rich contextual information
as templates but focus on making boolean decisions rather than generating content. Each expression
must evaluate to either true (activate the policy) or false (skip this resource), and all expressions
in a policy's condition list must return true for the policy to trigger.

The expression environment includes the triggering resource under the \`trigger\` variable, letting
you examine any field in the resource's structure. This enables sophisticated filtering based on
resource specifications, labels, annotations, or even status conditions. You might write
\`trigger.spec.tier == "premium"\` to only apply quota policies to premium resources, or use
\`trigger.metadata.labels["environment"] == "prod"\` to restrict enforcement to production workloads.

User context through the \`user\` variable enables authorization-based policies. The expression
\`user.groups.exists(g, g == "admin")\` would limit quota enforcement to resources created by
administrators, while \`user.name.startsWith("service-")\` might target service accounts.
Combined with resource filtering, you can create nuanced policies that apply different quota
rules based on who is creating what types of resources in which contexts.

### Consumer Resolution
The system automatically resolves spec.consumerRef for created claims:
- Uses parent context resolution to find the appropriate consumer
- Typically resolves to Organization for Project resources, Project for User resources, etc.
- Consumer must match the ResourceRegistration.spec.consumerTypeRef for the requested resource type

### Validation and Dependencies
**Policy Validation:**
- Target resource type must exist and be accessible
- All resource types in claim template must have active ResourceRegistrations
- Consumer resolution must be resolvable for target resources
- CEL expressions and Go templates must be syntactically valid

**Runtime Dependencies:**
- ResourceRegistration must be Active for each requested resource type
- Triggering resource kind must be listed in ResourceRegistration.spec.claimingResources
- AllowanceBucket must exist (created automatically when ResourceGrants are active)

### Policy Lifecycle
1. **Creation**: Administrator creates ClaimCreationPolicy
2. **Validation**: Controller validates target resource, expressions, and templates
3. **Activation**: Controller sets Ready=True when validation passes
4. **Operation**: Admission webhook uses active policies to create claims
5. **Updates**: Changes trigger re-validation; only Ready policies are used

### Status Conditions
- **Ready=True**: Policy is validated and actively creating claims
- **Ready=False, reason=ValidationFailed**: Configuration errors prevent activation (check message)
- **Ready=False, reason=PolicyDisabled**: Policy is disabled (spec.enabled=false)

### Automatic Claim Features
Claims created by ClaimCreationPolicy include:
- **Standard Labels**: quota.miloapis.com/auto-created=true, quota.miloapis.com/policy=<policy-name>
- **Standard Annotations**: quota.miloapis.com/created-by=claim-creation-plugin, timestamps
- **Owner References**: Set to triggering resource when possible for lifecycle management
- **Cleanup**: Automatically cleaned up when denied to prevent accumulation

### Field Constraints and Limits
- Maximum 10 conditions per trigger (spec.trigger.conditions)
- Static amounts only in v1alpha1 (no expression-based quota amounts)
- Template metadata labels are literal strings (no template processing)
- Template annotation values support templating

### Selectors and Filtering
- **Field selectors**: spec.trigger.resource.kind, spec.trigger.resource.apiVersion, spec.enabled
- **Recommended labels** (add manually):
  - quota.miloapis.com/target-kind: Project
  - quota.miloapis.com/environment: production
  - quota.miloapis.com/tier: premium

### Common Queries
- All policies for a resource kind: label selector quota.miloapis.com/target-kind=<kind>
- Enabled policies only: field selector spec.enabled=true
- Environment-specific policies: label selector quota.miloapis.com/environment=<env>
- Failed policies: filter by status.conditions[type=Ready].status=False

### Troubleshooting
- **Policy not triggering**: Check spec.enabled=true and status.conditions[type=Ready]=True
- **Template errors**: Review status condition message for template syntax issues
- **CEL expression failures**: Validate expression syntax and available variables
- **Claims not created**: Verify trigger conditions match the incoming resource
- **Consumer resolution errors**: Check parent context resolution and ResourceRegistration setup

### Performance Considerations
- Policies are evaluated synchronously during admission (affects API latency)
- Complex CEL expressions can impact admission performance
- Template rendering occurs for every matching admission request
- Consider using specific trigger conditions to limit policy evaluation scope

### Security Considerations
- Templates can access complete trigger resource data (sensitive field exposure)
- CEL expressions have access to user information and request details
- Only trusted administrators should create or modify policies
- Review template output to ensure no sensitive data leakage in claim metadata`,
  type: 'object',
  required: ['spec'],
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
      type: 'string',
    },
    kind: {
      description:
        'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    metadata: {
      description:
        "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta',
        },
      ],
    },
    spec: {
      description: 'ClaimCreationPolicySpec defines the desired state of ClaimCreationPolicy.',
      type: 'object',
      required: ['target', 'trigger'],
      properties: {
        enabled: {
          description: `Enabled determines if this policy is active.
If false, no **ResourceClaims** will be created for matching resources.`,
          type: 'boolean',
          default: true,
        },
        target: {
          description: 'Target defines how and where **ResourceClaims** should be created.',
          type: 'object',
          required: ['resourceClaimTemplate'],
          properties: {
            resourceClaimTemplate: {
              description: `ResourceClaimTemplate defines how to create **ResourceClaims**.
String fields support Go template syntax for dynamic content.`,
              type: 'object',
              required: ['metadata', 'spec'],
              properties: {
                metadata: {
                  description: `Metadata for the created **ResourceClaim**.
String fields support Go template syntax.`,
                  type: 'object',
                  properties: {
                    annotations: {
                      description: `Annotations specifies annotations to apply to the created ResourceClaim.
Values support Go template syntax for dynamic content.
The system automatically adds standard annotations for tracking.

Template variables available:
- .trigger: The resource triggering claim creation
- .requestInfo: Request details
- .user: User information

Examples:
- created-for: "{{.trigger.metadata.name}}"
- requested-by: "{{.user.name}}"
- trigger-kind: "{{.trigger.kind}}"`,
                      type: 'object',
                      additionalProperties: {
                        type: 'string',
                      },
                    },
                    generateName: {
                      description: `GenerateName specifies a prefix for auto-generated names when Name is empty.
Kubernetes appends random characters to create unique names.
Supports Go template syntax.

Example: "{{.trigger.spec.type}}-claim-"`,
                      type: 'string',
                    },
                    labels: {
                      description: `Labels specifies static labels to apply to the created ResourceClaim.
Values are literal strings (no template processing).
The system automatically adds standard labels for policy tracking.

Useful for:
- Organizing claims by policy or resource type
- Adding environment or tier indicators
- Enabling label-based queries and monitoring`,
                      type: 'object',
                      additionalProperties: {
                        type: 'string',
                      },
                    },
                    name: {
                      description: `Name specifies the exact name for the created ResourceClaim.
Supports Go template syntax with access to template variables.
Leave empty to use GenerateName for auto-generated names.

Template variables available:
- .trigger: The resource triggering claim creation
- .requestInfo: Request details (verb, resource, name, etc.)
- .user: User information (name, uid, groups, extra)

Example: "{{.trigger.metadata.name}}-quota-claim"`,
                      type: 'string',
                    },
                    namespace: {
                      description: `Namespace specifies where the ResourceClaim will be created.
Supports Go template syntax to derive namespace from trigger resource.
Leave empty to create in the same namespace as the trigger resource.

Examples:
- "{{.trigger.metadata.namespace}}" (same namespace as trigger)
- "milo-system" (fixed system namespace)
- "{{.trigger.spec.organization}}-claims" (derived namespace)`,
                      type: 'string',
                    },
                  },
                },
                spec: {
                  description: `Spec for the created ResourceClaim.
String fields support Go template syntax.`,
                  type: 'object',
                  required: ['consumerRef', 'requests', 'resourceRef'],
                  properties: {
                    consumerRef: {
                      description: `ConsumerRef identifies the quota consumer making this claim. The consumer
must match the ConsumerTypeRef defined in the ResourceRegistration for each
requested resource type. The system validates this relationship during
claim processing.

Examples:

  - Organization consuming Project quota
  - Project consuming User quota
  - Organization consuming storage quota`,
                      type: 'object',
                      required: ['kind', 'name'],
                      properties: {
                        apiGroup: {
                          description: `APIGroup specifies the API group of the consumer resource.
Use full group name for Milo resources.

Examples:
- "resourcemanager.miloapis.com" (Organization/Project resources)
- "iam.miloapis.com" (User/Group resources)
- "infrastructure.miloapis.com" (infrastructure resources)`,
                          type: 'string',
                        },
                        kind: {
                          description: `Kind specifies the type of consumer resource.
Must match an existing Kubernetes resource type that can receive quota grants.

Common consumer types:
- "Organization" (top-level quota consumer)
- "Project" (project-level quota consumer)
- "User" (user-level quota consumer)`,
                          type: 'string',
                        },
                        name: {
                          description: `Name identifies the specific consumer resource instance.
Must match the name of an existing consumer resource in the cluster.

Examples:
- "acme-corp" (Organization name)
- "web-application" (Project name)
- "john.doe" (User name)`,
                          type: 'string',
                        },
                        namespace: {
                          description: `Namespace identifies the namespace of the consumer resource.
Required for namespaced consumer resources (e.g., Projects).
Leave empty for cluster-scoped consumer resources (e.g., Organizations).

Examples:
- "" (empty for cluster-scoped Organizations)
- "organization-acme-corp" (namespace for Projects within an organization)
- "project-web-app" (namespace for resources within a project)`,
                          type: 'string',
                        },
                      },
                    },
                    requests: {
                      description: `Requests specifies the resource types and amounts being claimed from quota.
Each resource type can appear only once in the requests array. Minimum 1
request, maximum 20 requests per claim.

The system processes all requests as a single atomic operation: either all
requests are granted or all are denied.`,
                      type: 'array',
                      maxItems: 20,
                      items: {
                        description: `ResourceRequest defines a single resource request within a ResourceClaim.
Each request specifies a resource type and the amount of quota being claimed.`,
                        type: 'object',
                        required: ['amount', 'resourceType'],
                        properties: {
                          amount: {
                            description: `Amount specifies how much quota to claim for this resource type. Must be
measured in the BaseUnit defined by the corresponding ResourceRegistration.
Must be a positive integer (minimum value is 0, but 0 means no quota
requested).

For Entity registrations: Use 1 for single resource instances (1 Project, 1
User) For Allocation registrations: Use actual capacity amounts (2048 for
2048 MB, 1000 for 1000 millicores)

Examples:

  - 1 (claiming 1 Project)
  - 2048 (claiming 2048 bytes of storage)
  - 1000 (claiming 1000 CPU millicores)`,
                            type: 'integer',
                            format: 'int64',
                            minimum: 0,
                          },
                          resourceType: {
                            description: `ResourceType identifies the specific resource type being claimed. Must
exactly match a ResourceRegistration.spec.resourceType that is currently
active. The quota system validates this reference during claim processing.

The format is defined by platform administrators when creating ResourceRegistrations.
Service providers can use any identifier that makes sense for their quota system usage.

Examples:

  - "resourcemanager.miloapis.com/projects"
  - "compute_cpu"
  - "storage.volumes"
  - "custom-service-quota"`,
                            type: 'string',
                          },
                        },
                      },
                    },
                    resourceRef: {
                      description: `ResourceRef identifies the actual Kubernetes resource that triggered this
claim. ClaimCreationPolicy automatically populates this field during
admission. Uses unversioned reference (apiGroup + kind + name + namespace)
to remain valid across API version changes.

The referenced resource's kind must be listed in the ResourceRegistration's
spec.claimingResources for the claim to be valid.

Examples:

  - Project resource triggering Project quota claim
  - User resource triggering User quota claim
  - Organization resource triggering storage quota claim`,
                      type: 'object',
                      required: ['kind', 'name'],
                      properties: {
                        apiGroup: {
                          description: `APIGroup specifies the API group of the referenced resource.
Use full group name for Milo resources.

Examples:
- "resourcemanager.miloapis.com" (Project, Organization)
- "iam.miloapis.com" (User, Group)
- "infrastructure.miloapis.com" (infrastructure resources)`,
                          type: 'string',
                        },
                        kind: {
                          description: `Kind specifies the type of the referenced resource.
Must match an existing Kubernetes resource type.

Examples:
- "Project" (Project resource that triggered quota claim)
- "User" (User resource that triggered quota claim)
- "Organization" (Organization resource that triggered quota claim)`,
                          type: 'string',
                        },
                        name: {
                          description: `Name identifies the specific resource instance that triggered the quota claim.
Used for linking claims back to their triggering resources.

Examples:
- "web-app-project" (Project that triggered Project quota claim)
- "john.doe" (User that triggered User quota claim)`,
                          type: 'string',
                        },
                        namespace: {
                          description: `Namespace specifies the namespace containing the referenced resource.
Required for namespaced resources, omitted for cluster-scoped resources.

Examples:
- "acme-corp" (organization namespace containing Project)
- "team-alpha" (project namespace containing User)
- "" or omitted (for cluster-scoped resources like Organization)`,
                          type: 'string',
                        },
                      },
                    },
                  },
                },
              },
            },
          },
        },
        trigger: {
          description: 'Trigger defines what resource changes should trigger claim creation.',
          type: 'object',
          required: ['resource'],
          properties: {
            conditions: {
              description: `Conditions are CEL expressions that must evaluate to true for claim creation to occur.
Evaluated in the admission context.`,
              type: 'array',
              maxItems: 10,
              items: {
                description: `ConditionExpression defines a CEL expression that determines when the policy should trigger.
All expressions in a policy's trigger conditions must evaluate to true for the policy to activate.`,
                type: 'object',
                required: ['expression'],
                properties: {
                  expression: {
                    description: `Expression specifies the CEL expression to evaluate against the trigger resource.
Must return a boolean value (true to match, false to skip).
Maximum 1024 characters.

Available variables in GrantCreationPolicy context:
- object: The complete resource being watched (map[string]any)
  - object.metadata.name, object.spec.*, object.status.*, etc.

Common expression patterns:
- object.spec.tier == "premium" (check resource field)
- object.metadata.labels["environment"] == "prod" (check labels)
- object.status.phase == "Active" (check status)
- object.metadata.namespace == "production" (check namespace)
- has(object.spec.quotaProfile) (check field existence)`,
                    type: 'string',
                    maxLength: 1024,
                    minLength: 1,
                  },
                  message: {
                    description: `Message provides a human-readable description explaining when this condition applies.
Used for documentation and debugging. Maximum 256 characters.

Examples:
- "Applies only to premium tier organizations"
- "Matches organizations in production environment"
- "Triggers when quota profile is specified"`,
                    type: 'string',
                    maxLength: 256,
                  },
                },
              },
            },
            resource: {
              description: 'Resource specifies which resource type triggers this policy.',
              type: 'object',
              required: ['apiVersion', 'kind'],
              properties: {
                apiVersion: {
                  description: 'APIVersion of the target resource in the format "group/version".',
                  type: 'string',
                  pattern:
                    '^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\/v[0-9]+((alpha|beta)[0-9]*)?$',
                },
                kind: {
                  description: 'Kind is the kind of the target resource.',
                  type: 'string',
                  minLength: 1,
                },
              },
            },
          },
        },
      },
    },
    status: {
      description: `ClaimCreationPolicyStatus defines the observed state of ClaimCreationPolicy.

Status fields
- conditions[type=Ready]: True when the policy is validated and active.

See also
- [ResourceClaim](#resourceclaim): The object created by this policy.`,
      type: 'object',
      properties: {
        conditions: {
          description:
            "Conditions represent the latest available observations of the policy's current state.",
          type: 'array',
          items: {
            description:
              'Condition contains details for one aspect of the current state of this API Resource.',
            type: 'object',
            required: ['lastTransitionTime', 'message', 'reason', 'status', 'type'],
            properties: {
              lastTransitionTime: {
                description: `lastTransitionTime is the last time the condition transitioned from one status to another.
This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.`,
                type: 'string',
                format: 'date-time',
              },
              message: {
                description: `message is a human readable message indicating details about the transition.
This may be an empty string.`,
                type: 'string',
                maxLength: 32768,
              },
              observedGeneration: {
                description: `observedGeneration represents the .metadata.generation that the condition was set based upon.
For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
with respect to the current state of the instance.`,
                type: 'integer',
                format: 'int64',
                minimum: 0,
              },
              reason: {
                description: `reason contains a programmatic identifier indicating the reason for the condition's last transition.
Producers of specific condition types may define expected values and meanings for this field,
and whether the values are considered a guaranteed API.
The value should be a CamelCase string.
This field may not be empty.`,
                type: 'string',
                maxLength: 1024,
                minLength: 1,
                pattern: '^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$',
              },
              status: {
                description: 'status of the condition, one of True, False, Unknown.',
                type: 'string',
                enum: ['True', 'False', 'Unknown'],
              },
              type: {
                description: 'type of condition in CamelCase or in foo.example.com/CamelCase.',
                type: 'string',
                maxLength: 316,
                pattern:
                  '^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$',
              },
            },
          },
        },
        observedGeneration: {
          description: 'ObservedGeneration is the most recent generation observed.',
          type: 'integer',
          format: 'int64',
        },
      },
    },
  },
  'x-kubernetes-group-version-kind': [
    {
      group: 'quota.miloapis.com',
      kind: 'ClaimCreationPolicy',
      version: 'v1alpha1',
    },
  ],
  'x-kubernetes-selectable-fields': [
    {
      fieldPath: 'spec.trigger.resource.kind',
    },
    {
      fieldPath: 'spec.trigger.resource.apiVersion',
    },
    {
      fieldPath: 'spec.enabled',
    },
  ],
} as const;

export const com_miloapis_quota_v1alpha1_ClaimCreationPolicyListSchema = {
  description: 'ClaimCreationPolicyList is a list of ClaimCreationPolicy',
  type: 'object',
  required: ['items'],
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
      type: 'string',
    },
    items: {
      description:
        'List of claimcreationpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md',
      type: 'array',
      items: {
        $ref: '#/components/schemas/com.miloapis.quota.v1alpha1.ClaimCreationPolicy',
      },
    },
    kind: {
      description:
        'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    metadata: {
      description:
        'Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta',
        },
      ],
    },
  },
  'x-kubernetes-group-version-kind': [
    {
      group: 'quota.miloapis.com',
      kind: 'ClaimCreationPolicyList',
      version: 'v1alpha1',
    },
  ],
  'x-kubernetes-selectable-fields': [
    {
      fieldPath: 'spec.trigger.resource.kind',
    },
    {
      fieldPath: 'spec.trigger.resource.apiVersion',
    },
    {
      fieldPath: 'spec.enabled',
    },
  ],
} as const;

export const com_miloapis_quota_v1alpha1_GrantCreationPolicySchema = {
  description: `GrantCreationPolicy automates ResourceGrant creation when observed resources meet conditions.
Use it to provision quota based on resource lifecycle events and attributes.

### How It Works
- Watch the kind in \`spec.trigger.resource\` and evaluate all \`spec.trigger.conditions[]\`.
- When all conditions are true, render \`spec.target.resourceGrantTemplate\` and create a \`ResourceGrant\`.
- Optionally target a parent control plane via \`spec.target.parentContext\` (CEL-resolved name) for cross-cluster allocation.
- Templating supports variables \`.trigger\`, \`.requestInfo\`, \`.user\` and functions \`lower\`, \`upper\`, \`title\`, \`default\`, \`contains\`, \`join\`, \`split\`, \`replace\`, \`trim\`, \`toInt\`, \`toString\`.
- Allowances (resource types and amounts) are static in \`v1alpha1\`.

### Works With
- Creates [ResourceGrant](#resourcegrant) objects whose \`allowances[].resourceType\` must exist in a [ResourceRegistration](#resourceregistration).
- May target a parent control plane via \`spec.target.parentContext\` for cross-plane quota allocation.
- Policy readiness (\`status.conditions[type=Ready]\`) signals template/condition validity.

### Status
- \`status.conditions[type=Ready]\`: Policy validated and active.
- \`status.conditions[type=ParentContextReady]\`: Cross‑cluster targeting is resolvable.
- \`status.observedGeneration\`: Latest spec generation processed.

### Selectors and Filtering
  - Field selectors (server-side):
    \`spec.trigger.resource.kind\`, \`spec.trigger.resource.apiVersion\`,
    \`spec.target.parentContext.kind\`, \`spec.target.parentContext.apiGroup\`.
  - Label selectors (add your own):
  - \`quota.miloapis.com/trigger-kind\`: \`Organization\`
  - \`quota.miloapis.com/environment\`: \`prod\`
  - Common queries:
  - All policies for a trigger kind: label selector \`quota.miloapis.com/trigger-kind\`.
  - All enabled policies: field selector \`spec.enabled=true\`.

### Defaults and Limits
- Resource grant allowances are static (no expression-based amounts) in \`v1alpha1\`.

### Notes
- If \`ParentContextReady=False\`, verify \`nameExpression\` and referenced attributes.
- Disabled policies (\`spec.enabled=false\`) do not create grants.

### See Also
- [ResourceGrant](#resourcegrant): The object created by this policy.
- [ResourceRegistration](#resourceregistration): Resource types that grants must reference.
- [ClaimCreationPolicy](#claimcreationpolicy): Creates claims at admission for enforcement.`,
  type: 'object',
  required: ['spec'],
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
      type: 'string',
    },
    kind: {
      description:
        'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    metadata: {
      description:
        "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta',
        },
      ],
    },
    spec: {
      description: 'GrantCreationPolicySpec defines the desired state of GrantCreationPolicy.',
      type: 'object',
      required: ['target', 'trigger'],
      properties: {
        enabled: {
          description: `Enabled determines if this policy is active.
If false, no **ResourceGrants** will be created for matching resources.`,
          type: 'boolean',
          default: true,
        },
        target: {
          description: 'Target defines where and how grants should be created.',
          type: 'object',
          required: ['resourceGrantTemplate'],
          properties: {
            parentContext: {
              description: `ParentContext defines cross-control-plane targeting.
If specified, grants will be created in the target parent context
instead of the current control plane.`,
              type: 'object',
              required: ['apiGroup', 'kind', 'nameExpression'],
              properties: {
                apiGroup: {
                  description: `APIGroup specifies the API group of the parent context resource.
Must follow DNS subdomain format. Maximum 253 characters.

Examples:
- "resourcemanager.miloapis.com" (for Organization parent context)
- "infrastructure.miloapis.com" (for Cluster parent context)`,
                  type: 'string',
                  maxLength: 253,
                  pattern: '^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$',
                },
                kind: {
                  description: `Kind specifies the resource type that represents the parent context.
Must be a valid Kubernetes resource Kind. Maximum 63 characters.

Examples:
- "Organization" (create grants in organization's parent control plane)
- "Cluster" (create grants in cluster's parent infrastructure)`,
                  type: 'string',
                  maxLength: 63,
                  minLength: 1,
                  pattern: '^[A-Z][a-zA-Z0-9]*$',
                },
                nameExpression: {
                  description: `NameExpression is a CEL expression that resolves the name of the parent context resource.
Must return a string value that identifies the specific parent context instance.
Maximum 512 characters.

Available variables:
- object: The trigger resource being evaluated (complete object)

Common expression patterns:
- object.spec.organization (direct field reference)
- object.metadata.labels["parent-org"] (label-based resolution)
- object.metadata.namespace.split("-")[0] (derived from namespace naming)

Examples:
- "acme-corp" (literal parent name)
- object.spec.parentOrganization (field from trigger resource)
- object.metadata.labels["quota.miloapis.com/organization"] (label value)`,
                  type: 'string',
                  maxLength: 512,
                  minLength: 1,
                },
              },
            },
            resourceGrantTemplate: {
              description: `ResourceGrantTemplate defines how to create **ResourceGrants**.
String fields support Go template syntax for dynamic content.`,
              type: 'object',
              required: ['metadata', 'spec'],
              properties: {
                metadata: {
                  description: `Metadata for the created ResourceGrant.
String fields support Go template syntax.`,
                  type: 'object',
                  properties: {
                    annotations: {
                      description: `Annotations specifies annotations to apply to the created ResourceClaim.
Values support Go template syntax for dynamic content.
The system automatically adds standard annotations for tracking.

Template variables available:
- .trigger: The resource triggering claim creation
- .requestInfo: Request details
- .user: User information

Examples:
- created-for: "{{.trigger.metadata.name}}"
- requested-by: "{{.user.name}}"
- trigger-kind: "{{.trigger.kind}}"`,
                      type: 'object',
                      additionalProperties: {
                        type: 'string',
                      },
                    },
                    generateName: {
                      description: `GenerateName specifies a prefix for auto-generated names when Name is empty.
Kubernetes appends random characters to create unique names.
Supports Go template syntax.

Example: "{{.trigger.spec.type}}-claim-"`,
                      type: 'string',
                    },
                    labels: {
                      description: `Labels specifies static labels to apply to the created ResourceClaim.
Values are literal strings (no template processing).
The system automatically adds standard labels for policy tracking.

Useful for:
- Organizing claims by policy or resource type
- Adding environment or tier indicators
- Enabling label-based queries and monitoring`,
                      type: 'object',
                      additionalProperties: {
                        type: 'string',
                      },
                    },
                    name: {
                      description: `Name specifies the exact name for the created ResourceClaim.
Supports Go template syntax with access to template variables.
Leave empty to use GenerateName for auto-generated names.

Template variables available:
- .trigger: The resource triggering claim creation
- .requestInfo: Request details (verb, resource, name, etc.)
- .user: User information (name, uid, groups, extra)

Example: "{{.trigger.metadata.name}}-quota-claim"`,
                      type: 'string',
                    },
                    namespace: {
                      description: `Namespace specifies where the ResourceClaim will be created.
Supports Go template syntax to derive namespace from trigger resource.
Leave empty to create in the same namespace as the trigger resource.

Examples:
- "{{.trigger.metadata.namespace}}" (same namespace as trigger)
- "milo-system" (fixed system namespace)
- "{{.trigger.spec.organization}}-claims" (derived namespace)`,
                      type: 'string',
                    },
                  },
                },
                spec: {
                  description: `Spec for the created ResourceGrant.
String fields support Go template syntax.`,
                  type: 'object',
                  required: ['allowances', 'consumerRef'],
                  properties: {
                    allowances: {
                      description: `Allowances specifies the quota allocations provided by this grant.
Each allowance grants capacity for a specific resource type.
Minimum 1 allowance required, maximum 20 allowances per grant.

All allowances in a single grant:
- Apply to the same consumer (spec.consumerRef)
- Contribute to the same AllowanceBucket for each resource type
- Activate and deactivate together based on the grant's status`,
                      type: 'array',
                      minItems: 1,
                      items: {
                        description: `Allowance defines quota allocation for a specific resource type within a ResourceGrant.
Each allowance can contain multiple buckets that sum to provide total capacity.`,
                        type: 'object',
                        required: ['buckets', 'resourceType'],
                        properties: {
                          buckets: {
                            description: `Buckets contains the quota allocations for this resource type.
All bucket amounts are summed to determine the total allowance.
Minimum 1 bucket required per allowance.

Multiple buckets can be used for:
- Separating quota from different sources or tiers
- Managing incremental quota increases over time
- Tracking quota attribution for billing or reporting`,
                            type: 'array',
                            minItems: 1,
                            items: {
                              description: `Bucket represents a single allocation of quota capacity within an allowance.
Each bucket contributes its amount to the total allowance for a resource type.`,
                              type: 'object',
                              required: ['amount'],
                              properties: {
                                amount: {
                                  description: `Amount specifies the quota capacity provided by this bucket.
Must be measured in the BaseUnit defined by the corresponding ResourceRegistration.
Must be a non-negative integer (0 is valid but provides no quota).

Examples:
- 100 (providing 100 projects)
- 2048000 (providing 2048000 bytes = 2GB)
- 5000 (providing 5000 CPU millicores = 5 cores)`,
                                  type: 'integer',
                                  format: 'int64',
                                  minimum: 0,
                                },
                              },
                            },
                          },
                          resourceType: {
                            description: `ResourceType identifies the specific resource type receiving quota allocation.
Must exactly match a ResourceRegistration.spec.resourceType that is currently active.
The quota system validates this reference when processing the grant.

The identifier format is flexible, as defined by platform administrators
in their ResourceRegistrations.

Examples:
- "resourcemanager.miloapis.com/projects"
- "compute_cpu"
- "storage.volumes"
- "custom-service-quota"`,
                            type: 'string',
                          },
                        },
                      },
                    },
                    consumerRef: {
                      description: `ConsumerRef identifies the quota consumer that receives these allowances.
The consumer type must match the ConsumerTypeRef defined in the ResourceRegistration
for each allowance resource type. The system validates this relationship.

Examples:
- Organization receiving Project quota allowances
- Project receiving User quota allowances
- Organization receiving storage quota allowances`,
                      type: 'object',
                      required: ['kind', 'name'],
                      properties: {
                        apiGroup: {
                          description: `APIGroup specifies the API group of the consumer resource.
Use full group name for Milo resources.

Examples:
- "resourcemanager.miloapis.com" (Organization/Project resources)
- "iam.miloapis.com" (User/Group resources)
- "infrastructure.miloapis.com" (infrastructure resources)`,
                          type: 'string',
                        },
                        kind: {
                          description: `Kind specifies the type of consumer resource.
Must match an existing Kubernetes resource type that can receive quota grants.

Common consumer types:
- "Organization" (top-level quota consumer)
- "Project" (project-level quota consumer)
- "User" (user-level quota consumer)`,
                          type: 'string',
                        },
                        name: {
                          description: `Name identifies the specific consumer resource instance.
Must match the name of an existing consumer resource in the cluster.

Examples:
- "acme-corp" (Organization name)
- "web-application" (Project name)
- "john.doe" (User name)`,
                          type: 'string',
                        },
                        namespace: {
                          description: `Namespace identifies the namespace of the consumer resource.
Required for namespaced consumer resources (e.g., Projects).
Leave empty for cluster-scoped consumer resources (e.g., Organizations).

Examples:
- "" (empty for cluster-scoped Organizations)
- "organization-acme-corp" (namespace for Projects within an organization)
- "project-web-app" (namespace for resources within a project)`,
                          type: 'string',
                        },
                      },
                    },
                  },
                },
              },
            },
          },
        },
        trigger: {
          description: 'Trigger defines what resource changes should trigger grant creation.',
          type: 'object',
          required: ['resource'],
          properties: {
            conditions: {
              description: `Conditions are CEL expressions that must evaluate to true for grant creation.
All conditions must pass for the policy to trigger.
The 'object' variable contains the trigger resource being evaluated.`,
              type: 'array',
              maxItems: 10,
              items: {
                description: `ConditionExpression defines a CEL expression that determines when the policy should trigger.
All expressions in a policy's trigger conditions must evaluate to true for the policy to activate.`,
                type: 'object',
                required: ['expression'],
                properties: {
                  expression: {
                    description: `Expression specifies the CEL expression to evaluate against the trigger resource.
Must return a boolean value (true to match, false to skip).
Maximum 1024 characters.

Available variables in GrantCreationPolicy context:
- object: The complete resource being watched (map[string]any)
  - object.metadata.name, object.spec.*, object.status.*, etc.

Common expression patterns:
- object.spec.tier == "premium" (check resource field)
- object.metadata.labels["environment"] == "prod" (check labels)
- object.status.phase == "Active" (check status)
- object.metadata.namespace == "production" (check namespace)
- has(object.spec.quotaProfile) (check field existence)`,
                    type: 'string',
                    maxLength: 1024,
                    minLength: 1,
                  },
                  message: {
                    description: `Message provides a human-readable description explaining when this condition applies.
Used for documentation and debugging. Maximum 256 characters.

Examples:
- "Applies only to premium tier organizations"
- "Matches organizations in production environment"
- "Triggers when quota profile is specified"`,
                    type: 'string',
                    maxLength: 256,
                  },
                },
              },
            },
            resource: {
              description: 'Resource specifies which resource type triggers this policy.',
              type: 'object',
              required: ['apiVersion', 'kind'],
              properties: {
                apiVersion: {
                  description: `APIVersion of the trigger resource in the format "group/version".
For core resources, use "v1".`,
                  type: 'string',
                  pattern:
                    '^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\/)?v[0-9]+((alpha|beta)[0-9]*)?$',
                },
                kind: {
                  description: 'Kind is the kind of the trigger resource.',
                  type: 'string',
                  maxLength: 63,
                  minLength: 1,
                  pattern: '^[A-Z][a-zA-Z0-9]*$',
                },
              },
            },
          },
        },
      },
    },
    status: {
      description: `GrantCreationPolicyStatus defines the observed state of GrantCreationPolicy.

Status fields
- conditions[type=Ready]: True when the policy is validated and active.
- conditions[type=ParentContextReady]: True when cross‑cluster targeting is resolvable.
- observedGeneration: Latest spec generation processed by the quota system.

See also
- [ResourceGrant](#resourcegrant): The object created by this policy.
- [ResourceRegistration](#resourceregistration): Resource types for which grants are issued.`,
      type: 'object',
      properties: {
        conditions: {
          description:
            "Conditions represent the latest available observations of the policy's current state.",
          type: 'array',
          items: {
            description:
              'Condition contains details for one aspect of the current state of this API Resource.',
            type: 'object',
            required: ['lastTransitionTime', 'message', 'reason', 'status', 'type'],
            properties: {
              lastTransitionTime: {
                description: `lastTransitionTime is the last time the condition transitioned from one status to another.
This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.`,
                type: 'string',
                format: 'date-time',
              },
              message: {
                description: `message is a human readable message indicating details about the transition.
This may be an empty string.`,
                type: 'string',
                maxLength: 32768,
              },
              observedGeneration: {
                description: `observedGeneration represents the .metadata.generation that the condition was set based upon.
For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
with respect to the current state of the instance.`,
                type: 'integer',
                format: 'int64',
                minimum: 0,
              },
              reason: {
                description: `reason contains a programmatic identifier indicating the reason for the condition's last transition.
Producers of specific condition types may define expected values and meanings for this field,
and whether the values are considered a guaranteed API.
The value should be a CamelCase string.
This field may not be empty.`,
                type: 'string',
                maxLength: 1024,
                minLength: 1,
                pattern: '^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$',
              },
              status: {
                description: 'status of the condition, one of True, False, Unknown.',
                type: 'string',
                enum: ['True', 'False', 'Unknown'],
              },
              type: {
                description: 'type of condition in CamelCase or in foo.example.com/CamelCase.',
                type: 'string',
                maxLength: 316,
                pattern:
                  '^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$',
              },
            },
          },
        },
        observedGeneration: {
          description: 'ObservedGeneration is the most recent generation observed.',
          type: 'integer',
          format: 'int64',
        },
      },
    },
  },
  'x-kubernetes-group-version-kind': [
    {
      group: 'quota.miloapis.com',
      kind: 'GrantCreationPolicy',
      version: 'v1alpha1',
    },
  ],
  'x-kubernetes-selectable-fields': [
    {
      fieldPath: 'spec.trigger.resource.kind',
    },
    {
      fieldPath: 'spec.trigger.resource.apiVersion',
    },
    {
      fieldPath: 'spec.target.parentContext.kind',
    },
    {
      fieldPath: 'spec.target.parentContext.apiGroup',
    },
  ],
} as const;

export const com_miloapis_quota_v1alpha1_GrantCreationPolicyListSchema = {
  description: 'GrantCreationPolicyList is a list of GrantCreationPolicy',
  type: 'object',
  required: ['items'],
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
      type: 'string',
    },
    items: {
      description:
        'List of grantcreationpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md',
      type: 'array',
      items: {
        $ref: '#/components/schemas/com.miloapis.quota.v1alpha1.GrantCreationPolicy',
      },
    },
    kind: {
      description:
        'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    metadata: {
      description:
        'Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta',
        },
      ],
    },
  },
  'x-kubernetes-group-version-kind': [
    {
      group: 'quota.miloapis.com',
      kind: 'GrantCreationPolicyList',
      version: 'v1alpha1',
    },
  ],
  'x-kubernetes-selectable-fields': [
    {
      fieldPath: 'spec.trigger.resource.kind',
    },
    {
      fieldPath: 'spec.trigger.resource.apiVersion',
    },
    {
      fieldPath: 'spec.target.parentContext.kind',
    },
    {
      fieldPath: 'spec.target.parentContext.apiGroup',
    },
  ],
} as const;

export const com_miloapis_quota_v1alpha1_ResourceClaimSchema = {
  description: `ResourceClaim requests quota allocation during resource creation. Claims
consume quota capacity from AllowanceBuckets and link to the triggering
Kubernetes resource for lifecycle management and auditing.

### How It Works

**ResourceClaims** follow a straightforward lifecycle from creation to
resolution. When a **ClaimCreationPolicy** triggers during admission, it
creates a **ResourceClaim** that immediately enters the quota evaluation
pipeline. The quota system first validates that the consumer type matches the
expected \`ConsumerTypeRef\` from the **ResourceRegistration**, then verifies
that the triggering resource kind is authorized to claim the requested
resource types.

Once validation passes, the quota system checks quota availability by
consulting the relevant **AllowanceBuckets**, one for each (consumer,
resourceType) combination in the claim's requests. The quota system treats
all requests in a claim as an atomic unit: either sufficient quota exists for
every request and the entire claim is granted, or any shortage results in
denying the complete claim. This atomic approach ensures consistency and
prevents partial resource allocations that could leave the system in an
inconsistent state.

When a claim is granted, it permanently reserves the requested quota amounts
until the claim is deleted. This consumption immediately reduces the
available quota in the corresponding **AllowanceBuckets**, preventing other
claims from accessing that capacity. The quota system updates the claim's
status with detailed results for each resource request, including which
**AllowanceBucket** provided the quota and any relevant error messages.

### Core Relationships

  - **Created by**: **ClaimCreationPolicy** during admission (automatically) or
    administrators (manually)
  - **Consumes from**: **AllowanceBucket** matching
    (\`spec.consumerRef\`, \`spec.requests[].resourceType\`)
  - **Capacity sourced from**: **ResourceGrant** objects aggregated by the bucket
  - **Linked to**: Triggering resource via \`spec.resourceRef\` for lifecycle management
  - **Validated against**: **ResourceRegistration** for each \`spec.requests[].resourceType\`

### Claim Lifecycle States

  - **Initial**: \`Granted=False\`, \`reason=PendingEvaluation\` (claim created, awaiting processing)
  - **Granted**: \`Granted=True\`, \`reason=QuotaAvailable\` (all requests allocated successfully)
  - **Denied**: \`Granted=False\`, \`reason=QuotaExceeded\` or \`ValidationFailed\` (requests could not be satisfied)

### Automatic vs Manual Claims

**Automatic Claims** (created by **ClaimCreationPolicy**):

  - Include standard labels and annotations for tracking
  - Set owner references to triggering resource when possible
  - Automatically cleaned up when denied to prevent accumulation
  - Marked with \`quota.miloapis.com/auto-created=true\` label

**Manual Claims** (created by administrators):

  - Require explicit metadata and references
  - Not automatically cleaned up when denied
  - Used for testing or special allocation scenarios

### Status Information

  - **Overall Status**: \`status.conditions[type=Granted]\` indicates claim approval
  - **Detailed Results**: \`status.allocations[]\` provides per-request allocation details
  - **Bucket References**: \`status.allocations[].allocatingBucket\` identifies quota sources

### Field Constraints and Validation

  - Maximum 20 resource requests per claim
  - Each resource type can appear only once in requests
  - Consumer type must match \`ResourceRegistration.spec.consumerTypeRef\` for each requested type
  - Triggering resource kind must be listed in \`ResourceRegistration.spec.claimingResources\`

### Selectors and Filtering

  - **Field selectors**: spec.consumerRef.kind, spec.consumerRef.name, spec.resourceRef.apiGroup, spec.resourceRef.kind, spec.resourceRef.name, spec.resourceRef.namespace
  - **Auto-created labels**: quota.miloapis.com/auto-created, quota.miloapis.com/policy, quota.miloapis.com/gvk
  - **Auto-created annotations**: quota.miloapis.com/created-by, quota.miloapis.com/created-at,  quota.miloapis.com/resource-name

### Common Queries

  - All claims for a consumer: field selector spec.consumerRef.kind + spec.consumerRef.name
  - Claims from a specific policy: label selector quota.miloapis.com/policy=<policy-name>
  - Claims for a resource type: add custom labels via policy template
  - Failed claims: field  selector on status conditions

### Troubleshooting

  - **Denied claims**: Check status.allocations[].message for specific quota or validation errors
  - **Pending claims**: Verify ResourceRegistration is Active and AllowanceBucket exists
  - **Missing claims**: Check ClaimCreationPolicy conditions and trigger expressions

### Performance Considerations

  - Claims are processed synchronously during admission (affects API latency)
  - Large numbers of claims can impact bucket aggregation performance
  - Consider batch processing for bulk resource creation`,
  type: 'object',
  required: ['spec'],
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
      type: 'string',
    },
    kind: {
      description:
        'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    metadata: {
      description:
        "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta',
        },
      ],
    },
    spec: {
      description: 'ResourceClaimSpec defines the desired state of ResourceClaim.',
      type: 'object',
      required: ['consumerRef', 'requests', 'resourceRef'],
      properties: {
        consumerRef: {
          description: `ConsumerRef identifies the quota consumer making this claim. The consumer
must match the ConsumerTypeRef defined in the ResourceRegistration for each
requested resource type. The system validates this relationship during
claim processing.

Examples:

  - Organization consuming Project quota
  - Project consuming User quota
  - Organization consuming storage quota`,
          type: 'object',
          required: ['kind', 'name'],
          properties: {
            apiGroup: {
              description: `APIGroup specifies the API group of the consumer resource.
Use full group name for Milo resources.

Examples:
- "resourcemanager.miloapis.com" (Organization/Project resources)
- "iam.miloapis.com" (User/Group resources)
- "infrastructure.miloapis.com" (infrastructure resources)`,
              type: 'string',
            },
            kind: {
              description: `Kind specifies the type of consumer resource.
Must match an existing Kubernetes resource type that can receive quota grants.

Common consumer types:
- "Organization" (top-level quota consumer)
- "Project" (project-level quota consumer)
- "User" (user-level quota consumer)`,
              type: 'string',
            },
            name: {
              description: `Name identifies the specific consumer resource instance.
Must match the name of an existing consumer resource in the cluster.

Examples:
- "acme-corp" (Organization name)
- "web-application" (Project name)
- "john.doe" (User name)`,
              type: 'string',
            },
            namespace: {
              description: `Namespace identifies the namespace of the consumer resource.
Required for namespaced consumer resources (e.g., Projects).
Leave empty for cluster-scoped consumer resources (e.g., Organizations).

Examples:
- "" (empty for cluster-scoped Organizations)
- "organization-acme-corp" (namespace for Projects within an organization)
- "project-web-app" (namespace for resources within a project)`,
              type: 'string',
            },
          },
        },
        requests: {
          description: `Requests specifies the resource types and amounts being claimed from quota.
Each resource type can appear only once in the requests array. Minimum 1
request, maximum 20 requests per claim.

The system processes all requests as a single atomic operation: either all
requests are granted or all are denied.`,
          type: 'array',
          maxItems: 20,
          items: {
            description: `ResourceRequest defines a single resource request within a ResourceClaim.
Each request specifies a resource type and the amount of quota being claimed.`,
            type: 'object',
            required: ['amount', 'resourceType'],
            properties: {
              amount: {
                description: `Amount specifies how much quota to claim for this resource type. Must be
measured in the BaseUnit defined by the corresponding ResourceRegistration.
Must be a positive integer (minimum value is 0, but 0 means no quota
requested).

For Entity registrations: Use 1 for single resource instances (1 Project, 1
User) For Allocation registrations: Use actual capacity amounts (2048 for
2048 MB, 1000 for 1000 millicores)

Examples:

  - 1 (claiming 1 Project)
  - 2048 (claiming 2048 bytes of storage)
  - 1000 (claiming 1000 CPU millicores)`,
                type: 'integer',
                format: 'int64',
                minimum: 0,
              },
              resourceType: {
                description: `ResourceType identifies the specific resource type being claimed. Must
exactly match a ResourceRegistration.spec.resourceType that is currently
active. The quota system validates this reference during claim processing.

The format is defined by platform administrators when creating ResourceRegistrations.
Service providers can use any identifier that makes sense for their quota system usage.

Examples:

  - "resourcemanager.miloapis.com/projects"
  - "compute_cpu"
  - "storage.volumes"
  - "custom-service-quota"`,
                type: 'string',
              },
            },
          },
        },
        resourceRef: {
          description: `ResourceRef identifies the actual Kubernetes resource that triggered this
claim. ClaimCreationPolicy automatically populates this field during
admission. Uses unversioned reference (apiGroup + kind + name + namespace)
to remain valid across API version changes.

The referenced resource's kind must be listed in the ResourceRegistration's
spec.claimingResources for the claim to be valid.

Examples:

  - Project resource triggering Project quota claim
  - User resource triggering User quota claim
  - Organization resource triggering storage quota claim`,
          type: 'object',
          required: ['kind', 'name'],
          properties: {
            apiGroup: {
              description: `APIGroup specifies the API group of the referenced resource.
Use full group name for Milo resources.

Examples:
- "resourcemanager.miloapis.com" (Project, Organization)
- "iam.miloapis.com" (User, Group)
- "infrastructure.miloapis.com" (infrastructure resources)`,
              type: 'string',
            },
            kind: {
              description: `Kind specifies the type of the referenced resource.
Must match an existing Kubernetes resource type.

Examples:
- "Project" (Project resource that triggered quota claim)
- "User" (User resource that triggered quota claim)
- "Organization" (Organization resource that triggered quota claim)`,
              type: 'string',
            },
            name: {
              description: `Name identifies the specific resource instance that triggered the quota claim.
Used for linking claims back to their triggering resources.

Examples:
- "web-app-project" (Project that triggered Project quota claim)
- "john.doe" (User that triggered User quota claim)`,
              type: 'string',
            },
            namespace: {
              description: `Namespace specifies the namespace containing the referenced resource.
Required for namespaced resources, omitted for cluster-scoped resources.

Examples:
- "acme-corp" (organization namespace containing Project)
- "team-alpha" (project namespace containing User)
- "" or omitted (for cluster-scoped resources like Organization)`,
              type: 'string',
            },
          },
        },
      },
    },
    status: {
      description: `ResourceClaimStatus reports the claim's processing state and allocation
results. The system updates this status to communicate whether quota was
granted and provide detailed allocation information for each requested
resource type.`,
      type: 'object',
      default: {
        conditions: [
          {
            lastTransitionTime: '1970-01-01T00:00:00Z',
            message: 'Awaiting capacity evaluation',
            reason: 'PendingEvaluation',
            status: 'False',
            type: 'Granted',
          },
        ],
      },
      properties: {
        allocations: {
          description: `Allocations provides detailed status for each resource request in the
claim. The system creates one allocation entry for each request in
spec.requests. Use this field to understand which specific requests were
granted or denied.

List is indexed by ResourceType for efficient lookups.`,
          type: 'array',
          items: {
            description: `RequestAllocation tracks the allocation status for a specific resource
request within a claim. The system creates one allocation entry for each
request in the claim specification.`,
            type: 'object',
            required: ['lastTransitionTime', 'resourceType', 'status'],
            properties: {
              allocatedAmount: {
                description: `AllocatedAmount specifies how much quota was actually allocated for this
request. Measured in the BaseUnit defined by the ResourceRegistration.
Currently always equals the requested amount or 0 (partial allocations not
supported).

Set to the requested amount when Status=Granted, 0 when Status=Denied or
Pending.`,
                type: 'integer',
                format: 'int64',
              },
              allocatingBucket: {
                description: `AllocatingBucket identifies the AllowanceBucket that provided the quota for
this request. Set only when Status=Granted. Used for tracking and debugging
quota consumption.

Format: bucket name (generated as:
consumer-kind-consumer-name-resource-type-hash)`,
                type: 'string',
              },
              lastTransitionTime: {
                description: `LastTransitionTime records when this allocation status last changed.
Updates whenever Status, Reason, or Message changes.`,
                type: 'string',
                format: 'date-time',
              },
              message: {
                description: `Message provides a human-readable explanation of the allocation result.
Includes specific details about quota availability or validation errors.

Examples:

  - "Allocated 1 project from bucket organization-acme-projects"
  - "Insufficient quota: need 2048 bytes, only 1024 available"
  - "ResourceRegistration not found for resourceType"`,
                type: 'string',
              },
              reason: {
                description: `Reason provides a machine-readable explanation for the current status.
Standard reasons include "QuotaAvailable", "QuotaExceeded",
"ValidationFailed".`,
                type: 'string',
              },
              resourceType: {
                description: `ResourceType identifies which resource request this allocation status
describes. Must exactly match one of the resourceType values in
spec.requests.`,
                type: 'string',
              },
              status: {
                description: `Status indicates the allocation result for this specific resource request.

Valid values:

  - "Granted": Quota was available and the request was approved
  - "Denied": Insufficient quota or validation failure prevented allocation
  - "Pending": Request is being evaluated (initial state)`,
                type: 'string',
                enum: ['Granted', 'Denied', 'Pending'],
              },
            },
          },
          'x-kubernetes-list-map-keys': ['resourceType'],
          'x-kubernetes-list-type': 'map',
        },
        conditions: {
          description: `Conditions represents the overall status of the claim evaluation.
Controllers set these conditions to provide a high-level view of claim
processing.

Standard condition types:

  - "Granted": Indicates whether the claim was approved and quota allocated

Standard condition reasons for "Granted":

  - "QuotaAvailable": All requested quota was available and allocated
  - "QuotaExceeded": Insufficient quota prevented allocation (claim denied)
  - "ValidationFailed": Configuration errors prevented evaluation (claim denied)
  - "PendingEvaluation": Claim is still being processed (initial state)

Claim Lifecycle:

  1. Created: Granted=False, reason=PendingEvaluation
  2. Processed: Granted=True/False based on quota availability and validation
  3. Updated: Granted condition changes only when allocation results change`,
          type: 'array',
          items: {
            description:
              'Condition contains details for one aspect of the current state of this API Resource.',
            type: 'object',
            required: ['lastTransitionTime', 'message', 'reason', 'status', 'type'],
            properties: {
              lastTransitionTime: {
                description: `lastTransitionTime is the last time the condition transitioned from one status to another.
This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.`,
                type: 'string',
                format: 'date-time',
              },
              message: {
                description: `message is a human readable message indicating details about the transition.
This may be an empty string.`,
                type: 'string',
                maxLength: 32768,
              },
              observedGeneration: {
                description: `observedGeneration represents the .metadata.generation that the condition was set based upon.
For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
with respect to the current state of the instance.`,
                type: 'integer',
                format: 'int64',
                minimum: 0,
              },
              reason: {
                description: `reason contains a programmatic identifier indicating the reason for the condition's last transition.
Producers of specific condition types may define expected values and meanings for this field,
and whether the values are considered a guaranteed API.
The value should be a CamelCase string.
This field may not be empty.`,
                type: 'string',
                maxLength: 1024,
                minLength: 1,
                pattern: '^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$',
              },
              status: {
                description: 'status of the condition, one of True, False, Unknown.',
                type: 'string',
                enum: ['True', 'False', 'Unknown'],
              },
              type: {
                description: 'type of condition in CamelCase or in foo.example.com/CamelCase.',
                type: 'string',
                maxLength: 316,
                pattern:
                  '^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$',
              },
            },
          },
          'x-kubernetes-validations': [
            {
              rule: "self.all(c, c.type == 'Granted' ? c.reason in ['QuotaAvailable', 'QuotaExceeded', 'ValidationFailed', 'PendingEvaluation'] : true)",
              message: 'Granted condition reason must be valid',
            },
          ],
        },
        observedGeneration: {
          description: `ObservedGeneration indicates the most recent spec generation the system has
processed. When ObservedGeneration matches metadata.generation, the status
reflects the current spec. When ObservedGeneration is lower, the system is
still processing recent changes.`,
          type: 'integer',
          format: 'int64',
        },
      },
    },
  },
  'x-kubernetes-group-version-kind': [
    {
      group: 'quota.miloapis.com',
      kind: 'ResourceClaim',
      version: 'v1alpha1',
    },
  ],
  'x-kubernetes-selectable-fields': [
    {
      fieldPath: 'spec.consumerRef.kind',
    },
    {
      fieldPath: 'spec.consumerRef.name',
    },
    {
      fieldPath: 'spec.resourceRef.apiGroup',
    },
    {
      fieldPath: 'spec.resourceRef.kind',
    },
    {
      fieldPath: 'spec.resourceRef.name',
    },
    {
      fieldPath: 'spec.resourceRef.namespace',
    },
  ],
} as const;

export const com_miloapis_quota_v1alpha1_ResourceClaimListSchema = {
  description: 'ResourceClaimList is a list of ResourceClaim',
  type: 'object',
  required: ['items'],
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
      type: 'string',
    },
    items: {
      description:
        'List of resourceclaims. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md',
      type: 'array',
      items: {
        $ref: '#/components/schemas/com.miloapis.quota.v1alpha1.ResourceClaim',
      },
    },
    kind: {
      description:
        'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    metadata: {
      description:
        'Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta',
        },
      ],
    },
  },
  'x-kubernetes-group-version-kind': [
    {
      group: 'quota.miloapis.com',
      kind: 'ResourceClaimList',
      version: 'v1alpha1',
    },
  ],
  'x-kubernetes-selectable-fields': [
    {
      fieldPath: 'spec.consumerRef.kind',
    },
    {
      fieldPath: 'spec.consumerRef.name',
    },
    {
      fieldPath: 'spec.resourceRef.apiGroup',
    },
    {
      fieldPath: 'spec.resourceRef.kind',
    },
    {
      fieldPath: 'spec.resourceRef.name',
    },
    {
      fieldPath: 'spec.resourceRef.namespace',
    },
  ],
} as const;

export const com_miloapis_quota_v1alpha1_ResourceGrantSchema = {
  description: `ResourceGrant allocates quota capacity to a consumer for specific resource types.
Grants provide the allowances that AllowanceBuckets aggregate to determine
available quota for ResourceClaim evaluation.

### How It Works
**ResourceGrants** begin their lifecycle when either an administrator creates them manually or a
**GrantCreationPolicy** generates them automatically in response to observed resource changes. Upon
creation, the grant enters a validation phase where the quota system examines the consumer type
to ensure it matches the expected \`ConsumerTypeRef\` from each **ResourceRegistration** targeted by
the grant's allowances. The quota system also verifies that all specified resource types correspond
to active registrations and that the allowance amounts are valid non-negative integers.

When validation succeeds, the quota system marks the grant as \`Active\`, signaling to **AllowanceBucket**
resources that this grant should contribute to quota calculations. The bucket resources
continuously monitor for active grants and aggregate their allowance amounts into the appropriate
buckets based on consumer and resource type matching. This aggregation process makes the granted
quota capacity available for **ResourceClaim** consumption.

**ResourceClaims** then consume the capacity that active grants provide, creating a flow from grants
through buckets to claims. The grant's capacity remains reserved as long as claims reference it,
ensuring that quota allocations persist until the consuming resources are removed. This creates
a stable quota environment where capacity allocations remain consistent across resource lifecycles.

### Core Relationships
- **Provides capacity to**: AllowanceBucket matching (spec.consumerRef, spec.allowances[].resourceType)
- **Consumed by**: ResourceClaim objects processed against the aggregated buckets
- **Validated against**: ResourceRegistration for each spec.allowances[].resourceType
- **Created by**: Administrators manually or GrantCreationPolicy automatically

### Quota Aggregation Logic
Multiple ResourceGrants for the same (consumer, resourceType) combination:
- Aggregate into a single AllowanceBucket for that combination
- All bucket amounts from all allowances are summed for total capacity
- Only Active grants contribute to the aggregated limit
- Inactive grants are excluded from quota calculations

### Grant vs Bucket Relationship
- **ResourceGrant**: Specifies intended quota allocations
- **AllowanceBucket**: Aggregates actual available quota from active grants
- **ResourceClaim**: Consumes quota from buckets (which source from grants)

### Allowance Structure
Each grant can contain multiple allowances for different resource types:
- All allowances share the same consumer (spec.consumerRef)
- Each allowance can have multiple buckets (for tracking, attribution, or incremental increases)
- Bucket amounts within an allowance are summed for that resource type

### Manual vs Automated Grants
**Manual Grants** (created by administrators):
- Explicit quota allocations for specific consumers
- Require direct management and updates
- Useful for base quotas, special allocations, or testing

**Automated Grants** (created by GrantCreationPolicy):
- Generated based on resource lifecycle events
- Include labels/annotations for tracking policy source
- Automatically managed based on trigger conditions

### Validation Requirements
- Consumer type must match ResourceRegistration.spec.consumerTypeRef for each resource type
- All resource types must reference active ResourceRegistration objects
- Maximum 20 allowances per grant
- All amounts must be non-negative integers in BaseUnit

### Field Constraints and Limits
- Maximum 20 allowances per grant
- Each allowance must have at least 1 bucket
- Bucket amounts must be non-negative (0 is allowed but provides no quota)
- All amounts measured in BaseUnit from ResourceRegistration

### Status Information
- **Active condition**: Indicates whether grant is contributing to quota buckets
- **Validation errors**: Reported in condition message when Active=False
- **Processing status**: ObservedGeneration tracks spec changes

### Selectors and Filtering
- **Field selectors**: spec.consumerRef.kind, spec.consumerRef.name
- **Recommended labels** (add manually for better organization):
  - quota.miloapis.com/consumer-kind: Organization
  - quota.miloapis.com/consumer-name: acme-corp
  - quota.miloapis.com/source: policy-name or manual
  - quota.miloapis.com/tier: basic, premium, enterprise

### Common Queries
- All grants for a consumer: field selector spec.consumerRef.kind + spec.consumerRef.name
- Grants by source policy: label selector quota.miloapis.com/source=<policy-name>
- Grants by resource tier: label selector quota.miloapis.com/tier=<tier-name>
- Active vs inactive grants: check status.conditions[type=Active].status

### Cross-Cluster Allocation
GrantCreationPolicy can create grants in parent control planes for cross-cluster quota:
- Policy running in child cluster creates grants in parent cluster
- Grants provide capacity that spans multiple child clusters
- Enables centralized quota management across cluster hierarchies

### Troubleshooting
- **Inactive grants**: Check status.conditions[type=Active] for validation errors
- **Missing quota**: Verify grants are Active and contributing to correct buckets
- **Grant conflicts**: Multiple grants for same consumer+resourceType are aggregated, not conflicting

### Performance Considerations
- Large numbers of grants can impact bucket aggregation performance
- Consider consolidating grants where possible to reduce aggregation overhead
- Grant status updates are asynchronous and may lag spec changes`,
  type: 'object',
  required: ['spec'],
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
      type: 'string',
    },
    kind: {
      description:
        'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    metadata: {
      description:
        "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta',
        },
      ],
    },
    spec: {
      description: 'ResourceGrantSpec defines the desired state of ResourceGrant.',
      type: 'object',
      required: ['allowances', 'consumerRef'],
      properties: {
        allowances: {
          description: `Allowances specifies the quota allocations provided by this grant.
Each allowance grants capacity for a specific resource type.
Minimum 1 allowance required, maximum 20 allowances per grant.

All allowances in a single grant:
- Apply to the same consumer (spec.consumerRef)
- Contribute to the same AllowanceBucket for each resource type
- Activate and deactivate together based on the grant's status`,
          type: 'array',
          minItems: 1,
          items: {
            description: `Allowance defines quota allocation for a specific resource type within a ResourceGrant.
Each allowance can contain multiple buckets that sum to provide total capacity.`,
            type: 'object',
            required: ['buckets', 'resourceType'],
            properties: {
              buckets: {
                description: `Buckets contains the quota allocations for this resource type.
All bucket amounts are summed to determine the total allowance.
Minimum 1 bucket required per allowance.

Multiple buckets can be used for:
- Separating quota from different sources or tiers
- Managing incremental quota increases over time
- Tracking quota attribution for billing or reporting`,
                type: 'array',
                minItems: 1,
                items: {
                  description: `Bucket represents a single allocation of quota capacity within an allowance.
Each bucket contributes its amount to the total allowance for a resource type.`,
                  type: 'object',
                  required: ['amount'],
                  properties: {
                    amount: {
                      description: `Amount specifies the quota capacity provided by this bucket.
Must be measured in the BaseUnit defined by the corresponding ResourceRegistration.
Must be a non-negative integer (0 is valid but provides no quota).

Examples:
- 100 (providing 100 projects)
- 2048000 (providing 2048000 bytes = 2GB)
- 5000 (providing 5000 CPU millicores = 5 cores)`,
                      type: 'integer',
                      format: 'int64',
                      minimum: 0,
                    },
                  },
                },
              },
              resourceType: {
                description: `ResourceType identifies the specific resource type receiving quota allocation.
Must exactly match a ResourceRegistration.spec.resourceType that is currently active.
The quota system validates this reference when processing the grant.

The identifier format is flexible, as defined by platform administrators
in their ResourceRegistrations.

Examples:
- "resourcemanager.miloapis.com/projects"
- "compute_cpu"
- "storage.volumes"
- "custom-service-quota"`,
                type: 'string',
              },
            },
          },
        },
        consumerRef: {
          description: `ConsumerRef identifies the quota consumer that receives these allowances.
The consumer type must match the ConsumerTypeRef defined in the ResourceRegistration
for each allowance resource type. The system validates this relationship.

Examples:
- Organization receiving Project quota allowances
- Project receiving User quota allowances
- Organization receiving storage quota allowances`,
          type: 'object',
          required: ['kind', 'name'],
          properties: {
            apiGroup: {
              description: `APIGroup specifies the API group of the consumer resource.
Use full group name for Milo resources.

Examples:
- "resourcemanager.miloapis.com" (Organization/Project resources)
- "iam.miloapis.com" (User/Group resources)
- "infrastructure.miloapis.com" (infrastructure resources)`,
              type: 'string',
            },
            kind: {
              description: `Kind specifies the type of consumer resource.
Must match an existing Kubernetes resource type that can receive quota grants.

Common consumer types:
- "Organization" (top-level quota consumer)
- "Project" (project-level quota consumer)
- "User" (user-level quota consumer)`,
              type: 'string',
            },
            name: {
              description: `Name identifies the specific consumer resource instance.
Must match the name of an existing consumer resource in the cluster.

Examples:
- "acme-corp" (Organization name)
- "web-application" (Project name)
- "john.doe" (User name)`,
              type: 'string',
            },
            namespace: {
              description: `Namespace identifies the namespace of the consumer resource.
Required for namespaced consumer resources (e.g., Projects).
Leave empty for cluster-scoped consumer resources (e.g., Organizations).

Examples:
- "" (empty for cluster-scoped Organizations)
- "organization-acme-corp" (namespace for Projects within an organization)
- "project-web-app" (namespace for resources within a project)`,
              type: 'string',
            },
          },
        },
      },
    },
    status: {
      description: `ResourceGrantStatus reports the grant's operational state and processing status.
Controllers update status conditions to indicate whether the grant is active
and contributing capacity to AllowanceBuckets.`,
      type: 'object',
      properties: {
        conditions: {
          description: `Conditions represents the latest available observations of the grant's state.
Controllers set these conditions to communicate operational status.

Standard condition types:
- "Active": Indicates whether the grant is operational and contributing to quota buckets.
  When True, allowances are aggregated into AllowanceBuckets and available for claims.
  When False, allowances do not contribute to quota decisions.

Standard condition reasons for "Active":
- "GrantActive": Grant is validated and contributing to quota buckets
- "ValidationFailed": Specification contains errors preventing activation (see message)
- "GrantPending": Grant is being processed by the quota system

Grant Lifecycle:
1. Created: Active=Unknown, reason=GrantPending
2. Validated: Active=True, reason=GrantActive OR Active=False, reason=ValidationFailed
3. Updated: Active condition changes only when validation results change`,
          type: 'array',
          items: {
            description:
              'Condition contains details for one aspect of the current state of this API Resource.',
            type: 'object',
            required: ['lastTransitionTime', 'message', 'reason', 'status', 'type'],
            properties: {
              lastTransitionTime: {
                description: `lastTransitionTime is the last time the condition transitioned from one status to another.
This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.`,
                type: 'string',
                format: 'date-time',
              },
              message: {
                description: `message is a human readable message indicating details about the transition.
This may be an empty string.`,
                type: 'string',
                maxLength: 32768,
              },
              observedGeneration: {
                description: `observedGeneration represents the .metadata.generation that the condition was set based upon.
For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
with respect to the current state of the instance.`,
                type: 'integer',
                format: 'int64',
                minimum: 0,
              },
              reason: {
                description: `reason contains a programmatic identifier indicating the reason for the condition's last transition.
Producers of specific condition types may define expected values and meanings for this field,
and whether the values are considered a guaranteed API.
The value should be a CamelCase string.
This field may not be empty.`,
                type: 'string',
                maxLength: 1024,
                minLength: 1,
                pattern: '^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$',
              },
              status: {
                description: 'status of the condition, one of True, False, Unknown.',
                type: 'string',
                enum: ['True', 'False', 'Unknown'],
              },
              type: {
                description: 'type of condition in CamelCase or in foo.example.com/CamelCase.',
                type: 'string',
                maxLength: 316,
                pattern:
                  '^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$',
              },
            },
          },
          'x-kubernetes-validations': [
            {
              rule: "self.all(c, c.type == 'Active' ? c.reason in ['GrantActive', 'ValidationFailed', 'GrantPending'] : true)",
              message: 'Active condition reason must be valid',
            },
          ],
        },
        observedGeneration: {
          description: `ObservedGeneration indicates the most recent spec generation the quota system has processed.
When ObservedGeneration matches metadata.generation, the status reflects the current spec.
When ObservedGeneration is lower, the quota system is still processing recent changes.`,
          type: 'integer',
          format: 'int64',
        },
      },
    },
  },
  'x-kubernetes-group-version-kind': [
    {
      group: 'quota.miloapis.com',
      kind: 'ResourceGrant',
      version: 'v1alpha1',
    },
  ],
  'x-kubernetes-selectable-fields': [
    {
      fieldPath: 'spec.consumerRef.kind',
    },
    {
      fieldPath: 'spec.consumerRef.name',
    },
  ],
} as const;

export const com_miloapis_quota_v1alpha1_ResourceGrantListSchema = {
  description: 'ResourceGrantList is a list of ResourceGrant',
  type: 'object',
  required: ['items'],
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
      type: 'string',
    },
    items: {
      description:
        'List of resourcegrants. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md',
      type: 'array',
      items: {
        $ref: '#/components/schemas/com.miloapis.quota.v1alpha1.ResourceGrant',
      },
    },
    kind: {
      description:
        'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    metadata: {
      description:
        'Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta',
        },
      ],
    },
  },
  'x-kubernetes-group-version-kind': [
    {
      group: 'quota.miloapis.com',
      kind: 'ResourceGrantList',
      version: 'v1alpha1',
    },
  ],
  'x-kubernetes-selectable-fields': [
    {
      fieldPath: 'spec.consumerRef.kind',
    },
    {
      fieldPath: 'spec.consumerRef.name',
    },
  ],
} as const;

export const com_miloapis_quota_v1alpha1_ResourceRegistrationSchema = {
  description: `ResourceRegistration enables quota tracking for a specific resource type.
Administrators create registrations to define measurement units, consumer relationships,
and claiming permissions.

### How It Works
- Administrators create registrations to enable quota tracking for specific resource types
- The system validates the registration and sets the "Active" condition when ready
- ResourceGrants can then allocate capacity for the registered resource type
- ResourceClaims can consume capacity when allowed resources are created

### Core Relationships
- **ResourceGrant.spec.allowances[].resourceType** must match this registration's **spec.resourceType**
- **ResourceClaim.spec.requests[].resourceType** must match this registration's **spec.resourceType**
- **ResourceClaim.spec.consumerRef** must match this registration's **spec.consumerTypeRef** type
- **ResourceClaim.spec.resourceRef** kind must be listed in this registration's **spec.claimingResources**

### Registration Lifecycle
1. **Creation**: Administrator creates **ResourceRegistration** with resource type and consumer type
2. **Validation**: System validates that referenced resource types exist and are accessible
3. **Activation**: System sets \`Active=True\` condition when validation passes
4. **Operation**: **ResourceGrants** and **ResourceClaims** can reference the active registration
5. **Updates**: Only mutable fields (\`description\`, \`claimingResources\`) can be changed

### Status Conditions
- **Active=True**: Registration is validated and operational; grants and claims can use it
- **Active=False, reason=ValidationFailed**: Configuration errors prevent activation (check message)
- **Active=False, reason=RegistrationPending**: Quota system is processing the registration

### Measurement Types
- **Entity registrations** (\`spec.type=Entity\`): Count discrete resource instances (**Projects**, **Users**)
- **Allocation registrations** (\`spec.type=Allocation\`): Measure capacity amounts (CPU, memory, storage)

### Field Constraints and Limits
- Maximum 20 entries in **spec.claimingResources**
- **spec.resourceType**, **spec.consumerTypeRef**, and **spec.type** are immutable after creation
- **spec.description** maximum 500 characters
- **spec.baseUnit** and **spec.displayUnit** maximum 50 characters each
- **spec.unitConversionFactor** minimum value is 1

### Selectors and Filtering
- **Field selectors**: spec.consumerTypeRef.kind, spec.consumerTypeRef.apiGroup, spec.resourceType
- **Recommended labels** (add manually):
  - quota.miloapis.com/resource-kind: Project
  - quota.miloapis.com/resource-apigroup: resourcemanager.miloapis.com
  - quota.miloapis.com/consumer-kind: Organization

### Security Considerations
- Only include trusted resource types in **spec.claimingResources**
- Registrations are cluster-scoped and affect quota system-wide
- Consumer types must have appropriate RBAC permissions to create claims`,
  type: 'object',
  required: ['spec'],
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
      type: 'string',
    },
    kind: {
      description:
        'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    metadata: {
      description:
        "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta',
        },
      ],
    },
    spec: {
      description: 'ResourceRegistrationSpec defines the desired state of ResourceRegistration.',
      type: 'object',
      required: [
        'baseUnit',
        'consumerTypeRef',
        'displayUnit',
        'resourceType',
        'type',
        'unitConversionFactor',
      ],
      properties: {
        baseUnit: {
          description: `BaseUnit defines the internal measurement unit for all quota calculations.
The system stores and processes all quota amounts using this unit.
Use singular form with lowercase letters. Maximum 50 characters.

Examples:
- "project" (for Entity type tracking Projects)
- "millicore" (for CPU allocation)
- "byte" (for storage or memory)
- "user" (for Entity type tracking Users)`,
          type: 'string',
          maxLength: 50,
        },
        claimingResources: {
          description: `ClaimingResources specifies which resource types can create ResourceClaims for this registration.
Only resources listed here can trigger quota consumption for this resource type.
Empty list means no resources can claim quota (administrators must create claims manually).
Maximum 20 entries.

The quota system monitors these resource types for automatic owner reference creation.
Uses unversioned references (APIGroup + Kind) to survive API version changes.

Security consideration: Only include resource types that should consume this quota.
For example, when registering **Projects**, only include **Project** as a claiming resource
to prevent other resource types from consuming **Project** quota.`,
          type: 'array',
          maxItems: 20,
          items: {
            description: `ClaimingResource identifies a resource type that can create **ResourceClaims**
for this registration. Uses unversioned references to remain valid across API version changes.`,
            type: 'object',
            required: ['kind'],
            properties: {
              apiGroup: {
                description: `APIGroup specifies the API group of the resource that can create claims.
Use empty string for Kubernetes core resources (**Pod**, **Service**, etc.).
Use full group name for custom resources.

Examples:
- \`""\` (core resources like **Pod**, **Namespace**)
- \`apps\` (Kubernetes apps group)
- \`resourcemanager.miloapis.com\` (custom resource group)`,
                type: 'string',
                pattern: '^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$',
              },
              kind: {
                description: `Kind specifies the resource type that can create **ResourceClaims** for this registration.
Must match an existing resource type. Maximum 63 characters.

Examples:
- \`Project\` (**Project** resource creating claims for **Project** quota)
- \`User\` (**User** resource creating claims for **User** quota)
- \`Organization\` (**Organization** resource creating claims for **Organization** quota)`,
                type: 'string',
                maxLength: 63,
                minLength: 1,
              },
            },
          },
        },
        consumerTypeRef: {
          description: `ConsumerTypeRef specifies which resource type receives grants and creates claims for this registration.
The consumer type must exist in the cluster before creating the registration.

Example: When registering "Projects per Organization", set \`ConsumerTypeRef\` to **Organization**
(apiGroup: \`resourcemanager.miloapis.com\`, kind: \`Organization\`). **Organizations** then
receive **ResourceGrants** allocating **Project** quota and create **ResourceClaims** when **Projects** are created.`,
          type: 'object',
          required: ['apiGroup', 'kind'],
          properties: {
            apiGroup: {
              description: `APIGroup specifies the API group of the quota consumer resource type.
Use empty string for Kubernetes core resources (**Pod**, **Service**, etc.).
Use full group name for custom resources (for example, \`resourcemanager.miloapis.com\`).
Must follow DNS subdomain format with lowercase letters, numbers, and hyphens.

Examples:
- \`resourcemanager.miloapis.com\` (**Organizations**, **Projects**)
- \`iam.miloapis.com\` (**Users**, **Groups**)
- \`infrastructure.miloapis.com\` (custom infrastructure resources)`,
              type: 'string',
              pattern: '^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$',
            },
            kind: {
              description: `Kind specifies the resource type that receives quota grants and creates quota claims.
Must match an existing Kubernetes resource type (core or custom).
Use the exact Kind name as defined in the resource's schema.

Examples:
- **Organization** (receives **Project** quotas)
- **Project** (receives **User** quotas)
- **User** (receives resource quotas within projects)`,
              type: 'string',
            },
          },
        },
        description: {
          description: `Description provides human-readable context about what this registration tracks.
Use clear, specific language that explains the resource type and measurement approach.
Maximum 500 characters.

Examples:
- "Projects created within Organizations"
- "CPU millicores allocated to Pods"
- "Storage bytes claimed by PersistentVolumeClaims"`,
          type: 'string',
          minLength: 1,
        },
        displayUnit: {
          description: `DisplayUnit defines the unit shown in user interfaces and API responses.
Should be more human-readable than BaseUnit. Use singular form. Maximum 50 characters.

Examples:
- "project" (same as BaseUnit when no conversion needed)
- "core" (for displaying CPU instead of millicores)
- "GiB" (for displaying memory/storage instead of bytes)
- "TB" (for large storage volumes)`,
          type: 'string',
          maxLength: 50,
        },
        resourceType: {
          description: `ResourceType identifies the resource to track with quota.
Platform administrators define resource type identifiers that make sense for their
quota system usage. This field is immutable after creation.

The identifier format is flexible to accommodate various naming conventions
and organizational needs. Service providers can use any meaningful identifier.

Examples:
- "resourcemanager.miloapis.com/projects"
- "iam.miloapis.com/users"
- "compute_cpu"
- "storage.volumes"
- "custom-service-quota"`,
          type: 'string',
          maxLength: 253,
          minLength: 1,
        },
        type: {
          description: `Type specifies the measurement method for quota tracking.
This field is immutable after creation.

Valid values:
- \`Entity\`: Counts discrete resource instances. Use for resources where each instance
  consumes exactly 1 quota unit (for example, **Projects**, **Users**, **Databases**).
  Claims always request integer quantities.
- \`Allocation\`: Measures numeric capacity or resource amounts. Use for resources
  with variable consumption (for example, CPU millicores, memory bytes, storage capacity).
  Claims can request fractional amounts based on resource specifications.`,
          type: 'string',
          enum: ['Entity', 'Allocation'],
        },
        unitConversionFactor: {
          description: `UnitConversionFactor converts BaseUnit values to DisplayUnit values for presentation.
Must be a positive integer. Minimum value is 1 (no conversion).

Formula: displayValue = baseValue / unitConversionFactor

Examples:
- 1 (no conversion: "project" to "project")
- 1000 (millicores to cores: 2000 millicores displays as 2 cores)
- 1073741824 (bytes to GiB: 2147483648 bytes displays as 2 GiB)
- 1000000000000 (bytes to TB: 2000000000000 bytes displays as 2 TB)`,
          type: 'integer',
          format: 'int64',
          minimum: 1,
        },
      },
    },
    status: {
      description: `ResourceRegistrationStatus reports the registration's operational state and processing status.
The system updates status conditions to indicate whether the registration is active and
usable for quota operations.`,
      type: 'object',
      properties: {
        conditions: {
          description: `Conditions represents the latest available observations of the registration's state.
The system sets these conditions to communicate operational status.

Standard condition types:
- "Active": Indicates whether the registration is operational. When True, ResourceGrants
  and ResourceClaims can reference this registration. When False, quota operations are blocked.

Standard condition reasons for "Active":
- "RegistrationActive": Registration is validated and operational
- "ValidationFailed": Specification contains errors (see message for details)
- "RegistrationPending": Registration is being processed`,
          type: 'array',
          items: {
            description:
              'Condition contains details for one aspect of the current state of this API Resource.',
            type: 'object',
            required: ['lastTransitionTime', 'message', 'reason', 'status', 'type'],
            properties: {
              lastTransitionTime: {
                description: `lastTransitionTime is the last time the condition transitioned from one status to another.
This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.`,
                type: 'string',
                format: 'date-time',
              },
              message: {
                description: `message is a human readable message indicating details about the transition.
This may be an empty string.`,
                type: 'string',
                maxLength: 32768,
              },
              observedGeneration: {
                description: `observedGeneration represents the .metadata.generation that the condition was set based upon.
For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
with respect to the current state of the instance.`,
                type: 'integer',
                format: 'int64',
                minimum: 0,
              },
              reason: {
                description: `reason contains a programmatic identifier indicating the reason for the condition's last transition.
Producers of specific condition types may define expected values and meanings for this field,
and whether the values are considered a guaranteed API.
The value should be a CamelCase string.
This field may not be empty.`,
                type: 'string',
                maxLength: 1024,
                minLength: 1,
                pattern: '^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$',
              },
              status: {
                description: 'status of the condition, one of True, False, Unknown.',
                type: 'string',
                enum: ['True', 'False', 'Unknown'],
              },
              type: {
                description: 'type of condition in CamelCase or in foo.example.com/CamelCase.',
                type: 'string',
                maxLength: 316,
                pattern:
                  '^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$',
              },
            },
          },
          'x-kubernetes-validations': [
            {
              rule: "self.all(c, c.type == 'Active' ? c.reason in ['RegistrationActive', 'ValidationFailed', 'RegistrationPending'] : true)",
              message: 'Active condition reason must be valid',
            },
          ],
        },
        observedGeneration: {
          description: `ObservedGeneration indicates the most recent spec generation that the system has processed.
When ObservedGeneration matches metadata.generation, the status reflects the current spec.
When ObservedGeneration is lower, the system is still processing recent changes.`,
          type: 'integer',
          format: 'int64',
        },
      },
    },
  },
  'x-kubernetes-group-version-kind': [
    {
      group: 'quota.miloapis.com',
      kind: 'ResourceRegistration',
      version: 'v1alpha1',
    },
  ],
  'x-kubernetes-selectable-fields': [
    {
      fieldPath: 'spec.consumerTypeRef.kind',
    },
    {
      fieldPath: 'spec.consumerTypeRef.apiGroup',
    },
    {
      fieldPath: 'spec.resourceType',
    },
  ],
  'x-kubernetes-validations': [
    {
      rule: '!has(oldSelf.spec.resourceType) || self.spec.resourceType == oldSelf.spec.resourceType',
      message: 'spec.resourceType is immutable',
    },
    {
      rule: '!has(oldSelf.spec.consumerTypeRef) || self.spec.consumerTypeRef == oldSelf.spec.consumerTypeRef',
      message: 'spec.consumerTypeRef is immutable',
    },
    {
      rule: '!has(oldSelf.spec.type) || self.spec.type == oldSelf.spec.type',
      message: 'spec.type is immutable',
    },
  ],
} as const;

export const com_miloapis_quota_v1alpha1_ResourceRegistrationListSchema = {
  description: 'ResourceRegistrationList is a list of ResourceRegistration',
  type: 'object',
  required: ['items'],
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
      type: 'string',
    },
    items: {
      description:
        'List of resourceregistrations. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md',
      type: 'array',
      items: {
        $ref: '#/components/schemas/com.miloapis.quota.v1alpha1.ResourceRegistration',
      },
    },
    kind: {
      description:
        'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    metadata: {
      description:
        'Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta',
        },
      ],
    },
  },
  'x-kubernetes-group-version-kind': [
    {
      group: 'quota.miloapis.com',
      kind: 'ResourceRegistrationList',
      version: 'v1alpha1',
    },
  ],
  'x-kubernetes-selectable-fields': [
    {
      fieldPath: 'spec.consumerTypeRef.kind',
    },
    {
      fieldPath: 'spec.consumerTypeRef.apiGroup',
    },
    {
      fieldPath: 'spec.resourceType',
    },
  ],
} as const;

export const io_k8s_apimachinery_pkg_apis_meta_v1_DeleteOptionsSchema = {
  description: 'DeleteOptions may be provided when deleting an API object.',
  type: 'object',
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
      type: 'string',
    },
    dryRun: {
      description:
        'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
      type: 'array',
      items: {
        type: 'string',
        default: '',
      },
      'x-kubernetes-list-type': 'atomic',
    },
    gracePeriodSeconds: {
      description:
        'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
      type: 'integer',
      format: 'int64',
    },
    ignoreStoreReadErrorWithClusterBreakingPotential: {
      description:
        'if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it',
      type: 'boolean',
    },
    kind: {
      description:
        'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    orphanDependents: {
      description: `Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.`,
      type: 'boolean',
    },
    preconditions: {
      description:
        'Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be returned.',
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions',
        },
      ],
    },
    propagationPolicy: {
      description:
        "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
      type: 'string',
    },
  },
  'x-kubernetes-group-version-kind': [
    {
      group: '',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'admissionregistration.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'admissionregistration.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1alpha1',
    },
    {
      group: 'admissionregistration.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'apps',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'apps',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'apps',
      kind: 'DeleteOptions',
      version: 'v1beta2',
    },
    {
      group: 'authentication.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'authentication.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1alpha1',
    },
    {
      group: 'authentication.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'authorization.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'authorization.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'autoscaling',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'autoscaling',
      kind: 'DeleteOptions',
      version: 'v2',
    },
    {
      group: 'autoscaling',
      kind: 'DeleteOptions',
      version: 'v2beta1',
    },
    {
      group: 'autoscaling',
      kind: 'DeleteOptions',
      version: 'v2beta2',
    },
    {
      group: 'batch',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'batch',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'certificates.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'certificates.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1alpha1',
    },
    {
      group: 'certificates.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'coordination.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'coordination.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1alpha2',
    },
    {
      group: 'coordination.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'discovery.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'discovery.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'events.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'events.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'extensions',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'flowcontrol.apiserver.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'flowcontrol.apiserver.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'flowcontrol.apiserver.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta2',
    },
    {
      group: 'flowcontrol.apiserver.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta3',
    },
    {
      group: 'internal.apiserver.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1alpha1',
    },
    {
      group: 'networking.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'networking.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1alpha1',
    },
    {
      group: 'networking.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'node.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'node.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1alpha1',
    },
    {
      group: 'node.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'policy',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'policy',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'rbac.authorization.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'rbac.authorization.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1alpha1',
    },
    {
      group: 'rbac.authorization.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'resource.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1alpha3',
    },
    {
      group: 'resource.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'scheduling.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'scheduling.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1alpha1',
    },
    {
      group: 'scheduling.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'storage.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1',
    },
    {
      group: 'storage.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1alpha1',
    },
    {
      group: 'storage.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1beta1',
    },
    {
      group: 'storagemigration.k8s.io',
      kind: 'DeleteOptions',
      version: 'v1alpha1',
    },
  ],
} as const;

export const io_k8s_apimachinery_pkg_apis_meta_v1_FieldsV1Schema = {
  description: `FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.

Each key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:<name>', where <name> is the name of a field in a struct, or key in a map 'v:<value>', where <value> is the exact json formatted value of a list item 'i:<index>', where <index> is position of a item in a list 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.

The exact format is defined in sigs.k8s.io/structured-merge-diff`,
  type: 'object',
} as const;

export const io_k8s_apimachinery_pkg_apis_meta_v1_ListMetaSchema = {
  description:
    'ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.',
  type: 'object',
  properties: {
    continue: {
      description:
        'continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.',
      type: 'string',
    },
    remainingItemCount: {
      description:
        'remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.',
      type: 'integer',
      format: 'int64',
    },
    resourceVersion: {
      description:
        "String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
      type: 'string',
    },
    selfLink: {
      description:
        'Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.',
      type: 'string',
    },
  },
} as const;

export const io_k8s_apimachinery_pkg_apis_meta_v1_ManagedFieldsEntrySchema = {
  description:
    'ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.',
  type: 'object',
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.',
      type: 'string',
    },
    fieldsType: {
      description:
        'FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"',
      type: 'string',
    },
    fieldsV1: {
      description:
        'FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.',
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.FieldsV1',
        },
      ],
    },
    manager: {
      description: 'Manager is an identifier of the workflow managing these fields.',
      type: 'string',
    },
    operation: {
      description:
        "Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.",
      type: 'string',
    },
    subresource: {
      description:
        'Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.',
      type: 'string',
    },
    time: {
      description:
        'Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.',
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time',
        },
      ],
    },
  },
} as const;

export const io_k8s_apimachinery_pkg_apis_meta_v1_ObjectMetaSchema = {
  description:
    'ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.',
  type: 'object',
  properties: {
    annotations: {
      description:
        'Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations',
      type: 'object',
      additionalProperties: {
        type: 'string',
        default: '',
      },
    },
    creationTimestamp: {
      description: `CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.

Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata`,
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time',
        },
      ],
    },
    deletionGracePeriodSeconds: {
      description:
        'Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.',
      type: 'integer',
      format: 'int64',
    },
    deletionTimestamp: {
      description: `DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.

Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata`,
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time',
        },
      ],
    },
    finalizers: {
      description:
        'Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.',
      type: 'array',
      items: {
        type: 'string',
        default: '',
      },
      'x-kubernetes-list-type': 'set',
      'x-kubernetes-patch-strategy': 'merge',
    },
    generateName: {
      description: `GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.

If this field is specified and the generated name exists, the server will return a 409.

Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency`,
      type: 'string',
    },
    generation: {
      description:
        'A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.',
      type: 'integer',
      format: 'int64',
    },
    labels: {
      description:
        'Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels',
      type: 'object',
      additionalProperties: {
        type: 'string',
        default: '',
      },
    },
    managedFields: {
      description: `ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.`,
      type: 'array',
      items: {
        default: {},
        allOf: [
          {
            $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry',
          },
        ],
      },
      'x-kubernetes-list-type': 'atomic',
    },
    name: {
      description:
        'Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names',
      type: 'string',
    },
    namespace: {
      description: `Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.

Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces`,
      type: 'string',
    },
    ownerReferences: {
      description:
        'List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.',
      type: 'array',
      items: {
        default: {},
        allOf: [
          {
            $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference',
          },
        ],
      },
      'x-kubernetes-list-map-keys': ['uid'],
      'x-kubernetes-list-type': 'map',
      'x-kubernetes-patch-merge-key': 'uid',
      'x-kubernetes-patch-strategy': 'merge',
    },
    resourceVersion: {
      description: `An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.

Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency`,
      type: 'string',
    },
    selfLink: {
      description:
        'Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.',
      type: 'string',
    },
    uid: {
      description: `UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.

Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids`,
      type: 'string',
    },
  },
} as const;

export const io_k8s_apimachinery_pkg_apis_meta_v1_OwnerReferenceSchema = {
  description:
    'OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.',
  type: 'object',
  required: ['apiVersion', 'kind', 'name', 'uid'],
  properties: {
    apiVersion: {
      description: 'API version of the referent.',
      type: 'string',
      default: '',
    },
    blockOwnerDeletion: {
      description:
        'If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.',
      type: 'boolean',
    },
    controller: {
      description: 'If true, this reference points to the managing controller.',
      type: 'boolean',
    },
    kind: {
      description:
        'Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
      default: '',
    },
    name: {
      description:
        'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names',
      type: 'string',
      default: '',
    },
    uid: {
      description:
        'UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids',
      type: 'string',
      default: '',
    },
  },
  'x-kubernetes-map-type': 'atomic',
} as const;

export const io_k8s_apimachinery_pkg_apis_meta_v1_PatchSchema = {
  description:
    'Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.',
  type: 'object',
} as const;

export const io_k8s_apimachinery_pkg_apis_meta_v1_PreconditionsSchema = {
  description:
    'Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.',
  type: 'object',
  properties: {
    resourceVersion: {
      description: 'Specifies the target ResourceVersion',
      type: 'string',
    },
    uid: {
      description: 'Specifies the target UID.',
      type: 'string',
    },
  },
} as const;

export const io_k8s_apimachinery_pkg_apis_meta_v1_StatusSchema = {
  description: "Status is a return value for calls that don't return other objects.",
  type: 'object',
  properties: {
    apiVersion: {
      description:
        'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
      type: 'string',
    },
    code: {
      description: 'Suggested HTTP return code for this status, 0 if not set.',
      type: 'integer',
      format: 'int32',
    },
    details: {
      description:
        'Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.',
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails',
        },
      ],
      'x-kubernetes-list-type': 'atomic',
    },
    kind: {
      description:
        'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    message: {
      description: 'A human-readable description of the status of this operation.',
      type: 'string',
    },
    metadata: {
      description:
        'Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      default: {},
      allOf: [
        {
          $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta',
        },
      ],
    },
    reason: {
      description:
        'A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.',
      type: 'string',
    },
    status: {
      description:
        'Status of the operation. One of: "Success" or "Failure". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status',
      type: 'string',
    },
  },
  'x-kubernetes-group-version-kind': [
    {
      group: '',
      kind: 'Status',
      version: 'v1',
    },
  ],
} as const;

export const io_k8s_apimachinery_pkg_apis_meta_v1_StatusCauseSchema = {
  description:
    'StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.',
  type: 'object',
  properties: {
    field: {
      description: `The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.

Examples:
  "name" - the field "name" on the current resource
  "items[0].name" - the field "name" on the first array entry in "items"`,
      type: 'string',
    },
    message: {
      description:
        'A human-readable description of the cause of the error.  This field may be presented as-is to a reader.',
      type: 'string',
    },
    reason: {
      description:
        'A machine-readable description of the cause of the error. If this value is empty there is no information available.',
      type: 'string',
    },
  },
} as const;

export const io_k8s_apimachinery_pkg_apis_meta_v1_StatusDetailsSchema = {
  description:
    'StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.',
  type: 'object',
  properties: {
    causes: {
      description:
        'The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.',
      type: 'array',
      items: {
        default: {},
        allOf: [
          {
            $ref: '#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause',
          },
        ],
      },
      'x-kubernetes-list-type': 'atomic',
    },
    group: {
      description: 'The group attribute of the resource associated with the status StatusReason.',
      type: 'string',
    },
    kind: {
      description:
        'The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
      type: 'string',
    },
    name: {
      description:
        'The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).',
      type: 'string',
    },
    retryAfterSeconds: {
      description:
        'If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.',
      type: 'integer',
      format: 'int32',
    },
    uid: {
      description:
        'UID of the resource. (when there is a single resource which can be described). More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids',
      type: 'string',
    },
  },
} as const;

export const io_k8s_apimachinery_pkg_apis_meta_v1_TimeSchema = {
  description:
    'Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.',
  type: 'string',
  format: 'date-time',
} as const;
