// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseURL: `${string}://${string}` | (string & {});
};

/**
 * **AllowanceBucket** aggregates quota limits and usage for a single (consumer, resourceType) combination.
 * The system automatically creates buckets to provide real-time quota availability information
 * for **ResourceClaim** evaluation during admission.
 *
 * ### How It Works
 * 1. **Auto-Creation**: Quota system creates buckets automatically for each unique (consumer, resourceType) pair found in active **ResourceGrants**
 * 2. **Aggregation**: Quota system continuously aggregates capacity from active **ResourceGrants** and consumption from granted **ResourceClaims**
 * 3. **Decision Support**: Quota system uses bucket `status.available` to determine if **ResourceClaims** can be granted
 * 4. **Updates**: Quota system updates bucket status whenever contributing grants or claims change
 *
 * ### Aggregation Logic
 * **AllowanceBuckets** serve as the central aggregation point where quota capacity meets quota consumption.
 * The quota system continuously scans for **ResourceGrants** that match both the bucket's consumer
 * and resource type, but only considers grants with an `Active` status condition. For each qualifying
 * grant, the quota system examines all allowances targeting the bucket's resource type and sums the
 * amounts from every bucket within those allowances. This sum becomes the bucket's limit - the total
 * quota capacity available to the consumer for that specific resource type.
 *
 * Simultaneously, the quota system tracks quota consumption by finding all **ResourceClaims** with matching
 * consumer and resource type specifications. However, only claims that have been successfully granted
 * contribute to the allocated total. The quota system sums the allocated amounts from all granted
 * requests, creating a running total of consumed quota capacity.
 *
 * The available quota emerges from this simple relationship: Available = Limit - Allocated. The
 * system ensures this value never goes negative, treating any calculated negative as zero. This
 * available amount represents the quota capacity remaining for new **ResourceClaims** and drives
 * real-time admission decisions throughout the cluster.
 *
 * ### Real-Time Admission Decisions
 * When a **ResourceClaim** is created:
 * 1. Quota system identifies the relevant bucket (matching consumer and resource type)
 * 2. Compares requested amount with bucket's `status.available`
 * 3. Grants claim if requested amount <= available capacity
 * 4. Denies claim if requested amount > available capacity
 * 5. Updates bucket status to reflect the new allocation (if granted)
 *
 * ### Bucket Lifecycle
 * 1. **Auto-Created**: When first ResourceGrant creates allowance for (consumer, resourceType)
 * 2. **Active**: Continuously aggregated while ResourceGrants or ResourceClaims exist
 * 3. **Updated**: Status refreshed whenever contributing resources change
 * 4. **Persistent**: Buckets remain even when limit drops to 0 (for monitoring)
 *
 * ### Consistency and Performance
 * **Eventual Consistency:**
 * - Status may lag briefly after ResourceGrant or ResourceClaim changes
 * - Controller processes updates asynchronously for performance
 * - LastReconciliation timestamp indicates data freshness
 *
 * **Scale Optimization:**
 * - Stores aggregates (limit, allocated, available) rather than individual entries
 * - ContributingGrantRefs tracks grants (few) but not claims (many)
 * - Single bucket per (consumer, resourceType) regardless of claim count
 *
 * ### Status Information
 * - **Limit**: Total quota capacity from all contributing ResourceGrants
 * - **Allocated**: Total quota consumed by all granted ResourceClaims
 * - **Available**: Remaining quota capacity (Limit - Allocated)
 * - **ClaimCount**: Number of granted claims consuming from this bucket
 * - **GrantCount**: Number of active grants contributing to this bucket
 * - **ContributingGrantRefs**: Detailed information about contributing grants
 *
 * ### Monitoring and Troubleshooting
 * **Quota Monitoring:**
 * - Monitor status.available to track quota usage trends
 * - Check status.allocated vs status.limit for utilization ratios
 * - Use status.claimCount to understand resource creation patterns
 *
 * **Troubleshooting Issues:**
 * When investigating quota problems, start with the bucket's limit value. A limit of zero typically
 * indicates that no ResourceGrants are contributing capacity for this consumer and resource type
 * combination. Verify that ResourceGrants exist with matching consumer and resource type specifications,
 * and confirm their status conditions show Active=True. Grants with validation failures or pending
 * states won't contribute to bucket limits.
 *
 * High allocation values relative to limits suggest quota consumption issues. Review the ResourceClaims
 * that match this bucket's consumer and resource type to identify which resources are consuming large
 * amounts of quota. Check the claim allocation details to understand consumption patterns and identify
 * potential quota leaks where claims aren't being cleaned up properly.
 *
 * Stale bucket data manifests as allocation or limit values that don't reflect recent changes to
 * grants or claims. Check the lastReconciliation timestamp to determine data freshness, then examine
 * quota system logs for aggregation errors or performance issues. The quota system should process
 * changes within seconds under normal conditions.
 *
 * ### System Architecture
 * - **Single Writer**: Only the quota system updates bucket status (prevents races)
 * - **Dedicated Processing**: Separate components focus solely on bucket aggregation
 * - **Event-Driven**: Responds to ResourceGrant and ResourceClaim changes
 * - **Efficient Queries**: Uses indexes and field selectors for fast aggregation
 *
 * ### Selectors and Filtering
 * - **Field selectors**: spec.consumerRef.kind, spec.consumerRef.name, spec.resourceType
 * - **System labels** (set automatically by quota system):
 * - quota.miloapis.com/consumer-kind: Organization
 * - quota.miloapis.com/consumer-name: acme-corp
 *
 * ### Common Queries
 * - All buckets for a consumer: label selector quota.miloapis.com/consumer-kind + quota.miloapis.com/consumer-name
 * - All buckets for a resource type: field selector spec.resourceType=<value>
 * - Specific bucket: field selector spec.consumerRef.name + spec.resourceType
 * - Overutilized buckets: filter by status.available < threshold
 * - Empty buckets: filter by status.limit = 0
 *
 * ### Performance Considerations
 * - Bucket status updates are asynchronous and may lag resource changes
 * - Large numbers of ResourceClaims can impact aggregation performance
 * - Controller uses efficient aggregation queries to handle scale
 * - Status updates are batched to reduce API server load
 */
export type ComMiloapisQuotaV1Alpha1AllowanceBucket = {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   */
  metadata?: IoK8sApimachineryPkgApisMetaV1ObjectMeta;
  /**
   * AllowanceBucketSpec defines the desired state of AllowanceBucket.
   * The system automatically creates buckets for each unique (consumer, resourceType) combination
   * found in active ResourceGrants.
   */
  spec: {
    /**
     * ConsumerRef identifies the quota consumer tracked by this bucket.
     * Must match the ConsumerRef from ResourceGrants that contribute to this bucket.
     * Only one bucket exists per unique (ConsumerRef, ResourceType) combination.
     *
     * Examples:
     * - Organization "acme-corp" consuming Project quota
     * - Project "web-app" consuming User quota
     * - Organization "enterprise-corp" consuming storage quota
     */
    consumerRef: {
      /**
       * APIGroup specifies the API group of the consumer resource.
       * Use full group name for Milo resources.
       *
       * Examples:
       * - "resourcemanager.miloapis.com" (Organization/Project resources)
       * - "iam.miloapis.com" (User/Group resources)
       * - "infrastructure.miloapis.com" (infrastructure resources)
       */
      apiGroup?: string;
      /**
       * Kind specifies the type of consumer resource.
       * Must match an existing Kubernetes resource type that can receive quota grants.
       *
       * Common consumer types:
       * - "Organization" (top-level quota consumer)
       * - "Project" (project-level quota consumer)
       * - "User" (user-level quota consumer)
       */
      kind: string;
      /**
       * Name identifies the specific consumer resource instance.
       * Must match the name of an existing consumer resource in the cluster.
       *
       * Examples:
       * - "acme-corp" (Organization name)
       * - "web-application" (Project name)
       * - "john.doe" (User name)
       */
      name: string;
      /**
       * Namespace identifies the namespace of the consumer resource.
       * Required for namespaced consumer resources (e.g., Projects).
       * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
       *
       * Examples:
       * - "" (empty for cluster-scoped Organizations)
       * - "organization-acme-corp" (namespace for Projects within an organization)
       * - "project-web-app" (namespace for resources within a project)
       */
      namespace?: string;
    };
    /**
     * ResourceType specifies which resource type this bucket aggregates quota for.
     * Must exactly match a ResourceRegistration.spec.resourceType that is currently active.
     * The quota system validates this reference and only creates buckets for registered types.
     *
     * The identifier format is flexible, as defined by platform administrators
     * in their ResourceRegistrations.
     *
     * Examples:
     * - "resourcemanager.miloapis.com/projects"
     * - "compute_cpu"
     * - "storage.volumes"
     * - "custom-service-quota"
     */
    resourceType: string;
  };
  /**
   * AllowanceBucketStatus contains the quota system-computed quota aggregation for a specific
   * (consumer, resourceType) combination. The quota system continuously updates this status
   * by aggregating capacity from active ResourceGrants and consumption from granted ResourceClaims.
   */
  status?: {
    /**
     * Allocated represents the total quota currently consumed by granted ResourceClaims.
     * Calculated by summing all allocation amounts from ResourceClaims with status.conditions[type=Granted]=True
     * that match the bucket's spec.consumerRef and have requests for spec.resourceType.
     *
     * Aggregation logic:
     * - Only ResourceClaims with Granted=True contribute to allocated amount
     * - Only requests matching spec.resourceType are included
     * - All allocated amounts from matching requests are summed
     */
    allocated: bigint;
    /**
     * Available represents the quota capacity remaining for new ResourceClaims.
     * Always calculated as: Available = Limit - Allocated (never negative).
     * The system uses this value to determine whether new ResourceClaims can be granted.
     *
     * Decision logic:
     * - ResourceClaim is granted if requested amount <= Available
     * - ResourceClaim is denied if requested amount > Available
     * - Multiple concurrent claims may race; first to be processed wins
     */
    available: bigint;
    /**
     * ClaimCount indicates the total number of granted ResourceClaims consuming quota from this bucket.
     * Includes all ResourceClaims with status.conditions[type=Granted]=True that have requests
     * matching spec.resourceType and spec.consumerRef.
     *
     * Used for monitoring quota usage patterns and identifying potential issues.
     */
    claimCount: number;
    /**
     * ContributingGrantRefs provides detailed information about each ResourceGrant that contributes
     * to this bucket's limit. Includes grant names, amounts, and last observed generations for
     * tracking and debugging quota sources.
     *
     * This field provides visibility into:
     * - Which grants are providing quota capacity
     * - How much each grant contributes
     * - Whether grants have been updated since last bucket calculation
     *
     * Grants are tracked individually because they are typically few in number compared to claims.
     */
    contributingGrantRefs?: Array<{
      /**
       * Amount specifies how much quota capacity this grant contributes to the bucket.
       * Represents the sum of all buckets within all allowances for the matching
       * resource type in the referenced grant. Measured in BaseUnit.
       */
      amount: bigint;
      /**
       * LastObservedGeneration records the ResourceGrant's generation when the bucket
       * quota system last processed it. Used to detect when grants have been updated
       * and the bucket needs to recalculate its aggregated limit.
       */
      lastObservedGeneration: bigint;
      /**
       * Name identifies the ResourceGrant that contributes to this bucket's limit.
       * Used for tracking quota sources and debugging allocation issues.
       */
      name: string;
    }>;
    /**
     * GrantCount indicates the total number of active ResourceGrants contributing to this bucket's limit.
     * Includes all ResourceGrants with status.conditions[type=Active]=True that have allowances
     * matching spec.resourceType and spec.consumerRef.
     *
     * Used for understanding quota source distribution and debugging capacity issues.
     */
    grantCount: number;
    /**
     * LastReconciliation records when the quota system last recalculated this status.
     * Used for monitoring quota system health and understanding how fresh the aggregated data is.
     *
     * The quota system updates this timestamp every time it processes the bucket, regardless of
     * whether the aggregated values changed.
     */
    lastReconciliation?: Date;
    /**
     * Limit represents the total quota capacity available for this (consumer, resourceType) combination.
     * Calculated by summing all bucket amounts from active ResourceGrants that match the bucket's
     * spec.consumerRef and spec.resourceType. Measured in BaseUnit from the ResourceRegistration.
     *
     * Aggregation logic:
     * - Only ResourceGrants with status.conditions[type=Active]=True contribute to the limit
     * - All allowances matching spec.resourceType are included from contributing grants
     * - All bucket amounts within matching allowances are summed
     */
    limit: bigint;
    /**
     * ObservedGeneration indicates the most recent spec generation the quota system has processed.
     * When ObservedGeneration matches metadata.generation, the status reflects the current spec.
     * When ObservedGeneration is lower, the quota system is still processing recent changes.
     */
    observedGeneration?: bigint;
  };
};

/**
 * AllowanceBucketList is a list of AllowanceBucket
 */
export type ComMiloapisQuotaV1Alpha1AllowanceBucketList = {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * List of allowancebuckets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
   */
  items: Array<ComMiloapisQuotaV1Alpha1AllowanceBucket>;
  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  metadata?: IoK8sApimachineryPkgApisMetaV1ListMeta;
};

/**
 * ClaimCreationPolicy automatically creates ResourceClaims during admission to enforce quota in real-time.
 * Policies intercept resource creation requests, evaluate trigger conditions, and generate
 * quota claims that prevent resource creation when quota limits are exceeded.
 *
 * ### How It Works
 * 1. **Trigger Matching**: Admission webhook matches incoming resource creates against spec.trigger.resource
 * 2. **Condition Evaluation**: All CEL expressions in spec.trigger.conditions must evaluate to true
 * 3. **Template Rendering**: Policy renders spec.target.resourceClaimTemplate using available template variables
 * 4. **Claim Creation**: System creates the rendered ResourceClaim in the specified namespace
 * 5. **Quota Evaluation**: Claim is immediately evaluated against AllowanceBucket capacity
 * 6. **Admission Decision**: Original resource creation succeeds or fails based on claim result
 *
 * ### Policy Processing Flow
 * **Enabled Policies** (spec.enabled=true):
 * 1. Admission webhook receives resource creation request
 * 2. Finds all ClaimCreationPolicies matching the resource type
 * 3. Evaluates trigger conditions for each matching policy
 * 4. Creates ResourceClaim for each policy where all conditions are true
 * 5. Evaluates all created claims against quota buckets
 * 6. Allows resource creation only if all claims are granted
 *
 * **Disabled Policies** (spec.enabled=false):
 * - Completely ignored during admission processing
 * - No conditions evaluated, no claims created
 * - Useful for temporarily disabling quota enforcement
 *
 * ### Template System
 * The template system transforms static ResourceClaim specifications into dynamic claims that reflect
 * the context of each admission request. When a policy triggers, the template engine receives rich
 * contextual information about the resource being created, the user making the request, and details
 * about the admission operation itself.
 *
 * The most important template variable is `.trigger`, which contains the complete structure of the
 * resource that triggered the policy. This includes all metadata like labels and annotations, the
 * entire spec section, and any status information if the resource already exists. You can navigate
 * this structure using standard template dot notation: `.trigger.metadata.name` gives you the
 * resource's name, while `.trigger.spec.replicas` might tell you how many instances are requested.
 *
 * Authentication context comes through the `.user` variable, providing access to the requester's
 * name, unique identifier, group memberships, and any additional attributes. This enables policies
 * to create claims that track who requested resources and potentially apply different quota rules
 * based on user attributes. The `.requestInfo` variable adds operational context like the specific
 * API verb being performed and which resource type is being manipulated.
 *
 * Template functions help transform and manipulate these values. The `default` function proves
 * particularly useful for providing fallback values when template variables might be empty.
 * String manipulation functions like `lower`, `upper`, and `trim` help normalize names and values,
 * while `replace` enables pattern substitution for complex naming schemes. For example, you might
 * use `{{default "milo-system" .trigger.metadata.namespace}}` to place claims in a system namespace
 * when the triggering resource doesn't specify one.
 *
 * ### CEL Expression System
 * CEL expressions act as the gatekeepers that determine whether a policy should create a quota claim
 * for a particular resource. These expressions have access to the same rich contextual information
 * as templates but focus on making boolean decisions rather than generating content. Each expression
 * must evaluate to either true (activate the policy) or false (skip this resource), and all expressions
 * in a policy's condition list must return true for the policy to trigger.
 *
 * The expression environment includes the triggering resource under the `trigger` variable, letting
 * you examine any field in the resource's structure. This enables sophisticated filtering based on
 * resource specifications, labels, annotations, or even status conditions. You might write
 * `trigger.spec.tier == "premium"` to only apply quota policies to premium resources, or use
 * `trigger.metadata.labels["environment"] == "prod"` to restrict enforcement to production workloads.
 *
 * User context through the `user` variable enables authorization-based policies. The expression
 * `user.groups.exists(g, g == "admin")` would limit quota enforcement to resources created by
 * administrators, while `user.name.startsWith("service-")` might target service accounts.
 * Combined with resource filtering, you can create nuanced policies that apply different quota
 * rules based on who is creating what types of resources in which contexts.
 *
 * ### Consumer Resolution
 * The system automatically resolves spec.consumerRef for created claims:
 * - Uses parent context resolution to find the appropriate consumer
 * - Typically resolves to Organization for Project resources, Project for User resources, etc.
 * - Consumer must match the ResourceRegistration.spec.consumerTypeRef for the requested resource type
 *
 * ### Validation and Dependencies
 * **Policy Validation:**
 * - Target resource type must exist and be accessible
 * - All resource types in claim template must have active ResourceRegistrations
 * - Consumer resolution must be resolvable for target resources
 * - CEL expressions and Go templates must be syntactically valid
 *
 * **Runtime Dependencies:**
 * - ResourceRegistration must be Active for each requested resource type
 * - Triggering resource kind must be listed in ResourceRegistration.spec.claimingResources
 * - AllowanceBucket must exist (created automatically when ResourceGrants are active)
 *
 * ### Policy Lifecycle
 * 1. **Creation**: Administrator creates ClaimCreationPolicy
 * 2. **Validation**: Controller validates target resource, expressions, and templates
 * 3. **Activation**: Controller sets Ready=True when validation passes
 * 4. **Operation**: Admission webhook uses active policies to create claims
 * 5. **Updates**: Changes trigger re-validation; only Ready policies are used
 *
 * ### Status Conditions
 * - **Ready=True**: Policy is validated and actively creating claims
 * - **Ready=False, reason=ValidationFailed**: Configuration errors prevent activation (check message)
 * - **Ready=False, reason=PolicyDisabled**: Policy is disabled (spec.enabled=false)
 *
 * ### Automatic Claim Features
 * Claims created by ClaimCreationPolicy include:
 * - **Standard Labels**: quota.miloapis.com/auto-created=true, quota.miloapis.com/policy=<policy-name>
 * - **Standard Annotations**: quota.miloapis.com/created-by=claim-creation-plugin, timestamps
 * - **Owner References**: Set to triggering resource when possible for lifecycle management
 * - **Cleanup**: Automatically cleaned up when denied to prevent accumulation
 *
 * ### Field Constraints and Limits
 * - Maximum 10 conditions per trigger (spec.trigger.conditions)
 * - Static amounts only in v1alpha1 (no expression-based quota amounts)
 * - Template metadata labels are literal strings (no template processing)
 * - Template annotation values support templating
 *
 * ### Selectors and Filtering
 * - **Field selectors**: spec.trigger.resource.kind, spec.trigger.resource.apiVersion, spec.enabled
 * - **Recommended labels** (add manually):
 * - quota.miloapis.com/target-kind: Project
 * - quota.miloapis.com/environment: production
 * - quota.miloapis.com/tier: premium
 *
 * ### Common Queries
 * - All policies for a resource kind: label selector quota.miloapis.com/target-kind=<kind>
 * - Enabled policies only: field selector spec.enabled=true
 * - Environment-specific policies: label selector quota.miloapis.com/environment=<env>
 * - Failed policies: filter by status.conditions[type=Ready].status=False
 *
 * ### Troubleshooting
 * - **Policy not triggering**: Check spec.enabled=true and status.conditions[type=Ready]=True
 * - **Template errors**: Review status condition message for template syntax issues
 * - **CEL expression failures**: Validate expression syntax and available variables
 * - **Claims not created**: Verify trigger conditions match the incoming resource
 * - **Consumer resolution errors**: Check parent context resolution and ResourceRegistration setup
 *
 * ### Performance Considerations
 * - Policies are evaluated synchronously during admission (affects API latency)
 * - Complex CEL expressions can impact admission performance
 * - Template rendering occurs for every matching admission request
 * - Consider using specific trigger conditions to limit policy evaluation scope
 *
 * ### Security Considerations
 * - Templates can access complete trigger resource data (sensitive field exposure)
 * - CEL expressions have access to user information and request details
 * - Only trusted administrators should create or modify policies
 * - Review template output to ensure no sensitive data leakage in claim metadata
 */
export type ComMiloapisQuotaV1Alpha1ClaimCreationPolicy = {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   */
  metadata?: IoK8sApimachineryPkgApisMetaV1ObjectMeta;
  /**
   * ClaimCreationPolicySpec defines the desired state of ClaimCreationPolicy.
   */
  spec: {
    /**
     * Enabled determines if this policy is active.
     * If false, no **ResourceClaims** will be created for matching resources.
     */
    enabled?: boolean;
    /**
     * Target defines how and where **ResourceClaims** should be created.
     */
    target: {
      /**
       * ResourceClaimTemplate defines how to create **ResourceClaims**.
       * String fields support Go template syntax for dynamic content.
       */
      resourceClaimTemplate: {
        /**
         * Metadata for the created **ResourceClaim**.
         * String fields support Go template syntax.
         */
        metadata: {
          /**
           * Annotations specifies annotations to apply to the created ResourceClaim.
           * Values support Go template syntax for dynamic content.
           * The system automatically adds standard annotations for tracking.
           *
           * Template variables available:
           * - .trigger: The resource triggering claim creation
           * - .requestInfo: Request details
           * - .user: User information
           *
           * Examples:
           * - created-for: "{{.trigger.metadata.name}}"
           * - requested-by: "{{.user.name}}"
           * - trigger-kind: "{{.trigger.kind}}"
           */
          annotations?: {
            [key: string]: string;
          };
          /**
           * GenerateName specifies a prefix for auto-generated names when Name is empty.
           * Kubernetes appends random characters to create unique names.
           * Supports Go template syntax.
           *
           * Example: "{{.trigger.spec.type}}-claim-"
           */
          generateName?: string;
          /**
           * Labels specifies static labels to apply to the created ResourceClaim.
           * Values are literal strings (no template processing).
           * The system automatically adds standard labels for policy tracking.
           *
           * Useful for:
           * - Organizing claims by policy or resource type
           * - Adding environment or tier indicators
           * - Enabling label-based queries and monitoring
           */
          labels?: {
            [key: string]: string;
          };
          /**
           * Name specifies the exact name for the created ResourceClaim.
           * Supports Go template syntax with access to template variables.
           * Leave empty to use GenerateName for auto-generated names.
           *
           * Template variables available:
           * - .trigger: The resource triggering claim creation
           * - .requestInfo: Request details (verb, resource, name, etc.)
           * - .user: User information (name, uid, groups, extra)
           *
           * Example: "{{.trigger.metadata.name}}-quota-claim"
           */
          name?: string;
          /**
           * Namespace specifies where the ResourceClaim will be created.
           * Supports Go template syntax to derive namespace from trigger resource.
           * Leave empty to create in the same namespace as the trigger resource.
           *
           * Examples:
           * - "{{.trigger.metadata.namespace}}" (same namespace as trigger)
           * - "milo-system" (fixed system namespace)
           * - "{{.trigger.spec.organization}}-claims" (derived namespace)
           */
          namespace?: string;
        };
        /**
         * Spec for the created ResourceClaim.
         * String fields support Go template syntax.
         */
        spec: {
          /**
           * ConsumerRef identifies the quota consumer making this claim. The consumer
           * must match the ConsumerTypeRef defined in the ResourceRegistration for each
           * requested resource type. The system validates this relationship during
           * claim processing.
           *
           * Examples:
           *
           * - Organization consuming Project quota
           * - Project consuming User quota
           * - Organization consuming storage quota
           */
          consumerRef: {
            /**
             * APIGroup specifies the API group of the consumer resource.
             * Use full group name for Milo resources.
             *
             * Examples:
             * - "resourcemanager.miloapis.com" (Organization/Project resources)
             * - "iam.miloapis.com" (User/Group resources)
             * - "infrastructure.miloapis.com" (infrastructure resources)
             */
            apiGroup?: string;
            /**
             * Kind specifies the type of consumer resource.
             * Must match an existing Kubernetes resource type that can receive quota grants.
             *
             * Common consumer types:
             * - "Organization" (top-level quota consumer)
             * - "Project" (project-level quota consumer)
             * - "User" (user-level quota consumer)
             */
            kind: string;
            /**
             * Name identifies the specific consumer resource instance.
             * Must match the name of an existing consumer resource in the cluster.
             *
             * Examples:
             * - "acme-corp" (Organization name)
             * - "web-application" (Project name)
             * - "john.doe" (User name)
             */
            name: string;
            /**
             * Namespace identifies the namespace of the consumer resource.
             * Required for namespaced consumer resources (e.g., Projects).
             * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
             *
             * Examples:
             * - "" (empty for cluster-scoped Organizations)
             * - "organization-acme-corp" (namespace for Projects within an organization)
             * - "project-web-app" (namespace for resources within a project)
             */
            namespace?: string;
          };
          /**
           * Requests specifies the resource types and amounts being claimed from quota.
           * Each resource type can appear only once in the requests array. Minimum 1
           * request, maximum 20 requests per claim.
           *
           * The system processes all requests as a single atomic operation: either all
           * requests are granted or all are denied.
           */
          requests: Array<{
            /**
             * Amount specifies how much quota to claim for this resource type. Must be
             * measured in the BaseUnit defined by the corresponding ResourceRegistration.
             * Must be a positive integer (minimum value is 0, but 0 means no quota
             * requested).
             *
             * For Entity registrations: Use 1 for single resource instances (1 Project, 1
             * User) For Allocation registrations: Use actual capacity amounts (2048 for
             * 2048 MB, 1000 for 1000 millicores)
             *
             * Examples:
             *
             * - 1 (claiming 1 Project)
             * - 2048 (claiming 2048 bytes of storage)
             * - 1000 (claiming 1000 CPU millicores)
             */
            amount: bigint;
            /**
             * ResourceType identifies the specific resource type being claimed. Must
             * exactly match a ResourceRegistration.spec.resourceType that is currently
             * active. The quota system validates this reference during claim processing.
             *
             * The format is defined by platform administrators when creating ResourceRegistrations.
             * Service providers can use any identifier that makes sense for their quota system usage.
             *
             * Examples:
             *
             * - "resourcemanager.miloapis.com/projects"
             * - "compute_cpu"
             * - "storage.volumes"
             * - "custom-service-quota"
             */
            resourceType: string;
          }>;
          /**
           * ResourceRef identifies the actual Kubernetes resource that triggered this
           * claim. ClaimCreationPolicy automatically populates this field during
           * admission. Uses unversioned reference (apiGroup + kind + name + namespace)
           * to remain valid across API version changes.
           *
           * The referenced resource's kind must be listed in the ResourceRegistration's
           * spec.claimingResources for the claim to be valid.
           *
           * Examples:
           *
           * - Project resource triggering Project quota claim
           * - User resource triggering User quota claim
           * - Organization resource triggering storage quota claim
           */
          resourceRef: {
            /**
             * APIGroup specifies the API group of the referenced resource.
             * Use full group name for Milo resources.
             *
             * Examples:
             * - "resourcemanager.miloapis.com" (Project, Organization)
             * - "iam.miloapis.com" (User, Group)
             * - "infrastructure.miloapis.com" (infrastructure resources)
             */
            apiGroup?: string;
            /**
             * Kind specifies the type of the referenced resource.
             * Must match an existing Kubernetes resource type.
             *
             * Examples:
             * - "Project" (Project resource that triggered quota claim)
             * - "User" (User resource that triggered quota claim)
             * - "Organization" (Organization resource that triggered quota claim)
             */
            kind: string;
            /**
             * Name identifies the specific resource instance that triggered the quota claim.
             * Used for linking claims back to their triggering resources.
             *
             * Examples:
             * - "web-app-project" (Project that triggered Project quota claim)
             * - "john.doe" (User that triggered User quota claim)
             */
            name: string;
            /**
             * Namespace specifies the namespace containing the referenced resource.
             * Required for namespaced resources, omitted for cluster-scoped resources.
             *
             * Examples:
             * - "acme-corp" (organization namespace containing Project)
             * - "team-alpha" (project namespace containing User)
             * - "" or omitted (for cluster-scoped resources like Organization)
             */
            namespace?: string;
          };
        };
      };
    };
    /**
     * Trigger defines what resource changes should trigger claim creation.
     */
    trigger: {
      /**
       * Conditions are CEL expressions that must evaluate to true for claim creation to occur.
       * Evaluated in the admission context.
       */
      conditions?: Array<{
        /**
         * Expression specifies the CEL expression to evaluate against the trigger resource.
         * Must return a boolean value (true to match, false to skip).
         * Maximum 1024 characters.
         *
         * Available variables in GrantCreationPolicy context:
         * - object: The complete resource being watched (map[string]any)
         * - object.metadata.name, object.spec.*, object.status.*, etc.
         *
         * Common expression patterns:
         * - object.spec.tier == "premium" (check resource field)
         * - object.metadata.labels["environment"] == "prod" (check labels)
         * - object.status.phase == "Active" (check status)
         * - object.metadata.namespace == "production" (check namespace)
         * - has(object.spec.quotaProfile) (check field existence)
         */
        expression: string;
        /**
         * Message provides a human-readable description explaining when this condition applies.
         * Used for documentation and debugging. Maximum 256 characters.
         *
         * Examples:
         * - "Applies only to premium tier organizations"
         * - "Matches organizations in production environment"
         * - "Triggers when quota profile is specified"
         */
        message?: string;
      }>;
      /**
       * Resource specifies which resource type triggers this policy.
       */
      resource: {
        /**
         * APIVersion of the target resource in the format "group/version".
         */
        apiVersion: string;
        /**
         * Kind is the kind of the target resource.
         */
        kind: string;
      };
    };
  };
  /**
   * ClaimCreationPolicyStatus defines the observed state of ClaimCreationPolicy.
   *
   * Status fields
   * - conditions[type=Ready]: True when the policy is validated and active.
   *
   * See also
   * - [ResourceClaim](#resourceclaim): The object created by this policy.
   */
  status?: {
    /**
     * Conditions represent the latest available observations of the policy's current state.
     */
    conditions?: Array<{
      /**
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       */
      lastTransitionTime: Date;
      /**
       * message is a human readable message indicating details about the transition.
       * This may be an empty string.
       */
      message: string;
      /**
       * observedGeneration represents the .metadata.generation that the condition was set based upon.
       * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
       * with respect to the current state of the instance.
       */
      observedGeneration?: bigint;
      /**
       * reason contains a programmatic identifier indicating the reason for the condition's last transition.
       * Producers of specific condition types may define expected values and meanings for this field,
       * and whether the values are considered a guaranteed API.
       * The value should be a CamelCase string.
       * This field may not be empty.
       */
      reason: string;
      /**
       * status of the condition, one of True, False, Unknown.
       */
      status: 'True' | 'False' | 'Unknown';
      /**
       * type of condition in CamelCase or in foo.example.com/CamelCase.
       */
      type: string;
    }>;
    /**
     * ObservedGeneration is the most recent generation observed.
     */
    observedGeneration?: bigint;
  };
};

/**
 * ClaimCreationPolicyList is a list of ClaimCreationPolicy
 */
export type ComMiloapisQuotaV1Alpha1ClaimCreationPolicyList = {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * List of claimcreationpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
   */
  items: Array<ComMiloapisQuotaV1Alpha1ClaimCreationPolicy>;
  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  metadata?: IoK8sApimachineryPkgApisMetaV1ListMeta;
};

/**
 * GrantCreationPolicy automates ResourceGrant creation when observed resources meet conditions.
 * Use it to provision quota based on resource lifecycle events and attributes.
 *
 * ### How It Works
 * - Watch the kind in `spec.trigger.resource` and evaluate all `spec.trigger.conditions[]`.
 * - When all conditions are true, render `spec.target.resourceGrantTemplate` and create a `ResourceGrant`.
 * - Optionally target a parent control plane via `spec.target.parentContext` (CEL-resolved name) for cross-cluster allocation.
 * - Templating supports variables `.trigger`, `.requestInfo`, `.user` and functions `lower`, `upper`, `title`, `default`, `contains`, `join`, `split`, `replace`, `trim`, `toInt`, `toString`.
 * - Allowances (resource types and amounts) are static in `v1alpha1`.
 *
 * ### Works With
 * - Creates [ResourceGrant](#resourcegrant) objects whose `allowances[].resourceType` must exist in a [ResourceRegistration](#resourceregistration).
 * - May target a parent control plane via `spec.target.parentContext` for cross-plane quota allocation.
 * - Policy readiness (`status.conditions[type=Ready]`) signals template/condition validity.
 *
 * ### Status
 * - `status.conditions[type=Ready]`: Policy validated and active.
 * - `status.conditions[type=ParentContextReady]`: Crossâ€‘cluster targeting is resolvable.
 * - `status.observedGeneration`: Latest spec generation processed.
 *
 * ### Selectors and Filtering
 * - Field selectors (server-side):
 * `spec.trigger.resource.kind`, `spec.trigger.resource.apiVersion`,
 * `spec.target.parentContext.kind`, `spec.target.parentContext.apiGroup`.
 * - Label selectors (add your own):
 * - `quota.miloapis.com/trigger-kind`: `Organization`
 * - `quota.miloapis.com/environment`: `prod`
 * - Common queries:
 * - All policies for a trigger kind: label selector `quota.miloapis.com/trigger-kind`.
 * - All enabled policies: field selector `spec.enabled=true`.
 *
 * ### Defaults and Limits
 * - Resource grant allowances are static (no expression-based amounts) in `v1alpha1`.
 *
 * ### Notes
 * - If `ParentContextReady=False`, verify `nameExpression` and referenced attributes.
 * - Disabled policies (`spec.enabled=false`) do not create grants.
 *
 * ### See Also
 * - [ResourceGrant](#resourcegrant): The object created by this policy.
 * - [ResourceRegistration](#resourceregistration): Resource types that grants must reference.
 * - [ClaimCreationPolicy](#claimcreationpolicy): Creates claims at admission for enforcement.
 */
export type ComMiloapisQuotaV1Alpha1GrantCreationPolicy = {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   */
  metadata?: IoK8sApimachineryPkgApisMetaV1ObjectMeta;
  /**
   * GrantCreationPolicySpec defines the desired state of GrantCreationPolicy.
   */
  spec: {
    /**
     * Enabled determines if this policy is active.
     * If false, no **ResourceGrants** will be created for matching resources.
     */
    enabled?: boolean;
    /**
     * Target defines where and how grants should be created.
     */
    target: {
      /**
       * ParentContext defines cross-control-plane targeting.
       * If specified, grants will be created in the target parent context
       * instead of the current control plane.
       */
      parentContext?: {
        /**
         * APIGroup specifies the API group of the parent context resource.
         * Must follow DNS subdomain format. Maximum 253 characters.
         *
         * Examples:
         * - "resourcemanager.miloapis.com" (for Organization parent context)
         * - "infrastructure.miloapis.com" (for Cluster parent context)
         */
        apiGroup: string;
        /**
         * Kind specifies the resource type that represents the parent context.
         * Must be a valid Kubernetes resource Kind. Maximum 63 characters.
         *
         * Examples:
         * - "Organization" (create grants in organization's parent control plane)
         * - "Cluster" (create grants in cluster's parent infrastructure)
         */
        kind: string;
        /**
         * NameExpression is a CEL expression that resolves the name of the parent context resource.
         * Must return a string value that identifies the specific parent context instance.
         * Maximum 512 characters.
         *
         * Available variables:
         * - object: The trigger resource being evaluated (complete object)
         *
         * Common expression patterns:
         * - object.spec.organization (direct field reference)
         * - object.metadata.labels["parent-org"] (label-based resolution)
         * - object.metadata.namespace.split("-")[0] (derived from namespace naming)
         *
         * Examples:
         * - "acme-corp" (literal parent name)
         * - object.spec.parentOrganization (field from trigger resource)
         * - object.metadata.labels["quota.miloapis.com/organization"] (label value)
         */
        nameExpression: string;
      };
      /**
       * ResourceGrantTemplate defines how to create **ResourceGrants**.
       * String fields support Go template syntax for dynamic content.
       */
      resourceGrantTemplate: {
        /**
         * Metadata for the created ResourceGrant.
         * String fields support Go template syntax.
         */
        metadata: {
          /**
           * Annotations specifies annotations to apply to the created ResourceClaim.
           * Values support Go template syntax for dynamic content.
           * The system automatically adds standard annotations for tracking.
           *
           * Template variables available:
           * - .trigger: The resource triggering claim creation
           * - .requestInfo: Request details
           * - .user: User information
           *
           * Examples:
           * - created-for: "{{.trigger.metadata.name}}"
           * - requested-by: "{{.user.name}}"
           * - trigger-kind: "{{.trigger.kind}}"
           */
          annotations?: {
            [key: string]: string;
          };
          /**
           * GenerateName specifies a prefix for auto-generated names when Name is empty.
           * Kubernetes appends random characters to create unique names.
           * Supports Go template syntax.
           *
           * Example: "{{.trigger.spec.type}}-claim-"
           */
          generateName?: string;
          /**
           * Labels specifies static labels to apply to the created ResourceClaim.
           * Values are literal strings (no template processing).
           * The system automatically adds standard labels for policy tracking.
           *
           * Useful for:
           * - Organizing claims by policy or resource type
           * - Adding environment or tier indicators
           * - Enabling label-based queries and monitoring
           */
          labels?: {
            [key: string]: string;
          };
          /**
           * Name specifies the exact name for the created ResourceClaim.
           * Supports Go template syntax with access to template variables.
           * Leave empty to use GenerateName for auto-generated names.
           *
           * Template variables available:
           * - .trigger: The resource triggering claim creation
           * - .requestInfo: Request details (verb, resource, name, etc.)
           * - .user: User information (name, uid, groups, extra)
           *
           * Example: "{{.trigger.metadata.name}}-quota-claim"
           */
          name?: string;
          /**
           * Namespace specifies where the ResourceClaim will be created.
           * Supports Go template syntax to derive namespace from trigger resource.
           * Leave empty to create in the same namespace as the trigger resource.
           *
           * Examples:
           * - "{{.trigger.metadata.namespace}}" (same namespace as trigger)
           * - "milo-system" (fixed system namespace)
           * - "{{.trigger.spec.organization}}-claims" (derived namespace)
           */
          namespace?: string;
        };
        /**
         * Spec for the created ResourceGrant.
         * String fields support Go template syntax.
         */
        spec: {
          /**
           * Allowances specifies the quota allocations provided by this grant.
           * Each allowance grants capacity for a specific resource type.
           * Minimum 1 allowance required, maximum 20 allowances per grant.
           *
           * All allowances in a single grant:
           * - Apply to the same consumer (spec.consumerRef)
           * - Contribute to the same AllowanceBucket for each resource type
           * - Activate and deactivate together based on the grant's status
           */
          allowances: Array<{
            /**
             * Buckets contains the quota allocations for this resource type.
             * All bucket amounts are summed to determine the total allowance.
             * Minimum 1 bucket required per allowance.
             *
             * Multiple buckets can be used for:
             * - Separating quota from different sources or tiers
             * - Managing incremental quota increases over time
             * - Tracking quota attribution for billing or reporting
             */
            buckets: Array<{
              /**
               * Amount specifies the quota capacity provided by this bucket.
               * Must be measured in the BaseUnit defined by the corresponding ResourceRegistration.
               * Must be a non-negative integer (0 is valid but provides no quota).
               *
               * Examples:
               * - 100 (providing 100 projects)
               * - 2048000 (providing 2048000 bytes = 2GB)
               * - 5000 (providing 5000 CPU millicores = 5 cores)
               */
              amount: bigint;
            }>;
            /**
             * ResourceType identifies the specific resource type receiving quota allocation.
             * Must exactly match a ResourceRegistration.spec.resourceType that is currently active.
             * The quota system validates this reference when processing the grant.
             *
             * The identifier format is flexible, as defined by platform administrators
             * in their ResourceRegistrations.
             *
             * Examples:
             * - "resourcemanager.miloapis.com/projects"
             * - "compute_cpu"
             * - "storage.volumes"
             * - "custom-service-quota"
             */
            resourceType: string;
          }>;
          /**
           * ConsumerRef identifies the quota consumer that receives these allowances.
           * The consumer type must match the ConsumerTypeRef defined in the ResourceRegistration
           * for each allowance resource type. The system validates this relationship.
           *
           * Examples:
           * - Organization receiving Project quota allowances
           * - Project receiving User quota allowances
           * - Organization receiving storage quota allowances
           */
          consumerRef: {
            /**
             * APIGroup specifies the API group of the consumer resource.
             * Use full group name for Milo resources.
             *
             * Examples:
             * - "resourcemanager.miloapis.com" (Organization/Project resources)
             * - "iam.miloapis.com" (User/Group resources)
             * - "infrastructure.miloapis.com" (infrastructure resources)
             */
            apiGroup?: string;
            /**
             * Kind specifies the type of consumer resource.
             * Must match an existing Kubernetes resource type that can receive quota grants.
             *
             * Common consumer types:
             * - "Organization" (top-level quota consumer)
             * - "Project" (project-level quota consumer)
             * - "User" (user-level quota consumer)
             */
            kind: string;
            /**
             * Name identifies the specific consumer resource instance.
             * Must match the name of an existing consumer resource in the cluster.
             *
             * Examples:
             * - "acme-corp" (Organization name)
             * - "web-application" (Project name)
             * - "john.doe" (User name)
             */
            name: string;
            /**
             * Namespace identifies the namespace of the consumer resource.
             * Required for namespaced consumer resources (e.g., Projects).
             * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
             *
             * Examples:
             * - "" (empty for cluster-scoped Organizations)
             * - "organization-acme-corp" (namespace for Projects within an organization)
             * - "project-web-app" (namespace for resources within a project)
             */
            namespace?: string;
          };
        };
      };
    };
    /**
     * Trigger defines what resource changes should trigger grant creation.
     */
    trigger: {
      /**
       * Conditions are CEL expressions that must evaluate to true for grant creation.
       * All conditions must pass for the policy to trigger.
       * The 'object' variable contains the trigger resource being evaluated.
       */
      conditions?: Array<{
        /**
         * Expression specifies the CEL expression to evaluate against the trigger resource.
         * Must return a boolean value (true to match, false to skip).
         * Maximum 1024 characters.
         *
         * Available variables in GrantCreationPolicy context:
         * - object: The complete resource being watched (map[string]any)
         * - object.metadata.name, object.spec.*, object.status.*, etc.
         *
         * Common expression patterns:
         * - object.spec.tier == "premium" (check resource field)
         * - object.metadata.labels["environment"] == "prod" (check labels)
         * - object.status.phase == "Active" (check status)
         * - object.metadata.namespace == "production" (check namespace)
         * - has(object.spec.quotaProfile) (check field existence)
         */
        expression: string;
        /**
         * Message provides a human-readable description explaining when this condition applies.
         * Used for documentation and debugging. Maximum 256 characters.
         *
         * Examples:
         * - "Applies only to premium tier organizations"
         * - "Matches organizations in production environment"
         * - "Triggers when quota profile is specified"
         */
        message?: string;
      }>;
      /**
       * Resource specifies which resource type triggers this policy.
       */
      resource: {
        /**
         * APIVersion of the trigger resource in the format "group/version".
         * For core resources, use "v1".
         */
        apiVersion: string;
        /**
         * Kind is the kind of the trigger resource.
         */
        kind: string;
      };
    };
  };
  /**
   * GrantCreationPolicyStatus defines the observed state of GrantCreationPolicy.
   *
   * Status fields
   * - conditions[type=Ready]: True when the policy is validated and active.
   * - conditions[type=ParentContextReady]: True when crossâ€‘cluster targeting is resolvable.
   * - observedGeneration: Latest spec generation processed by the quota system.
   *
   * See also
   * - [ResourceGrant](#resourcegrant): The object created by this policy.
   * - [ResourceRegistration](#resourceregistration): Resource types for which grants are issued.
   */
  status?: {
    /**
     * Conditions represent the latest available observations of the policy's current state.
     */
    conditions?: Array<{
      /**
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       */
      lastTransitionTime: Date;
      /**
       * message is a human readable message indicating details about the transition.
       * This may be an empty string.
       */
      message: string;
      /**
       * observedGeneration represents the .metadata.generation that the condition was set based upon.
       * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
       * with respect to the current state of the instance.
       */
      observedGeneration?: bigint;
      /**
       * reason contains a programmatic identifier indicating the reason for the condition's last transition.
       * Producers of specific condition types may define expected values and meanings for this field,
       * and whether the values are considered a guaranteed API.
       * The value should be a CamelCase string.
       * This field may not be empty.
       */
      reason: string;
      /**
       * status of the condition, one of True, False, Unknown.
       */
      status: 'True' | 'False' | 'Unknown';
      /**
       * type of condition in CamelCase or in foo.example.com/CamelCase.
       */
      type: string;
    }>;
    /**
     * ObservedGeneration is the most recent generation observed.
     */
    observedGeneration?: bigint;
  };
};

/**
 * GrantCreationPolicyList is a list of GrantCreationPolicy
 */
export type ComMiloapisQuotaV1Alpha1GrantCreationPolicyList = {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * List of grantcreationpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
   */
  items: Array<ComMiloapisQuotaV1Alpha1GrantCreationPolicy>;
  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  metadata?: IoK8sApimachineryPkgApisMetaV1ListMeta;
};

/**
 * ResourceClaim requests quota allocation during resource creation. Claims
 * consume quota capacity from AllowanceBuckets and link to the triggering
 * Kubernetes resource for lifecycle management and auditing.
 *
 * ### How It Works
 *
 * **ResourceClaims** follow a straightforward lifecycle from creation to
 * resolution. When a **ClaimCreationPolicy** triggers during admission, it
 * creates a **ResourceClaim** that immediately enters the quota evaluation
 * pipeline. The quota system first validates that the consumer type matches the
 * expected `ConsumerTypeRef` from the **ResourceRegistration**, then verifies
 * that the triggering resource kind is authorized to claim the requested
 * resource types.
 *
 * Once validation passes, the quota system checks quota availability by
 * consulting the relevant **AllowanceBuckets**, one for each (consumer,
 * resourceType) combination in the claim's requests. The quota system treats
 * all requests in a claim as an atomic unit: either sufficient quota exists for
 * every request and the entire claim is granted, or any shortage results in
 * denying the complete claim. This atomic approach ensures consistency and
 * prevents partial resource allocations that could leave the system in an
 * inconsistent state.
 *
 * When a claim is granted, it permanently reserves the requested quota amounts
 * until the claim is deleted. This consumption immediately reduces the
 * available quota in the corresponding **AllowanceBuckets**, preventing other
 * claims from accessing that capacity. The quota system updates the claim's
 * status with detailed results for each resource request, including which
 * **AllowanceBucket** provided the quota and any relevant error messages.
 *
 * ### Core Relationships
 *
 * - **Created by**: **ClaimCreationPolicy** during admission (automatically) or
 * administrators (manually)
 * - **Consumes from**: **AllowanceBucket** matching
 * (`spec.consumerRef`, `spec.requests[].resourceType`)
 * - **Capacity sourced from**: **ResourceGrant** objects aggregated by the bucket
 * - **Linked to**: Triggering resource via `spec.resourceRef` for lifecycle management
 * - **Validated against**: **ResourceRegistration** for each `spec.requests[].resourceType`
 *
 * ### Claim Lifecycle States
 *
 * - **Initial**: `Granted=False`, `reason=PendingEvaluation` (claim created, awaiting processing)
 * - **Granted**: `Granted=True`, `reason=QuotaAvailable` (all requests allocated successfully)
 * - **Denied**: `Granted=False`, `reason=QuotaExceeded` or `ValidationFailed` (requests could not be satisfied)
 *
 * ### Automatic vs Manual Claims
 *
 * **Automatic Claims** (created by **ClaimCreationPolicy**):
 *
 * - Include standard labels and annotations for tracking
 * - Set owner references to triggering resource when possible
 * - Automatically cleaned up when denied to prevent accumulation
 * - Marked with `quota.miloapis.com/auto-created=true` label
 *
 * **Manual Claims** (created by administrators):
 *
 * - Require explicit metadata and references
 * - Not automatically cleaned up when denied
 * - Used for testing or special allocation scenarios
 *
 * ### Status Information
 *
 * - **Overall Status**: `status.conditions[type=Granted]` indicates claim approval
 * - **Detailed Results**: `status.allocations[]` provides per-request allocation details
 * - **Bucket References**: `status.allocations[].allocatingBucket` identifies quota sources
 *
 * ### Field Constraints and Validation
 *
 * - Maximum 20 resource requests per claim
 * - Each resource type can appear only once in requests
 * - Consumer type must match `ResourceRegistration.spec.consumerTypeRef` for each requested type
 * - Triggering resource kind must be listed in `ResourceRegistration.spec.claimingResources`
 *
 * ### Selectors and Filtering
 *
 * - **Field selectors**: spec.consumerRef.kind, spec.consumerRef.name, spec.resourceRef.apiGroup, spec.resourceRef.kind, spec.resourceRef.name, spec.resourceRef.namespace
 * - **Auto-created labels**: quota.miloapis.com/auto-created, quota.miloapis.com/policy, quota.miloapis.com/gvk
 * - **Auto-created annotations**: quota.miloapis.com/created-by, quota.miloapis.com/created-at,  quota.miloapis.com/resource-name
 *
 * ### Common Queries
 *
 * - All claims for a consumer: field selector spec.consumerRef.kind + spec.consumerRef.name
 * - Claims from a specific policy: label selector quota.miloapis.com/policy=<policy-name>
 * - Claims for a resource type: add custom labels via policy template
 * - Failed claims: field  selector on status conditions
 *
 * ### Troubleshooting
 *
 * - **Denied claims**: Check status.allocations[].message for specific quota or validation errors
 * - **Pending claims**: Verify ResourceRegistration is Active and AllowanceBucket exists
 * - **Missing claims**: Check ClaimCreationPolicy conditions and trigger expressions
 *
 * ### Performance Considerations
 *
 * - Claims are processed synchronously during admission (affects API latency)
 * - Large numbers of claims can impact bucket aggregation performance
 * - Consider batch processing for bulk resource creation
 */
export type ComMiloapisQuotaV1Alpha1ResourceClaim = {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   */
  metadata?: IoK8sApimachineryPkgApisMetaV1ObjectMeta;
  /**
   * ResourceClaimSpec defines the desired state of ResourceClaim.
   */
  spec: {
    /**
     * ConsumerRef identifies the quota consumer making this claim. The consumer
     * must match the ConsumerTypeRef defined in the ResourceRegistration for each
     * requested resource type. The system validates this relationship during
     * claim processing.
     *
     * Examples:
     *
     * - Organization consuming Project quota
     * - Project consuming User quota
     * - Organization consuming storage quota
     */
    consumerRef: {
      /**
       * APIGroup specifies the API group of the consumer resource.
       * Use full group name for Milo resources.
       *
       * Examples:
       * - "resourcemanager.miloapis.com" (Organization/Project resources)
       * - "iam.miloapis.com" (User/Group resources)
       * - "infrastructure.miloapis.com" (infrastructure resources)
       */
      apiGroup?: string;
      /**
       * Kind specifies the type of consumer resource.
       * Must match an existing Kubernetes resource type that can receive quota grants.
       *
       * Common consumer types:
       * - "Organization" (top-level quota consumer)
       * - "Project" (project-level quota consumer)
       * - "User" (user-level quota consumer)
       */
      kind: string;
      /**
       * Name identifies the specific consumer resource instance.
       * Must match the name of an existing consumer resource in the cluster.
       *
       * Examples:
       * - "acme-corp" (Organization name)
       * - "web-application" (Project name)
       * - "john.doe" (User name)
       */
      name: string;
      /**
       * Namespace identifies the namespace of the consumer resource.
       * Required for namespaced consumer resources (e.g., Projects).
       * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
       *
       * Examples:
       * - "" (empty for cluster-scoped Organizations)
       * - "organization-acme-corp" (namespace for Projects within an organization)
       * - "project-web-app" (namespace for resources within a project)
       */
      namespace?: string;
    };
    /**
     * Requests specifies the resource types and amounts being claimed from quota.
     * Each resource type can appear only once in the requests array. Minimum 1
     * request, maximum 20 requests per claim.
     *
     * The system processes all requests as a single atomic operation: either all
     * requests are granted or all are denied.
     */
    requests: Array<{
      /**
       * Amount specifies how much quota to claim for this resource type. Must be
       * measured in the BaseUnit defined by the corresponding ResourceRegistration.
       * Must be a positive integer (minimum value is 0, but 0 means no quota
       * requested).
       *
       * For Entity registrations: Use 1 for single resource instances (1 Project, 1
       * User) For Allocation registrations: Use actual capacity amounts (2048 for
       * 2048 MB, 1000 for 1000 millicores)
       *
       * Examples:
       *
       * - 1 (claiming 1 Project)
       * - 2048 (claiming 2048 bytes of storage)
       * - 1000 (claiming 1000 CPU millicores)
       */
      amount: bigint;
      /**
       * ResourceType identifies the specific resource type being claimed. Must
       * exactly match a ResourceRegistration.spec.resourceType that is currently
       * active. The quota system validates this reference during claim processing.
       *
       * The format is defined by platform administrators when creating ResourceRegistrations.
       * Service providers can use any identifier that makes sense for their quota system usage.
       *
       * Examples:
       *
       * - "resourcemanager.miloapis.com/projects"
       * - "compute_cpu"
       * - "storage.volumes"
       * - "custom-service-quota"
       */
      resourceType: string;
    }>;
    /**
     * ResourceRef identifies the actual Kubernetes resource that triggered this
     * claim. ClaimCreationPolicy automatically populates this field during
     * admission. Uses unversioned reference (apiGroup + kind + name + namespace)
     * to remain valid across API version changes.
     *
     * The referenced resource's kind must be listed in the ResourceRegistration's
     * spec.claimingResources for the claim to be valid.
     *
     * Examples:
     *
     * - Project resource triggering Project quota claim
     * - User resource triggering User quota claim
     * - Organization resource triggering storage quota claim
     */
    resourceRef: {
      /**
       * APIGroup specifies the API group of the referenced resource.
       * Use full group name for Milo resources.
       *
       * Examples:
       * - "resourcemanager.miloapis.com" (Project, Organization)
       * - "iam.miloapis.com" (User, Group)
       * - "infrastructure.miloapis.com" (infrastructure resources)
       */
      apiGroup?: string;
      /**
       * Kind specifies the type of the referenced resource.
       * Must match an existing Kubernetes resource type.
       *
       * Examples:
       * - "Project" (Project resource that triggered quota claim)
       * - "User" (User resource that triggered quota claim)
       * - "Organization" (Organization resource that triggered quota claim)
       */
      kind: string;
      /**
       * Name identifies the specific resource instance that triggered the quota claim.
       * Used for linking claims back to their triggering resources.
       *
       * Examples:
       * - "web-app-project" (Project that triggered Project quota claim)
       * - "john.doe" (User that triggered User quota claim)
       */
      name: string;
      /**
       * Namespace specifies the namespace containing the referenced resource.
       * Required for namespaced resources, omitted for cluster-scoped resources.
       *
       * Examples:
       * - "acme-corp" (organization namespace containing Project)
       * - "team-alpha" (project namespace containing User)
       * - "" or omitted (for cluster-scoped resources like Organization)
       */
      namespace?: string;
    };
  };
  /**
   * ResourceClaimStatus reports the claim's processing state and allocation
   * results. The system updates this status to communicate whether quota was
   * granted and provide detailed allocation information for each requested
   * resource type.
   */
  status?: {
    /**
     * Allocations provides detailed status for each resource request in the
     * claim. The system creates one allocation entry for each request in
     * spec.requests. Use this field to understand which specific requests were
     * granted or denied.
     *
     * List is indexed by ResourceType for efficient lookups.
     */
    allocations?: Array<{
      /**
       * AllocatedAmount specifies how much quota was actually allocated for this
       * request. Measured in the BaseUnit defined by the ResourceRegistration.
       * Currently always equals the requested amount or 0 (partial allocations not
       * supported).
       *
       * Set to the requested amount when Status=Granted, 0 when Status=Denied or
       * Pending.
       */
      allocatedAmount?: bigint;
      /**
       * AllocatingBucket identifies the AllowanceBucket that provided the quota for
       * this request. Set only when Status=Granted. Used for tracking and debugging
       * quota consumption.
       *
       * Format: bucket name (generated as:
       * consumer-kind-consumer-name-resource-type-hash)
       */
      allocatingBucket?: string;
      /**
       * LastTransitionTime records when this allocation status last changed.
       * Updates whenever Status, Reason, or Message changes.
       */
      lastTransitionTime: Date;
      /**
       * Message provides a human-readable explanation of the allocation result.
       * Includes specific details about quota availability or validation errors.
       *
       * Examples:
       *
       * - "Allocated 1 project from bucket organization-acme-projects"
       * - "Insufficient quota: need 2048 bytes, only 1024 available"
       * - "ResourceRegistration not found for resourceType"
       */
      message?: string;
      /**
       * Reason provides a machine-readable explanation for the current status.
       * Standard reasons include "QuotaAvailable", "QuotaExceeded",
       * "ValidationFailed".
       */
      reason?: string;
      /**
       * ResourceType identifies which resource request this allocation status
       * describes. Must exactly match one of the resourceType values in
       * spec.requests.
       */
      resourceType: string;
      /**
       * Status indicates the allocation result for this specific resource request.
       *
       * Valid values:
       *
       * - "Granted": Quota was available and the request was approved
       * - "Denied": Insufficient quota or validation failure prevented allocation
       * - "Pending": Request is being evaluated (initial state)
       */
      status: 'Granted' | 'Denied' | 'Pending';
    }>;
    /**
     * Conditions represents the overall status of the claim evaluation.
     * Controllers set these conditions to provide a high-level view of claim
     * processing.
     *
     * Standard condition types:
     *
     * - "Granted": Indicates whether the claim was approved and quota allocated
     *
     * Standard condition reasons for "Granted":
     *
     * - "QuotaAvailable": All requested quota was available and allocated
     * - "QuotaExceeded": Insufficient quota prevented allocation (claim denied)
     * - "ValidationFailed": Configuration errors prevented evaluation (claim denied)
     * - "PendingEvaluation": Claim is still being processed (initial state)
     *
     * Claim Lifecycle:
     *
     * 1. Created: Granted=False, reason=PendingEvaluation
     * 2. Processed: Granted=True/False based on quota availability and validation
     * 3. Updated: Granted condition changes only when allocation results change
     */
    conditions?: Array<{
      /**
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       */
      lastTransitionTime: Date;
      /**
       * message is a human readable message indicating details about the transition.
       * This may be an empty string.
       */
      message: string;
      /**
       * observedGeneration represents the .metadata.generation that the condition was set based upon.
       * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
       * with respect to the current state of the instance.
       */
      observedGeneration?: bigint;
      /**
       * reason contains a programmatic identifier indicating the reason for the condition's last transition.
       * Producers of specific condition types may define expected values and meanings for this field,
       * and whether the values are considered a guaranteed API.
       * The value should be a CamelCase string.
       * This field may not be empty.
       */
      reason: string;
      /**
       * status of the condition, one of True, False, Unknown.
       */
      status: 'True' | 'False' | 'Unknown';
      /**
       * type of condition in CamelCase or in foo.example.com/CamelCase.
       */
      type: string;
    }>;
    /**
     * ObservedGeneration indicates the most recent spec generation the system has
     * processed. When ObservedGeneration matches metadata.generation, the status
     * reflects the current spec. When ObservedGeneration is lower, the system is
     * still processing recent changes.
     */
    observedGeneration?: bigint;
  };
};

/**
 * ResourceClaimList is a list of ResourceClaim
 */
export type ComMiloapisQuotaV1Alpha1ResourceClaimList = {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * List of resourceclaims. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
   */
  items: Array<ComMiloapisQuotaV1Alpha1ResourceClaim>;
  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  metadata?: IoK8sApimachineryPkgApisMetaV1ListMeta;
};

/**
 * ResourceGrant allocates quota capacity to a consumer for specific resource types.
 * Grants provide the allowances that AllowanceBuckets aggregate to determine
 * available quota for ResourceClaim evaluation.
 *
 * ### How It Works
 * **ResourceGrants** begin their lifecycle when either an administrator creates them manually or a
 * **GrantCreationPolicy** generates them automatically in response to observed resource changes. Upon
 * creation, the grant enters a validation phase where the quota system examines the consumer type
 * to ensure it matches the expected `ConsumerTypeRef` from each **ResourceRegistration** targeted by
 * the grant's allowances. The quota system also verifies that all specified resource types correspond
 * to active registrations and that the allowance amounts are valid non-negative integers.
 *
 * When validation succeeds, the quota system marks the grant as `Active`, signaling to **AllowanceBucket**
 * resources that this grant should contribute to quota calculations. The bucket resources
 * continuously monitor for active grants and aggregate their allowance amounts into the appropriate
 * buckets based on consumer and resource type matching. This aggregation process makes the granted
 * quota capacity available for **ResourceClaim** consumption.
 *
 * **ResourceClaims** then consume the capacity that active grants provide, creating a flow from grants
 * through buckets to claims. The grant's capacity remains reserved as long as claims reference it,
 * ensuring that quota allocations persist until the consuming resources are removed. This creates
 * a stable quota environment where capacity allocations remain consistent across resource lifecycles.
 *
 * ### Core Relationships
 * - **Provides capacity to**: AllowanceBucket matching (spec.consumerRef, spec.allowances[].resourceType)
 * - **Consumed by**: ResourceClaim objects processed against the aggregated buckets
 * - **Validated against**: ResourceRegistration for each spec.allowances[].resourceType
 * - **Created by**: Administrators manually or GrantCreationPolicy automatically
 *
 * ### Quota Aggregation Logic
 * Multiple ResourceGrants for the same (consumer, resourceType) combination:
 * - Aggregate into a single AllowanceBucket for that combination
 * - All bucket amounts from all allowances are summed for total capacity
 * - Only Active grants contribute to the aggregated limit
 * - Inactive grants are excluded from quota calculations
 *
 * ### Grant vs Bucket Relationship
 * - **ResourceGrant**: Specifies intended quota allocations
 * - **AllowanceBucket**: Aggregates actual available quota from active grants
 * - **ResourceClaim**: Consumes quota from buckets (which source from grants)
 *
 * ### Allowance Structure
 * Each grant can contain multiple allowances for different resource types:
 * - All allowances share the same consumer (spec.consumerRef)
 * - Each allowance can have multiple buckets (for tracking, attribution, or incremental increases)
 * - Bucket amounts within an allowance are summed for that resource type
 *
 * ### Manual vs Automated Grants
 * **Manual Grants** (created by administrators):
 * - Explicit quota allocations for specific consumers
 * - Require direct management and updates
 * - Useful for base quotas, special allocations, or testing
 *
 * **Automated Grants** (created by GrantCreationPolicy):
 * - Generated based on resource lifecycle events
 * - Include labels/annotations for tracking policy source
 * - Automatically managed based on trigger conditions
 *
 * ### Validation Requirements
 * - Consumer type must match ResourceRegistration.spec.consumerTypeRef for each resource type
 * - All resource types must reference active ResourceRegistration objects
 * - Maximum 20 allowances per grant
 * - All amounts must be non-negative integers in BaseUnit
 *
 * ### Field Constraints and Limits
 * - Maximum 20 allowances per grant
 * - Each allowance must have at least 1 bucket
 * - Bucket amounts must be non-negative (0 is allowed but provides no quota)
 * - All amounts measured in BaseUnit from ResourceRegistration
 *
 * ### Status Information
 * - **Active condition**: Indicates whether grant is contributing to quota buckets
 * - **Validation errors**: Reported in condition message when Active=False
 * - **Processing status**: ObservedGeneration tracks spec changes
 *
 * ### Selectors and Filtering
 * - **Field selectors**: spec.consumerRef.kind, spec.consumerRef.name
 * - **Recommended labels** (add manually for better organization):
 * - quota.miloapis.com/consumer-kind: Organization
 * - quota.miloapis.com/consumer-name: acme-corp
 * - quota.miloapis.com/source: policy-name or manual
 * - quota.miloapis.com/tier: basic, premium, enterprise
 *
 * ### Common Queries
 * - All grants for a consumer: field selector spec.consumerRef.kind + spec.consumerRef.name
 * - Grants by source policy: label selector quota.miloapis.com/source=<policy-name>
 * - Grants by resource tier: label selector quota.miloapis.com/tier=<tier-name>
 * - Active vs inactive grants: check status.conditions[type=Active].status
 *
 * ### Cross-Cluster Allocation
 * GrantCreationPolicy can create grants in parent control planes for cross-cluster quota:
 * - Policy running in child cluster creates grants in parent cluster
 * - Grants provide capacity that spans multiple child clusters
 * - Enables centralized quota management across cluster hierarchies
 *
 * ### Troubleshooting
 * - **Inactive grants**: Check status.conditions[type=Active] for validation errors
 * - **Missing quota**: Verify grants are Active and contributing to correct buckets
 * - **Grant conflicts**: Multiple grants for same consumer+resourceType are aggregated, not conflicting
 *
 * ### Performance Considerations
 * - Large numbers of grants can impact bucket aggregation performance
 * - Consider consolidating grants where possible to reduce aggregation overhead
 * - Grant status updates are asynchronous and may lag spec changes
 */
export type ComMiloapisQuotaV1Alpha1ResourceGrant = {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   */
  metadata?: IoK8sApimachineryPkgApisMetaV1ObjectMeta;
  /**
   * ResourceGrantSpec defines the desired state of ResourceGrant.
   */
  spec: {
    /**
     * Allowances specifies the quota allocations provided by this grant.
     * Each allowance grants capacity for a specific resource type.
     * Minimum 1 allowance required, maximum 20 allowances per grant.
     *
     * All allowances in a single grant:
     * - Apply to the same consumer (spec.consumerRef)
     * - Contribute to the same AllowanceBucket for each resource type
     * - Activate and deactivate together based on the grant's status
     */
    allowances: Array<{
      /**
       * Buckets contains the quota allocations for this resource type.
       * All bucket amounts are summed to determine the total allowance.
       * Minimum 1 bucket required per allowance.
       *
       * Multiple buckets can be used for:
       * - Separating quota from different sources or tiers
       * - Managing incremental quota increases over time
       * - Tracking quota attribution for billing or reporting
       */
      buckets: Array<{
        /**
         * Amount specifies the quota capacity provided by this bucket.
         * Must be measured in the BaseUnit defined by the corresponding ResourceRegistration.
         * Must be a non-negative integer (0 is valid but provides no quota).
         *
         * Examples:
         * - 100 (providing 100 projects)
         * - 2048000 (providing 2048000 bytes = 2GB)
         * - 5000 (providing 5000 CPU millicores = 5 cores)
         */
        amount: bigint;
      }>;
      /**
       * ResourceType identifies the specific resource type receiving quota allocation.
       * Must exactly match a ResourceRegistration.spec.resourceType that is currently active.
       * The quota system validates this reference when processing the grant.
       *
       * The identifier format is flexible, as defined by platform administrators
       * in their ResourceRegistrations.
       *
       * Examples:
       * - "resourcemanager.miloapis.com/projects"
       * - "compute_cpu"
       * - "storage.volumes"
       * - "custom-service-quota"
       */
      resourceType: string;
    }>;
    /**
     * ConsumerRef identifies the quota consumer that receives these allowances.
     * The consumer type must match the ConsumerTypeRef defined in the ResourceRegistration
     * for each allowance resource type. The system validates this relationship.
     *
     * Examples:
     * - Organization receiving Project quota allowances
     * - Project receiving User quota allowances
     * - Organization receiving storage quota allowances
     */
    consumerRef: {
      /**
       * APIGroup specifies the API group of the consumer resource.
       * Use full group name for Milo resources.
       *
       * Examples:
       * - "resourcemanager.miloapis.com" (Organization/Project resources)
       * - "iam.miloapis.com" (User/Group resources)
       * - "infrastructure.miloapis.com" (infrastructure resources)
       */
      apiGroup?: string;
      /**
       * Kind specifies the type of consumer resource.
       * Must match an existing Kubernetes resource type that can receive quota grants.
       *
       * Common consumer types:
       * - "Organization" (top-level quota consumer)
       * - "Project" (project-level quota consumer)
       * - "User" (user-level quota consumer)
       */
      kind: string;
      /**
       * Name identifies the specific consumer resource instance.
       * Must match the name of an existing consumer resource in the cluster.
       *
       * Examples:
       * - "acme-corp" (Organization name)
       * - "web-application" (Project name)
       * - "john.doe" (User name)
       */
      name: string;
      /**
       * Namespace identifies the namespace of the consumer resource.
       * Required for namespaced consumer resources (e.g., Projects).
       * Leave empty for cluster-scoped consumer resources (e.g., Organizations).
       *
       * Examples:
       * - "" (empty for cluster-scoped Organizations)
       * - "organization-acme-corp" (namespace for Projects within an organization)
       * - "project-web-app" (namespace for resources within a project)
       */
      namespace?: string;
    };
  };
  /**
   * ResourceGrantStatus reports the grant's operational state and processing status.
   * Controllers update status conditions to indicate whether the grant is active
   * and contributing capacity to AllowanceBuckets.
   */
  status?: {
    /**
     * Conditions represents the latest available observations of the grant's state.
     * Controllers set these conditions to communicate operational status.
     *
     * Standard condition types:
     * - "Active": Indicates whether the grant is operational and contributing to quota buckets.
     * When True, allowances are aggregated into AllowanceBuckets and available for claims.
     * When False, allowances do not contribute to quota decisions.
     *
     * Standard condition reasons for "Active":
     * - "GrantActive": Grant is validated and contributing to quota buckets
     * - "ValidationFailed": Specification contains errors preventing activation (see message)
     * - "GrantPending": Grant is being processed by the quota system
     *
     * Grant Lifecycle:
     * 1. Created: Active=Unknown, reason=GrantPending
     * 2. Validated: Active=True, reason=GrantActive OR Active=False, reason=ValidationFailed
     * 3. Updated: Active condition changes only when validation results change
     */
    conditions?: Array<{
      /**
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       */
      lastTransitionTime: Date;
      /**
       * message is a human readable message indicating details about the transition.
       * This may be an empty string.
       */
      message: string;
      /**
       * observedGeneration represents the .metadata.generation that the condition was set based upon.
       * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
       * with respect to the current state of the instance.
       */
      observedGeneration?: bigint;
      /**
       * reason contains a programmatic identifier indicating the reason for the condition's last transition.
       * Producers of specific condition types may define expected values and meanings for this field,
       * and whether the values are considered a guaranteed API.
       * The value should be a CamelCase string.
       * This field may not be empty.
       */
      reason: string;
      /**
       * status of the condition, one of True, False, Unknown.
       */
      status: 'True' | 'False' | 'Unknown';
      /**
       * type of condition in CamelCase or in foo.example.com/CamelCase.
       */
      type: string;
    }>;
    /**
     * ObservedGeneration indicates the most recent spec generation the quota system has processed.
     * When ObservedGeneration matches metadata.generation, the status reflects the current spec.
     * When ObservedGeneration is lower, the quota system is still processing recent changes.
     */
    observedGeneration?: bigint;
  };
};

/**
 * ResourceGrantList is a list of ResourceGrant
 */
export type ComMiloapisQuotaV1Alpha1ResourceGrantList = {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * List of resourcegrants. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
   */
  items: Array<ComMiloapisQuotaV1Alpha1ResourceGrant>;
  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  metadata?: IoK8sApimachineryPkgApisMetaV1ListMeta;
};

/**
 * ResourceRegistration enables quota tracking for a specific resource type.
 * Administrators create registrations to define measurement units, consumer relationships,
 * and claiming permissions.
 *
 * ### How It Works
 * - Administrators create registrations to enable quota tracking for specific resource types
 * - The system validates the registration and sets the "Active" condition when ready
 * - ResourceGrants can then allocate capacity for the registered resource type
 * - ResourceClaims can consume capacity when allowed resources are created
 *
 * ### Core Relationships
 * - **ResourceGrant.spec.allowances[].resourceType** must match this registration's **spec.resourceType**
 * - **ResourceClaim.spec.requests[].resourceType** must match this registration's **spec.resourceType**
 * - **ResourceClaim.spec.consumerRef** must match this registration's **spec.consumerTypeRef** type
 * - **ResourceClaim.spec.resourceRef** kind must be listed in this registration's **spec.claimingResources**
 *
 * ### Registration Lifecycle
 * 1. **Creation**: Administrator creates **ResourceRegistration** with resource type and consumer type
 * 2. **Validation**: System validates that referenced resource types exist and are accessible
 * 3. **Activation**: System sets `Active=True` condition when validation passes
 * 4. **Operation**: **ResourceGrants** and **ResourceClaims** can reference the active registration
 * 5. **Updates**: Only mutable fields (`description`, `claimingResources`) can be changed
 *
 * ### Status Conditions
 * - **Active=True**: Registration is validated and operational; grants and claims can use it
 * - **Active=False, reason=ValidationFailed**: Configuration errors prevent activation (check message)
 * - **Active=False, reason=RegistrationPending**: Quota system is processing the registration
 *
 * ### Measurement Types
 * - **Entity registrations** (`spec.type=Entity`): Count discrete resource instances (**Projects**, **Users**)
 * - **Allocation registrations** (`spec.type=Allocation`): Measure capacity amounts (CPU, memory, storage)
 *
 * ### Field Constraints and Limits
 * - Maximum 20 entries in **spec.claimingResources**
 * - **spec.resourceType**, **spec.consumerTypeRef**, and **spec.type** are immutable after creation
 * - **spec.description** maximum 500 characters
 * - **spec.baseUnit** and **spec.displayUnit** maximum 50 characters each
 * - **spec.unitConversionFactor** minimum value is 1
 *
 * ### Selectors and Filtering
 * - **Field selectors**: spec.consumerTypeRef.kind, spec.consumerTypeRef.apiGroup, spec.resourceType
 * - **Recommended labels** (add manually):
 * - quota.miloapis.com/resource-kind: Project
 * - quota.miloapis.com/resource-apigroup: resourcemanager.miloapis.com
 * - quota.miloapis.com/consumer-kind: Organization
 *
 * ### Security Considerations
 * - Only include trusted resource types in **spec.claimingResources**
 * - Registrations are cluster-scoped and affect quota system-wide
 * - Consumer types must have appropriate RBAC permissions to create claims
 */
export type ComMiloapisQuotaV1Alpha1ResourceRegistration = {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   */
  metadata?: IoK8sApimachineryPkgApisMetaV1ObjectMeta;
  /**
   * ResourceRegistrationSpec defines the desired state of ResourceRegistration.
   */
  spec: {
    /**
     * BaseUnit defines the internal measurement unit for all quota calculations.
     * The system stores and processes all quota amounts using this unit.
     * Use singular form with lowercase letters. Maximum 50 characters.
     *
     * Examples:
     * - "project" (for Entity type tracking Projects)
     * - "millicore" (for CPU allocation)
     * - "byte" (for storage or memory)
     * - "user" (for Entity type tracking Users)
     */
    baseUnit: string;
    /**
     * ClaimingResources specifies which resource types can create ResourceClaims for this registration.
     * Only resources listed here can trigger quota consumption for this resource type.
     * Empty list means no resources can claim quota (administrators must create claims manually).
     * Maximum 20 entries.
     *
     * The quota system monitors these resource types for automatic owner reference creation.
     * Uses unversioned references (APIGroup + Kind) to survive API version changes.
     *
     * Security consideration: Only include resource types that should consume this quota.
     * For example, when registering **Projects**, only include **Project** as a claiming resource
     * to prevent other resource types from consuming **Project** quota.
     */
    claimingResources?: Array<{
      /**
       * APIGroup specifies the API group of the resource that can create claims.
       * Use empty string for Kubernetes core resources (**Pod**, **Service**, etc.).
       * Use full group name for custom resources.
       *
       * Examples:
       * - `""` (core resources like **Pod**, **Namespace**)
       * - `apps` (Kubernetes apps group)
       * - `resourcemanager.miloapis.com` (custom resource group)
       */
      apiGroup?: string;
      /**
       * Kind specifies the resource type that can create **ResourceClaims** for this registration.
       * Must match an existing resource type. Maximum 63 characters.
       *
       * Examples:
       * - `Project` (**Project** resource creating claims for **Project** quota)
       * - `User` (**User** resource creating claims for **User** quota)
       * - `Organization` (**Organization** resource creating claims for **Organization** quota)
       */
      kind: string;
    }>;
    /**
     * ConsumerTypeRef specifies which resource type receives grants and creates claims for this registration.
     * The consumer type must exist in the cluster before creating the registration.
     *
     * Example: When registering "Projects per Organization", set `ConsumerTypeRef` to **Organization**
     * (apiGroup: `resourcemanager.miloapis.com`, kind: `Organization`). **Organizations** then
     * receive **ResourceGrants** allocating **Project** quota and create **ResourceClaims** when **Projects** are created.
     */
    consumerTypeRef: {
      /**
       * APIGroup specifies the API group of the quota consumer resource type.
       * Use empty string for Kubernetes core resources (**Pod**, **Service**, etc.).
       * Use full group name for custom resources (for example, `resourcemanager.miloapis.com`).
       * Must follow DNS subdomain format with lowercase letters, numbers, and hyphens.
       *
       * Examples:
       * - `resourcemanager.miloapis.com` (**Organizations**, **Projects**)
       * - `iam.miloapis.com` (**Users**, **Groups**)
       * - `infrastructure.miloapis.com` (custom infrastructure resources)
       */
      apiGroup: string;
      /**
       * Kind specifies the resource type that receives quota grants and creates quota claims.
       * Must match an existing Kubernetes resource type (core or custom).
       * Use the exact Kind name as defined in the resource's schema.
       *
       * Examples:
       * - **Organization** (receives **Project** quotas)
       * - **Project** (receives **User** quotas)
       * - **User** (receives resource quotas within projects)
       */
      kind: string;
    };
    /**
     * Description provides human-readable context about what this registration tracks.
     * Use clear, specific language that explains the resource type and measurement approach.
     * Maximum 500 characters.
     *
     * Examples:
     * - "Projects created within Organizations"
     * - "CPU millicores allocated to Pods"
     * - "Storage bytes claimed by PersistentVolumeClaims"
     */
    description?: string;
    /**
     * DisplayUnit defines the unit shown in user interfaces and API responses.
     * Should be more human-readable than BaseUnit. Use singular form. Maximum 50 characters.
     *
     * Examples:
     * - "project" (same as BaseUnit when no conversion needed)
     * - "core" (for displaying CPU instead of millicores)
     * - "GiB" (for displaying memory/storage instead of bytes)
     * - "TB" (for large storage volumes)
     */
    displayUnit: string;
    /**
     * ResourceType identifies the resource to track with quota.
     * Platform administrators define resource type identifiers that make sense for their
     * quota system usage. This field is immutable after creation.
     *
     * The identifier format is flexible to accommodate various naming conventions
     * and organizational needs. Service providers can use any meaningful identifier.
     *
     * Examples:
     * - "resourcemanager.miloapis.com/projects"
     * - "iam.miloapis.com/users"
     * - "compute_cpu"
     * - "storage.volumes"
     * - "custom-service-quota"
     */
    resourceType: string;
    /**
     * Type specifies the measurement method for quota tracking.
     * This field is immutable after creation.
     *
     * Valid values:
     * - `Entity`: Counts discrete resource instances. Use for resources where each instance
     * consumes exactly 1 quota unit (for example, **Projects**, **Users**, **Databases**).
     * Claims always request integer quantities.
     * - `Allocation`: Measures numeric capacity or resource amounts. Use for resources
     * with variable consumption (for example, CPU millicores, memory bytes, storage capacity).
     * Claims can request fractional amounts based on resource specifications.
     */
    type: 'Entity' | 'Allocation';
    /**
     * UnitConversionFactor converts BaseUnit values to DisplayUnit values for presentation.
     * Must be a positive integer. Minimum value is 1 (no conversion).
     *
     * Formula: displayValue = baseValue / unitConversionFactor
     *
     * Examples:
     * - 1 (no conversion: "project" to "project")
     * - 1000 (millicores to cores: 2000 millicores displays as 2 cores)
     * - 1073741824 (bytes to GiB: 2147483648 bytes displays as 2 GiB)
     * - 1000000000000 (bytes to TB: 2000000000000 bytes displays as 2 TB)
     */
    unitConversionFactor: bigint;
  };
  /**
   * ResourceRegistrationStatus reports the registration's operational state and processing status.
   * The system updates status conditions to indicate whether the registration is active and
   * usable for quota operations.
   */
  status?: {
    /**
     * Conditions represents the latest available observations of the registration's state.
     * The system sets these conditions to communicate operational status.
     *
     * Standard condition types:
     * - "Active": Indicates whether the registration is operational. When True, ResourceGrants
     * and ResourceClaims can reference this registration. When False, quota operations are blocked.
     *
     * Standard condition reasons for "Active":
     * - "RegistrationActive": Registration is validated and operational
     * - "ValidationFailed": Specification contains errors (see message for details)
     * - "RegistrationPending": Registration is being processed
     */
    conditions?: Array<{
      /**
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       */
      lastTransitionTime: Date;
      /**
       * message is a human readable message indicating details about the transition.
       * This may be an empty string.
       */
      message: string;
      /**
       * observedGeneration represents the .metadata.generation that the condition was set based upon.
       * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
       * with respect to the current state of the instance.
       */
      observedGeneration?: bigint;
      /**
       * reason contains a programmatic identifier indicating the reason for the condition's last transition.
       * Producers of specific condition types may define expected values and meanings for this field,
       * and whether the values are considered a guaranteed API.
       * The value should be a CamelCase string.
       * This field may not be empty.
       */
      reason: string;
      /**
       * status of the condition, one of True, False, Unknown.
       */
      status: 'True' | 'False' | 'Unknown';
      /**
       * type of condition in CamelCase or in foo.example.com/CamelCase.
       */
      type: string;
    }>;
    /**
     * ObservedGeneration indicates the most recent spec generation that the system has processed.
     * When ObservedGeneration matches metadata.generation, the status reflects the current spec.
     * When ObservedGeneration is lower, the system is still processing recent changes.
     */
    observedGeneration?: bigint;
  };
};

/**
 * ResourceRegistrationList is a list of ResourceRegistration
 */
export type ComMiloapisQuotaV1Alpha1ResourceRegistrationList = {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * List of resourceregistrations. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
   */
  items: Array<ComMiloapisQuotaV1Alpha1ResourceRegistration>;
  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  metadata?: IoK8sApimachineryPkgApisMetaV1ListMeta;
};

/**
 * DeleteOptions may be provided when deleting an API object.
 */
export type IoK8sApimachineryPkgApisMetaV1DeleteOptions = {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
   */
  dryRun?: Array<string>;
  /**
   * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   */
  gracePeriodSeconds?: bigint;
  /**
   * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
   */
  ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
   */
  orphanDependents?: boolean;
  /**
   * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be returned.
   */
  preconditions?: IoK8sApimachineryPkgApisMetaV1Preconditions;
  /**
   * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
   */
  propagationPolicy?: string;
};

/**
 * FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.
 *
 * Each key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:<name>', where <name> is the name of a field in a struct, or key in a map 'v:<value>', where <value> is the exact json formatted value of a list item 'i:<index>', where <index> is position of a item in a list 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.
 *
 * The exact format is defined in sigs.k8s.io/structured-merge-diff
 */
export type IoK8sApimachineryPkgApisMetaV1FieldsV1 = {
  [key: string]: unknown;
};

/**
 * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
 */
export type IoK8sApimachineryPkgApisMetaV1ListMeta = {
  /**
   * continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
   */
  continue?: string;
  /**
   * remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.
   */
  remainingItemCount?: bigint;
  /**
   * String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   */
  resourceVersion?: string;
  /**
   * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
   */
  selfLink?: string;
};

/**
 * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
 */
export type IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry = {
  /**
   * APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
   */
  apiVersion?: string;
  /**
   * FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
   */
  fieldsType?: string;
  /**
   * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
   */
  fieldsV1?: IoK8sApimachineryPkgApisMetaV1FieldsV1;
  /**
   * Manager is an identifier of the workflow managing these fields.
   */
  manager?: string;
  /**
   * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
   */
  operation?: string;
  /**
   * Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
   */
  subresource?: string;
  /**
   * Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.
   */
  time?: IoK8sApimachineryPkgApisMetaV1Time;
};

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 */
export type IoK8sApimachineryPkgApisMetaV1ObjectMeta = {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   */
  annotations?: {
    [key: string]: string;
  };
  /**
   * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.
   *
   * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   */
  creationTimestamp?: IoK8sApimachineryPkgApisMetaV1Time;
  /**
   * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
   */
  deletionGracePeriodSeconds?: bigint;
  /**
   * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.
   *
   * Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   */
  deletionTimestamp?: IoK8sApimachineryPkgApisMetaV1Time;
  /**
   * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.
   */
  finalizers?: Array<string>;
  /**
   * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
   *
   * If this field is specified and the generated name exists, the server will return a 409.
   *
   * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
   */
  generateName?: string;
  /**
   * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
   */
  generation?: bigint;
  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   */
  labels?: {
    [key: string]: string;
  };
  /**
   * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.
   */
  managedFields?: Array<IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry>;
  /**
   * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   */
  name?: string;
  /**
   * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
   *
   * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
   */
  namespace?: string;
  /**
   * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
   */
  ownerReferences?: Array<IoK8sApimachineryPkgApisMetaV1OwnerReference>;
  /**
   * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
   *
   * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   */
  resourceVersion?: string;
  /**
   * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
   */
  selfLink?: string;
  /**
   * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
   *
   * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
   */
  uid?: string;
};

/**
 * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
 */
export type IoK8sApimachineryPkgApisMetaV1OwnerReference = {
  /**
   * API version of the referent.
   */
  apiVersion: string;
  /**
   * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
   */
  blockOwnerDeletion?: boolean;
  /**
   * If true, this reference points to the managing controller.
   */
  controller?: boolean;
  /**
   * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind: string;
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   */
  name: string;
  /**
   * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
   */
  uid: string;
};

/**
 * Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.
 */
export type IoK8sApimachineryPkgApisMetaV1Patch = {
  [key: string]: unknown;
};

/**
 * Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
 */
export type IoK8sApimachineryPkgApisMetaV1Preconditions = {
  /**
   * Specifies the target ResourceVersion
   */
  resourceVersion?: string;
  /**
   * Specifies the target UID.
   */
  uid?: string;
};

/**
 * Status is a return value for calls that don't return other objects.
 */
export type IoK8sApimachineryPkgApisMetaV1Status = {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * Suggested HTTP return code for this status, 0 if not set.
   */
  code?: number;
  /**
   * Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
   */
  details?: IoK8sApimachineryPkgApisMetaV1StatusDetails;
  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * A human-readable description of the status of this operation.
   */
  message?: string;
  /**
   * Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  metadata?: IoK8sApimachineryPkgApisMetaV1ListMeta;
  /**
   * A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
   */
  reason?: string;
  /**
   * Status of the operation. One of: "Success" or "Failure". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   */
  status?: string;
};

/**
 * StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.
 */
export type IoK8sApimachineryPkgApisMetaV1StatusCause = {
  /**
   * The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.
   *
   * Examples:
   * "name" - the field "name" on the current resource
   * "items[0].name" - the field "name" on the first array entry in "items"
   */
  field?: string;
  /**
   * A human-readable description of the cause of the error.  This field may be presented as-is to a reader.
   */
  message?: string;
  /**
   * A machine-readable description of the cause of the error. If this value is empty there is no information available.
   */
  reason?: string;
};

/**
 * StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.
 */
export type IoK8sApimachineryPkgApisMetaV1StatusDetails = {
  /**
   * The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
   */
  causes?: Array<IoK8sApimachineryPkgApisMetaV1StatusCause>;
  /**
   * The group attribute of the resource associated with the status StatusReason.
   */
  group?: string;
  /**
   * The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  /**
   * The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
   */
  name?: string;
  /**
   * If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.
   */
  retryAfterSeconds?: number;
  /**
   * UID of the resource. (when there is a single resource which can be described). More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
   */
  uid?: string;
};

/**
 * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
 */
export type IoK8sApimachineryPkgApisMetaV1Time = Date;

export type ListQuotaMiloapisComV1Alpha1AllowanceBucketForAllNamespacesData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/allowancebuckets';
};

export type ListQuotaMiloapisComV1Alpha1AllowanceBucketForAllNamespacesErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ListQuotaMiloapisComV1Alpha1AllowanceBucketForAllNamespacesResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1AllowanceBucketList;
};

export type ListQuotaMiloapisComV1Alpha1AllowanceBucketForAllNamespacesResponse =
  ListQuotaMiloapisComV1Alpha1AllowanceBucketForAllNamespacesResponses[keyof ListQuotaMiloapisComV1Alpha1AllowanceBucketForAllNamespacesResponses];

export type DeleteQuotaMiloapisComV1Alpha1CollectionClaimCreationPolicyData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/claimcreationpolicies';
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionClaimCreationPolicyErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionClaimCreationPolicyResponses = {
  /**
   * OK
   */
  200: IoK8sApimachineryPkgApisMetaV1Status;
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionClaimCreationPolicyResponse =
  DeleteQuotaMiloapisComV1Alpha1CollectionClaimCreationPolicyResponses[keyof DeleteQuotaMiloapisComV1Alpha1CollectionClaimCreationPolicyResponses];

export type ListQuotaMiloapisComV1Alpha1ClaimCreationPolicyData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/claimcreationpolicies';
};

export type ListQuotaMiloapisComV1Alpha1ClaimCreationPolicyErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ListQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ClaimCreationPolicyList;
};

export type ListQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponse =
  ListQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses[keyof ListQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses];

export type CreateQuotaMiloapisComV1Alpha1ClaimCreationPolicyData = {
  body: ComMiloapisQuotaV1Alpha1ClaimCreationPolicy;
  path?: never;
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/claimcreationpolicies';
};

export type CreateQuotaMiloapisComV1Alpha1ClaimCreationPolicyErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type CreateQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ClaimCreationPolicy;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1ClaimCreationPolicy;
  /**
   * Accepted
   */
  202: ComMiloapisQuotaV1Alpha1ClaimCreationPolicy;
};

export type CreateQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponse =
  CreateQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses[keyof CreateQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses];

export type DeleteQuotaMiloapisComV1Alpha1ClaimCreationPolicyData = {
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
  path: {
    /**
     * name of the ClaimCreationPolicy
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     */
    gracePeriodSeconds?: number;
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     */
    orphanDependents?: boolean;
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     */
    propagationPolicy?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/claimcreationpolicies/{name}';
};

export type DeleteQuotaMiloapisComV1Alpha1ClaimCreationPolicyErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type DeleteQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses = {
  /**
   * OK
   */
  200: IoK8sApimachineryPkgApisMetaV1Status;
  /**
   * Accepted
   */
  202: IoK8sApimachineryPkgApisMetaV1Status;
};

export type DeleteQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponse =
  DeleteQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses[keyof DeleteQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses];

export type ReadQuotaMiloapisComV1Alpha1ClaimCreationPolicyData = {
  body?: never;
  path: {
    /**
     * name of the ClaimCreationPolicy
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/claimcreationpolicies/{name}';
};

export type ReadQuotaMiloapisComV1Alpha1ClaimCreationPolicyErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReadQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ClaimCreationPolicy;
};

export type ReadQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponse =
  ReadQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses[keyof ReadQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses];

export type PatchQuotaMiloapisComV1Alpha1ClaimCreationPolicyData = {
  body: IoK8sApimachineryPkgApisMetaV1Patch;
  path: {
    /**
     * name of the ClaimCreationPolicy
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
    /**
     * Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     */
    force?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/claimcreationpolicies/{name}';
};

export type PatchQuotaMiloapisComV1Alpha1ClaimCreationPolicyErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type PatchQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ClaimCreationPolicy;
};

export type PatchQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponse =
  PatchQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses[keyof PatchQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses];

export type ReplaceQuotaMiloapisComV1Alpha1ClaimCreationPolicyData = {
  body: ComMiloapisQuotaV1Alpha1ClaimCreationPolicy;
  path: {
    /**
     * name of the ClaimCreationPolicy
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/claimcreationpolicies/{name}';
};

export type ReplaceQuotaMiloapisComV1Alpha1ClaimCreationPolicyErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReplaceQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ClaimCreationPolicy;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1ClaimCreationPolicy;
};

export type ReplaceQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponse =
  ReplaceQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses[keyof ReplaceQuotaMiloapisComV1Alpha1ClaimCreationPolicyResponses];

export type ReadQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusData = {
  body?: never;
  path: {
    /**
     * name of the ClaimCreationPolicy
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/claimcreationpolicies/{name}/status';
};

export type ReadQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReadQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ClaimCreationPolicy;
};

export type ReadQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusResponse =
  ReadQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusResponses[keyof ReadQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusResponses];

export type PatchQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusData = {
  body: IoK8sApimachineryPkgApisMetaV1Patch;
  path: {
    /**
     * name of the ClaimCreationPolicy
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
    /**
     * Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     */
    force?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/claimcreationpolicies/{name}/status';
};

export type PatchQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type PatchQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ClaimCreationPolicy;
};

export type PatchQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusResponse =
  PatchQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusResponses[keyof PatchQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusResponses];

export type ReplaceQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusData = {
  body: ComMiloapisQuotaV1Alpha1ClaimCreationPolicy;
  path: {
    /**
     * name of the ClaimCreationPolicy
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/claimcreationpolicies/{name}/status';
};

export type ReplaceQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReplaceQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ClaimCreationPolicy;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1ClaimCreationPolicy;
};

export type ReplaceQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusResponse =
  ReplaceQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusResponses[keyof ReplaceQuotaMiloapisComV1Alpha1ClaimCreationPolicyStatusResponses];

export type DeleteQuotaMiloapisComV1Alpha1CollectionGrantCreationPolicyData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/grantcreationpolicies';
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionGrantCreationPolicyErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionGrantCreationPolicyResponses = {
  /**
   * OK
   */
  200: IoK8sApimachineryPkgApisMetaV1Status;
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionGrantCreationPolicyResponse =
  DeleteQuotaMiloapisComV1Alpha1CollectionGrantCreationPolicyResponses[keyof DeleteQuotaMiloapisComV1Alpha1CollectionGrantCreationPolicyResponses];

export type ListQuotaMiloapisComV1Alpha1GrantCreationPolicyData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/grantcreationpolicies';
};

export type ListQuotaMiloapisComV1Alpha1GrantCreationPolicyErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ListQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1GrantCreationPolicyList;
};

export type ListQuotaMiloapisComV1Alpha1GrantCreationPolicyResponse =
  ListQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses[keyof ListQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses];

export type CreateQuotaMiloapisComV1Alpha1GrantCreationPolicyData = {
  body: ComMiloapisQuotaV1Alpha1GrantCreationPolicy;
  path?: never;
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/grantcreationpolicies';
};

export type CreateQuotaMiloapisComV1Alpha1GrantCreationPolicyErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type CreateQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1GrantCreationPolicy;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1GrantCreationPolicy;
  /**
   * Accepted
   */
  202: ComMiloapisQuotaV1Alpha1GrantCreationPolicy;
};

export type CreateQuotaMiloapisComV1Alpha1GrantCreationPolicyResponse =
  CreateQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses[keyof CreateQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses];

export type DeleteQuotaMiloapisComV1Alpha1GrantCreationPolicyData = {
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
  path: {
    /**
     * name of the GrantCreationPolicy
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     */
    gracePeriodSeconds?: number;
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     */
    orphanDependents?: boolean;
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     */
    propagationPolicy?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/grantcreationpolicies/{name}';
};

export type DeleteQuotaMiloapisComV1Alpha1GrantCreationPolicyErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type DeleteQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses = {
  /**
   * OK
   */
  200: IoK8sApimachineryPkgApisMetaV1Status;
  /**
   * Accepted
   */
  202: IoK8sApimachineryPkgApisMetaV1Status;
};

export type DeleteQuotaMiloapisComV1Alpha1GrantCreationPolicyResponse =
  DeleteQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses[keyof DeleteQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses];

export type ReadQuotaMiloapisComV1Alpha1GrantCreationPolicyData = {
  body?: never;
  path: {
    /**
     * name of the GrantCreationPolicy
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/grantcreationpolicies/{name}';
};

export type ReadQuotaMiloapisComV1Alpha1GrantCreationPolicyErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReadQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1GrantCreationPolicy;
};

export type ReadQuotaMiloapisComV1Alpha1GrantCreationPolicyResponse =
  ReadQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses[keyof ReadQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses];

export type PatchQuotaMiloapisComV1Alpha1GrantCreationPolicyData = {
  body: IoK8sApimachineryPkgApisMetaV1Patch;
  path: {
    /**
     * name of the GrantCreationPolicy
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
    /**
     * Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     */
    force?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/grantcreationpolicies/{name}';
};

export type PatchQuotaMiloapisComV1Alpha1GrantCreationPolicyErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type PatchQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1GrantCreationPolicy;
};

export type PatchQuotaMiloapisComV1Alpha1GrantCreationPolicyResponse =
  PatchQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses[keyof PatchQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses];

export type ReplaceQuotaMiloapisComV1Alpha1GrantCreationPolicyData = {
  body: ComMiloapisQuotaV1Alpha1GrantCreationPolicy;
  path: {
    /**
     * name of the GrantCreationPolicy
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/grantcreationpolicies/{name}';
};

export type ReplaceQuotaMiloapisComV1Alpha1GrantCreationPolicyErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReplaceQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1GrantCreationPolicy;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1GrantCreationPolicy;
};

export type ReplaceQuotaMiloapisComV1Alpha1GrantCreationPolicyResponse =
  ReplaceQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses[keyof ReplaceQuotaMiloapisComV1Alpha1GrantCreationPolicyResponses];

export type ReadQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusData = {
  body?: never;
  path: {
    /**
     * name of the GrantCreationPolicy
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/grantcreationpolicies/{name}/status';
};

export type ReadQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReadQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1GrantCreationPolicy;
};

export type ReadQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusResponse =
  ReadQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusResponses[keyof ReadQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusResponses];

export type PatchQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusData = {
  body: IoK8sApimachineryPkgApisMetaV1Patch;
  path: {
    /**
     * name of the GrantCreationPolicy
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
    /**
     * Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     */
    force?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/grantcreationpolicies/{name}/status';
};

export type PatchQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type PatchQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1GrantCreationPolicy;
};

export type PatchQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusResponse =
  PatchQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusResponses[keyof PatchQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusResponses];

export type ReplaceQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusData = {
  body: ComMiloapisQuotaV1Alpha1GrantCreationPolicy;
  path: {
    /**
     * name of the GrantCreationPolicy
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/grantcreationpolicies/{name}/status';
};

export type ReplaceQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReplaceQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1GrantCreationPolicy;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1GrantCreationPolicy;
};

export type ReplaceQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusResponse =
  ReplaceQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusResponses[keyof ReplaceQuotaMiloapisComV1Alpha1GrantCreationPolicyStatusResponses];

export type DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedAllowanceBucketData = {
  body?: never;
  path: {
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/allowancebuckets';
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedAllowanceBucketErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedAllowanceBucketResponses = {
  /**
   * OK
   */
  200: IoK8sApimachineryPkgApisMetaV1Status;
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedAllowanceBucketResponse =
  DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedAllowanceBucketResponses[keyof DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedAllowanceBucketResponses];

export type ListQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketData = {
  body?: never;
  path: {
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/allowancebuckets';
};

export type ListQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ListQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1AllowanceBucketList;
};

export type ListQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponse =
  ListQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses[keyof ListQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses];

export type CreateQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketData = {
  body: ComMiloapisQuotaV1Alpha1AllowanceBucket;
  path: {
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/allowancebuckets';
};

export type CreateQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type CreateQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1AllowanceBucket;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1AllowanceBucket;
  /**
   * Accepted
   */
  202: ComMiloapisQuotaV1Alpha1AllowanceBucket;
};

export type CreateQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponse =
  CreateQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses[keyof CreateQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses];

export type DeleteQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketData = {
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
  path: {
    /**
     * name of the AllowanceBucket
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     */
    gracePeriodSeconds?: number;
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     */
    orphanDependents?: boolean;
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     */
    propagationPolicy?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/allowancebuckets/{name}';
};

export type DeleteQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type DeleteQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses = {
  /**
   * OK
   */
  200: IoK8sApimachineryPkgApisMetaV1Status;
  /**
   * Accepted
   */
  202: IoK8sApimachineryPkgApisMetaV1Status;
};

export type DeleteQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponse =
  DeleteQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses[keyof DeleteQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses];

export type ReadQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketData = {
  body?: never;
  path: {
    /**
     * name of the AllowanceBucket
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/allowancebuckets/{name}';
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1AllowanceBucket;
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponse =
  ReadQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses[keyof ReadQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses];

export type PatchQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketData = {
  body: IoK8sApimachineryPkgApisMetaV1Patch;
  path: {
    /**
     * name of the AllowanceBucket
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
    /**
     * Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     */
    force?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/allowancebuckets/{name}';
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1AllowanceBucket;
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponse =
  PatchQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses[keyof PatchQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses];

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketData = {
  body: ComMiloapisQuotaV1Alpha1AllowanceBucket;
  path: {
    /**
     * name of the AllowanceBucket
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/allowancebuckets/{name}';
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1AllowanceBucket;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1AllowanceBucket;
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponse =
  ReplaceQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses[keyof ReplaceQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketResponses];

export type ReadQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusData = {
  body?: never;
  path: {
    /**
     * name of the AllowanceBucket
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/allowancebuckets/{name}/status';
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1AllowanceBucket;
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusResponse =
  ReadQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusResponses[keyof ReadQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusResponses];

export type PatchQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusData = {
  body: IoK8sApimachineryPkgApisMetaV1Patch;
  path: {
    /**
     * name of the AllowanceBucket
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
    /**
     * Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     */
    force?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/allowancebuckets/{name}/status';
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1AllowanceBucket;
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusResponse =
  PatchQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusResponses[keyof PatchQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusResponses];

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusData = {
  body: ComMiloapisQuotaV1Alpha1AllowanceBucket;
  path: {
    /**
     * name of the AllowanceBucket
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/allowancebuckets/{name}/status';
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1AllowanceBucket;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1AllowanceBucket;
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusResponse =
  ReplaceQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusResponses[keyof ReplaceQuotaMiloapisComV1Alpha1NamespacedAllowanceBucketStatusResponses];

export type DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedResourceClaimData = {
  body?: never;
  path: {
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourceclaims';
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedResourceClaimErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedResourceClaimResponses = {
  /**
   * OK
   */
  200: IoK8sApimachineryPkgApisMetaV1Status;
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedResourceClaimResponse =
  DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedResourceClaimResponses[keyof DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedResourceClaimResponses];

export type ListQuotaMiloapisComV1Alpha1NamespacedResourceClaimData = {
  body?: never;
  path: {
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourceclaims';
};

export type ListQuotaMiloapisComV1Alpha1NamespacedResourceClaimErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ListQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceClaimList;
};

export type ListQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponse =
  ListQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses[keyof ListQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses];

export type CreateQuotaMiloapisComV1Alpha1NamespacedResourceClaimData = {
  body: ComMiloapisQuotaV1Alpha1ResourceClaim;
  path: {
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourceclaims';
};

export type CreateQuotaMiloapisComV1Alpha1NamespacedResourceClaimErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type CreateQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceClaim;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1ResourceClaim;
  /**
   * Accepted
   */
  202: ComMiloapisQuotaV1Alpha1ResourceClaim;
};

export type CreateQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponse =
  CreateQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses[keyof CreateQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses];

export type DeleteQuotaMiloapisComV1Alpha1NamespacedResourceClaimData = {
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
  path: {
    /**
     * name of the ResourceClaim
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     */
    gracePeriodSeconds?: number;
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     */
    orphanDependents?: boolean;
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     */
    propagationPolicy?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourceclaims/{name}';
};

export type DeleteQuotaMiloapisComV1Alpha1NamespacedResourceClaimErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type DeleteQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses = {
  /**
   * OK
   */
  200: IoK8sApimachineryPkgApisMetaV1Status;
  /**
   * Accepted
   */
  202: IoK8sApimachineryPkgApisMetaV1Status;
};

export type DeleteQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponse =
  DeleteQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses[keyof DeleteQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses];

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceClaimData = {
  body?: never;
  path: {
    /**
     * name of the ResourceClaim
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourceclaims/{name}';
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceClaimErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceClaim;
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponse =
  ReadQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses[keyof ReadQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses];

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceClaimData = {
  body: IoK8sApimachineryPkgApisMetaV1Patch;
  path: {
    /**
     * name of the ResourceClaim
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
    /**
     * Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     */
    force?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourceclaims/{name}';
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceClaimErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceClaim;
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponse =
  PatchQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses[keyof PatchQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses];

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceClaimData = {
  body: ComMiloapisQuotaV1Alpha1ResourceClaim;
  path: {
    /**
     * name of the ResourceClaim
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourceclaims/{name}';
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceClaimErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceClaim;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1ResourceClaim;
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponse =
  ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses[keyof ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceClaimResponses];

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusData = {
  body?: never;
  path: {
    /**
     * name of the ResourceClaim
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourceclaims/{name}/status';
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceClaim;
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusResponse =
  ReadQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusResponses[keyof ReadQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusResponses];

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusData = {
  body: IoK8sApimachineryPkgApisMetaV1Patch;
  path: {
    /**
     * name of the ResourceClaim
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
    /**
     * Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     */
    force?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourceclaims/{name}/status';
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceClaim;
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusResponse =
  PatchQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusResponses[keyof PatchQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusResponses];

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusData = {
  body: ComMiloapisQuotaV1Alpha1ResourceClaim;
  path: {
    /**
     * name of the ResourceClaim
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourceclaims/{name}/status';
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceClaim;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1ResourceClaim;
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusResponse =
  ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusResponses[keyof ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceClaimStatusResponses];

export type DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedResourceGrantData = {
  body?: never;
  path: {
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourcegrants';
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedResourceGrantErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedResourceGrantResponses = {
  /**
   * OK
   */
  200: IoK8sApimachineryPkgApisMetaV1Status;
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedResourceGrantResponse =
  DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedResourceGrantResponses[keyof DeleteQuotaMiloapisComV1Alpha1CollectionNamespacedResourceGrantResponses];

export type ListQuotaMiloapisComV1Alpha1NamespacedResourceGrantData = {
  body?: never;
  path: {
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourcegrants';
};

export type ListQuotaMiloapisComV1Alpha1NamespacedResourceGrantErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ListQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceGrantList;
};

export type ListQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponse =
  ListQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses[keyof ListQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses];

export type CreateQuotaMiloapisComV1Alpha1NamespacedResourceGrantData = {
  body: ComMiloapisQuotaV1Alpha1ResourceGrant;
  path: {
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourcegrants';
};

export type CreateQuotaMiloapisComV1Alpha1NamespacedResourceGrantErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type CreateQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceGrant;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1ResourceGrant;
  /**
   * Accepted
   */
  202: ComMiloapisQuotaV1Alpha1ResourceGrant;
};

export type CreateQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponse =
  CreateQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses[keyof CreateQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses];

export type DeleteQuotaMiloapisComV1Alpha1NamespacedResourceGrantData = {
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
  path: {
    /**
     * name of the ResourceGrant
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     */
    gracePeriodSeconds?: number;
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     */
    orphanDependents?: boolean;
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     */
    propagationPolicy?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourcegrants/{name}';
};

export type DeleteQuotaMiloapisComV1Alpha1NamespacedResourceGrantErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type DeleteQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses = {
  /**
   * OK
   */
  200: IoK8sApimachineryPkgApisMetaV1Status;
  /**
   * Accepted
   */
  202: IoK8sApimachineryPkgApisMetaV1Status;
};

export type DeleteQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponse =
  DeleteQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses[keyof DeleteQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses];

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceGrantData = {
  body?: never;
  path: {
    /**
     * name of the ResourceGrant
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourcegrants/{name}';
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceGrantErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceGrant;
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponse =
  ReadQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses[keyof ReadQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses];

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceGrantData = {
  body: IoK8sApimachineryPkgApisMetaV1Patch;
  path: {
    /**
     * name of the ResourceGrant
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
    /**
     * Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     */
    force?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourcegrants/{name}';
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceGrantErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceGrant;
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponse =
  PatchQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses[keyof PatchQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses];

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceGrantData = {
  body: ComMiloapisQuotaV1Alpha1ResourceGrant;
  path: {
    /**
     * name of the ResourceGrant
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourcegrants/{name}';
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceGrantErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceGrant;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1ResourceGrant;
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponse =
  ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses[keyof ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceGrantResponses];

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusData = {
  body?: never;
  path: {
    /**
     * name of the ResourceGrant
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourcegrants/{name}/status';
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceGrant;
};

export type ReadQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusResponse =
  ReadQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusResponses[keyof ReadQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusResponses];

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusData = {
  body: IoK8sApimachineryPkgApisMetaV1Patch;
  path: {
    /**
     * name of the ResourceGrant
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
    /**
     * Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     */
    force?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourcegrants/{name}/status';
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceGrant;
};

export type PatchQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusResponse =
  PatchQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusResponses[keyof PatchQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusResponses];

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusData = {
  body: ComMiloapisQuotaV1Alpha1ResourceGrant;
  path: {
    /**
     * name of the ResourceGrant
     */
    name: string;
    /**
     * object name and auth scope, such as for teams and projects
     */
    namespace: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/namespaces/{namespace}/resourcegrants/{name}/status';
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceGrant;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1ResourceGrant;
};

export type ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusResponse =
  ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusResponses[keyof ReplaceQuotaMiloapisComV1Alpha1NamespacedResourceGrantStatusResponses];

export type ListQuotaMiloapisComV1Alpha1ResourceClaimForAllNamespacesData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/resourceclaims';
};

export type ListQuotaMiloapisComV1Alpha1ResourceClaimForAllNamespacesErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ListQuotaMiloapisComV1Alpha1ResourceClaimForAllNamespacesResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceClaimList;
};

export type ListQuotaMiloapisComV1Alpha1ResourceClaimForAllNamespacesResponse =
  ListQuotaMiloapisComV1Alpha1ResourceClaimForAllNamespacesResponses[keyof ListQuotaMiloapisComV1Alpha1ResourceClaimForAllNamespacesResponses];

export type ListQuotaMiloapisComV1Alpha1ResourceGrantForAllNamespacesData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/resourcegrants';
};

export type ListQuotaMiloapisComV1Alpha1ResourceGrantForAllNamespacesErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ListQuotaMiloapisComV1Alpha1ResourceGrantForAllNamespacesResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceGrantList;
};

export type ListQuotaMiloapisComV1Alpha1ResourceGrantForAllNamespacesResponse =
  ListQuotaMiloapisComV1Alpha1ResourceGrantForAllNamespacesResponses[keyof ListQuotaMiloapisComV1Alpha1ResourceGrantForAllNamespacesResponses];

export type DeleteQuotaMiloapisComV1Alpha1CollectionResourceRegistrationData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/resourceregistrations';
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionResourceRegistrationErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionResourceRegistrationResponses = {
  /**
   * OK
   */
  200: IoK8sApimachineryPkgApisMetaV1Status;
};

export type DeleteQuotaMiloapisComV1Alpha1CollectionResourceRegistrationResponse =
  DeleteQuotaMiloapisComV1Alpha1CollectionResourceRegistrationResponses[keyof DeleteQuotaMiloapisComV1Alpha1CollectionResourceRegistrationResponses];

export type ListQuotaMiloapisComV1Alpha1ResourceRegistrationData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * allowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     */
    continue?: string;
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     */
    fieldSelector?: string;
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     */
    limit?: number;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersionMatch?: string;
    /**
     * `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic "Bookmark" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward compatibility reasons) and to false otherwise.
     */
    sendInitialEvents?: boolean;
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     */
    timeoutSeconds?: number;
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    watch?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/resourceregistrations';
};

export type ListQuotaMiloapisComV1Alpha1ResourceRegistrationErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ListQuotaMiloapisComV1Alpha1ResourceRegistrationResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceRegistrationList;
};

export type ListQuotaMiloapisComV1Alpha1ResourceRegistrationResponse =
  ListQuotaMiloapisComV1Alpha1ResourceRegistrationResponses[keyof ListQuotaMiloapisComV1Alpha1ResourceRegistrationResponses];

export type CreateQuotaMiloapisComV1Alpha1ResourceRegistrationData = {
  body: ComMiloapisQuotaV1Alpha1ResourceRegistration;
  path?: never;
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/resourceregistrations';
};

export type CreateQuotaMiloapisComV1Alpha1ResourceRegistrationErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type CreateQuotaMiloapisComV1Alpha1ResourceRegistrationResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceRegistration;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1ResourceRegistration;
  /**
   * Accepted
   */
  202: ComMiloapisQuotaV1Alpha1ResourceRegistration;
};

export type CreateQuotaMiloapisComV1Alpha1ResourceRegistrationResponse =
  CreateQuotaMiloapisComV1Alpha1ResourceRegistrationResponses[keyof CreateQuotaMiloapisComV1Alpha1ResourceRegistrationResponses];

export type DeleteQuotaMiloapisComV1Alpha1ResourceRegistrationData = {
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
  path: {
    /**
     * name of the ResourceRegistration
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     */
    gracePeriodSeconds?: number;
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
     */
    orphanDependents?: boolean;
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
     */
    propagationPolicy?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/resourceregistrations/{name}';
};

export type DeleteQuotaMiloapisComV1Alpha1ResourceRegistrationErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type DeleteQuotaMiloapisComV1Alpha1ResourceRegistrationResponses = {
  /**
   * OK
   */
  200: IoK8sApimachineryPkgApisMetaV1Status;
  /**
   * Accepted
   */
  202: IoK8sApimachineryPkgApisMetaV1Status;
};

export type DeleteQuotaMiloapisComV1Alpha1ResourceRegistrationResponse =
  DeleteQuotaMiloapisComV1Alpha1ResourceRegistrationResponses[keyof DeleteQuotaMiloapisComV1Alpha1ResourceRegistrationResponses];

export type ReadQuotaMiloapisComV1Alpha1ResourceRegistrationData = {
  body?: never;
  path: {
    /**
     * name of the ResourceRegistration
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/resourceregistrations/{name}';
};

export type ReadQuotaMiloapisComV1Alpha1ResourceRegistrationErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReadQuotaMiloapisComV1Alpha1ResourceRegistrationResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceRegistration;
};

export type ReadQuotaMiloapisComV1Alpha1ResourceRegistrationResponse =
  ReadQuotaMiloapisComV1Alpha1ResourceRegistrationResponses[keyof ReadQuotaMiloapisComV1Alpha1ResourceRegistrationResponses];

export type PatchQuotaMiloapisComV1Alpha1ResourceRegistrationData = {
  body: IoK8sApimachineryPkgApisMetaV1Patch;
  path: {
    /**
     * name of the ResourceRegistration
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
    /**
     * Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     */
    force?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/resourceregistrations/{name}';
};

export type PatchQuotaMiloapisComV1Alpha1ResourceRegistrationErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type PatchQuotaMiloapisComV1Alpha1ResourceRegistrationResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceRegistration;
};

export type PatchQuotaMiloapisComV1Alpha1ResourceRegistrationResponse =
  PatchQuotaMiloapisComV1Alpha1ResourceRegistrationResponses[keyof PatchQuotaMiloapisComV1Alpha1ResourceRegistrationResponses];

export type ReplaceQuotaMiloapisComV1Alpha1ResourceRegistrationData = {
  body: ComMiloapisQuotaV1Alpha1ResourceRegistration;
  path: {
    /**
     * name of the ResourceRegistration
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/resourceregistrations/{name}';
};

export type ReplaceQuotaMiloapisComV1Alpha1ResourceRegistrationErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReplaceQuotaMiloapisComV1Alpha1ResourceRegistrationResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceRegistration;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1ResourceRegistration;
};

export type ReplaceQuotaMiloapisComV1Alpha1ResourceRegistrationResponse =
  ReplaceQuotaMiloapisComV1Alpha1ResourceRegistrationResponses[keyof ReplaceQuotaMiloapisComV1Alpha1ResourceRegistrationResponses];

export type ReadQuotaMiloapisComV1Alpha1ResourceRegistrationStatusData = {
  body?: never;
  path: {
    /**
     * name of the ResourceRegistration
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
     *
     * Defaults to unset
     */
    resourceVersion?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/resourceregistrations/{name}/status';
};

export type ReadQuotaMiloapisComV1Alpha1ResourceRegistrationStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReadQuotaMiloapisComV1Alpha1ResourceRegistrationStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceRegistration;
};

export type ReadQuotaMiloapisComV1Alpha1ResourceRegistrationStatusResponse =
  ReadQuotaMiloapisComV1Alpha1ResourceRegistrationStatusResponses[keyof ReadQuotaMiloapisComV1Alpha1ResourceRegistrationStatusResponses];

export type PatchQuotaMiloapisComV1Alpha1ResourceRegistrationStatusData = {
  body: IoK8sApimachineryPkgApisMetaV1Patch;
  path: {
    /**
     * name of the ResourceRegistration
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
    /**
     * Force is going to "force" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     */
    force?: boolean;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/resourceregistrations/{name}/status';
};

export type PatchQuotaMiloapisComV1Alpha1ResourceRegistrationStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type PatchQuotaMiloapisComV1Alpha1ResourceRegistrationStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceRegistration;
};

export type PatchQuotaMiloapisComV1Alpha1ResourceRegistrationStatusResponse =
  PatchQuotaMiloapisComV1Alpha1ResourceRegistrationStatusResponses[keyof PatchQuotaMiloapisComV1Alpha1ResourceRegistrationStatusResponses];

export type ReplaceQuotaMiloapisComV1Alpha1ResourceRegistrationStatusData = {
  body: ComMiloapisQuotaV1Alpha1ResourceRegistration;
  path: {
    /**
     * name of the ResourceRegistration
     */
    name: string;
  };
  query?: {
    /**
     * If 'true', then the output is pretty printed. Defaults to 'false' unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     */
    pretty?: string;
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     */
    dryRun?: string;
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    fieldManager?: string;
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     */
    fieldValidation?: string;
  };
  url: '/apis/quota.miloapis.com/v1alpha1/resourceregistrations/{name}/status';
};

export type ReplaceQuotaMiloapisComV1Alpha1ResourceRegistrationStatusErrors = {
  /**
   * Unauthorized
   */
  401: unknown;
};

export type ReplaceQuotaMiloapisComV1Alpha1ResourceRegistrationStatusResponses = {
  /**
   * OK
   */
  200: ComMiloapisQuotaV1Alpha1ResourceRegistration;
  /**
   * Created
   */
  201: ComMiloapisQuotaV1Alpha1ResourceRegistration;
};

export type ReplaceQuotaMiloapisComV1Alpha1ResourceRegistrationStatusResponse =
  ReplaceQuotaMiloapisComV1Alpha1ResourceRegistrationStatusResponses[keyof ReplaceQuotaMiloapisComV1Alpha1ResourceRegistrationStatusResponses];
